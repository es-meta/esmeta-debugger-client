[
  [
    629,
    [
      "TryStatement[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of |Catch| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "TryStatement[0,0].ContainsUndefinedBreakTarget",
        "name" : "TryStatement[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2163,
    [
      "TimeFromYear",
      0,
      [
        [
          "y",
          false,
          "NumberInt"
        ]
      ],
      "\n          1. Return msPerDay × DayFromYear(_y_).\n        ",
      {
        "normalizedName" : "TimeFromYear",
        "name" : "TimeFromYear",
        "htmlId" : "sec-timefromyear",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    645,
    [
      "Block[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Block[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Block[0,0].ContainsUndefinedContinueTarget",
        "name" : "Block[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Block",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    892,
    [
      "ArrayBindingPattern[0,1].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. If |Elision| is present, then\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[0,1].IteratorBindingInitialization",
        "name" : "ArrayBindingPattern[0,1].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    69,
    [
      "Number::bitwiseOR",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. Return NumberBitwiseOp(`|`, _x_, _y_).\n          ",
      {
        "normalizedName" : "Number::bitwiseOR",
        "name" : "Number::bitwiseOR",
        "htmlId" : "sec-numeric-types-number-bitwiseOR",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2199,
    [
      "INTRINSICS.Date.prototype.getTimezoneOffset",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return (_t_ - LocalTime(_t_)) / msPerMinute.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getTimezoneOffset",
        "name" : "INTRINSICS.Date.prototype.getTimezoneOffset",
        "htmlId" : "sec-date.prototype.gettimezoneoffset",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1322,
    [
      "ArgumentList[2,0].ArgumentListEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArgumentList[2]]"
        ]
      ],
      "\n          1. Let _precedingArgs_ be ? ArgumentListEvaluation of |ArgumentList|.\n          1. Let _ref_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _arg_ be ? GetValue(_ref_).\n          1. Return the list-concatenation of _precedingArgs_ and « _arg_ ».\n        ",
      {
        "normalizedName" : "ArgumentList[2,0].ArgumentListEvaluation",
        "name" : "ArgumentList[2,0].ArgumentListEvaluation",
        "htmlId" : "sec-runtime-semantics-argumentlistevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArgumentListEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ArgumentList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArgumentList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1665,
    [
      "ClassElement[2,0].ClassElementKind",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[2]]"
        ]
      ],
      "\n        1. Return ~non-constructor-method~.\n      ",
      {
        "normalizedName" : "ClassElement[2,0].ClassElementKind",
        "name" : "ClassElement[2,0].ClassElementKind",
        "htmlId" : "sec-static-semantics-classelementkind",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassElementKind",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FieldDefinition"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1036,
    [
      "Record[GlobalEnvironmentRecord].SetMutableBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "S",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, then\n              1. Return ? _DclRec_.SetMutableBinding(_N_, _V_, _S_).\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Return ? <emu-meta effects=\"user-code\">_ObjRec_.SetMutableBinding</emu-meta>(_N_, _V_, _S_).\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].SetMutableBinding",
        "name" : "Record[GlobalEnvironmentRecord].SetMutableBinding",
        "htmlId" : "sec-global-environment-records-setmutablebinding-n-v-s",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "SetMutableBinding"
        ]
      }
    ]
  ],
  [
    2822,
    [
      "AsyncGeneratorAwaitReturn",
      0,
      [
        [
          "generator",
          false,
          "Record[AsyncGenerator]"
        ]
      ],
      "\n          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].\n          1. Assert: _queue_ is not empty.\n          1. Let _next_ be the first element of _queue_.\n          1. Let _completion_ be Completion(_next_.[[Completion]]).\n          1. Assert: _completion_ is a return completion.\n          1. Let _promise_ be ? PromiseResolve(%Promise%, _completion_.[[Value]]).\n          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_value_) that captures _generator_ and performs the following steps when called:\n            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n            1. Let _result_ be NormalCompletion(_value_).\n            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).\n            1. Perform AsyncGeneratorDrainQueue(_generator_).\n            1. Return *undefined*.\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _generator_ and performs the following steps when called:\n            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n            1. Let _result_ be ThrowCompletion(_reason_).\n            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).\n            1. Perform AsyncGeneratorDrainQueue(_generator_).\n            1. Return *undefined*.\n          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncGeneratorAwaitReturn",
        "name" : "AsyncGeneratorAwaitReturn",
        "htmlId" : "sec-asyncgeneratorawaitreturn",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2630,
    [
      "CloneArrayBuffer",
      0,
      [
        [
          "srcBuffer",
          false,
          "Record[ArrayBuffer | SharedArrayBuffer]"
        ],
        [
          "srcByteOffset",
          false,
          "Int[0+]"
        ],
        [
          "srcLength",
          false,
          "Int[0+]"
        ]
      ],
      "\n          1. Assert: IsDetachedBuffer(_srcBuffer_) is *false*.\n          1. Let _targetBuffer_ be ? <emu-meta suppress-effects=\"user-code\">AllocateArrayBuffer(%ArrayBuffer%, _srcLength_)</emu-meta>.\n          1. Let _srcBlock_ be _srcBuffer_.[[ArrayBufferData]].\n          1. Let _targetBlock_ be _targetBuffer_.[[ArrayBufferData]].\n          1. Perform CopyDataBlockBytes(_targetBlock_, 0, _srcBlock_, _srcByteOffset_, _srcLength_).\n          1. Return _targetBuffer_.\n        ",
      {
        "normalizedName" : "CloneArrayBuffer",
        "name" : "CloneArrayBuffer",
        "htmlId" : "sec-clonearraybuffer",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1586,
    [
      "SingleNameBinding[0,1].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[SingleNameBinding[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "SingleNameBinding[0,1].IsSimpleParameterList",
        "name" : "SingleNameBinding[0,1].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "SingleNameBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1501,
    [
      "ForInOfStatement[6,0].ForInOfLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[6]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~).\n          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_, ~async~).\n        ",
      {
        "normalizedName" : "ForInOfStatement[6,0].ForInOfLoopEvaluation",
        "name" : "ForInOfStatement[6,0].ForInOfLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forinofloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForInOfLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2452,
    [
      "INTRINSICS.get RegExp.prototype.hasIndices",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0064 (LATIN SMALL LETTER D).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get RegExp.prototype.hasIndices",
        "name" : "INTRINSICS.get RegExp.prototype.hasIndices",
        "htmlId" : "sec-get-regexp.prototype.hasIndices",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    809,
    [
      "MemberExpression[4,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[4]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[4,0].IsIdentifierRef",
        "name" : "MemberExpression[4,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SuperProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1879,
    [
      "PrimaryExpression[4,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[4]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[4,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[4,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ObjectLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1337,
    [
      "OptionalChain[9,0].ChainEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[9]]"
        ],
        [
          "baseValue",
          false,
          "ESValue"
        ],
        [
          "baseReference",
          false,
          "ESValue | Record[ReferenceRecord]"
        ]
      ],
      "\n          1. Let _optionalChain_ be |OptionalChain|.\n          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n          1. Let _newValue_ be ? GetValue(_newReference_).\n          1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.\n          1. Return MakePrivateReference(_newValue_, _fieldNameString_).\n        ",
      {
        "normalizedName" : "OptionalChain[9,0].ChainEvaluation",
        "name" : "OptionalChain[9,0].ChainEvaluation",
        "htmlId" : "sec-optional-chaining-chain-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ChainEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 9,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1718,
    [
      "AsyncFunctionExpression[0,1].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,1].ContainsArguments",
        "name" : "AsyncFunctionExpression[0,1].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2094,
    [
      "INTRINSICS.Symbol.keyFor",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _sym_ is not a Symbol, throw a *TypeError* exception.\n          1. Return KeyForSymbol(_sym_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Symbol.keyFor",
        "name" : "INTRINSICS.Symbol.keyFor",
        "htmlId" : "sec-symbol.keyfor",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1411,
    [
      "AssignmentElementList[1,0].IteratorDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentElementList[1]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_.\n          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| with argument _iteratorRecord_.\n        ",
      {
        "normalizedName" : "AssignmentElementList[1,0].IteratorDestructuringAssignmentEvaluation",
        "name" : "AssignmentElementList[1,0].IteratorDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AssignmentElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AssignmentElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentElisionElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2612,
    [
      "INTRINSICS.Set.prototype.values",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Return ? CreateSetIterator(_S_, ~value~).\n        ",
      {
        "normalizedName" : "INTRINSICS.Set.prototype.values",
        "name" : "INTRINSICS.Set.prototype.values",
        "htmlId" : "sec-set.prototype.values",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1024,
    [
      "Record[ObjectEnvironmentRecord].HasThisBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[ObjectEnvironmentRecord]"
        ]
      ],
      "\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "Record[ObjectEnvironmentRecord].HasThisBinding",
        "name" : "Record[ObjectEnvironmentRecord].HasThisBinding",
        "htmlId" : "sec-object-environment-records-hasthisbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ObjectEnvironmentRecord",
          "HasThisBinding"
        ]
      }
    ]
  ],
  [
    1469,
    [
      "ForStatement[1,0].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Perform ? Evaluation of |VariableDeclarationList|.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        ",
      {
        "normalizedName" : "ForStatement[1,0].ForLoopEvaluation",
        "name" : "ForStatement[1,0].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    365,
    [
      "IfStatement[1,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[1]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "IfStatement[1,0].VarDeclaredNames",
        "name" : "IfStatement[1,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2744,
    [
      "INTRINSICS.AsyncFromSyncIteratorPrototype.return",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _O_ be the *this* value.\n            1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.\n            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n            1. Let _syncIterator_ be _O_.[[SyncIteratorRecord]].[[Iterator]].\n            1. Let _return_ be Completion(GetMethod(_syncIterator_, *\"return\"*)).\n            1. IfAbruptRejectPromise(_return_, _promiseCapability_).\n            1. If _return_ is *undefined*, then\n              1. Let _iterResult_ be CreateIterResultObject(_value_, *true*).\n              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _iterResult_ »).\n              1. Return _promiseCapability_.[[Promise]].\n            1. If _value_ is present, then\n              1. Let _result_ be Completion(Call(_return_, _syncIterator_, « _value_ »)).\n            1. Else,\n              1. Let _result_ be Completion(Call(_return_, _syncIterator_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n            1. If _result_ is not an Object, then\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).\n              1. Return _promiseCapability_.[[Promise]].\n            1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_).\n          ",
      {
        "normalizedName" : "INTRINSICS.AsyncFromSyncIteratorPrototype.return",
        "name" : "INTRINSICS.AsyncFromSyncIteratorPrototype.return",
        "htmlId" : "sec-%asyncfromsynciteratorprototype%.return",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1369,
    [
      "RelationalExpression[5,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[5]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Return ? InstanceofOperator(_lval_, _rval_).\n      ",
      {
        "normalizedName" : "RelationalExpression[5,0].Evaluation",
        "name" : "RelationalExpression[5,0].Evaluation",
        "htmlId" : "sec-relational-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "instanceof"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    138,
    [
      "ToUint8Clamp",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is *NaN*, return *+0*<sub>𝔽</sub>.\n        1. Let _mv_ be the extended mathematical value of _number_.\n        1. Let _clamped_ be the result of clamping _mv_ between 0 and 255.\n        1. Let _f_ be floor(_clamped_).\n        1. If _clamped_ < _f_ + 0.5, return 𝔽(_f_).\n        1. If _clamped_ > _f_ + 0.5, return 𝔽(_f_ + 1).\n        1. If _f_ is even, return 𝔽(_f_). Otherwise, return 𝔽(_f_ + 1).\n      ",
      {
        "normalizedName" : "ToUint8Clamp",
        "name" : "ToUint8Clamp",
        "htmlId" : "sec-touint8clamp",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1823,
    [
      "AssignmentExpression[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[2,0].HasCallInTailPosition",
        "name" : "AssignmentExpression[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrowFunction"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1190,
    [
      "SetImmutablePrototype",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "V",
          false,
          "Record[Object] | Null"
        ]
      ],
      "\n          1. Let _current_ be ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]</emu-meta>().\n          1. If SameValue(_V_, _current_) is *true*, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "SetImmutablePrototype",
        "name" : "SetImmutablePrototype",
        "htmlId" : "sec-set-immutable-prototype",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1168,
    [
      "MakeTypedArrayWithBufferWitnessRecord",
      0,
      [
        [
          "obj",
          false,
          "Record[TypedArray]"
        ],
        [
          "order",
          false,
          "Enum[~seq-cst~, ~unordered~]"
        ]
      ],
      "\n          1. Let _buffer_ be _obj_.[[ViewedArrayBuffer]].\n          1. If IsDetachedBuffer(_buffer_) is *true*, then\n            1. Let _byteLength_ be ~detached~.\n          1. Else,\n            1. Let _byteLength_ be ArrayBufferByteLength(_buffer_, _order_).\n          1. Return the TypedArray With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ }.\n        ",
      {
        "normalizedName" : "MakeTypedArrayWithBufferWitnessRecord",
        "name" : "MakeTypedArrayWithBufferWitnessRecord",
        "htmlId" : "sec-maketypedarraywithbufferwitnessrecord",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2295,
    [
      "CharacterEscape[2,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterEscape[2]]"
        ]
      ],
      "\n          1. Return the numeric value of U+0000 (NULL).\n        ",
      {
        "normalizedName" : "CharacterEscape[2,0].CharacterValue",
        "name" : "CharacterEscape[2,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "CharacterEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "0"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2306,
    [
      "ClassSetCharacter[3,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSetCharacter[3]]"
        ]
      ],
      "\n          1. Return the numeric value of U+0008 (BACKSPACE).\n        ",
      {
        "normalizedName" : "ClassSetCharacter[3,0].CharacterValue",
        "name" : "ClassSetCharacter[3,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ClassSetCharacter",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "\\b"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    760,
    [
      "RelationalExpression[6,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[6]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[6,0].IsFunctionDefinition",
        "name" : "RelationalExpression[6,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2341,
    [
      "RegExpIdentifierStart[2,0].RegExpIdentifierCodePoint",
      2,
      [
        [
          "this",
          false,
          "Ast[RegExpIdentifierStart[2]]"
        ]
      ],
      "\n          1. Let _lead_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeLeadSurrogate|.\n          1. Let _trail_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeTrailSurrogate|.\n          1. Return UTF16SurrogatePairToCodePoint(_lead_, _trail_).\n        ",
      {
        "normalizedName" : "RegExpIdentifierStart[2,0].RegExpIdentifierCodePoint",
        "name" : "RegExpIdentifierStart[2,0].RegExpIdentifierCodePoint",
        "htmlId" : "sec-regexpidentifiercodepoint",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "RegExpIdentifierCodePoint",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "RegExpIdentifierStart",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "UnicodeLeadSurrogate"
              },
              {
                "type" : "nonterminal",
                "value" : "UnicodeTrailSurrogate"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    101,
    [
      "IsDataDescriptor",
      0,
      [
        [
          "Desc",
          false,
          "Record[PropertyDescriptor] | Undefined"
        ]
      ],
      "\n          1. If _Desc_ is *undefined*, return *false*.\n          1. If _Desc_ has a [[Value]] field, return *true*.\n          1. If _Desc_ has a [[Writable]] field, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "IsDataDescriptor",
        "name" : "IsDataDescriptor",
        "htmlId" : "sec-isdatadescriptor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2336,
    [
      "RegExpIdentifierName[1,0].RegExpIdentifierCodePoints",
      2,
      [
        [
          "this",
          false,
          "Ast[RegExpIdentifierName[1]]"
        ]
      ],
      "\n          1. Let _cps_ be RegExpIdentifierCodePoints of the derived |RegExpIdentifierName|.\n          1. Let _cp_ be RegExpIdentifierCodePoint of |RegExpIdentifierPart|.\n          1. Return the list-concatenation of _cps_ and « _cp_ ».\n        ",
      {
        "normalizedName" : "RegExpIdentifierName[1,0].RegExpIdentifierCodePoints",
        "name" : "RegExpIdentifierName[1,0].RegExpIdentifierCodePoints",
        "htmlId" : "sec-regexpidentifiercodepoints",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "RegExpIdentifierCodePoints",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "RegExpIdentifierName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RegExpIdentifierName"
              },
              {
                "type" : "nonterminal",
                "value" : "RegExpIdentifierPart"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2109,
    [
      "INTRINSICS.Number.isInteger",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return IsIntegralNumber(_number_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Number.isInteger",
        "name" : "INTRINSICS.Number.isInteger",
        "htmlId" : "sec-number.isinteger",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2131,
    [
      "INTRINSICS.Math.atanh",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ > *1*<sub>𝔽</sub> or _n_ < *-1*<sub>𝔽</sub>, return *NaN*.\n          1. If _n_ is *1*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n          1. If _n_ is *-1*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of the inverse hyperbolic tangent of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.atanh",
        "name" : "INTRINSICS.Math.atanh",
        "htmlId" : "sec-math.atanh",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1454,
    [
      "LoopContinues",
      0,
      [
        [
          "completion",
          false,
          "Completion"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. If _completion_ is a normal completion, return *true*.\n          1. If _completion_ is not a continue completion, return *false*.\n          1. If _completion_.[[Target]] is ~empty~, return *true*.\n          1. If _labelSet_ contains _completion_.[[Target]], return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "LoopContinues",
        "name" : "LoopContinues",
        "htmlId" : "sec-loopcontinues",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2031,
    [
      "EvalDeclarationInstantiation",
      0,
      [
        [
          "body",
          false,
          "Ast[ScriptBody]"
        ],
        [
          "varEnv",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "lexEnv",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ],
        [
          "strict",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Let _varNames_ be the VarDeclaredNames of _body_.\n          1. Let _varDeclarations_ be the VarScopedDeclarations of _body_.\n          1. If _strict_ is *false*, then\n            1. If _varEnv_ is a Global Environment Record, then\n              1. For each element _name_ of _varNames_, do\n                1. If _varEnv_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.\n                1. NOTE: `eval` will not create a global var declaration that would be shadowed by a global lexical declaration.\n            1. Let _thisEnv_ be _lexEnv_.\n            1. Assert: The following loop will terminate.\n            1. Repeat, while _thisEnv_ is not _varEnv_,\n              1. If _thisEnv_ is not an Object Environment Record, then\n                1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.\n                1. For each element _name_ of _varNames_, do\n                  1. If ! _thisEnv_.HasBinding(_name_) is *true*, then\n                    1. [id=\"step-evaldeclarationinstantiation-throw-duplicate-binding\"] Throw a *SyntaxError* exception.\n                    1. NOTE: Annex <emu-xref href=\"#sec-variablestatements-in-catch-blocks\"></emu-xref> defines alternate semantics for the above step.\n                  1. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.\n              1. Set _thisEnv_ to _thisEnv_.[[OuterEnv]].\n          1. Let _privateIdentifiers_ be a new empty List.\n          1. Let _pointer_ be _privateEnv_.\n          1. Repeat, while _pointer_ is not *null*,\n            1. For each Private Name _binding_ of _pointer_.[[Names]], do\n              1. If _privateIdentifiers_ does not contain _binding_.[[Description]], append _binding_.[[Description]] to _privateIdentifiers_.\n            1. Set _pointer_ to _pointer_.[[OuterPrivateEnvironment]].\n          1. If AllPrivateIdentifiersValid of _body_ with argument _privateIdentifiers_ is *false*, throw a *SyntaxError* exception.\n          1. Let _functionsToInitialize_ be a new empty List.\n          1. Let _declaredFunctionNames_ be a new empty List.\n          1. For each element _d_ of _varDeclarations_, in reverse List order, do\n            1. If _d_ is not either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then\n              1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.\n              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.\n              1. Let _fn_ be the sole element of the BoundNames of _d_.\n              1. If _declaredFunctionNames_ does not contain _fn_, then\n                1. If _varEnv_ is a Global Environment Record, then\n                  1. Let _fnDefinable_ be ? _varEnv_.CanDeclareGlobalFunction(_fn_).\n                  1. If _fnDefinable_ is *false*, throw a *TypeError* exception.\n                1. Append _fn_ to _declaredFunctionNames_.\n                1. Insert _d_ as the first element of _functionsToInitialize_.\n          1. Let _declaredVarNames_ be a new empty List.\n          1. For each element _d_ of _varDeclarations_, do\n            1. If _d_ is either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then\n              1. For each String _vn_ of the BoundNames of _d_, do\n                1. If _declaredFunctionNames_ does not contain _vn_, then\n                  1. If _varEnv_ is a Global Environment Record, then\n                    1. Let _vnDefinable_ be ? _varEnv_.CanDeclareGlobalVar(_vn_).\n                    1. If _vnDefinable_ is *false*, throw a *TypeError* exception.\n                  1. If _declaredVarNames_ does not contain _vn_, then\n                    1. Append _vn_ to _declaredVarNames_.\n          1. [id=\"step-evaldeclarationinstantiation-web-compat-insertion-point\"] NOTE: Annex <emu-xref href=\"#sec-web-compat-evaldeclarationinstantiation\"></emu-xref> adds additional steps at this point.\n          1. [id=\"step-evaldeclarationinstantiation-post-validation\"] NOTE: No abnormal terminations occur after this algorithm step unless _varEnv_ is a Global Environment Record and the global object is a Proxy exotic object.\n          1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _body_.\n          1. For each element _d_ of _lexDeclarations_, do\n            1. NOTE: Lexically declared names are only instantiated here but not initialized.\n            1. For each element _dn_ of the BoundNames of _d_, do\n              1. If IsConstantDeclaration of _d_ is *true*, then\n                1. Perform ? _lexEnv_.CreateImmutableBinding(_dn_, *true*).\n              1. Else,\n                1. Perform ? _lexEnv_.CreateMutableBinding(_dn_, *false*).\n          1. For each Parse Node _f_ of _functionsToInitialize_, do\n            1. Let _fn_ be the sole element of the BoundNames of _f_.\n            1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_.\n            1. If _varEnv_ is a Global Environment Record, then\n              1. Perform ? _varEnv_.CreateGlobalFunctionBinding(_fn_, _fo_, *true*).\n            1. Else,\n              1. Let _bindingExists_ be ! _varEnv_.HasBinding(_fn_).\n              1. If _bindingExists_ is *false*, then\n                1. NOTE: The following invocation cannot return an abrupt completion because of the validation preceding step <emu-xref href=\"#step-evaldeclarationinstantiation-post-validation\"></emu-xref>.\n                1. Perform ! _varEnv_.CreateMutableBinding(_fn_, *true*).\n                1. Perform ! _varEnv_.InitializeBinding(_fn_, _fo_).\n              1. Else,\n                1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).\n          1. For each String _vn_ of _declaredVarNames_, do\n            1. If _varEnv_ is a Global Environment Record, then\n              1. Perform ? _varEnv_.CreateGlobalVarBinding(_vn_, *true*).\n            1. Else,\n              1. Let _bindingExists_ be ! _varEnv_.HasBinding(_vn_).\n              1. If _bindingExists_ is *false*, then\n                1. NOTE: The following invocation cannot return an abrupt completion because of the validation preceding step <emu-xref href=\"#step-evaldeclarationinstantiation-post-validation\"></emu-xref>.\n                1. Perform ! _varEnv_.CreateMutableBinding(_vn_, *true*).\n                1. Perform ! _varEnv_.InitializeBinding(_vn_, *undefined*).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "EvalDeclarationInstantiation",
        "name" : "EvalDeclarationInstantiation",
        "htmlId" : "sec-evaldeclarationinstantiation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1633,
    [
      "MethodDefinition[0,0].SpecialMethod",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MethodDefinition[0,0].SpecialMethod",
        "name" : "MethodDefinition[0,0].SpecialMethod",
        "htmlId" : "sec-static-semantics-specialmethod",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "SpecialMethod",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2778,
    [
      "INTRINSICS.Promise.withResolvers",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the *this* value.\n          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"promise\"*, _promiseCapability_.[[Promise]]).\n          1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"resolve\"*, _promiseCapability_.[[Resolve]]).\n          1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"reject\"*, _promiseCapability_.[[Reject]]).\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.withResolvers",
        "name" : "INTRINSICS.Promise.withResolvers",
        "htmlId" : "sec-promise.withResolvers",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2072,
    [
      "INTRINSICS.Object.prototype.propertyIsEnumerable",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. [id=\"step-propertyisenumerable-topropertykey\"] Let _P_ be ? ToPropertyKey(_V_).\n          1. [id=\"step-propertyisenumerable-toobject\"] Let _O_ be ? ToObject(*this* value).\n          1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. If _desc_ is *undefined*, return *false*.\n          1. Return _desc_.[[Enumerable]].\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.prototype.propertyIsEnumerable",
        "name" : "INTRINSICS.Object.prototype.propertyIsEnumerable",
        "htmlId" : "sec-object.prototype.propertyisenumerable",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1767,
    [
      "StatementListItem[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "StatementListItem[1,0].HasCallInTailPosition",
        "name" : "StatementListItem[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1995,
    [
      "ExportDeclaration[6,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[6]]"
        ]
      ],
      "\n          1. Return « *\"default\"* ».\n        ",
      {
        "normalizedName" : "ExportDeclaration[6,0].ExportedNames",
        "name" : "ExportDeclaration[6,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2263,
    [
      "INTRINSICS.String.prototype.slice",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _len_ be the length of _S_.\n          1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _intStart_ = -∞, let _from_ be 0.\n          1. Else if _intStart_ < 0, let _from_ be max(_len_ + _intStart_, 0).\n          1. Else, let _from_ be min(_intStart_, _len_).\n          1. If _end_ is *undefined*, let _intEnd_ be _len_; else let _intEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _intEnd_ = -∞, let _to_ be 0.\n          1. Else if _intEnd_ < 0, let _to_ be max(_len_ + _intEnd_, 0).\n          1. Else, let _to_ be min(_intEnd_, _len_).\n          1. If _from_ ≥ _to_, return the empty String.\n          1. Return the substring of _S_ from _from_ to _to_.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.slice",
        "name" : "INTRINSICS.String.prototype.slice",
        "htmlId" : "sec-string.prototype.slice",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    479,
    [
      "TryStatement[2,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[2]]"
        ]
      ],
      "\n        1. Let _declarations1_ be VarScopedDeclarations of |Block|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Catch|.\n        1. Let _declarations3_ be VarScopedDeclarations of |Finally|.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      ",
      {
        "normalizedName" : "TryStatement[2,0].VarScopedDeclarations",
        "name" : "TryStatement[2,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1559,
    [
      "ArrayBindingPattern[0,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[0,0].ContainsExpression",
        "name" : "ArrayBindingPattern[0,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1105,
    [
      "Record[OrdinaryObject].OwnPropertyKeys",
      4,
      [
        [
          "O",
          false,
          "Record[OrdinaryObject]"
        ]
      ],
      "\n        1. Return OrdinaryOwnPropertyKeys(_O_).\n      ",
      {
        "normalizedName" : "Record[OrdinaryObject].OwnPropertyKeys",
        "name" : "Record[OrdinaryObject].OwnPropertyKeys",
        "htmlId" : "sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "OrdinaryObject",
          "[[OwnPropertyKeys]]"
        ]
      }
    ]
  ],
  [
    347,
    [
      "ExportDeclaration[1,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[1]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ExportDeclaration[1,0].LexicallyScopedDeclarations",
        "name" : "ExportDeclaration[1,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "NamedExports"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1729,
    [
      "ClassElement[2,0].ClassElementEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[2]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Return ? ClassFieldDefinitionEvaluation of |FieldDefinition| with argument _object_.\n      ",
      {
        "normalizedName" : "ClassElement[2,0].ClassElementEvaluation",
        "name" : "ClassElement[2,0].ClassElementEvaluation",
        "htmlId" : "sec-static-semantics-classelementevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassElementEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FieldDefinition"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2412,
    [
      "ClassIntersection[1,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassIntersection[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of the |ClassIntersection| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of the |ClassSetOperand| with argument _rer_.\n          1. Return the intersection of CharSets _A_ and _B_.\n        ",
      {
        "normalizedName" : "ClassIntersection[1,0].CompileToCharSet",
        "name" : "ClassIntersection[1,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassIntersection",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassIntersection"
              },
              {
                "type" : "terminal",
                "value" : "&&"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1237,
    [
      "ModuleExportName[1,0].StringValue",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleExportName[1]]"
        ]
      ],
      "\n        1. Return the SV of |StringLiteral|.\n      ",
      {
        "normalizedName" : "ModuleExportName[1,0].StringValue",
        "name" : "ModuleExportName[1,0].StringValue",
        "htmlId" : "sec-static-semantics-stringvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleExportName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StringLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    846,
    [
      "ArrowFunction[0,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowFunction[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.\n        1. If |ArrowParameters| Contains _symbol_ is *true*, return *true*.\n        1. Return |ConciseBody| Contains _symbol_.\n      ",
      {
        "normalizedName" : "ArrowFunction[0,0].Contains",
        "name" : "ArrowFunction[0,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrowFunction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrowParameters"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "ConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    909,
    [
      "ArrowParameters[1,0].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowParameters[1]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _environment_.\n      ",
      {
        "normalizedName" : "ArrowParameters[1,0].IteratorBindingInitialization",
        "name" : "ArrowParameters[1,0].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ArrowParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1031,
    [
      "Record[FunctionEnvironmentRecord].GetSuperBase",
      3,
      [
        [
          "envRec",
          false,
          "Record[FunctionEnvironmentRecord]"
        ]
      ],
      "\n            1. Let _home_ be _envRec_.[[FunctionObject]].[[HomeObject]].\n            1. If _home_ is *undefined*, return *undefined*.\n            1. Assert: _home_ is an Object.\n            1. Return ? <emu-meta effects=\"user-code\">_home_.[[GetPrototypeOf]]</emu-meta>().\n          ",
      {
        "normalizedName" : "Record[FunctionEnvironmentRecord].GetSuperBase",
        "name" : "Record[FunctionEnvironmentRecord].GetSuperBase",
        "htmlId" : "sec-getsuperbase",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "FunctionEnvironmentRecord",
          "GetSuperBase"
        ]
      }
    ]
  ],
  [
    249,
    [
      "ClassDeclaration[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassDeclaration[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingIdentifier|.\n      ",
      {
        "normalizedName" : "ClassDeclaration[0,0].BoundNames",
        "name" : "ClassDeclaration[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    333,
    [
      "LabelledItem[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "LabelledItem[0,0].LexicallyScopedDeclarations",
        "name" : "LabelledItem[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    628,
    [
      "LabelledItem[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "LabelledItem[1,0].ContainsUndefinedBreakTarget",
        "name" : "LabelledItem[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2463,
    [
      "INTRINSICS.RegExp.prototype.test",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. If _R_ is not an Object, throw a *TypeError* exception.\n          1. Let _string_ be ? ToString(_S_).\n          1. Let _match_ be ? RegExpExec(_R_, _string_).\n          1. If _match_ is not *null*, return *true*; else return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.RegExp.prototype.test",
        "name" : "INTRINSICS.RegExp.prototype.test",
        "htmlId" : "sec-regexp.prototype.test",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1899,
    [
      "OptionalChain[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "OptionalChain[1,0].HasCallInTailPosition",
        "name" : "OptionalChain[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "?."
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    893,
    [
      "ArrayBindingPattern[0,3].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. If |Elision| is present, then\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[0,3].IteratorBindingInitialization",
        "name" : "ArrayBindingPattern[0,3].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1840,
    [
      "RelationalExpression[4,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[4]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[4,0].HasCallInTailPosition",
        "name" : "RelationalExpression[4,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : ">="
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1315,
    [
      "SuperProperty[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[SuperProperty[1]]"
        ]
      ],
      "\n          1. Let _env_ be GetThisEnvironment().\n          1. Let _actualThis_ be ? _env_.GetThisBinding().\n          1. Let _propertyKey_ be StringValue of |IdentifierName|.\n          1. If the source text matched by this |SuperProperty| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return ? MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_).\n        ",
      {
        "normalizedName" : "SuperProperty[1,0].Evaluation",
        "name" : "SuperProperty[1,0].Evaluation",
        "htmlId" : "sec-super-keyword-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "SuperProperty",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "super"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2787,
    [
      "PerformPromiseThen",
      0,
      [
        [
          "promise",
          false,
          "Record[Promise]"
        ],
        [
          "onFulfilled",
          false,
          "ESValue"
        ],
        [
          "onRejected",
          false,
          "ESValue"
        ],
        [
          "resultCapability",
          true,
          "Record[PromiseCapabilityRecord]"
        ]
      ],
      "\n            1. Assert: IsPromise(_promise_) is *true*.\n            1. If _resultCapability_ is not present, then\n              1. Set _resultCapability_ to *undefined*.\n            1. If IsCallable(_onFulfilled_) is *false*, then\n              1. Let _onFulfilledJobCallback_ be ~empty~.\n            1. Else,\n              1. Let _onFulfilledJobCallback_ be HostMakeJobCallback(_onFulfilled_).\n            1. If IsCallable(_onRejected_) is *false*, then\n              1. Let _onRejectedJobCallback_ be ~empty~.\n            1. Else,\n              1. Let _onRejectedJobCallback_ be HostMakeJobCallback(_onRejected_).\n            1. Let _fulfillReaction_ be the PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~fulfill~, [[Handler]]: _onFulfilledJobCallback_ }.\n            1. Let _rejectReaction_ be the PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~reject~, [[Handler]]: _onRejectedJobCallback_ }.\n            1. If _promise_.[[PromiseState]] is ~pending~, then\n              1. Append _fulfillReaction_ to _promise_.[[PromiseFulfillReactions]].\n              1. Append _rejectReaction_ to _promise_.[[PromiseRejectReactions]].\n            1. Else if _promise_.[[PromiseState]] is ~fulfilled~, then\n              1. Let _value_ be _promise_.[[PromiseResult]].\n              1. Let _fulfillJob_ be NewPromiseReactionJob(_fulfillReaction_, _value_).\n              1. Perform HostEnqueuePromiseJob(_fulfillJob_.[[Job]], _fulfillJob_.[[Realm]]).\n            1. Else,\n              1. Assert: The value of _promise_.[[PromiseState]] is ~rejected~.\n              1. Let _reason_ be _promise_.[[PromiseResult]].\n              1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *\"handle\"*).\n              1. Let _rejectJob_ be NewPromiseReactionJob(_rejectReaction_, _reason_).\n              1. Perform HostEnqueuePromiseJob(_rejectJob_.[[Job]], _rejectJob_.[[Realm]]).\n            1. Set _promise_.[[PromiseIsHandled]] to *true*.\n            1. If _resultCapability_ is *undefined*, then\n              1. Return *undefined*.\n            1. Else,\n              1. Return _resultCapability_.[[Promise]].\n          ",
      {
        "normalizedName" : "PerformPromiseThen",
        "name" : "PerformPromiseThen",
        "htmlId" : "sec-performpromisethen",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2595,
    [
      "INTRINSICS.Map.prototype.has",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Map.prototype.has",
        "name" : "INTRINSICS.Map.prototype.has",
        "htmlId" : "sec-map.prototype.has",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    518,
    [
      "Statement[13,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[13]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[13,0].ContainsDuplicateLabels",
        "name" : "Statement[13,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 13,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DebuggerStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1850,
    [
      "ExponentiationExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ExponentiationExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ExponentiationExpression[1,0].HasCallInTailPosition",
        "name" : "ExponentiationExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExponentiationExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "UpdateExpression"
              },
              {
                "type" : "terminal",
                "value" : "**"
              },
              {
                "type" : "nonterminal",
                "value" : "ExponentiationExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2499,
    [
      "INTRINSICS.Array.prototype.includes",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If _len_ = 0, return *false*.\n          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.\n          1. If _n_ = +∞, return *false*.\n          1. Else if _n_ = -∞, set _n_ to 0.\n          1. If _n_ ≥ 0, then\n            1. Let _k_ be _n_.\n          1. Else,\n            1. Let _k_ be _len_ + _n_.\n            1. If _k_ < 0, set _k_ to 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).\n            1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.\n            1. Set _k_ to _k_ + 1.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.includes",
        "name" : "INTRINSICS.Array.prototype.includes",
        "htmlId" : "sec-array.prototype.includes",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1083,
    [
      "OrdinaryGetPrototypeOf",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Return _O_.[[Prototype]].\n        ",
      {
        "normalizedName" : "OrdinaryGetPrototypeOf",
        "name" : "OrdinaryGetPrototypeOf",
        "htmlId" : "sec-ordinarygetprototypeof",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    962,
    [
      "ShiftExpression[3,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[ShiftExpression[3]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "ShiftExpression[3,0].AssignmentTargetType",
        "name" : "ShiftExpression[3,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ShiftExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              },
              {
                "type" : "terminal",
                "value" : ">>>"
              },
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2427,
    [
      "ClassSetCharacter[2,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSetCharacter[2]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _cv_ be the CharacterValue of this |ClassSetCharacter|.\n          1. Let _c_ be the character whose character value is _cv_.\n          1. Return the CharSet containing the single character _c_.\n        ",
      {
        "normalizedName" : "ClassSetCharacter[2,0].CompileToCharSet",
        "name" : "ClassSetCharacter[2,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ClassSetCharacter",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "\\"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassSetReservedPunctuator"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2480,
    [
      "INTRINSICS.Array.of",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _len_ be the number of elements in _items_.\n          1. Let _lenNumber_ be 𝔽(_len_).\n          1. Let _C_ be the *this* value.\n          1. If IsConstructor(_C_) is *true*, then\n            1. Let _A_ be ? Construct(_C_, « _lenNumber_ »).\n          1. Else,\n            1. Let _A_ be ? ArrayCreate(_len_).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _kValue_ be _items_[_k_].\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _kValue_).\n            1. Set _k_ to _k_ + 1.\n          1. Perform ? Set(_A_, *\"length\"*, _lenNumber_, *true*).\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.of",
        "name" : "INTRINSICS.Array.of",
        "htmlId" : "sec-array.of",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1982,
    [
      "ExportSpecifier[1,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportSpecifier[1]]"
        ]
      ],
      "\n          1. Return a List whose sole element is the StringValue of the first |ModuleExportName|.\n        ",
      {
        "normalizedName" : "ExportSpecifier[1,0].ExportedBindings",
        "name" : "ExportSpecifier[1,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportSpecifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              },
              {
                "type" : "terminal",
                "value" : "as"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    468,
    [
      "CaseBlock[1,2].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _declarations1_ be the VarScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be VarScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the VarScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,2].VarScopedDeclarations",
        "name" : "CaseBlock[1,2].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2559,
    [
      "SetTypedArrayFromTypedArray",
      0,
      [
        [
          "target",
          false,
          "Record[TypedArray]"
        ],
        [
          "targetOffset",
          false,
          "Int[0+] | +INF"
        ],
        [
          "source",
          false,
          "Record[TypedArray]"
        ]
      ],
      "\n            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].\n            1. Let _targetRecord_ be MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~).\n            1. If IsTypedArrayOutOfBounds(_targetRecord_) is *true*, throw a *TypeError* exception.\n            1. Let _targetLength_ be TypedArrayLength(_targetRecord_).\n            1. Let _srcBuffer_ be _source_.[[ViewedArrayBuffer]].\n            1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_source_, ~seq-cst~).\n            1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, throw a *TypeError* exception.\n            1. Let _srcLength_ be TypedArrayLength(_srcRecord_).\n            1. Let _targetType_ be TypedArrayElementType(_target_).\n            1. Let _targetElementSize_ be TypedArrayElementSize(_target_).\n            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].\n            1. Let _srcType_ be TypedArrayElementType(_source_).\n            1. Let _srcElementSize_ be TypedArrayElementSize(_source_).\n            1. Let _srcByteOffset_ be _source_.[[ByteOffset]].\n            1. If _targetOffset_ = +∞, throw a *RangeError* exception.\n            1. If _srcLength_ + _targetOffset_ > _targetLength_, throw a *RangeError* exception.\n            1. If _target_.[[ContentType]] is not _source_.[[ContentType]], throw a *TypeError* exception.\n            1. If IsSharedArrayBuffer(_srcBuffer_) is *true*, IsSharedArrayBuffer(_targetBuffer_) is *true*, and _srcBuffer_.[[ArrayBufferData]] is _targetBuffer_.[[ArrayBufferData]], let _sameSharedArrayBuffer_ be *true*; otherwise, let _sameSharedArrayBuffer_ be *false*.\n            1. If SameValue(_srcBuffer_, _targetBuffer_) is *true* or _sameSharedArrayBuffer_ is *true*, then\n              1. Let _srcByteLength_ be TypedArrayByteLength(_srcRecord_).\n              1. Set _srcBuffer_ to ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_).\n              1. Let _srcByteIndex_ be 0.\n            1. Else,\n              1. Let _srcByteIndex_ be _srcByteOffset_.\n            1. Let _targetByteIndex_ be (_targetOffset_ × _targetElementSize_) + _targetByteOffset_.\n            1. Let _limit_ be _targetByteIndex_ + (_targetElementSize_ × _srcLength_).\n            1. If _srcType_ is _targetType_, then\n              1. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n              1. Repeat, while _targetByteIndex_ < _limit_,\n                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~).\n                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~).\n                1. Set _srcByteIndex_ to _srcByteIndex_ + 1.\n                1. Set _targetByteIndex_ to _targetByteIndex_ + 1.\n            1. Else,\n              1. Repeat, while _targetByteIndex_ < _limit_,\n                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~unordered~).\n                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~unordered~).\n                1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.\n                1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "SetTypedArrayFromTypedArray",
        "name" : "SetTypedArrayFromTypedArray",
        "htmlId" : "sec-settypedarrayfromtypedarray",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    234,
    [
      "SingleNameBinding[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[SingleNameBinding[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingIdentifier|.\n      ",
      {
        "normalizedName" : "SingleNameBinding[0,0].BoundNames",
        "name" : "SingleNameBinding[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SingleNameBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2544,
    [
      "INTRINSICS.TypedArray.prototype.findIndex",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Index]].\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.findIndex",
        "name" : "INTRINSICS.TypedArray.prototype.findIndex",
        "htmlId" : "sec-%typedarray%.prototype.findindex",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    941,
    [
      "NewTarget[0,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[NewTarget[0]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "NewTarget[0,0].AssignmentTargetType",
        "name" : "NewTarget[0,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NewTarget",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "terminal",
                "value" : "target"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    0,
    [
      "BigInt::exponentiate",
      1,
      [
        [
          "base",
          false,
          "BigInt"
        ],
        [
          "exponent",
          false,
          "BigInt"
        ]
      ],
      "\n            1. If _exponent_ < *0*<sub>ℤ</sub>, throw a *RangeError* exception.\n            1. If _base_ is *0*<sub>ℤ</sub> and _exponent_ is *0*<sub>ℤ</sub>, return *1*<sub>ℤ</sub>.\n            1. Return _base_ raised to the power _exponent_.\n          ",
      {
        "normalizedName" : "BigInt::exponentiate",
        "name" : "BigInt::exponentiate",
        "htmlId" : "sec-numeric-types-bigint-exponentiate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1179,
    [
      "Record[ModuleNamespaceExoticObject].IsExtensible",
      4,
      [
        [
          "this",
          false,
          "Record[ModuleNamespaceExoticObject]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "Record[ModuleNamespaceExoticObject].IsExtensible",
        "name" : "Record[ModuleNamespaceExoticObject].IsExtensible",
        "htmlId" : "sec-module-namespace-exotic-objects-isextensible",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleNamespaceExoticObject",
          "[[IsExtensible]]"
        ]
      }
    ]
  ],
  [
    2331,
    [
      "NonEmptyClassString[0,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[NonEmptyClassString[0]]"
        ]
      ],
      "\n          1. If |NonEmptyClassString| is present, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "NonEmptyClassString[0,0].MayContainStrings",
        "name" : "NonEmptyClassString[0,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NonEmptyClassString",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetCharacter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    777,
    [
      "AssignmentExpression[7,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[7]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[7,0].IsFunctionDefinition",
        "name" : "AssignmentExpression[7,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "||="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    555,
    [
      "CaseBlock[1,1].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,1].ContainsDuplicateLabels",
        "name" : "CaseBlock[1,1].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    666,
    [
      "ForStatement[2,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[2,0].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[2,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1818,
    [
      "TryStatement[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Catch| with argument _call_.\n      ",
      {
        "normalizedName" : "TryStatement[0,0].HasCallInTailPosition",
        "name" : "TryStatement[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1295,
    [
      "TemplateSpans[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateSpans[1]]"
        ]
      ],
      "\n          1. Let _head_ be ? Evaluation of |TemplateMiddleList|.\n          1. Let _tail_ be the TV of |TemplateTail| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.\n          1. Return the string-concatenation of _head_ and _tail_.\n        ",
      {
        "normalizedName" : "TemplateSpans[1,0].Evaluation",
        "name" : "TemplateSpans[1,0].Evaluation",
        "htmlId" : "sec-template-literals-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TemplateSpans",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateMiddleList"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1956,
    [
      "ModuleItemList[1,0].ImportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ]
      ],
      "\n          1. Let _entries1_ be ImportEntries of |ModuleItemList|.\n          1. Let _entries2_ be ImportEntries of |ModuleItem|.\n          1. Return the list-concatenation of _entries1_ and _entries2_.\n        ",
      {
        "normalizedName" : "ModuleItemList[1,0].ImportEntries",
        "name" : "ModuleItemList[1,0].ImportEntries",
        "htmlId" : "sec-static-semantics-importentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntries",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1950,
    [
      "GetModuleNamespace",
      0,
      [
        [
          "module",
          false,
          "Unknown[\"InstanceOfAConcreteSubclassOfModuleRecord\"]"
        ]
      ],
      "\n          1. Assert: If _module_ is a Cyclic Module Record, then _module_.[[Status]] is not ~new~ or ~unlinked~.\n          1. Let _namespace_ be _module_.[[Namespace]].\n          1. If _namespace_ is ~empty~, then\n            1. Let _exportedNames_ be _module_.GetExportedNames().\n            1. Let _unambiguousNames_ be a new empty List.\n            1. For each element _name_ of _exportedNames_, do\n              1. Let _resolution_ be _module_.ResolveExport(_name_).\n              1. If _resolution_ is a ResolvedBinding Record, append _name_ to _unambiguousNames_.\n            1. Set _namespace_ to ModuleNamespaceCreate(_module_, _unambiguousNames_).\n          1. Return _namespace_.\n        ",
      {
        "normalizedName" : "GetModuleNamespace",
        "name" : "GetModuleNamespace",
        "htmlId" : "sec-getmodulenamespace",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    88,
    [
      "NormalCompletion",
      0,
      [
        [
          "value",
          false,
          "Unknown[\"AnyValueExceptACompletionRecord\"]"
        ]
      ],
      "\n          1. Return Completion Record { [[Type]]: ~normal~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n        ",
      {
        "normalizedName" : "NormalCompletion",
        "name" : "NormalCompletion",
        "htmlId" : "sec-normalcompletion",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1549,
    [
      "ThrowStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ThrowStatement[0]]"
        ]
      ],
      "\n        1. Let _exprRef_ be ? Evaluation of |Expression|.\n        1. Let _exprValue_ be ? GetValue(_exprRef_).\n        1. Return ThrowCompletion(_exprValue_).\n      ",
      {
        "normalizedName" : "ThrowStatement[0,0].Evaluation",
        "name" : "ThrowStatement[0,0].Evaluation",
        "htmlId" : "sec-throw-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ThrowStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "throw"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2280,
    [
      "CountLeftCapturingParensBefore",
      0,
      [
        [
          "node",
          false,
          "Ast"
        ]
      ],
      "\n          1. Assert: _node_ is an instance of a production in <emu-xref href=\"#sec-patterns\">the RegExp Pattern grammar</emu-xref>.\n          1. Let _pattern_ be the |Pattern| containing _node_.\n          1. Return the number of <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> Parse Nodes contained within _pattern_ that either occur before _node_ or contain _node_.\n        ",
      {
        "normalizedName" : "CountLeftCapturingParensBefore",
        "name" : "CountLeftCapturingParensBefore",
        "htmlId" : "sec-countleftcapturingparensbefore",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1554,
    [
      "TryStatement[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[2]]"
        ]
      ],
      "\n        1. Let _B_ be Completion(Evaluation of |Block|).\n        1. If _B_ is a throw completion, let _C_ be Completion(CatchClauseEvaluation of |Catch| with argument _B_.[[Value]]).\n        1. Else, let _C_ be _B_.\n        1. Let _F_ be Completion(Evaluation of |Finally|).\n        1. If _F_ is a normal completion, set _F_ to _C_.\n        1. Return ? UpdateEmpty(_F_, *undefined*).\n      ",
      {
        "normalizedName" : "TryStatement[2,0].Evaluation",
        "name" : "TryStatement[2,0].Evaluation",
        "htmlId" : "sec-try-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1110,
    [
      "RequireInternalSlot",
      0,
      [
        [
          "O",
          false,
          "ESValue"
        ],
        [
          "internalSlot",
          false,
          "String"
        ]
      ],
      "\n        1. If _O_ is not an Object, throw a *TypeError* exception.\n        1. If _O_ does not have an _internalSlot_ internal slot, throw a *TypeError* exception.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "RequireInternalSlot",
        "name" : "RequireInternalSlot",
        "htmlId" : "sec-requireinternalslot",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1686,
    [
      "ClassBody[0,0].AllPrivateIdentifiersValid",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassBody[0]]"
        ],
        [
          "names",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _newNames_ be the list-concatenation of _names_ and PrivateBoundIdentifiers of |ClassBody|.\n        1. Return AllPrivateIdentifiersValid of |ClassElementList| with argument _newNames_.\n      ",
      {
        "normalizedName" : "ClassBody[0,0].AllPrivateIdentifiersValid",
        "name" : "ClassBody[0,0].AllPrivateIdentifiersValid",
        "htmlId" : "sec-static-semantics-allprivateidentifiersvalid",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AllPrivateIdentifiersValid",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    481,
    [
      "FunctionStatementList[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,0].VarScopedDeclarations",
        "name" : "FunctionStatementList[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    352,
    [
      "ExportDeclaration[6,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[6]]"
        ]
      ],
      "\n        1. Return a List whose sole element is this |ExportDeclaration|.\n      ",
      {
        "normalizedName" : "ExportDeclaration[6,0].LexicallyScopedDeclarations",
        "name" : "ExportDeclaration[6,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2250,
    [
      "INTRINSICS.String.prototype.match",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. If _regexp_ is neither *undefined* nor *null*, then\n            1. Let _matcher_ be ? GetMethod(_regexp_, @@match).\n            1. If _matcher_ is not *undefined*, then\n              1. Return ? Call(_matcher_, _regexp_, « _O_ »).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).\n          1. Return ? Invoke(_rx_, @@match, « _S_ »).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.match",
        "name" : "INTRINSICS.String.prototype.match",
        "htmlId" : "sec-string.prototype.match",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1211,
    [
      "IdentifierName[0,0].IdentifierCodePoints",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierName[0]]"
        ]
      ],
      "\n          1. Let _cp_ be IdentifierCodePoint of |IdentifierStart|.\n          1. Return « _cp_ ».\n        ",
      {
        "normalizedName" : "IdentifierName[0,0].IdentifierCodePoints",
        "name" : "IdentifierName[0,0].IdentifierCodePoints",
        "htmlId" : "sec-identifiercodepoints",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IdentifierCodePoints",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IdentifierName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierStart"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    683,
    [
      "CaseBlock[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CaseBlock[0,0].ContainsUndefinedContinueTarget",
        "name" : "CaseBlock[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1618,
    [
      "FunctionExpression[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ]
      ],
      "\n        1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression|.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,0].Evaluation",
        "name" : "FunctionExpression[0,0].Evaluation",
        "htmlId" : "sec-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1437,
    [
      "VariableStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[VariableStatement[0]]"
        ]
      ],
      "\n          1. Perform ? Evaluation of |VariableDeclarationList|.\n          1. Return ~empty~.\n        ",
      {
        "normalizedName" : "VariableStatement[0,0].Evaluation",
        "name" : "VariableStatement[0,0].Evaluation",
        "htmlId" : "sec-variable-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "VariableStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2363,
    [
      "IsWordChar",
      0,
      [
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "Input",
          false,
          "Unknown[\"ListOfCharacter\"]"
        ],
        [
          "e",
          false,
          "Int"
        ]
      ],
      "\n            1. Let _InputLength_ be the number of elements in _Input_.\n            1. If _e_ = -1 or _e_ = _InputLength_, return *false*.\n            1. Let _c_ be the character _Input_[_e_].\n            1. If WordCharacters(_rer_) contains _c_, return *true*.\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "IsWordChar",
        "name" : "IsWordChar",
        "htmlId" : "sec-runtime-semantics-iswordchar-abstract-operation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1855,
    [
      "UnaryExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[1,0].HasCallInTailPosition",
        "name" : "UnaryExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "delete"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1200,
    [
      "Record[ProxyExoticObject].Delete",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"deleteProperty\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[Delete]]</emu-meta>(_P_).\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)).\n        1. If _booleanTrapResult_ is *false*, return *false*.\n        1. Let _targetDesc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. If _targetDesc_ is *undefined*, return *true*.\n        1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.\n        1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n        1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].Delete",
        "name" : "Record[ProxyExoticObject].Delete",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-delete-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[Delete]]"
        ]
      }
    ]
  ],
  [
    2077,
    [
      "INTRINSICS.set Object.prototype.__proto__",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _O_ be ? RequireObjectCoercible(*this* value).\n            1. If _proto_ is not an Object and _proto_ is not *null*, return *undefined*.\n            1. If _O_ is not an Object, return *undefined*.\n            1. Let _status_ be ? <emu-meta effects=\"user-code\">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_).\n            1. If _status_ is *false*, throw a *TypeError* exception.\n            1. Return *undefined*.\n          ",
      {
        "normalizedName" : "INTRINSICS.set Object.prototype.__proto__",
        "name" : "INTRINSICS.set Object.prototype.__proto__",
        "htmlId" : "sec-set-object.prototype.__proto__",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1750,
    [
      "AsyncFunctionDeclaration[0,0].InstantiateAsyncFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionDeclaration[0]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Let _name_ be StringValue of |BindingIdentifier|.\n        1. Let _sourceText_ be the source text matched by |AsyncFunctionDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, _name_).\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "AsyncFunctionDeclaration[0,0].InstantiateAsyncFunctionObject",
        "name" : "AsyncFunctionDeclaration[0,0].InstantiateAsyncFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiateasyncfunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateAsyncFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    408,
    [
      "TryStatement[1,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[1]]"
        ]
      ],
      "\n        1. Let _names1_ be VarDeclaredNames of |Block|.\n        1. Let _names2_ be VarDeclaredNames of |Finally|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "TryStatement[1,0].VarDeclaredNames",
        "name" : "TryStatement[1,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    977,
    [
      "LogicalANDExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[LogicalANDExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "LogicalANDExpression[1,0].AssignmentTargetType",
        "name" : "LogicalANDExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LogicalANDExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LogicalANDExpression"
              },
              {
                "type" : "terminal",
                "value" : "&&"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseORExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    170,
    [
      "HasProperty",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n        1. Return ? <emu-meta effects=\"user-code\">_O_.[[HasProperty]]</emu-meta>(_P_).\n      ",
      {
        "normalizedName" : "HasProperty",
        "name" : "HasProperty",
        "htmlId" : "sec-hasproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    523,
    [
      "IfStatement[1,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "IfStatement[1,0].ContainsDuplicateLabels",
        "name" : "IfStatement[1,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1158,
    [
      "MakeArgGetter",
      0,
      [
        [
          "name",
          false,
          "String"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ]
      ],
      "\n            1. Let _getterClosure_ be a new Abstract Closure with no parameters that captures _name_ and _env_ and performs the following steps when called:\n              1. Return _env_.GetBindingValue(_name_, *false*).\n            1. Let _getter_ be CreateBuiltinFunction(_getterClosure_, 0, *\"\"*, « »).\n            1. NOTE: _getter_ is never directly accessible to ECMAScript code.\n            1. Return _getter_.\n          ",
      {
        "normalizedName" : "MakeArgGetter",
        "name" : "MakeArgGetter",
        "htmlId" : "sec-makearggetter",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2309,
    [
      "CharacterClassEscape[2,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[2]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "CharacterClassEscape[2,0].MayContainStrings",
        "name" : "CharacterClassEscape[2,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "s"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    762,
    [
      "EqualityExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "EqualityExpression[1,0].IsFunctionDefinition",
        "name" : "EqualityExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "=="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2512,
    [
      "INTRINSICS.Array.prototype.some",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n              1. If _testResult_ is *true*, return *true*.\n            1. Set _k_ to _k_ + 1.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.some",
        "name" : "INTRINSICS.Array.prototype.some",
        "htmlId" : "sec-array.prototype.some",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    582,
    [
      "StatementListItem[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "StatementListItem[1,0].ContainsUndefinedBreakTarget",
        "name" : "StatementListItem[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1924,
    [
      "ExportDeclaration[1,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[1]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ExportDeclaration[1,0].ModuleRequests",
        "name" : "ExportDeclaration[1,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "NamedExports"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1005,
    [
      "FieldDefinition[0,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[FieldDefinition[0]]"
        ]
      ],
      "\n        1. Return PropName of |ClassElementName|.\n      ",
      {
        "normalizedName" : "FieldDefinition[0,0].PropName",
        "name" : "FieldDefinition[0,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FieldDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2210,
    [
      "INTRINSICS.Date.prototype.setHours",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _h_ be ? ToNumber(_hour_).\n          1. If _min_ is present, let _m_ be ? ToNumber(_min_).\n          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Set _t_ to LocalTime(_t_).\n          1. If _min_ is not present, let _m_ be MinFromTime(_t_).\n          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).\n          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n          1. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).\n          1. Let _u_ be TimeClip(UTC(_date_)).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setHours",
        "name" : "INTRINSICS.Date.prototype.setHours",
        "htmlId" : "sec-date.prototype.sethours",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2117,
    [
      "ThisNumberValue",
      0,
      [
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n            1. If _value_ is a Number, return _value_.\n            1. If _value_ is an Object and _value_ has a [[NumberData]] internal slot, then\n              1. Let _n_ be _value_.[[NumberData]].\n              1. Assert: _n_ is a Number.\n              1. Return _n_.\n            1. Throw a *TypeError* exception.\n          ",
      {
        "normalizedName" : "ThisNumberValue",
        "name" : "ThisNumberValue",
        "htmlId" : "sec-thisnumbervalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1596,
    [
      "BindingElement[1,0].HasInitializer",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElement[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "BindingElement[1,0].HasInitializer",
        "name" : "BindingElement[1,0].HasInitializer",
        "htmlId" : "sec-static-semantics-hasinitializer",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasInitializer",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1406,
    [
      "AssignmentProperty[0,0].PropertyDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentProperty[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _P_ be StringValue of |IdentifierReference|.\n          1. Let _lref_ be ? ResolveBinding(_P_).\n          1. Let _v_ be ? GetV(_value_, _P_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n              1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _P_.\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Set _v_ to ? GetValue(_defaultValue_).\n          1. Perform ? PutValue(_lref_, _v_).\n          1. Return « _P_ ».\n        ",
      {
        "normalizedName" : "AssignmentProperty[0,0].PropertyDestructuringAssignmentEvaluation",
        "name" : "AssignmentProperty[0,0].PropertyDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-propertydestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AssignmentProperty",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierReference"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    115,
    [
      "StringNumericLiteral[1,0].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StringNumericLiteral[1]]"
        ]
      ],
      "\n            1. Return StringNumericValue of |StrNumericLiteral|.\n          ",
      {
        "normalizedName" : "StringNumericLiteral[1,0].StringNumericValue",
        "name" : "StringNumericLiteral[1,0].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StringNumericLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StrNumericLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2104,
    [
      "INTRINSICS._NativeError_",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.\n            1. [id=\"step-nativerror-ordinarycreatefromconstructor\"] Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, <code>\"%<var>NativeError</var>.prototype%\"</code>, « [[ErrorData]] »).\n            1. If _message_ is not *undefined*, then\n              1. Let _msg_ be ? ToString(_message_).\n              1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *\"message\"*, _msg_).\n            1. Perform ? InstallErrorCause(_O_, _options_).\n            1. Return _O_.\n          ",
      {
        "normalizedName" : "INTRINSICS._NativeError_",
        "name" : "INTRINSICS._NativeError_",
        "htmlId" : "sec-nativeerror",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    730,
    [
      "MemberExpression[5,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[5]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[5,0].IsFunctionDefinition",
        "name" : "MemberExpression[5,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MetaProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1290,
    [
      "TemplateMiddleList[0,0].SubstitutionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateMiddleList[0]]"
        ]
      ],
      "\n          1. Let _subRef_ be ? Evaluation of |Expression|.\n          1. Let _sub_ be ? GetValue(_subRef_).\n          1. Return « _sub_ ».\n        ",
      {
        "normalizedName" : "TemplateMiddleList[0,0].SubstitutionEvaluation",
        "name" : "TemplateMiddleList[0,0].SubstitutionEvaluation",
        "htmlId" : "sec-runtime-semantics-substitutionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "SubstitutionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TemplateMiddleList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateMiddle"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1882,
    [
      "PrimaryExpression[7,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[7]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[7,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[7,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "GeneratorExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    217,
    [
      "VariableDeclaration[0,1].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[VariableDeclaration[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingIdentifier|.\n      ",
      {
        "normalizedName" : "VariableDeclaration[0,1].BoundNames",
        "name" : "VariableDeclaration[0,1].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "VariableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    276,
    [
      "LetOrConst[1,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[LetOrConst[1]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "LetOrConst[1,0].IsConstantDeclaration",
        "name" : "LetOrConst[1,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LetOrConst",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "const"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2231,
    [
      "INTRINSICS.Date.prototype.toTimeString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _tv_ be _dateObject_.[[DateValue]].\n          1. If _tv_ is *NaN*, return *\"Invalid Date\"*.\n          1. Let _t_ be LocalTime(_tv_).\n          1. Return the string-concatenation of TimeString(_t_) and TimeZoneString(_tv_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.toTimeString",
        "name" : "INTRINSICS.Date.prototype.toTimeString",
        "htmlId" : "sec-date.prototype.totimestring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2622,
    [
      "INTRINSICS.WeakSet.prototype.add",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).\n          1. If CanBeHeldWeakly(_value_) is *false*, throw a *TypeError* exception.\n          1. For each element _e_ of _S_.[[WeakSetData]], do\n            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then\n              1. Return _S_.\n          1. Append _value_ to _S_.[[WeakSetData]].\n          1. Return _S_.\n        ",
      {
        "normalizedName" : "INTRINSICS.WeakSet.prototype.add",
        "name" : "INTRINSICS.WeakSet.prototype.add",
        "htmlId" : "sec-weakset.prototype.add",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1068,
    [
      "GetThisEnvironment",
      0,
      [
      ],
      "\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. [id=\"step-getthisenvironment-loop\"] Repeat,\n          1. Let _exists_ be _env_.HasThisBinding().\n          1. If _exists_ is *true*, return _env_.\n          1. Let _outer_ be _env_.[[OuterEnv]].\n          1. Assert: _outer_ is not *null*.\n          1. Set _env_ to _outer_.\n      ",
      {
        "normalizedName" : "GetThisEnvironment",
        "name" : "GetThisEnvironment",
        "htmlId" : "sec-getthisenvironment",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2808,
    [
      "INTRINSICS.AsyncGeneratorFunction.prototype.prototype.throw",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _generator_ be the *this* value.\n          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n          1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).\n          1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Let _state_ be _generator_.[[AsyncGeneratorState]].\n          1. If _state_ is ~suspended-start~, then\n            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n            1. Set _state_ to ~completed~.\n          1. If _state_ is ~completed~, then\n            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _exception_ »).\n            1. Return _promiseCapability_.[[Promise]].\n          1. Let _completion_ be ThrowCompletion(_exception_).\n          1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).\n          1. If _state_ is ~suspended-yield~, then\n            1. Perform AsyncGeneratorResume(_generator_, _completion_).\n          1. Else,\n            1. Assert: _state_ is either ~executing~ or ~awaiting-return~.\n          1. Return _promiseCapability_.[[Promise]].\n        ",
      {
        "normalizedName" : "INTRINSICS.AsyncGeneratorFunction.prototype.prototype.throw",
        "name" : "INTRINSICS.AsyncGeneratorFunction.prototype.prototype.throw",
        "htmlId" : "sec-asyncgenerator-prototype-throw",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1522,
    [
      "CaseBlock[1,1].CaseBlockEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "input",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _V_ be *undefined*.\n        1. If the first |CaseClauses| is present, then\n          1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _A_ be a new empty List.\n        1. Let _found_ be *false*.\n        1. For each |CaseClause| _C_ of _A_, do\n          1. If _found_ is *false*, then\n            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n          1. If _found_ is *true*, then\n            1. Let _R_ be Completion(Evaluation of _C_).\n            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n            1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Let _foundInB_ be *false*.\n        1. If the second |CaseClauses| is present, then\n          1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _B_ be a new empty List.\n        1. If _found_ is *false*, then\n          1. For each |CaseClause| _C_ of _B_, do\n            1. If _foundInB_ is *false*, then\n              1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).\n            1. If _foundInB_ is *true*, then\n              1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n              1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n              1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. If _foundInB_ is *true*, return _V_.\n        1. Let _defaultR_ be Completion(Evaluation of |DefaultClause|).\n        1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].\n        1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).\n        1. NOTE: The following is another complete iteration of the second |CaseClauses|.\n        1. For each |CaseClause| _C_ of _B_, do\n          1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n          1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n          1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Return _V_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,1].CaseBlockEvaluation",
        "name" : "CaseBlock[1,1].CaseBlockEvaluation",
        "htmlId" : "sec-runtime-semantics-caseblockevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CaseBlockEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2644,
    [
      "INTRINSICS.ArrayBuffer.isView",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _arg_ is not an Object, return *false*.\n          1. If _arg_ has a [[ViewedArrayBuffer]] internal slot, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.ArrayBuffer.isView",
        "name" : "INTRINSICS.ArrayBuffer.isView",
        "htmlId" : "sec-arraybuffer.isview",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2495,
    [
      "INTRINSICS.Array.prototype.flat",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _sourceLen_ be ? LengthOfArrayLike(_O_).\n          1. Let _depthNum_ be 1.\n          1. If _depth_ is not *undefined*, then\n            1. Set _depthNum_ to ? ToIntegerOrInfinity(_depth_).\n            1. If _depthNum_ < 0, set _depthNum_ to 0.\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).\n          1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, _depthNum_).\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.flat",
        "name" : "INTRINSICS.Array.prototype.flat",
        "htmlId" : "sec-array.prototype.flat",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2381,
    [
      "AtomEscape[3,0].CompileAtom",
      2,
      [
        [
          "this",
          false,
          "Ast[AtomEscape[3]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Let _matchingGroupSpecifiers_ be GroupSpecifiersThatMatch(|GroupName|).\n          1. Assert: _matchingGroupSpecifiers_ contains a single |GroupSpecifier|.\n          1. Let _groupSpecifier_ be the sole element of _matchingGroupSpecifiers_.\n          1. Let _parenIndex_ be CountLeftCapturingParensBefore(_groupSpecifier_).\n          1. Return BackreferenceMatcher(_rer_, _parenIndex_, _direction_).\n        ",
      {
        "normalizedName" : "AtomEscape[3,0].CompileAtom",
        "name" : "AtomEscape[3,0].CompileAtom",
        "htmlId" : "sec-compileatom",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAtom",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "AtomEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "k"
              },
              {
                "type" : "nonterminal",
                "value" : "GroupName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2395,
    [
      "ClassEscape[1,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassEscape[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _cv_ be the CharacterValue of this |ClassEscape|.\n          1. Let _c_ be the character whose character value is _cv_.\n          1. Return the CharSet containing the single character _c_.\n        ",
      {
        "normalizedName" : "ClassEscape[1,0].CompileToCharSet",
        "name" : "ClassEscape[1,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "-"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2062,
    [
      "INTRINSICS.Object.isExtensible",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _O_ is not an Object, return *false*.\n          1. Return ? IsExtensible(_O_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.isExtensible",
        "name" : "INTRINSICS.Object.isExtensible",
        "htmlId" : "sec-object.isextensible",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1443,
    [
      "BindingProperty[0,0].PropertyBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingProperty[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n          1. Let _name_ be the sole element of the BoundNames of |SingleNameBinding|.\n          1. Perform ? KeyedBindingInitialization of |SingleNameBinding| with arguments _value_, _environment_, and _name_.\n          1. Return « _name_ ».\n        ",
      {
        "normalizedName" : "BindingProperty[0,0].PropertyBindingInitialization",
        "name" : "BindingProperty[0,0].PropertyBindingInitialization",
        "htmlId" : "sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BindingProperty",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SingleNameBinding"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2776,
    [
      "INTRINSICS.Promise.resolve",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the *this* value.\n          1. If _C_ is not an Object, throw a *TypeError* exception.\n          1. Return ? PromiseResolve(_C_, _x_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.resolve",
        "name" : "INTRINSICS.Promise.resolve",
        "htmlId" : "sec-promise.resolve",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1808,
    [
      "SwitchStatement[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[SwitchStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |CaseBlock| with argument _call_.\n      ",
      {
        "normalizedName" : "SwitchStatement[0,0].HasCallInTailPosition",
        "name" : "SwitchStatement[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SwitchStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "switch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2659,
    [
      "INTRINSICS.SharedArrayBuffer.prototype.grow",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).\n          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n          1. Let _newByteLength_ be ? ToIndex(_newLength_).\n          1. Let _hostHandled_ be ? HostGrowSharedArrayBuffer(_O_, _newByteLength_).\n          1. If _hostHandled_ is ~handled~, return *undefined*.\n          1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n          1. Let _byteLengthBlock_ be _O_.[[ArrayBufferByteLengthData]].\n          1. Let _currentByteLengthRawBytes_ be GetRawBytesFromSharedBlock(_byteLengthBlock_, 0, ~biguint64~, *true*, ~seq-cst~).\n          1. Let _newByteLengthRawBytes_ be NumericToRawBytes(~biguint64~, ℤ(_newByteLength_), _isLittleEndian_).\n          1. Repeat,\n            1. NOTE: This is a compare-and-exchange loop to ensure that parallel, racing grows of the same buffer are totally ordered, are not lost, and do not silently do nothing. The loop exits if it was able to attempt to grow uncontended.\n            1. Let _currentByteLength_ be ℝ(RawBytesToNumeric(~biguint64~, _currentByteLengthRawBytes_, _isLittleEndian_)).\n            1. If _newByteLength_ = _currentByteLength_, return *undefined*.\n            1. If _newByteLength_ < _currentByteLength_ or _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.\n            1. Let _byteLengthDelta_ be _newByteLength_ - _currentByteLength_.\n            1. If it is impossible to create a new Shared Data Block value consisting of _byteLengthDelta_ bytes, throw a *RangeError* exception.\n            1. NOTE: No new Shared Data Block is constructed and used here. The observable behaviour of growable SharedArrayBuffers is specified by allocating a max-sized Shared Data Block at construction time, and this step captures the requirement that implementations that run out of memory must throw a *RangeError*.\n            1. Let _readByteLengthRawBytes_ be AtomicCompareExchangeInSharedBlock(_byteLengthBlock_, 0, 8, _currentByteLengthRawBytes_, _newByteLengthRawBytes_).\n            1. If ByteListEqual(_readByteLengthRawBytes_, _currentByteLengthRawBytes_) is *true*, return *undefined*.\n            1. Set _currentByteLengthRawBytes_ to _readByteLengthRawBytes_.\n        ",
      {
        "normalizedName" : "INTRINSICS.SharedArrayBuffer.prototype.grow",
        "name" : "INTRINSICS.SharedArrayBuffer.prototype.grow",
        "htmlId" : "sec-sharedarraybuffer.prototype.grow",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    994,
    [
      "LiteralPropertyName[1,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[LiteralPropertyName[1]]"
        ]
      ],
      "\n        1. Return the SV of |StringLiteral|.\n      ",
      {
        "normalizedName" : "LiteralPropertyName[1,0].PropName",
        "name" : "LiteralPropertyName[1,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LiteralPropertyName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StringLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2527,
    [
      "CreateArrayIterator:clo0",
      6,
      [
      ],
      "\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _kind_ and _array_ and performs the following steps when called:\n            1. Let _index_ be 0.\n            1. Repeat,\n              1. If _array_ has a [[TypedArrayName]] internal slot, then\n                1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_array_, ~seq-cst~).\n                1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n                1. Let _len_ be TypedArrayLength(_taRecord_).\n              1. Else,\n                1. Let _len_ be ? LengthOfArrayLike(_array_).\n              1. If _index_ ≥ _len_, return NormalCompletion(*undefined*).\n              1. Let _indexNumber_ be 𝔽(_index_).\n              1. If _kind_ is ~key~, then\n                1. Let _result_ be _indexNumber_.\n              1. Else,\n                1. Let _elementKey_ be ! ToString(_indexNumber_).\n                1. Let _elementValue_ be ? Get(_array_, _elementKey_).\n                1. If _kind_ is ~value~, then\n                  1. Let _result_ be _elementValue_.\n                1. Else,\n                  1. Assert: _kind_ is ~key+value~.\n                  1. Let _result_ be CreateArrayFromList(« _indexNumber_, _elementValue_ »).\n              1. Perform ? GeneratorYield(CreateIterResultObject(_result_, *false*)).\n              1. Set _index_ to _index_ + 1.\n          1. Return CreateIteratorFromClosure(_closure_, *\"%ArrayIteratorPrototype%\"*, %ArrayIteratorPrototype%).\n        ",
      {
        "normalizedName" : "CreateArrayIterator",
        "name" : "CreateArrayIterator",
        "htmlId" : "sec-createarrayiterator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2590,
    [
      "INTRINSICS.Map.prototype.clear",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do\n            1. Set _p_.[[Key]] to ~empty~.\n            1. Set _p_.[[Value]] to ~empty~.\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Map.prototype.clear",
        "name" : "INTRINSICS.Map.prototype.clear",
        "htmlId" : "sec-map.prototype.clear",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1401,
    [
      "ArrayAssignmentPattern[2,0].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayAssignmentPattern[2]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n          1. If _status_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n            1. Return ? _status_.\n          1. If |Elision| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n            1. If _status_ is an abrupt completion, then\n              1. Assert: _iteratorRecord_.[[Done]] is *true*.\n              1. Return ? _status_.\n          1. If |AssignmentRestElement| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n          1. Return ? _status_.\n        ",
      {
        "normalizedName" : "ArrayAssignmentPattern[2,0].DestructuringAssignmentEvaluation",
        "name" : "ArrayAssignmentPattern[2,0].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ArrayAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1422,
    [
      "HoistableDeclaration[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[HoistableDeclaration[1]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "HoistableDeclaration[1,0].Evaluation",
        "name" : "HoistableDeclaration[1,0].Evaluation",
        "htmlId" : "sec-statement-semantics-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "HoistableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "GeneratorDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    308,
    [
      "FunctionStatementList[0,1].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ]
      ],
      "\n        1. Return TopLevelLexicallyDeclaredNames of |StatementList|.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,1].LexicallyDeclaredNames",
        "name" : "FunctionStatementList[0,1].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1569,
    [
      "BindingElisionElement[0,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElisionElement[0]]"
        ]
      ],
      "\n        1. Return ContainsExpression of |BindingElement|.\n      ",
      {
        "normalizedName" : "BindingElisionElement[0,0].ContainsExpression",
        "name" : "BindingElisionElement[0,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BindingElisionElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1939,
    [
      "ExecuteAsyncModule",
      0,
      [
        [
          "module",
          false,
          "Record[CyclicModuleRecord]"
        ]
      ],
      "\n              1. Assert: _module_.[[Status]] is either ~evaluating~ or ~evaluating-async~.\n              1. Assert: _module_.[[HasTLA]] is *true*.\n              1. Let _capability_ be ! NewPromiseCapability(%Promise%).\n              1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and performs the following steps when called:\n                1. Perform AsyncModuleExecutionFulfilled(_module_).\n                1. Return *undefined*.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *\"\"*, « »).\n              1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_error_) that captures _module_ and performs the following steps when called:\n                1. Perform AsyncModuleExecutionRejected(_module_, _error_).\n                1. Return *undefined*.\n              1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 0, *\"\"*, « »).\n              1. Perform PerformPromiseThen(_capability_.[[Promise]], _onFulfilled_, _onRejected_).\n              1. Perform ! <emu-meta effects=\"user-code\">_module_.ExecuteModule</emu-meta>(_capability_).\n              1. Return ~unused~.\n            ",
      {
        "normalizedName" : "ExecuteAsyncModule",
        "name" : "ExecuteAsyncModule",
        "htmlId" : "sec-execute-async-module",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2248,
    [
      "INTRINSICS.String.prototype.lastIndexOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _searchStr_ be ? ToString(_searchString_).\n          1. Let _numPos_ be ? ToNumber(_position_).\n          1. Assert: If _position_ is *undefined*, then _numPos_ is *NaN*.\n          1. If _numPos_ is *NaN*, let _pos_ be +∞; otherwise, let _pos_ be ! ToIntegerOrInfinity(_numPos_).\n          1. Let _len_ be the length of _S_.\n          1. Let _searchLen_ be the length of _searchStr_.\n          1. Let _start_ be the result of clamping _pos_ between 0 and _len_ - _searchLen_.\n          1. If _searchStr_ is the empty String, return 𝔽(_start_).\n          1. For each integer _i_ such that 0 ≤ _i_ ≤ _start_, in descending order, do\n            1. Let _candidate_ be the substring of _S_ from _i_ to _i_ + _searchLen_.\n            1. If _candidate_ is _searchStr_, return 𝔽(_i_).\n          1. Return *-1*<sub>𝔽</sub>.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.lastIndexOf",
        "name" : "INTRINSICS.String.prototype.lastIndexOf",
        "htmlId" : "sec-string.prototype.lastindexof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    741,
    [
      "UnaryExpression[2,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[2,0].IsFunctionDefinition",
        "name" : "UnaryExpression[2,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "void"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1073,
    [
      "HostCallJobCallback",
      0,
      [
        [
          "jobCallback",
          false,
          "Record[JobCallbackRecord]"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Assert: IsCallable(_jobCallback_.[[Callback]]) is *true*.\n        1. Return ? Call(_jobCallback_.[[Callback]], _V_, _argumentsList_).\n      ",
      {
        "normalizedName" : "HostCallJobCallback",
        "name" : "HostCallJobCallback",
        "htmlId" : "sec-hostcalljobcallback",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2671,
    [
      "INTRINSICS.get DataView.prototype.byteOffset",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.\n          1. Let _offset_ be _O_.[[ByteOffset]].\n          1. Return 𝔽(_offset_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get DataView.prototype.byteOffset",
        "name" : "INTRINSICS.get DataView.prototype.byteOffset",
        "htmlId" : "sec-get-dataview.prototype.byteoffset",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1544,
    [
      "Statement[8,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[8]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |Statement|.\n      ",
      {
        "normalizedName" : "Statement[8,0].LabelledEvaluation",
        "name" : "Statement[8,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ReturnStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2676,
    [
      "INTRINSICS.DataView.prototype.getInt8",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. Return ? GetViewValue(_v_, _byteOffset_, *true*, ~int8~).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.getInt8",
        "name" : "INTRINSICS.DataView.prototype.getInt8",
        "htmlId" : "sec-dataview.prototype.getint8",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2014,
    [
      "ExportsList[1,0].ExportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportsList[1]]"
        ],
        [
          "module",
          false,
          "String | Null"
        ]
      ],
      "\n          1. Let _specs1_ be the ExportEntriesForModule of |ExportsList| with argument _module_.\n          1. Let _specs2_ be the ExportEntriesForModule of |ExportSpecifier| with argument _module_.\n          1. Return the list-concatenation of _specs1_ and _specs2_.\n        ",
      {
        "normalizedName" : "ExportsList[1,0].ExportEntriesForModule",
        "name" : "ExportsList[1,0].ExportEntriesForModule",
        "htmlId" : "sec-static-semantics-exportentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportsList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExportsList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "ExportSpecifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    5,
    [
      "HostFinalizeImportMeta",
      0,
      [
        [
          "importMeta",
          false,
          "Record[Object]"
        ],
        [
          "moduleRecord",
          false,
          "Record[ModuleRecord]"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1728,
    [
      "ClassStaticBlockBody[0,0].EvaluateClassStaticBlockBody",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ]
      ],
      "\n        1. Assert: _functionObject_ is a synthetic function created by ClassStaticBlockDefinitionEvaluation step <emu-xref href=\"#step-synthetic-class-static-block-fn\"></emu-xref>.\n        1. Perform ! FunctionDeclarationInstantiation(_functionObject_, « »).\n        1. Return ? Evaluation of |ClassStaticBlockStatementList|.\n      ",
      {
        "normalizedName" : "ClassStaticBlockBody[0,0].EvaluateClassStaticBlockBody",
        "name" : "ClassStaticBlockBody[0,0].EvaluateClassStaticBlockBody",
        "htmlId" : "sec-runtime-semantics-evaluateclassstaticblockbody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateClassStaticBlockBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStaticBlockBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassStaticBlockStatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    873,
    [
      "GeneratorDeclaration[0,0].InstantiateFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorDeclaration[0]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Return InstantiateGeneratorFunctionObject of |GeneratorDeclaration| with arguments _env_ and _privateEnv_.\n      ",
      {
        "normalizedName" : "GeneratorDeclaration[0,0].InstantiateFunctionObject",
        "name" : "GeneratorDeclaration[0,0].InstantiateFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiatefunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1205,
    [
      "ProxyCreate",
      0,
      [
        [
          "target",
          false,
          "ESValue"
        ],
        [
          "handler",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. If _handler_ is not an Object, throw a *TypeError* exception.\n        1. Let _P_ be MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] »).\n        1. Set _P_'s essential internal methods, except for [[Call]] and [[Construct]], to the definitions specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots\"></emu-xref>.\n        1. If IsCallable(_target_) is *true*, then\n          1. Set _P_.[[Call]] as specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist\"></emu-xref>.\n          1. If IsConstructor(_target_) is *true*, then\n            1. Set _P_.[[Construct]] as specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget\"></emu-xref>.\n        1. Set _P_.[[ProxyTarget]] to _target_.\n        1. Set _P_.[[ProxyHandler]] to _handler_.\n        1. Return _P_.\n      ",
      {
        "normalizedName" : "ProxyCreate",
        "name" : "ProxyCreate",
        "htmlId" : "sec-proxycreate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    449,
    [
      "ForStatement[1,3].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "ForStatement[1,3].VarScopedDeclarations",
        "name" : "ForStatement[1,3].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2282,
    [
      "DecimalEscape[0,1].CapturingGroupNumber",
      2,
      [
        [
          "this",
          false,
          "Ast[DecimalEscape[0]]"
        ]
      ],
      "\n          1. Let _n_ be the number of code points in |DecimalDigits|.\n          1. Return (the MV of |NonZeroDigit| × 10<sup>_n_</sup> plus the MV of |DecimalDigits|).\n        ",
      {
        "normalizedName" : "DecimalEscape[0,1].CapturingGroupNumber",
        "name" : "DecimalEscape[0,1].CapturingGroupNumber",
        "htmlId" : "sec-patterns-static-semantics-capturing-group-number",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CapturingGroupNumber",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "DecimalEscape",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NonZeroDigit"
              },
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    247,
    [
      "AsyncGeneratorDeclaration[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorDeclaration[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingIdentifier|.\n      ",
      {
        "normalizedName" : "AsyncGeneratorDeclaration[0,0].BoundNames",
        "name" : "AsyncGeneratorDeclaration[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1591,
    [
      "FormalParameter[0,0].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameter[0]]"
        ]
      ],
      "\n        1. Return IsSimpleParameterList of |BindingElement|.\n      ",
      {
        "normalizedName" : "FormalParameter[0,0].IsSimpleParameterList",
        "name" : "FormalParameter[0,0].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FormalParameter",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    120,
    [
      "StrDecimalLiteral[2,0].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StrDecimalLiteral[2]]"
        ]
      ],
      "\n            1. Let _a_ be StringNumericValue of |StrUnsignedDecimalLiteral|.\n            1. If _a_ is *+0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n            1. Return -_a_.\n          ",
      {
        "normalizedName" : "StrDecimalLiteral[2,0].StringNumericValue",
        "name" : "StrDecimalLiteral[2,0].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "StrDecimalLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "-"
              },
              {
                "type" : "nonterminal",
                "value" : "StrUnsignedDecimalLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2099,
    [
      "ThisSymbolValue",
      0,
      [
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n            1. If _value_ is a Symbol, return _value_.\n            1. If _value_ is an Object and _value_ has a [[SymbolData]] internal slot, then\n              1. Let _s_ be _value_.[[SymbolData]].\n              1. Assert: _s_ is a Symbol.\n              1. Return _s_.\n            1. Throw a *TypeError* exception.\n          ",
      {
        "normalizedName" : "ThisSymbolValue",
        "name" : "ThisSymbolValue",
        "htmlId" : "sec-thissymbolvalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2114,
    [
      "INTRINSICS.Number.prototype.toPrecision",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _x_ be ? ThisNumberValue(*this* value).\n          1. If _precision_ is *undefined*, return ! ToString(_x_).\n          1. Let _p_ be ? ToIntegerOrInfinity(_precision_).\n          1. If _x_ is not finite, return Number::toString(_x_, 10).\n          1. If _p_ < 1 or _p_ > 100, throw a *RangeError* exception.\n          1. Set _x_ to ℝ(_x_).\n          1. Let _s_ be the empty String.\n          1. If _x_ < 0, then\n            1. Set _s_ to the code unit 0x002D (HYPHEN-MINUS).\n            1. Set _x_ to -_x_.\n          1. If _x_ = 0, then\n            1. Let _m_ be the String value consisting of _p_ occurrences of the code unit 0x0030 (DIGIT ZERO).\n            1. Let _e_ be 0.\n          1. Else,\n            1. Let _e_ and _n_ be integers such that 10<sup>_p_ - 1</sup> ≤ _n_ < 10<sup>_p_</sup> and for which _n_ × 10<sup>_e_ - _p_ + 1</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ × 10<sup>_e_ - _p_ + 1</sup> is larger.\n            1. Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).\n            1. If _e_ < -6 or _e_ ≥ _p_, then\n              1. Assert: _e_ ≠ 0.\n              1. If _p_ ≠ 1, then\n                1. Let _a_ be the first code unit of _m_.\n                1. Let _b_ be the other _p_ - 1 code units of _m_.\n                1. Set _m_ to the string-concatenation of _a_, *\".\"*, and _b_.\n              1. If _e_ > 0, then\n                1. Let _c_ be the code unit 0x002B (PLUS SIGN).\n              1. Else,\n                1. Assert: _e_ < 0.\n                1. Let _c_ be the code unit 0x002D (HYPHEN-MINUS).\n                1. Set _e_ to -_e_.\n              1. Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).\n              1. Return the string-concatenation of _s_, _m_, the code unit 0x0065 (LATIN SMALL LETTER E), _c_, and _d_.\n          1. If _e_ = _p_ - 1, return the string-concatenation of _s_ and _m_.\n          1. If _e_ ≥ 0, then\n            1. Set _m_ to the string-concatenation of the first _e_ + 1 code units of _m_, the code unit 0x002E (FULL STOP), and the remaining _p_ - (_e_ + 1) code units of _m_.\n          1. Else,\n            1. Set _m_ to the string-concatenation of the code unit 0x0030 (DIGIT ZERO), the code unit 0x002E (FULL STOP), -(_e_ + 1) occurrences of the code unit 0x0030 (DIGIT ZERO), and the String _m_.\n          1. Return the string-concatenation of _s_ and _m_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Number.prototype.toPrecision",
        "name" : "INTRINSICS.Number.prototype.toPrecision",
        "htmlId" : "sec-number.prototype.toprecision",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2837,
    [
      "INTRINSICS.Reflect.apply",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If IsCallable(_target_) is *false*, throw a *TypeError* exception.\n        1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).\n        1. Perform PrepareForTailCall().\n        1. Return ? Call(_target_, _thisArgument_, _args_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.apply",
        "name" : "INTRINSICS.Reflect.apply",
        "htmlId" : "sec-reflect.apply",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1142,
    [
      "ArrayCreate",
      0,
      [
        [
          "length",
          false,
          "Int[0+]"
        ],
        [
          "proto",
          true,
          "Record[Object]"
        ]
      ],
      "\n          1. If _length_ > 2<sup>32</sup> - 1, throw a *RangeError* exception.\n          1. If _proto_ is not present, set _proto_ to %Array.prototype%.\n          1. Let _A_ be MakeBasicObject(« [[Prototype]], [[Extensible]] »).\n          1. Set _A_.[[Prototype]] to _proto_.\n          1. Set _A_.[[DefineOwnProperty]] as specified in <emu-xref href=\"#sec-array-exotic-objects-defineownproperty-p-desc\"></emu-xref>.\n          1. Perform ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "ArrayCreate",
        "name" : "ArrayCreate",
        "htmlId" : "sec-arraycreate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    379,
    [
      "ForStatement[1,3].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ]
      ],
      "\n        1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n        1. Let _names2_ be VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ForStatement[1,3].VarDeclaredNames",
        "name" : "ForStatement[1,3].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1269,
    [
      "LiteralPropertyName[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[LiteralPropertyName[0]]"
        ]
      ],
      "\n          1. Return StringValue of |IdentifierName|.\n        ",
      {
        "normalizedName" : "LiteralPropertyName[0,0].Evaluation",
        "name" : "LiteralPropertyName[0,0].Evaluation",
        "htmlId" : "sec-object-initializer-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LiteralPropertyName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    878,
    [
      "AsyncFunctionDeclaration[1,0].InstantiateFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionDeclaration[1]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Return InstantiateAsyncFunctionObject of |AsyncFunctionDeclaration| with arguments _env_ and _privateEnv_.\n      ",
      {
        "normalizedName" : "AsyncFunctionDeclaration[1,0].InstantiateFunctionObject",
        "name" : "AsyncFunctionDeclaration[1,0].InstantiateFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiatefunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncFunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    440,
    [
      "ForStatement[0,2].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,2].VarScopedDeclarations",
        "name" : "ForStatement[0,2].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    655,
    [
      "ForStatement[0,1].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[0,1].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[0,1].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    511,
    [
      "Statement[1,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[1,0].ContainsDuplicateLabels",
        "name" : "Statement[1,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "VariableStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2380,
    [
      "AtomEscape[1,0].CompileAtom",
      2,
      [
        [
          "this",
          false,
          "Ast[AtomEscape[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Let _cs_ be CompileToCharSet of |CharacterClassEscape| with argument _rer_.\n          1. If _rer_.[[UnicodeSets]] is *false*, or if every CharSetElement of _cs_ consists of a single character (including if _cs_ is empty), return CharacterSetMatcher(_rer_, _cs_, *false*, _direction_).\n          1. Let _lm_ be an empty List of Matchers.\n          1. For each CharSetElement _s_ in _cs_ containing more than 1 character, iterating in descending order of length, do\n            1. Let _cs2_ be a one-element CharSet containing the last code point of _s_.\n            1. Let _m2_ be CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_).\n            1. For each code point _c1_ in _s_, iterating backwards from its second-to-last code point, do\n              1. Let _cs1_ be a one-element CharSet containing _c1_.\n              1. Let _m1_ be CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_).\n              1. Set _m2_ to MatchSequence(_m1_, _m2_, _direction_).\n            1. Append _m2_ to _lm_.\n          1. Let _singles_ be the CharSet containing every CharSetElement of _cs_ that consists of a single character.\n          1. Append CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) to _lm_.\n          1. If _cs_ contains the empty sequence of characters, append EmptyMatcher() to _lm_.\n          1. Let _m2_ be the last Matcher in _lm_.\n          1. For each Matcher _m1_ of _lm_, iterating backwards from its second-to-last element, do\n            1. Set _m2_ to MatchTwoAlternatives(_m1_, _m2_).\n          1. Return _m2_.\n        ",
      {
        "normalizedName" : "AtomEscape[1,0].CompileAtom",
        "name" : "AtomEscape[1,0].CompileAtom",
        "htmlId" : "sec-compileatom",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAtom",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AtomEscape",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CharacterClassEscape"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1971,
    [
      "ModuleItem[2,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[2]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ModuleItem[2,0].ExportedBindings",
        "name" : "ModuleItem[2,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1793,
    [
      "ForStatement[0,7].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[0,7].HasCallInTailPosition",
        "name" : "ForStatement[0,7].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 7,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2854,
    [
      "SharedDataBlockEventSet",
      0,
      [
        [
          "execution",
          false,
          "Unknown[\"CandidateExecution\"]"
        ]
      ],
      "\n        1. Let _events_ be an empty Set.\n        1. For each event _E_ of EventSet(_execution_), do\n          1. If _E_ is a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event, add _E_ to _events_.\n        1. Return _events_.\n      ",
      {
        "normalizedName" : "SharedDataBlockEventSet",
        "name" : "SharedDataBlockEventSet",
        "htmlId" : "sec-sharedatablockeventset",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1533,
    [
      "BreakableStatement[0,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BreakableStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _stmtResult_ be Completion(LoopEvaluation of |IterationStatement| with argument _labelSet_).\n        1. If _stmtResult_ is a break completion, then\n          1. If _stmtResult_.[[Target]] is ~empty~, then\n            1. If _stmtResult_.[[Value]] is ~empty~, set _stmtResult_ to NormalCompletion(*undefined*).\n            1. Else, set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).\n        1. Return ? _stmtResult_.\n      ",
      {
        "normalizedName" : "BreakableStatement[0,0].LabelledEvaluation",
        "name" : "BreakableStatement[0,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BreakableStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IterationStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    614,
    [
      "BreakStatement[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[BreakStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If _labelSet_ does not contain the StringValue of |LabelIdentifier|, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "BreakStatement[1,0].ContainsUndefinedBreakTarget",
        "name" : "BreakStatement[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BreakStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "break"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1692,
    [
      "ClassElement[4,0].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[4]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ClassElement[4,0].PrivateBoundIdentifiers",
        "name" : "ClassElement[4,0].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassStaticBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    269,
    [
      "HoistableDeclaration[1,0].DeclarationPart",
      2,
      [
        [
          "this",
          false,
          "Ast[HoistableDeclaration[1]]"
        ]
      ],
      "\n        1. Return |GeneratorDeclaration|.\n      ",
      {
        "normalizedName" : "HoistableDeclaration[1,0].DeclarationPart",
        "name" : "HoistableDeclaration[1,0].DeclarationPart",
        "htmlId" : "sec-static-semantics-declarationpart",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DeclarationPart",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "HoistableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "GeneratorDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    677,
    [
      "ForInOfStatement[7,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[7]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForInOfStatement[7,0].ContainsUndefinedContinueTarget",
        "name" : "ForInOfStatement[7,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1305,
    [
      "CallExpression[7,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[7]]"
        ]
      ],
      "\n          1. Let _baseReference_ be ? Evaluation of |CallExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.\n          1. Return MakePrivateReference(_baseValue_, _fieldNameString_).\n        ",
      {
        "normalizedName" : "CallExpression[7,0].Evaluation",
        "name" : "CallExpression[7,0].Evaluation",
        "htmlId" : "sec-property-accessors-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    202,
    [
      "AsyncIteratorClose",
      0,
      [
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "completion",
          false,
          "Completion"
        ]
      ],
      "\n        1. Assert: _iteratorRecord_.[[Iterator]] is an Object.\n        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].\n        1. Let _innerResult_ be Completion(GetMethod(_iterator_, *\"return\"*)).\n        1. If _innerResult_ is a normal completion, then\n          1. Let _return_ be _innerResult_.[[Value]].\n          1. If _return_ is *undefined*, return ? _completion_.\n          1. Set _innerResult_ to Completion(Call(_return_, _iterator_)).\n          1. If _innerResult_ is a normal completion, set _innerResult_ to Completion(Await(_innerResult_.[[Value]])).\n        1. If _completion_ is a throw completion, return ? _completion_.\n        1. If _innerResult_ is a throw completion, return ? _innerResult_.\n        1. If _innerResult_.[[Value]] is not an Object, throw a *TypeError* exception.\n        1. Return ? _completion_.\n      ",
      {
        "normalizedName" : "AsyncIteratorClose",
        "name" : "AsyncIteratorClose",
        "htmlId" : "sec-asynciteratorclose",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    597,
    [
      "ForStatement[1,1].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[1,1].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[1,1].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1041,
    [
      "Record[GlobalEnvironmentRecord].WithBaseObject",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ]
      ],
      "\n            1. Return *undefined*.\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].WithBaseObject",
        "name" : "Record[GlobalEnvironmentRecord].WithBaseObject",
        "htmlId" : "sec-global-environment-records-withbaseobject",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "WithBaseObject"
        ]
      }
    ]
  ],
  [
    861,
    [
      "MethodDefinition[4,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[4]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      ",
      {
        "normalizedName" : "MethodDefinition[4,0].ComputedPropertyContains",
        "name" : "MethodDefinition[4,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "get"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1173,
    [
      "IsValidIntegerIndex",
      0,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "index",
          false,
          "Number"
        ]
      ],
      "\n          1. If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, return *false*.\n          1. If IsIntegralNumber(_index_) is *false*, return *false*.\n          1. If _index_ is *-0*<sub>𝔽</sub>, return *false*.\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~unordered~).\n          1. NOTE: Bounds checking is not a synchronizing operation when _O_'s backing buffer is a growable SharedArrayBuffer.\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *false*.\n          1. Let _length_ be TypedArrayLength(_taRecord_).\n          1. If ℝ(_index_) < 0 or ℝ(_index_) ≥ _length_, return *false*.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "IsValidIntegerIndex",
        "name" : "IsValidIntegerIndex",
        "htmlId" : "sec-isvalidintegerindex",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1486,
    [
      "MemberExpression[7,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[7]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "MemberExpression[7,0].IsDestructuring",
        "name" : "MemberExpression[7,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1671,
    [
      "ClassElement[0,0].IsStatic",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassElement[0,0].IsStatic",
        "name" : "ClassElement[0,0].IsStatic",
        "htmlId" : "sec-static-semantics-isstatic",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsStatic",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MethodDefinition"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1137,
    [
      "CreateBuiltinFunction",
      0,
      [
        [
          "behaviour",
          false,
          "Unknown[\"AbstractClosure,ASetOfAlgorithmSteps,OrSomeOtherDefinitionOfAFunction'sBehaviourProvidedInThisSpecification\"]"
        ],
        [
          "length",
          false,
          "Int[0+] | +INF"
        ],
        [
          "name",
          false,
          "Record[PrivateName | Symbol] | String"
        ],
        [
          "additionalInternalSlotsList",
          false,
          "Unknown[\"ListOfNamesOfInternalSlot\"]"
        ],
        [
          "realm",
          true,
          "Record[RealmRecord]"
        ],
        [
          "prototype",
          true,
          "Record[Object] | Null"
        ],
        [
          "prefix",
          true,
          "String"
        ]
      ],
      "\n        1. If _realm_ is not present, set _realm_ to the current Realm Record.\n        1. If _prototype_ is not present, set _prototype_ to _realm_.[[Intrinsics]].[[%Function.prototype%]].\n        1. Let _internalSlotsList_ be a List containing the names of all the internal slots that <emu-xref href=\"#sec-built-in-function-objects\"></emu-xref> requires for the built-in function object that is about to be created.\n        1. Append to _internalSlotsList_ the elements of _additionalInternalSlotsList_.\n        1. Let _func_ be a new built-in function object that, when called, performs the action described by _behaviour_ using the provided arguments as the values of the corresponding parameters specified by _behaviour_. The new function object has internal slots whose names are the elements of _internalSlotsList_, and an [[InitialName]] internal slot.\n        1. Set _func_.[[Prototype]] to _prototype_.\n        1. Set _func_.[[Extensible]] to *true*.\n        1. Set _func_.[[Realm]] to _realm_.\n        1. Set _func_.[[InitialName]] to *null*.\n        1. Perform SetFunctionLength(_func_, _length_).\n        1. If _prefix_ is not present, then\n          1. Perform SetFunctionName(_func_, _name_).\n        1. Else,\n          1. Perform SetFunctionName(_func_, _name_, _prefix_).\n        1. Return _func_.\n      ",
      {
        "normalizedName" : "CreateBuiltinFunction",
        "name" : "CreateBuiltinFunction",
        "htmlId" : "sec-createbuiltinfunction",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2035,
    [
      "INTRINSICS.parseInt",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _inputString_ be ? ToString(_string_).\n        1. Let _S_ be ! TrimString(_inputString_, ~start~).\n        1. Let _sign_ be 1.\n        1. If _S_ is not empty and the first code unit of _S_ is the code unit 0x002D (HYPHEN-MINUS), set _sign_ to -1.\n        1. If _S_ is not empty and the first code unit of _S_ is either the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS), set _S_ to the substring of _S_ from index 1.\n        1. Let _R_ be ℝ(? ToInt32(_radix_)).\n        1. Let _stripPrefix_ be *true*.\n        1. If _R_ ≠ 0, then\n          1. If _R_ < 2 or _R_ > 36, return *NaN*.\n          1. If _R_ ≠ 16, set _stripPrefix_ to *false*.\n        1. Else,\n          1. Set _R_ to 10.\n        1. If _stripPrefix_ is *true*, then\n          1. If the length of _S_ is at least 2 and the first two code units of _S_ are either *\"0x\"* or *\"0X\"*, then\n            1. Set _S_ to the substring of _S_ from index 2.\n            1. Set _R_ to 16.\n        1. If _S_ contains a code unit that is not a radix-_R_ digit, let _end_ be the index within _S_ of the first such code unit; otherwise, let _end_ be the length of _S_.\n        1. Let _Z_ be the substring of _S_ from 0 to _end_.\n        1. If _Z_ is empty, return *NaN*.\n        1. Let _mathInt_ be the integer value that is represented by _Z_ in radix-_R_ notation, using the letters <b>A</b> through <b>Z</b> and <b>a</b> through <b>z</b> for digits with values 10 through 35. (However, if _R_ = 10 and _Z_ contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if _R_ is not one of 2, 4, 8, 10, 16, or 32, then _mathInt_ may be an implementation-approximated integer representing the integer value denoted by _Z_ in radix-_R_ notation.)\n        1. If _mathInt_ = 0, then\n          1. If _sign_ = -1, return *-0*<sub>𝔽</sub>.\n          1. Return *+0*<sub>𝔽</sub>.\n        1. Return 𝔽(_sign_ × _mathInt_).\n      ",
      {
        "normalizedName" : "INTRINSICS.parseInt",
        "name" : "INTRINSICS.parseInt",
        "htmlId" : "sec-parseint-string-radix",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    550,
    [
      "ForInOfStatement[8,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[8]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[8,0].ContainsDuplicateLabels",
        "name" : "ForInOfStatement[8,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1735,
    [
      "ClassTail[0,0].ClassDefinitionEvaluation:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.\n        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n        1. If |ClassBody| is present, then\n          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do\n            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then\n              1. Assert: This is only possible for getter/setter pairs.\n            1. Else,\n              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.\n              1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n        1. If |ClassHeritage| is not present, then\n          1. Let _protoParent_ be %Object.prototype%.\n          1. Let _constructorParent_ be %Function.prototype%.\n        1. Else,\n          1. Set the running execution context's LexicalEnvironment to _classEnv_.\n          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).\n          1. Set the running execution context's LexicalEnvironment to _env_.\n          1. Let _superclass_ be ? GetValue(? _superclassRef_).\n          1. If _superclass_ is *null*, then\n            1. Let _protoParent_ be *null*.\n            1. Let _constructorParent_ be %Function.prototype%.\n          1. Else if IsConstructor(_superclass_) is *false*, then\n            1. Throw a *TypeError* exception.\n          1. Else,\n            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.\n            1. Let _constructorParent_ be _superclass_.\n        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n        1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n        1. Set the running execution context's LexicalEnvironment to _classEnv_.\n        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.\n        1. If _constructor_ is ~empty~, then\n          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n            1. If NewTarget is *undefined*, throw a *TypeError* exception.\n            1. Let _F_ be the active function object.\n            1. If _F_.[[ConstructorKind]] is ~derived~, then\n              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n            1. Else,\n              1. NOTE: This branch behaves similarly to `constructor() {}`.\n              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n            1. Perform ? InitializeInstanceElements(_result_, _F_).\n            1. Return _result_.\n          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n        1. Else,\n          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n          1. Let _F_ be _constructorInfo_.[[Closure]].\n          1. Perform MakeClassConstructor(_F_).\n          1. Perform SetFunctionName(_F_, _className_).\n        1. Perform MakeConstructor(_F_, *false*, _proto_).\n        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n        1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n        1. If |ClassBody| is not present, let _elements_ be a new empty List.\n        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n        1. Let _instancePrivateMethods_ be a new empty List.\n        1. Let _staticPrivateMethods_ be a new empty List.\n        1. Let _instanceFields_ be a new empty List.\n        1. Let _staticElements_ be a new empty List.\n        1. For each |ClassElement| _e_ of _elements_, do\n          1. If IsStatic of _e_ is *false*, then\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n          1. Else,\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n          1. If _element_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _env_.\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _element_.\n          1. Set _element_ to ! _element_.\n          1. If _element_ is a PrivateElement, then\n            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n            1. Else, let _container_ be _staticPrivateMethods_.\n            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.\n              1. If _element_.[[Get]] is *undefined*, then\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n              1. Else,\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n              1. Replace _pe_ in _container_ with _combined_.\n            1. Else,\n              1. Append _element_ to _container_.\n          1. Else if _element_ is a ClassFieldDefinition Record, then\n            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n            1. Else, append _element_ to _staticElements_.\n          1. Else if _element_ is a ClassStaticBlockDefinition Record, then\n            1. Append _element_ to _staticElements_.\n        1. Set the running execution context's LexicalEnvironment to _env_.\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n        1. Set _F_.[[Fields]] to _instanceFields_.\n        1. For each PrivateElement _method_ of _staticPrivateMethods_, do\n          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n        1. For each element _elementRecord_ of _staticElements_, do\n          1. If _elementRecord_ is a ClassFieldDefinition Record, then\n            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n          1. Else,\n            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.\n            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n          1. If _result_ is an abrupt completion, then\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _result_.\n        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "ClassTail[0,0].ClassDefinitionEvaluation",
        "name" : "ClassTail[0,0].ClassDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-classdefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1233,
    [
      "BindingIdentifier[2,0].StringValue",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingIdentifier[2]]"
        ]
      ],
      "\n        1. Return *\"await\"*.\n      ",
      {
        "normalizedName" : "BindingIdentifier[2,0].StringValue",
        "name" : "BindingIdentifier[2,0].StringValue",
        "htmlId" : "sec-static-semantics-stringvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringValue",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "BindingIdentifier",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "await"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    945,
    [
      "UpdateExpression[2,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[2]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "UpdateExpression[2,0].AssignmentTargetType",
        "name" : "UpdateExpression[2,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "--"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2042,
    [
      "ParseHexOctet",
      0,
      [
        [
          "string",
          false,
          "String"
        ],
        [
          "position",
          false,
          "Int[0+]"
        ]
      ],
      "\n          1. Let _len_ be the length of _string_.\n          1. Assert: _position_ + 2 ≤ _len_.\n          1. Let _hexDigits_ be the substring of _string_ from _position_ to _position_ + 2.\n          1. Let _parseResult_ be ParseText(StringToCodePoints(_hexDigits_), |HexDigits[~Sep]|).\n          1. If _parseResult_ is not a Parse Node, return _parseResult_.\n          1. Let _n_ be the MV of _parseResult_.\n          1. Assert: _n_ is in the inclusive interval from 0 to 255.\n          1. Return _n_.\n        ",
      {
        "normalizedName" : "ParseHexOctet",
        "name" : "ParseHexOctet",
        "htmlId" : "sec-parsehexoctet",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1458,
    [
      "IterationStatement[3,0].LoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[IterationStatement[3]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Return ? ForInOfLoopEvaluation of |ForInOfStatement| with argument _labelSet_.\n        ",
      {
        "normalizedName" : "IterationStatement[3,0].LoopEvaluation",
        "name" : "IterationStatement[3,0].LoopEvaluation",
        "htmlId" : "sec-runtime-semantics-loopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "IterationStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ForInOfStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1497,
    [
      "ForInOfStatement[2,0].ForInOfLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |Expression|, ~enumerate~).\n          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~enumerate~, ~lexical-binding~, _labelSet_).\n        ",
      {
        "normalizedName" : "ForInOfStatement[2,0].ForInOfLoopEvaluation",
        "name" : "ForInOfStatement[2,0].ForInOfLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forinofloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForInOfLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    10,
    [
      "INTRINSICS.Function.prototype.toString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Object] | Undefined"
        ]
      ],
      "\n          1. Let _func_ be the *this* value.\n          1. If _func_ is an Object, _func_ has a [[SourceText]] internal slot, _func_.[[SourceText]] is a sequence of Unicode code points, and HostHasSourceTextAvailable(_func_) is *true*, then\n            1. Return CodePointsToString(_func_.[[SourceText]]).\n          1. If _func_ is a <emu-xref href=\"#sec-built-in-function-objects\">built-in function object</emu-xref>, return an implementation-defined String source code representation of _func_. The representation must have the syntax of a |NativeFunction|. Additionally, if _func_ has an [[InitialName]] internal slot and _func_.[[InitialName]] is a String, the portion of the returned String that would be matched by |NativeFunctionAccessor?| |PropertyName| must be the value of _func_.[[InitialName]].\n          1. If _func_ is an Object and IsCallable(_func_) is *true*, return an implementation-defined String source code representation of _func_. The representation must have the syntax of a |NativeFunction|.\n          1. Throw a *TypeError* exception.\n        ",
      {
        "normalizedName" : "INTRINSICS.Function.prototype.toString",
        "name" : "INTRINSICS.Function.prototype.toString",
        "htmlId" : "sec-function.prototype.tostring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2195,
    [
      "INTRINSICS.Date.prototype.getMinutes",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return MinFromTime(LocalTime(_t_)).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getMinutes",
        "name" : "INTRINSICS.Date.prototype.getMinutes",
        "htmlId" : "sec-date.prototype.getminutes",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1705,
    [
      "FunctionExpression[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,0].ContainsArguments",
        "name" : "FunctionExpression[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1078,
    [
      "ClearKeptObjects",
      0,
      [
      ],
      "\n      1. Let _agentRecord_ be the surrounding agent's Agent Record.\n      1. Set _agentRecord_.[[KeptAlive]] to a new empty List.\n      1. Return ~unused~.\n    ",
      {
        "normalizedName" : "ClearKeptObjects",
        "name" : "ClearKeptObjects",
        "htmlId" : "sec-clear-kept-objects",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1788,
    [
      "ForStatement[0,2].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[0,2].HasCallInTailPosition",
        "name" : "ForStatement[0,2].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1426,
    [
      "BreakableStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BreakableStatement[0]]"
        ]
      ],
      "\n        1. Let _newLabelSet_ be a new empty List.\n        1. Return ? LabelledEvaluation of this |BreakableStatement| with argument _newLabelSet_.\n      ",
      {
        "normalizedName" : "BreakableStatement[0,0].Evaluation",
        "name" : "BreakableStatement[0,0].Evaluation",
        "htmlId" : "sec-statement-semantics-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BreakableStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IterationStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1608,
    [
      "PropertySetParameterList[0,0].ExpectedArgumentCount",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertySetParameterList[0]]"
        ]
      ],
      "\n        1. If HasInitializer of |FormalParameter| is *true*, return 0.\n        1. Return 1.\n      ",
      {
        "normalizedName" : "PropertySetParameterList[0,0].ExpectedArgumentCount",
        "name" : "PropertySetParameterList[0,0].ExpectedArgumentCount",
        "htmlId" : "sec-static-semantics-expectedargumentcount",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExpectedArgumentCount",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "PropertySetParameterList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    385,
    [
      "ForInOfStatement[2,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[2]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForInOfStatement[2,0].VarDeclaredNames",
        "name" : "ForInOfStatement[2,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1655,
    [
      "YieldExpression[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[YieldExpression[2]]"
        ]
      ],
      "\n        1. Let _generatorKind_ be GetGeneratorKind().\n        1. Let _exprRef_ be ? Evaluation of |AssignmentExpression|.\n        1. Let _value_ be ? GetValue(_exprRef_).\n        1. Let _iteratorRecord_ be ? GetIterator(_value_, _generatorKind_).\n        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].\n        1. Let _received_ be NormalCompletion(*undefined*).\n        1. Repeat,\n          1. If _received_ is a normal completion, then\n            1. Let _innerResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _received_.[[Value]] »).\n            1. If _generatorKind_ is ~async~, set _innerResult_ to ? Await(_innerResult_).\n            1. If _innerResult_ is not an Object, throw a *TypeError* exception.\n            1. Let _done_ be ? IteratorComplete(_innerResult_).\n            1. If _done_ is *true*, then\n              1. Return ? IteratorValue(_innerResult_).\n            1. If _generatorKind_ is ~async~, set _received_ to Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_))).\n            1. Else, set _received_ to Completion(GeneratorYield(_innerResult_)).\n          1. Else if _received_ is a throw completion, then\n            1. Let _throw_ be ? GetMethod(_iterator_, *\"throw\"*).\n            1. If _throw_ is not *undefined*, then\n              1. Let _innerResult_ be ? Call(_throw_, _iterator_, « _received_.[[Value]] »).\n              1. If _generatorKind_ is ~async~, set _innerResult_ to ? Await(_innerResult_).\n              1. NOTE: Exceptions from the inner iterator `throw` method are propagated. Normal completions from an inner `throw` method are processed similarly to an inner `next`.\n              1. If _innerResult_ is not an Object, throw a *TypeError* exception.\n              1. Let _done_ be ? IteratorComplete(_innerResult_).\n              1. If _done_ is *true*, then\n                1. Return ? IteratorValue(_innerResult_).\n              1. If _generatorKind_ is ~async~, set _received_ to Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_))).\n              1. Else, set _received_ to Completion(GeneratorYield(_innerResult_)).\n            1. Else,\n              1. NOTE: If _iterator_ does not have a `throw` method, this throw is going to terminate the `yield*` loop. But first we need to give _iterator_ a chance to clean up.\n              1. Let _closeCompletion_ be Completion Record { [[Type]]: ~normal~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.\n              1. If _generatorKind_ is ~async~, perform ? AsyncIteratorClose(_iteratorRecord_, _closeCompletion_).\n              1. Else, perform ? IteratorClose(_iteratorRecord_, _closeCompletion_).\n              1. NOTE: The next step throws a *TypeError* to indicate that there was a `yield*` protocol violation: _iterator_ does not have a `throw` method.\n              1. Throw a *TypeError* exception.\n          1. Else,\n            1. Assert: _received_ is a return completion.\n            1. Let _return_ be ? GetMethod(_iterator_, *\"return\"*).\n            1. If _return_ is *undefined*, then\n              1. Set _value_ to _received_.[[Value]].\n              1. If _generatorKind_ is ~async~, then\n                1. Set _value_ to ? Await(_value_).\n              1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n            1. Let _innerReturnResult_ be ? Call(_return_, _iterator_, « _received_.[[Value]] »).\n            1. If _generatorKind_ is ~async~, set _innerReturnResult_ to ? Await(_innerReturnResult_).\n            1. If _innerReturnResult_ is not an Object, throw a *TypeError* exception.\n            1. Let _done_ be ? IteratorComplete(_innerReturnResult_).\n            1. If _done_ is *true*, then\n              1. Set _value_ to ? IteratorValue(_innerReturnResult_).\n              1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n            1. If _generatorKind_ is ~async~, set _received_ to Completion(AsyncGeneratorYield(? IteratorValue(_innerReturnResult_))).\n            1. Else, set _received_ to Completion(GeneratorYield(_innerReturnResult_)).\n      ",
      {
        "normalizedName" : "YieldExpression[2,0].Evaluation",
        "name" : "YieldExpression[2,0].Evaluation",
        "htmlId" : "sec-generator-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "YieldExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "yield"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    384,
    [
      "ForInOfStatement[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForInOfStatement[0,0].VarDeclaredNames",
        "name" : "ForInOfStatement[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    56,
    [
      "Number::remainder",
      1,
      [
        [
          "n",
          false,
          "Number"
        ],
        [
          "d",
          false,
          "Number"
        ]
      ],
      "\n            1. If _n_ is *NaN* or _d_ is *NaN*, return *NaN*.\n            1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.\n            1. If _d_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return _n_.\n            1. If _d_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *NaN*.\n            1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n            1. Assert: _n_ and _d_ are finite and non-zero.\n            1. Let _quotient_ be ℝ(_n_) / ℝ(_d_).\n            1. Let _q_ be truncate(_quotient_).\n            1. Let _r_ be ℝ(_n_) - (ℝ(_d_) × _q_).\n            1. If _r_ = 0 and _n_ < *-0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n            1. Return 𝔽(_r_).\n          ",
      {
        "normalizedName" : "Number::remainder",
        "name" : "Number::remainder",
        "htmlId" : "sec-numeric-types-number-remainder",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2607,
    [
      "INTRINSICS.Set.prototype.delete",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n          1. For each element _e_ of _S_.[[SetData]], do\n            1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, then\n              1. Replace the element of _S_.[[SetData]] whose value is _e_ with an element whose value is ~empty~.\n              1. Return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Set.prototype.delete",
        "name" : "INTRINSICS.Set.prototype.delete",
        "htmlId" : "sec-set.prototype.delete",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2686,
    [
      "INTRINSICS.DataView.prototype.setInt8",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. Return ? SetViewValue(_v_, _byteOffset_, *true*, ~int8~, _value_).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.setInt8",
        "name" : "INTRINSICS.DataView.prototype.setInt8",
        "htmlId" : "sec-dataview.prototype.setint8",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1756,
    [
      "AsyncFunctionExpression[0,1].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ]
      ],
      "\n        1. Return InstantiateAsyncFunctionExpression of |AsyncFunctionExpression|.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,1].Evaluation",
        "name" : "AsyncFunctionExpression[0,1].Evaluation",
        "htmlId" : "sec-async-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1310,
    [
      "EvaluateNew",
      0,
      [
        [
          "constructExpr",
          false,
          "Ast[MemberExpression | NewExpression]"
        ],
        [
          "arguments",
          false,
          "Ast[Arguments] | Enum[~empty~]"
        ]
      ],
      "\n            1. Let _ref_ be ? Evaluation of _constructExpr_.\n            1. Let _constructor_ be ? GetValue(_ref_).\n            1. If _arguments_ is ~empty~, then\n              1. Let _argList_ be a new empty List.\n            1. Else,\n              1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.\n            1. If IsConstructor(_constructor_) is *false*, throw a *TypeError* exception.\n            1. Return ? Construct(_constructor_, _argList_).\n          ",
      {
        "normalizedName" : "EvaluateNew",
        "name" : "EvaluateNew",
        "htmlId" : "sec-evaluatenew",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    533,
    [
      "ForStatement[0,7].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,7].ContainsDuplicateLabels",
        "name" : "ForStatement[0,7].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 7,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    142,
    [
      "ToPropertyKey",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _key_ be ? ToPrimitive(_argument_, ~string~).\n        1. If _key_ is a Symbol, then\n          1. Return _key_.\n        1. Return ! ToString(_key_).\n      ",
      {
        "normalizedName" : "ToPropertyKey",
        "name" : "ToPropertyKey",
        "htmlId" : "sec-topropertykey",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2740,
    [
      "INTRINSICS.IteratorPrototype[@@iterator]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return the *this* value.\n        ",
      {
        "normalizedName" : "INTRINSICS.IteratorPrototype[@@iterator]",
        "name" : "INTRINSICS.IteratorPrototype[@@iterator]",
        "htmlId" : "sec-%iteratorprototype%-@@iterator",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1867,
    [
      "CallExpression[7,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[7]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CallExpression[7,0].HasCallInTailPosition",
        "name" : "CallExpression[7,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    500,
    [
      "StatementListItem[1,0].TopLevelVarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[1]]"
        ]
      ],
      "\n        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>, then\n          1. Return the BoundNames of |HoistableDeclaration|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "StatementListItem[1,0].TopLevelVarDeclaredNames",
        "name" : "StatementListItem[1,0].TopLevelVarDeclaredNames",
        "htmlId" : "sec-static-semantics-toplevelvardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelVarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2184,
    [
      "MakeFullYear",
      0,
      [
        [
          "year",
          false,
          "Number"
        ]
      ],
      "\n          1. If _year_ is *NaN*, return *NaN*.\n          1. Let _truncated_ be ! ToIntegerOrInfinity(_year_).\n          1. If _truncated_ is in the inclusive interval from 0 to 99, return *1900*<sub>𝔽</sub> + 𝔽(_truncated_).\n          1. Return 𝔽(_truncated_).\n        ",
      {
        "normalizedName" : "MakeFullYear",
        "name" : "MakeFullYear",
        "htmlId" : "sec-makefullyear",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1164,
    [
      "Record[TypedArray].Get",
      4,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If _P_ is a String, then\n            1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n            1. If _numericIndex_ is not *undefined*, then\n              1. Return TypedArrayGetElement(_O_, _numericIndex_).\n          1. Return ? OrdinaryGet(_O_, _P_, _Receiver_).\n        ",
      {
        "normalizedName" : "Record[TypedArray].Get",
        "name" : "Record[TypedArray].Get",
        "htmlId" : "sec-typedarray-get",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "TypedArray",
          "[[Get]]"
        ]
      }
    ]
  ],
  [
    1999,
    [
      "ExportSpecifier[1,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportSpecifier[1]]"
        ]
      ],
      "\n          1. Return a List whose sole element is the StringValue of the second |ModuleExportName|.\n        ",
      {
        "normalizedName" : "ExportSpecifier[1,0].ExportedNames",
        "name" : "ExportSpecifier[1,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportSpecifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              },
              {
                "type" : "terminal",
                "value" : "as"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    797,
    [
      "PrimaryExpression[4,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[4]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[4,0].IsIdentifierRef",
        "name" : "PrimaryExpression[4,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ObjectLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2316,
    [
      "ClassContents[0,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassContents[0]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ClassContents[0,0].MayContainStrings",
        "name" : "ClassContents[0,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassContents",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    715,
    [
      "AsyncGeneratorExpression[0,1].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,1].HasName",
        "name" : "AsyncGeneratorExpression[0,1].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2448,
    [
      "INTRINSICS.get RegExp.prototype.dotAll",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0073 (LATIN SMALL LETTER S).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get RegExp.prototype.dotAll",
        "name" : "INTRINSICS.get RegExp.prototype.dotAll",
        "htmlId" : "sec-get-regexp.prototype.dotAll",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1275,
    [
      "PropertyDefinition[0,0].PropertyDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyDefinition[0]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Let _propName_ be StringValue of |IdentifierReference|.\n          1. Let _exprValue_ be ? Evaluation of |IdentifierReference|.\n          1. Let _propValue_ be ? GetValue(_exprValue_).\n          1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.\n          1. Perform ! CreateDataPropertyOrThrow(_object_, _propName_, _propValue_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "PropertyDefinition[0,0].PropertyDefinitionEvaluation",
        "name" : "PropertyDefinition[0,0].PropertyDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-propertydefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "PropertyDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierReference"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2141,
    [
      "INTRINSICS.Math.fround",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is *NaN*, return *NaN*.\n          1. If _n_ is one of *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return _n_.\n          1. Let _n32_ be the result of converting _n_ to IEEE 754-2019 binary32 format using roundTiesToEven mode.\n          1. Let _n64_ be the result of converting _n32_ to IEEE 754-2019 binary64 format.\n          1. Return the ECMAScript Number value corresponding to _n64_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.fround",
        "name" : "INTRINSICS.Math.fround",
        "htmlId" : "sec-math.fround",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2434,
    [
      "CharacterComplement",
      0,
      [
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "S",
          false,
          "Record[CharSet]"
        ]
      ],
      "\n            1. Let _A_ be AllCharacters(_rer_).\n            1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _S_.\n          ",
      {
        "normalizedName" : "CharacterComplement",
        "name" : "CharacterComplement",
        "htmlId" : "sec-charactercomplement",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    472,
    [
      "CaseClause[0,1].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the VarScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "CaseClause[0,1].VarScopedDeclarations",
        "name" : "CaseClause[0,1].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1872,
    [
      "MemberExpression[5,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[5]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[5,0].HasCallInTailPosition",
        "name" : "MemberExpression[5,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MetaProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2712,
    [
      "ByteListEqual",
      0,
      [
        [
          "xBytes",
          false,
          "Unknown[\"ListOfByteValue\"]"
        ],
        [
          "yBytes",
          false,
          "Unknown[\"ListOfByteValue\"]"
        ]
      ],
      "\n          1. If _xBytes_ and _yBytes_ do not have the same number of elements, return *false*.\n          1. Let _i_ be 0.\n          1. For each element _xByte_ of _xBytes_, do\n            1. Let _yByte_ be _yBytes_[_i_].\n            1. If _xByte_ ≠ _yByte_, return *false*.\n            1. Set _i_ to _i_ + 1.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "ByteListEqual",
        "name" : "ByteListEqual",
        "htmlId" : "sec-bytelistequal",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    814,
    [
      "LeftHandSideExpression[1,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[LeftHandSideExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "LeftHandSideExpression[1,0].IsIdentifierRef",
        "name" : "LeftHandSideExpression[1,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LeftHandSideExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1327,
    [
      "OptionalExpression[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalExpression[0]]"
        ]
      ],
      "\n          1. Let _baseReference_ be ? Evaluation of |MemberExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If _baseValue_ is either *undefined* or *null*, then\n            1. Return *undefined*.\n          1. Return ? ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_.\n        ",
      {
        "normalizedName" : "OptionalExpression[0,0].Evaluation",
        "name" : "OptionalExpression[0,0].Evaluation",
        "htmlId" : "sec-optional-chaining-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "OptionalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2476,
    [
      "INTRINSICS.RegExpStringIteratorPrototype.next",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Return ? GeneratorResume(*this* value, ~empty~, *\"%RegExpStringIteratorPrototype%\"*).\n          ",
      {
        "normalizedName" : "INTRINSICS.RegExpStringIteratorPrototype.next",
        "name" : "INTRINSICS.RegExpStringIteratorPrototype.next",
        "htmlId" : "sec-%regexpstringiteratorprototype%.next",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2627,
    [
      "ArrayBufferCopyAndDetach",
      0,
      [
        [
          "arrayBuffer",
          false,
          "ESValue"
        ],
        [
          "newLength",
          false,
          "ESValue"
        ],
        [
          "preserveResizability",
          false,
          "Enum[~fixed-length~, ~preserve-resizability~]"
        ]
      ],
      "\n          1. Perform ? RequireInternalSlot(_arrayBuffer_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, throw a *TypeError* exception.\n          1. If _newLength_ is *undefined*, then\n            1. Let _newByteLength_ be _arrayBuffer_.[[ArrayBufferByteLength]].\n          1. Else,\n            1. Let _newByteLength_ be ? ToIndex(_newLength_).\n          1. If IsDetachedBuffer(_arrayBuffer_) is *true*, throw a *TypeError* exception.\n          1. If _preserveResizability_ is ~preserve-resizability~ and IsFixedLengthArrayBuffer(_arrayBuffer_) is *false*, then\n            1. Let _newMaxByteLength_ be _arrayBuffer_.[[ArrayBufferMaxByteLength]].\n          1. Else,\n            1. Let _newMaxByteLength_ be ~empty~.\n          1. If _arrayBuffer_.[[ArrayBufferDetachKey]] is not *undefined*, throw a *TypeError* exception.\n          1. Let _newBuffer_ be ? <emu-meta suppress-effects=\"user-code\">AllocateArrayBuffer(%ArrayBuffer%, _newByteLength_, _newMaxByteLength_)</emu-meta>.\n          1. Let _copyLength_ be min(_newByteLength_, _arrayBuffer_.[[ArrayBufferByteLength]]).\n          1. Let _fromBlock_ be _arrayBuffer_.[[ArrayBufferData]].\n          1. Let _toBlock_ be _newBuffer_.[[ArrayBufferData]].\n          1. Perform CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, 0, _copyLength_).\n          1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as a zero-copy move or a `realloc`.\n          1. Perform ! DetachArrayBuffer(_arrayBuffer_).\n          1. Return _newBuffer_.\n        ",
      {
        "normalizedName" : "ArrayBufferCopyAndDetach",
        "name" : "ArrayBufferCopyAndDetach",
        "htmlId" : "sec-arraybuffercopyanddetach",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2168,
    [
      "DateFromTime",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. Let _inLeapYear_ be InLeapYear(_t_).\n          1. Let _dayWithinYear_ be DayWithinYear(_t_).\n          1. Let _month_ be MonthFromTime(_t_).\n          1. If _month_ is *+0*<sub>𝔽</sub>, return _dayWithinYear_ + *1*<sub>𝔽</sub>.\n          1. If _month_ is *1*<sub>𝔽</sub>, return _dayWithinYear_ - *30*<sub>𝔽</sub>.\n          1. If _month_ is *2*<sub>𝔽</sub>, return _dayWithinYear_ - *58*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *3*<sub>𝔽</sub>, return _dayWithinYear_ - *89*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *4*<sub>𝔽</sub>, return _dayWithinYear_ - *119*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *5*<sub>𝔽</sub>, return _dayWithinYear_ - *150*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *6*<sub>𝔽</sub>, return _dayWithinYear_ - *180*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *7*<sub>𝔽</sub>, return _dayWithinYear_ - *211*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *8*<sub>𝔽</sub>, return _dayWithinYear_ - *242*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *9*<sub>𝔽</sub>, return _dayWithinYear_ - *272*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *10*<sub>𝔽</sub>, return _dayWithinYear_ - *303*<sub>𝔽</sub> - _inLeapYear_.\n          1. Assert: _month_ is *11*<sub>𝔽</sub>.\n          1. Return _dayWithinYear_ - *333*<sub>𝔽</sub> - _inLeapYear_.\n        ",
      {
        "normalizedName" : "DateFromTime",
        "name" : "DateFromTime",
        "htmlId" : "sec-datefromtime",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1260,
    [
      "ArrayLiteral[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayLiteral[2]]"
        ]
      ],
      "\n          1. Let _array_ be ! ArrayCreate(0).\n          1. Let _nextIndex_ be ? ArrayAccumulation of |ElementList| with arguments _array_ and 0.\n          1. If |Elision| is present, then\n            1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Return _array_.\n        ",
      {
        "normalizedName" : "ArrayLiteral[2,0].Evaluation",
        "name" : "ArrayLiteral[2,0].Evaluation",
        "htmlId" : "sec-array-initializer-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ArrayLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "ElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    698,
    [
      "Catch[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Catch[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "Catch[0,0].ContainsUndefinedContinueTarget",
        "name" : "Catch[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Catch",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "catch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "CatchParameter"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1919,
    [
      "ModuleItemList[1,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ]
      ],
      "\n          1. Let _moduleNames_ be ModuleRequests of |ModuleItemList|.\n          1. Let _additionalNames_ be ModuleRequests of |ModuleItem|.\n          1. For each String _name_ of _additionalNames_, do\n            1. If _moduleNames_ does not contain _name_, then\n              1. Append _name_ to _moduleNames_.\n          1. Return _moduleNames_.\n        ",
      {
        "normalizedName" : "ModuleItemList[1,0].ModuleRequests",
        "name" : "ModuleItemList[1,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1988,
    [
      "ExportFromClause[0,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportFromClause[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ExportFromClause[0,0].ExportedNames",
        "name" : "ExportFromClause[0,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportFromClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "*"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2459,
    [
      "INTRINSICS.get RegExp.prototype.source",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. If _R_ is not an Object, throw a *TypeError* exception.\n          1. If _R_ does not have an [[OriginalSource]] internal slot, then\n            1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *\"(?:)\"*.\n            1. Otherwise, throw a *TypeError* exception.\n          1. Assert: _R_ has an [[OriginalFlags]] internal slot.\n          1. Let _src_ be _R_.[[OriginalSource]].\n          1. Let _flags_ be _R_.[[OriginalFlags]].\n          1. Return EscapeRegExpPattern(_src_, _flags_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get RegExp.prototype.source",
        "name" : "INTRINSICS.get RegExp.prototype.source",
        "htmlId" : "sec-get-regexp.prototype.source",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1761,
    [
      "AsyncArrowFunction[0,0].InstantiateAsyncArrowFunctionExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowFunction[0]]"
        ],
        [
          "name",
          true,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncArrowFunction|.\n        1. Let _parameters_ be |AsyncArrowBindingIdentifier|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Return _closure_.\n      ",
      {
        "normalizedName" : "AsyncArrowFunction[0,0].InstantiateAsyncArrowFunctionExpression",
        "name" : "AsyncArrowFunction[0,0].InstantiateAsyncArrowFunctionExpression",
        "htmlId" : "sec-runtime-semantics-instantiateasyncarrowfunctionexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateAsyncArrowFunctionExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncArrowFunction",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncArrowBindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1342,
    [
      "ContinueDynamicImport",
      0,
      [
        [
          "promiseCapability",
          false,
          "Record[PromiseCapabilityRecord]"
        ],
        [
          "moduleCompletion",
          false,
          "Normal[Record[ModuleRecord]] | Throw"
        ]
      ],
      "\n            1. If _moduleCompletion_ is an abrupt completion, then\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).\n              1. Return ~unused~.\n            1. Let _module_ be _moduleCompletion_.[[Value]].\n            1. Let _loadPromise_ be _module_.LoadRequestedModules().\n            1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _reason_ »).\n              1. Return ~unused~.\n            1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n            1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, and _onRejected_ and performs the following steps when called:\n              1. Let _link_ be Completion(_module_.Link()).\n              1. If _link_ is an abrupt completion, then\n                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _link_.[[Value]] »).\n                1. Return ~unused~.\n              1. Let _evaluatePromise_ be _module_.Evaluate().\n              1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and _promiseCapability_ and performs the following steps when called:\n                1. Let _namespace_ be GetModuleNamespace(_module_).\n                1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _namespace_ »).\n                1. Return ~unused~.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *\"\"*, « »).\n              1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).\n              1. Return ~unused~.\n            1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, 0, *\"\"*, « »).\n            1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "ContinueDynamicImport",
        "name" : "ContinueDynamicImport",
        "htmlId" : "sec-ContinueDynamicImport",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    747,
    [
      "UnaryExpression[8,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[8]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[8,0].IsFunctionDefinition",
        "name" : "UnaryExpression[8,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AwaitExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    913,
    [
      "IdentifierReference[2,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierReference[2]]"
        ]
      ],
      "\n        1. Return ~simple~.\n      ",
      {
        "normalizedName" : "IdentifierReference[2,0].AssignmentTargetType",
        "name" : "IdentifierReference[2,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "IdentifierReference",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "await"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1640,
    [
      "MethodDefinition[0,0].MethodDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[0]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ],
        [
          "enumerable",
          false,
          "Boolean"
        ]
      ],
      "\n        1. Let _methodDef_ be ? DefineMethod of |MethodDefinition| with argument _object_.\n        1. Perform SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]]).\n        1. Return ? DefineMethodProperty(_object_, _methodDef_.[[Key]], _methodDef_.[[Closure]], _enumerable_).\n      ",
      {
        "normalizedName" : "MethodDefinition[0,0].MethodDefinitionEvaluation",
        "name" : "MethodDefinition[0,0].MethodDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-methoddefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MethodDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2580,
    [
      "AllocateTypedArray",
      0,
      [
        [
          "constructorName",
          false,
          "String"
        ],
        [
          "newTarget",
          false,
          "Record[Constructor]"
        ],
        [
          "defaultProto",
          false,
          "String"
        ],
        [
          "length",
          true,
          "Int[0+]"
        ]
      ],
      "\n            1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _defaultProto_).\n            1. Let _obj_ be TypedArrayCreate(_proto_).\n            1. Assert: _obj_.[[ViewedArrayBuffer]] is *undefined*.\n            1. Set _obj_.[[TypedArrayName]] to _constructorName_.\n            1. If _constructorName_ is either *\"BigInt64Array\"* or *\"BigUint64Array\"*, set _obj_.[[ContentType]] to ~bigint~.\n            1. Otherwise, set _obj_.[[ContentType]] to ~number~.\n            1. If _length_ is not present, then\n              1. Set _obj_.[[ByteLength]] to 0.\n              1. Set _obj_.[[ByteOffset]] to 0.\n              1. Set _obj_.[[ArrayLength]] to 0.\n            1. Else,\n              1. Perform ? AllocateTypedArrayBuffer(_obj_, _length_).\n            1. Return _obj_.\n          ",
      {
        "normalizedName" : "AllocateTypedArray",
        "name" : "AllocateTypedArray",
        "htmlId" : "sec-allocatetypedarray",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1063,
    [
      "CreateIntrinsics",
      0,
      [
        [
          "realmRec",
          false,
          "Record[RealmRecord]"
        ]
      ],
      "\n        1. Set _realmRec_.[[Intrinsics]] to a new Record.\n        1. [declared=\"steps,name,length,slots,prototype\"] Set fields of _realmRec_.[[Intrinsics]] with the values listed in <emu-xref href=\"#table-well-known-intrinsic-objects\"></emu-xref>. The field names are the names listed in column one of the table. The value of each field is a new object value fully and recursively populated with property values as defined by the specification of each object in clauses <emu-xref href=\"#sec-global-object\"></emu-xref> through <emu-xref href=\"#sec-reflection\"></emu-xref>. All object property values are newly created object values. All values that are built-in function objects are created by performing CreateBuiltinFunction(_steps_, _length_, _name_, _slots_, _realmRec_, _prototype_) where _steps_ is the definition of that function provided by this specification, _name_ is the initial value of the function's *\"name\"* property, _length_ is the initial value of the function's *\"length\"* property, _slots_ is a list of the names, if any, of the function's specified internal slots, and _prototype_ is the specified value of the function's [[Prototype]] internal slot. The creation of the intrinsics and their properties must be ordered to avoid any dependencies upon objects that have not yet been created.\n        1. Perform AddRestrictedFunctionProperties(_realmRec_.[[Intrinsics]].[[%Function.prototype%]], _realmRec_).\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "CreateIntrinsics",
        "name" : "CreateIntrinsics",
        "htmlId" : "sec-createintrinsics",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1954,
    [
      "ModuleItem[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[0]]"
        ]
      ],
      "\n          1. Return ~empty~.\n        ",
      {
        "normalizedName" : "ModuleItem[0,0].Evaluation",
        "name" : "ModuleItem[0,0].Evaluation",
        "htmlId" : "sec-module-semantics-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2844,
    [
      "INTRINSICS.Reflect.has",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[HasProperty]]</emu-meta>(_key_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.has",
        "name" : "INTRINSICS.Reflect.has",
        "htmlId" : "sec-reflect.has",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    340,
    [
      "AsyncConciseBody[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncConciseBody[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "AsyncConciseBody[0,0].LexicallyScopedDeclarations",
        "name" : "AsyncConciseBody[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    538,
    [
      "ForStatement[2,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[2,0].ContainsDuplicateLabels",
        "name" : "ForStatement[2,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1354,
    [
      "UnaryExpression[4,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[4]]"
        ]
      ],
      "\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Return ? ToNumber(? GetValue(_expr_)).\n        ",
      {
        "normalizedName" : "UnaryExpression[4,0].Evaluation",
        "name" : "UnaryExpression[4,0].Evaluation",
        "htmlId" : "sec-unary-plus-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "+"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    153,
    [
      "IsStringWellFormedUnicode",
      0,
      [
        [
          "string",
          false,
          "String"
        ]
      ],
      "\n        1. Let _len_ be the length of _string_.\n        1. Let _k_ be 0.\n        1. Repeat, while _k_ < _len_,\n          1. Let _cp_ be CodePointAt(_string_, _k_).\n          1. If _cp_.[[IsUnpairedSurrogate]] is *true*, return *false*.\n          1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "IsStringWellFormedUnicode",
        "name" : "IsStringWellFormedUnicode",
        "htmlId" : "sec-isstringwellformedunicode",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2146,
    [
      "INTRINSICS.Math.log10",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n          1. If _n_ < *-0*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the base 10 logarithm of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.log10",
        "name" : "INTRINSICS.Math.log10",
        "htmlId" : "sec-math.log10",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1507,
    [
      "BindingIdentifier[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingIdentifier[1]]"
        ]
      ],
      "\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Return ? ResolveBinding(_bindingId_).\n        ",
      {
        "normalizedName" : "BindingIdentifier[1,0].Evaluation",
        "name" : "BindingIdentifier[1,0].Evaluation",
        "htmlId" : "sec-for-in-and-for-of-statements-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingIdentifier",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "yield"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1222,
    [
      "DecimalBigIntegerLiteral[1,0].NumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[DecimalBigIntegerLiteral[1]]"
        ]
      ],
      "\n          1. Return the BigInt value for the MV of |NonZeroDigit|.\n        ",
      {
        "normalizedName" : "DecimalBigIntegerLiteral[1,0].NumericValue",
        "name" : "DecimalBigIntegerLiteral[1,0].NumericValue",
        "htmlId" : "sec-numericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NumericValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "DecimalBigIntegerLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NonZeroDigit"
              },
              {
                "type" : "nonterminal",
                "value" : "BigIntLiteralSuffix"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    930,
    [
      "PrimaryExpression[9,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[9]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "PrimaryExpression[9,0].AssignmentTargetType",
        "name" : "PrimaryExpression[9,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 9,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2360,
    [
      "Assertion[5,0].CompileAssertion",
      2,
      [
        [
          "this",
          false,
          "Ast[Assertion[5]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Return _y_.\n            1. Let _r_ be _m_(_x_, _d_).\n            1. If _r_ is not ~failure~, return ~failure~.\n            1. Return _c_(_x_).\n        ",
      {
        "normalizedName" : "Assertion[5,0].CompileAssertion",
        "name" : "Assertion[5,0].CompileAssertion",
        "htmlId" : "sec-compileassertion",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAssertion",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "Assertion",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "(?!"
              },
              {
                "type" : "nonterminal",
                "value" : "Disjunction"
              },
              {
                "type" : "terminal",
                "value" : ")"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    670,
    [
      "ForInOfStatement[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForInOfStatement[0,0].ContainsUndefinedContinueTarget",
        "name" : "ForInOfStatement[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2575,
    [
      "ValidateTypedArray",
      0,
      [
        [
          "O",
          false,
          "ESValue"
        ],
        [
          "order",
          false,
          "Enum[~seq-cst~, ~unordered~]"
        ]
      ],
      "\n          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, _order_).\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n          1. Return _taRecord_.\n        ",
      {
        "normalizedName" : "ValidateTypedArray",
        "name" : "ValidateTypedArray",
        "htmlId" : "sec-validatetypedarray",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1196,
    [
      "Record[ProxyExoticObject].DefineOwnProperty",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Desc",
          false,
          "Record[PropertyDescriptor]"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"defineProperty\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[DefineOwnProperty]]</emu-meta>(_P_, _Desc_).\n        1. Let _descObj_ be FromPropertyDescriptor(_Desc_).\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _descObj_ »)).\n        1. If _booleanTrapResult_ is *false*, return *false*.\n        1. Let _targetDesc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n        1. If _Desc_ has a [[Configurable]] field and _Desc_.[[Configurable]] is *false*, then\n          1. Let _settingConfigFalse_ be *true*.\n        1. Else,\n          1. Let _settingConfigFalse_ be *false*.\n        1. If _targetDesc_ is *undefined*, then\n          1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.\n          1. If _settingConfigFalse_ is *true*, throw a *TypeError* exception.\n        1. Else,\n          1. If IsCompatiblePropertyDescriptor(_extensibleTarget_, _Desc_, _targetDesc_) is *false*, throw a *TypeError* exception.\n          1. If _settingConfigFalse_ is *true* and _targetDesc_.[[Configurable]] is *true*, throw a *TypeError* exception.\n          1. If IsDataDescriptor(_targetDesc_) is *true*, _targetDesc_.[[Configurable]] is *false*, and _targetDesc_.[[Writable]] is *true*, then\n            1. If _Desc_ has a [[Writable]] field and _Desc_.[[Writable]] is *false*, throw a *TypeError* exception.\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].DefineOwnProperty",
        "name" : "Record[ProxyExoticObject].DefineOwnProperty",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[DefineOwnProperty]]"
        ]
      }
    ]
  ],
  [
    1835,
    [
      "EqualityExpression[3,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[3]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "EqualityExpression[3,0].HasCallInTailPosition",
        "name" : "EqualityExpression[3,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "==="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2216,
    [
      "INTRINSICS.Date.prototype.setUTCDate",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _dt_ be ? ToNumber(_date_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).\n          1. Let _v_ be TimeClip(_newDate_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setUTCDate",
        "name" : "INTRINSICS.Date.prototype.setUTCDate",
        "htmlId" : "sec-date.prototype.setutcdate",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2046,
    [
      "INTRINSICS.Object.defineProperties",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _O_ is not an Object, throw a *TypeError* exception.\n          1. Return ? ObjectDefineProperties(_O_, _Properties_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.defineProperties",
        "name" : "INTRINSICS.Object.defineProperties",
        "htmlId" : "sec-object.defineproperties",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    709,
    [
      "ArrowFunction[0,0].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowFunction[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ArrowFunction[0,0].HasName",
        "name" : "ArrowFunction[0,0].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrowFunction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrowParameters"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "ConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1359,
    [
      "MultiplicativeExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[MultiplicativeExpression[1]]"
        ]
      ],
      "\n        1. Let _opText_ be the source text matched by |MultiplicativeOperator|.\n        1. Return ? EvaluateStringOrNumericBinaryExpression(|MultiplicativeExpression|, _opText_, |ExponentiationExpression|).\n      ",
      {
        "normalizedName" : "MultiplicativeExpression[1,0].Evaluation",
        "name" : "MultiplicativeExpression[1,0].Evaluation",
        "htmlId" : "sec-multiplicative-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "MultiplicativeExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeOperator"
              },
              {
                "type" : "nonterminal",
                "value" : "ExponentiationExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2516,
    [
      "CompareArrayElements",
      0,
      [
        [
          "x",
          false,
          "ESValue"
        ],
        [
          "y",
          false,
          "ESValue"
        ],
        [
          "comparefn",
          false,
          "Record[FunctionObject] | Undefined"
        ]
      ],
      "\n            1. If _x_ and _y_ are both *undefined*, return *+0*<sub>𝔽</sub>.\n            1. If _x_ is *undefined*, return *1*<sub>𝔽</sub>.\n            1. If _y_ is *undefined*, return *-1*<sub>𝔽</sub>.\n            1. If _comparefn_ is not *undefined*, then\n              1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, « _x_, _y_ »)).\n              1. If _v_ is *NaN*, return *+0*<sub>𝔽</sub>.\n              1. Return _v_.\n            1. [id=\"step-sortcompare-tostring-x\"] Let _xString_ be ? ToString(_x_).\n            1. [id=\"step-sortcompare-tostring-y\"] Let _yString_ be ? ToString(_y_).\n            1. Let _xSmaller_ be ! IsLessThan(_xString_, _yString_, *true*).\n            1. If _xSmaller_ is *true*, return *-1*<sub>𝔽</sub>.\n            1. Let _ySmaller_ be ! IsLessThan(_yString_, _xString_, *true*).\n            1. If _ySmaller_ is *true*, return *1*<sub>𝔽</sub>.\n            1. Return *+0*<sub>𝔽</sub>.\n          ",
      {
        "normalizedName" : "CompareArrayElements",
        "name" : "CompareArrayElements",
        "htmlId" : "sec-comparearrayelements",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1887,
    [
      "Expression[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[Expression[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |AssignmentExpression| with argument _call_.\n      ",
      {
        "normalizedName" : "Expression[0,0].HasCallInTailPosition",
        "name" : "Expression[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Expression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    829,
    [
      "FunctionExpression[0,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,0].Contains",
        "name" : "FunctionExpression[0,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    174,
    [
      "SetIntegrityLevel",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "level",
          false,
          "Enum[~frozen~, ~sealed~]"
        ]
      ],
      "\n        1. Let _status_ be ? _O_.[[PreventExtensions]]().\n        1. If _status_ is *false*, return *false*.\n        1. Let _keys_ be ? _O_.[[OwnPropertyKeys]]().\n        1. If _level_ is ~sealed~, then\n          1. For each element _k_ of _keys_, do\n            1. Perform ? DefinePropertyOrThrow(_O_, _k_, PropertyDescriptor { [[Configurable]]: *false* }).\n        1. Else,\n          1. Assert: _level_ is ~frozen~.\n          1. For each element _k_ of _keys_, do\n            1. Let _currentDesc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_k_).\n            1. If _currentDesc_ is not *undefined*, then\n              1. If IsAccessorDescriptor(_currentDesc_) is *true*, then\n                1. Let _desc_ be the PropertyDescriptor { [[Configurable]]: *false* }.\n              1. Else,\n                1. Let _desc_ be the PropertyDescriptor { [[Configurable]]: *false*, [[Writable]]: *false* }.\n              1. Perform ? DefinePropertyOrThrow(_O_, _k_, _desc_).\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "SetIntegrityLevel",
        "name" : "SetIntegrityLevel",
        "htmlId" : "sec-setintegritylevel",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1095,
    [
      "ValidateAndApplyPropertyDescriptor",
      0,
      [
        [
          "O",
          false,
          "Record[Object] | Undefined"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "extensible",
          false,
          "Boolean"
        ],
        [
          "Desc",
          false,
          "Record[PropertyDescriptor]"
        ],
        [
          "current",
          false,
          "Record[PropertyDescriptor] | Undefined"
        ]
      ],
      "\n          1. Assert: IsPropertyKey(_P_) is *true*.\n          1. If _current_ is *undefined*, then\n            1. If _extensible_ is *false*, return *false*.\n            1. If _O_ is *undefined*, return *true*.\n            1. If IsAccessorDescriptor(_Desc_) is *true*, then\n              1. Create an own accessor property named _P_ of object _O_ whose [[Get]], [[Set]], [[Enumerable]], and [[Configurable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.\n            1. Else,\n              1. Create an own data property named _P_ of object _O_ whose [[Value]], [[Writable]], [[Enumerable]], and [[Configurable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.\n            1. Return *true*.\n          1. Assert: _current_ is a fully populated Property Descriptor.\n          1. If _Desc_ does not have any fields, return *true*.\n          1. If _current_.[[Configurable]] is *false*, then\n            1. If _Desc_ has a [[Configurable]] field and _Desc_.[[Configurable]] is *true*, return *false*.\n            1. If _Desc_ has an [[Enumerable]] field and _Desc_.[[Enumerable]] is not _current_.[[Enumerable]], return *false*.\n            1. If IsGenericDescriptor(_Desc_) is *false* and IsAccessorDescriptor(_Desc_) is not IsAccessorDescriptor(_current_), return *false*.\n            1. If IsAccessorDescriptor(_current_) is *true*, then\n              1. If _Desc_ has a [[Get]] field and SameValue(_Desc_.[[Get]], _current_.[[Get]]) is *false*, return *false*.\n              1. If _Desc_ has a [[Set]] field and SameValue(_Desc_.[[Set]], _current_.[[Set]]) is *false*, return *false*.\n            1. Else if _current_.[[Writable]] is *false*, then\n              1. If _Desc_ has a [[Writable]] field and _Desc_.[[Writable]] is *true*, return *false*.\n              1. If _Desc_ has a [[Value]] field and SameValue(_Desc_.[[Value]], _current_.[[Value]]) is *false*, return *false*.\n          1. If _O_ is not *undefined*, then\n            1. If IsDataDescriptor(_current_) is *true* and IsAccessorDescriptor(_Desc_) is *true*, then\n              1. If _Desc_ has a [[Configurable]] field, let _configurable_ be _Desc_.[[Configurable]]; else let _configurable_ be _current_.[[Configurable]].\n              1. If _Desc_ has a [[Enumerable]] field, let _enumerable_ be _Desc_.[[Enumerable]]; else let _enumerable_ be _current_.[[Enumerable]].\n              1. Replace the property named _P_ of object _O_ with an accessor property whose [[Configurable]] and [[Enumerable]] attributes are set to _configurable_ and _enumerable_, respectively, and whose [[Get]] and [[Set]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.\n            1. Else if IsAccessorDescriptor(_current_) is *true* and IsDataDescriptor(_Desc_) is *true*, then\n              1. If _Desc_ has a [[Configurable]] field, let _configurable_ be _Desc_.[[Configurable]]; else let _configurable_ be _current_.[[Configurable]].\n              1. If _Desc_ has a [[Enumerable]] field, let _enumerable_ be _Desc_.[[Enumerable]]; else let _enumerable_ be _current_.[[Enumerable]].\n              1. Replace the property named _P_ of object _O_ with a data property whose [[Configurable]] and [[Enumerable]] attributes are set to _configurable_ and _enumerable_, respectively, and whose [[Value]] and [[Writable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.\n            1. Else,\n              1. For each field of _Desc_, set the corresponding attribute of the property named _P_ of object _O_ to the value of the field.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "ValidateAndApplyPropertyDescriptor",
        "name" : "ValidateAndApplyPropertyDescriptor",
        "htmlId" : "sec-validateandapplypropertydescriptor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    404,
    [
      "DefaultClause[0,1].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the VarDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "DefaultClause[0,1].VarDeclaredNames",
        "name" : "DefaultClause[0,1].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1746,
    [
      "ClassExpression[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassExpression[0]]"
        ]
      ],
      "\n        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and *\"\"*.\n        1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.\n        1. Return _value_.\n      ",
      {
        "normalizedName" : "ClassExpression[0,0].Evaluation",
        "name" : "ClassExpression[0,0].Evaluation",
        "htmlId" : "sec-class-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    898,
    [
      "BindingElisionElement[0,1].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElisionElement[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n        1. Return ? IteratorBindingInitialization of |BindingElement| with arguments _iteratorRecord_ and _environment_.\n      ",
      {
        "normalizedName" : "BindingElisionElement[0,1].IteratorBindingInitialization",
        "name" : "BindingElisionElement[0,1].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "BindingElisionElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    185,
    [
      "PrivateElementFind",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[PrivateName]"
        ]
      ],
      "\n        1. If _O_.[[PrivateElements]] contains a PrivateElement _pe_ such that _pe_.[[Key]] is _P_, then\n          1. Return _pe_.\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "PrivateElementFind",
        "name" : "PrivateElementFind",
        "htmlId" : "sec-privateelementfind",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2348,
    [
      "Term[0,0].CompileSubpattern",
      2,
      [
        [
          "this",
          false,
          "Ast[Term[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Return CompileAssertion of |Assertion| with argument _rer_.\n        ",
      {
        "normalizedName" : "Term[0,0].CompileSubpattern",
        "name" : "Term[0,0].CompileSubpattern",
        "htmlId" : "sec-compilesubpattern",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileSubpattern",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Term",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Assertion"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1001,
    [
      "AsyncGeneratorMethod[0,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorMethod[0]]"
        ]
      ],
      "\n        1. Return PropName of |ClassElementName|.\n      ",
      {
        "normalizedName" : "AsyncGeneratorMethod[0,0].PropName",
        "name" : "AsyncGeneratorMethod[0,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2723,
    [
      "INTRINSICS.Atomics.waitAsync",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Return ? DoWait(~async~, _typedArray_, _index_, _value_, _timeout_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.waitAsync",
        "name" : "INTRINSICS.Atomics.waitAsync",
        "htmlId" : "sec-atomics.waitasync",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2432,
    [
      "AllCharacters",
      0,
      [
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n            1. If _rer_.[[UnicodeSets]] is *true* and _rer_.[[IgnoreCase]] is *true*, then\n              1. [declared=\"c\"] Return the CharSet containing all Unicode code points _c_ that do not have a <a href=\"https://www.unicode.org/reports/tr44/#Simple_Case_Folding\">Simple Case Folding</a> mapping (that is, scf(_c_)=_c_).\n            1. Else if HasEitherUnicodeFlag(_rer_) is *true*, then\n              1. Return the CharSet containing all code point values.\n            1. Else,\n              1. Return the CharSet containing all code unit values.\n          ",
      {
        "normalizedName" : "AllCharacters",
        "name" : "AllCharacters",
        "htmlId" : "sec-allcharacters",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1914,
    [
      "ScriptEvaluation",
      0,
      [
        [
          "scriptRecord",
          false,
          "Record[ScriptRecord]"
        ]
      ],
      "\n        1. Let _globalEnv_ be _scriptRecord_.[[Realm]].[[GlobalEnv]].\n        1. Let _scriptContext_ be a new ECMAScript code execution context.\n        1. Set the Function of _scriptContext_ to *null*.\n        1. Set the Realm of _scriptContext_ to _scriptRecord_.[[Realm]].\n        1. Set the ScriptOrModule of _scriptContext_ to _scriptRecord_.\n        1. Set the VariableEnvironment of _scriptContext_ to _globalEnv_.\n        1. Set the LexicalEnvironment of _scriptContext_ to _globalEnv_.\n        1. Set the PrivateEnvironment of _scriptContext_ to *null*.\n        1. Suspend the running execution context.\n        1. Push _scriptContext_ onto the execution context stack; _scriptContext_ is now the running execution context.\n        1. Let _script_ be _scriptRecord_.[[ECMAScriptCode]].\n        1. Let _result_ be Completion(GlobalDeclarationInstantiation(_script_, _globalEnv_)).\n        1. If _result_ is a normal completion, then\n          1. Set _result_ to Completion(Evaluation of _script_).\n          1. If _result_ is a normal completion and _result_.[[Value]] is ~empty~, then\n            1. Set _result_ to NormalCompletion(*undefined*).\n        1. Suspend _scriptContext_ and remove it from the execution context stack.\n        1. Assert: The execution context stack is not empty.\n        1. Resume the context that is now on the top of the execution context stack as the running execution context.\n        1. Return ? _result_.\n      ",
      {
        "normalizedName" : "ScriptEvaluation",
        "name" : "ScriptEvaluation",
        "htmlId" : "sec-runtime-semantics-scriptevaluation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1127,
    [
      "MakeConstructor",
      0,
      [
        [
          "F",
          false,
          "Record[BuiltinFunctionObject | ECMAScriptFunctionObject]"
        ],
        [
          "writablePrototype",
          true,
          "Boolean"
        ],
        [
          "prototype",
          true,
          "Record[Object]"
        ]
      ],
      "\n        1. If _F_ is an ECMAScript function object, then\n          1. Assert: IsConstructor(_F_) is *false*.\n          1. Assert: _F_ is an extensible object that does not have a *\"prototype\"* own property.\n          1. Set _F_.[[Construct]] to the definition specified in <emu-xref href=\"#sec-ecmascript-function-objects-construct-argumentslist-newtarget\"></emu-xref>.\n        1. Else,\n          1. Set _F_.[[Construct]] to the definition specified in <emu-xref href=\"#sec-built-in-function-objects-construct-argumentslist-newtarget\"></emu-xref>.\n        1. Set _F_.[[ConstructorKind]] to ~base~.\n        1. If _writablePrototype_ is not present, set _writablePrototype_ to *true*.\n        1. If _prototype_ is not present, then\n          1. Set _prototype_ to OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ! DefinePropertyOrThrow(_prototype_, *\"constructor\"*, PropertyDescriptor { [[Value]]: _F_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "MakeConstructor",
        "name" : "MakeConstructor",
        "htmlId" : "sec-makeconstructor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2763,
    [
      "GetPromiseResolve",
      0,
      [
        [
          "promiseConstructor",
          false,
          "Record[Constructor]"
        ]
      ],
      "\n            1. Let _promiseResolve_ be ? Get(_promiseConstructor_, *\"resolve\"*).\n            1. If IsCallable(_promiseResolve_) is *false*, throw a *TypeError* exception.\n            1. Return _promiseResolve_.\n          ",
      {
        "normalizedName" : "GetPromiseResolve",
        "name" : "GetPromiseResolve",
        "htmlId" : "sec-getpromiseresolve",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2548,
    [
      "INTRINSICS.TypedArray.prototype.includes",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If _len_ = 0, return *false*.\n          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.\n          1. If _n_ = +∞, return *false*.\n          1. Else if _n_ = -∞, set _n_ to 0.\n          1. If _n_ ≥ 0, then\n            1. Let _k_ be _n_.\n          1. Else,\n            1. Let _k_ be _len_ + _n_.\n            1. If _k_ < 0, set _k_ to 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _elementK_ be ! Get(_O_, ! ToString(𝔽(_k_))).\n            1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.\n            1. Set _k_ to _k_ + 1.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.includes",
        "name" : "INTRINSICS.TypedArray.prototype.includes",
        "htmlId" : "sec-%typedarray%.prototype.includes",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1782,
    [
      "IfStatement[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Let _has_ be HasCallInTailPosition of the first |Statement| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Return HasCallInTailPosition of the second |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "IfStatement[0,0].HasCallInTailPosition",
        "name" : "IfStatement[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "else"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2491,
    [
      "INTRINSICS.Array.prototype.findIndex",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Index]].\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.findIndex",
        "name" : "INTRINSICS.Array.prototype.findIndex",
        "htmlId" : "sec-array.prototype.findindex",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1243,
    [
      "Literal[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Literal[1]]"
        ]
      ],
      "\n          1. If |BooleanLiteral| is the token `false`, return *false*.\n          1. If |BooleanLiteral| is the token `true`, return *true*.\n        ",
      {
        "normalizedName" : "Literal[1,0].Evaluation",
        "name" : "Literal[1,0].Evaluation",
        "htmlId" : "sec-literals-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Literal",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BooleanLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2227,
    [
      "TimeString",
      0,
      [
        [
          "tv",
          false,
          "Unknown[\"Number,ButNot*NaN*\"]"
        ]
      ],
      "\n            1. Let _hour_ be ToZeroPaddedDecimalString(ℝ(HourFromTime(_tv_)), 2).\n            1. Let _minute_ be ToZeroPaddedDecimalString(ℝ(MinFromTime(_tv_)), 2).\n            1. Let _second_ be ToZeroPaddedDecimalString(ℝ(SecFromTime(_tv_)), 2).\n            1. Return the string-concatenation of _hour_, *\":\"*, _minute_, *\":\"*, _second_, the code unit 0x0020 (SPACE), and *\"GMT\"*.\n          ",
      {
        "normalizedName" : "TimeString",
        "name" : "TimeString",
        "htmlId" : "sec-timestring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1391,
    [
      "ObjectAssignmentPattern[0,0].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectAssignmentPattern[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Perform ? RequireObjectCoercible(_value_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "ObjectAssignmentPattern[0,0].DestructuringAssignmentEvaluation",
        "name" : "ObjectAssignmentPattern[0,0].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ObjectAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1576,
    [
      "BindingRestElement[1,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingRestElement[1]]"
        ]
      ],
      "\n        1. Return ContainsExpression of |BindingPattern|.\n      ",
      {
        "normalizedName" : "BindingRestElement[1,0].ContainsExpression",
        "name" : "BindingRestElement[1,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingRestElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "..."
              },
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    782,
    [
      "FunctionExpression[0,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,0].IsFunctionDefinition",
        "name" : "FunctionExpression[0,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1441,
    [
      "VariableDeclaration[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[VariableDeclaration[1]]"
        ]
      ],
      "\n          1. Let _rhs_ be ? Evaluation of |Initializer|.\n          1. Let _rval_ be ? GetValue(_rhs_).\n          1. Return ? BindingInitialization of |BindingPattern| with arguments _rval_ and *undefined*.\n        ",
      {
        "normalizedName" : "VariableDeclaration[1,0].Evaluation",
        "name" : "VariableDeclaration[1,0].Evaluation",
        "htmlId" : "sec-variable-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "VariableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2020,
    [
      "ModuleExportName[0,0].ReferencedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleExportName[0]]"
        ]
      ],
      "\n          1. Return a List whose sole element is the |IdentifierName|.\n        ",
      {
        "normalizedName" : "ModuleExportName[0,0].ReferencedBindings",
        "name" : "ModuleExportName[0,0].ReferencedBindings",
        "htmlId" : "sec-static-semantics-referencedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ReferencedBindings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleExportName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    841,
    [
      "AsyncFunctionExpression[0,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,0].Contains",
        "name" : "AsyncFunctionExpression[0,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    417,
    [
      "Script[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[Script[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Script[0,0].VarDeclaredNames",
        "name" : "Script[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Script",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    24,
    [
      "PrepareForTailCall",
      0,
      [
      ],
      "\n        1. Assert: The current execution context will not subsequently be used for the evaluation of any ECMAScript code or built-in functions. The invocation of Call subsequent to the invocation of this abstract operation will create and push a new execution context before performing any such evaluation.\n        1. Discard all resources associated with the current execution context.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "PrepareForTailCall",
        "name" : "PrepareForTailCall",
        "htmlId" : "sec-preparefortailcall",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    973,
    [
      "EqualityExpression[4,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[4]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "EqualityExpression[4,0].AssignmentTargetType",
        "name" : "EqualityExpression[4,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "!=="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    885,
    [
      "ObjectBindingPattern[2,0].BindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectBindingPattern[2]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Perform ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "ObjectBindingPattern[2,0].BindingInitialization",
        "name" : "ObjectBindingPattern[2,0].BindingInitialization",
        "htmlId" : "sec-runtime-semantics-bindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ObjectBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingPropertyList"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1046,
    [
      "Record[GlobalEnvironmentRecord].CanDeclareGlobalVar",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ]
      ],
      "\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n            1. Let _hasProperty_ be ? HasOwnProperty(_globalObject_, _N_).\n            1. If _hasProperty_ is *true*, return *true*.\n            1. Return ? IsExtensible(_globalObject_).\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].CanDeclareGlobalVar",
        "name" : "Record[GlobalEnvironmentRecord].CanDeclareGlobalVar",
        "htmlId" : "sec-candeclareglobalvar",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "CanDeclareGlobalVar"
        ]
      }
    ]
  ],
  [
    288,
    [
      "ExportDeclaration[1,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ExportDeclaration[1,0].IsConstantDeclaration",
        "name" : "ExportDeclaration[1,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "NamedExports"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1613,
    [
      "FunctionDeclaration[1,0].InstantiateOrdinaryFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[1]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Let _sourceText_ be the source text matched by |FunctionDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, *\"default\"*).\n        1. Perform MakeConstructor(_F_).\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[1,0].InstantiateOrdinaryFunctionObject",
        "name" : "FunctionDeclaration[1,0].InstantiateOrdinaryFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiateordinaryfunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateOrdinaryFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2010,
    [
      "ExportDeclaration[6,0].ExportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[6]]"
        ]
      ],
      "\n          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: *\"\\*default\\*\"*, [[ExportName]]: *\"default\"* }.\n          1. Return « _entry_ ».\n        ",
      {
        "normalizedName" : "ExportDeclaration[6,0].ExportEntries",
        "name" : "ExportDeclaration[6,0].ExportEntries",
        "htmlId" : "sec-static-semantics-exportentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntries",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1935,
    [
      "Record[CyclicModuleRecord].Evaluate",
      3,
      [
        [
          "module",
          false,
          "Record[CyclicModuleRecord]"
        ]
      ],
      "\n            1. Assert: This call to Evaluate is not happening at the same time as another call to Evaluate within the surrounding agent.\n            1. Assert: _module_.[[Status]] is one of ~linked~, ~evaluating-async~, or ~evaluated~.\n            1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, set _module_ to _module_.[[CycleRoot]].\n            1. If _module_.[[TopLevelCapability]] is not ~empty~, then\n              1. Return _module_.[[TopLevelCapability]].[[Promise]].\n            1. Let _stack_ be a new empty List.\n            1. Let _capability_ be ! NewPromiseCapability(%Promise%).\n            1. Set _module_.[[TopLevelCapability]] to _capability_.\n            1. Let _result_ be Completion(InnerModuleEvaluation(_module_, _stack_, 0)).\n            1. If _result_ is an abrupt completion, then\n              1. For each Cyclic Module Record _m_ of _stack_, do\n                1. Assert: _m_.[[Status]] is ~evaluating~.\n                1. Set _m_.[[Status]] to ~evaluated~.\n                1. Set _m_.[[EvaluationError]] to _result_.\n              1. Assert: _module_.[[Status]] is ~evaluated~.\n              1. Assert: _module_.[[EvaluationError]] is _result_.\n              1. Perform ! Call(_capability_.[[Reject]], *undefined*, « _result_.[[Value]] »).\n            1. Else,\n              1. Assert: _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~.\n              1. Assert: _module_.[[EvaluationError]] is ~empty~.\n              1. If _module_.[[AsyncEvaluation]] is *false*, then\n                1. Assert: _module_.[[Status]] is ~evaluated~.\n                1. Perform ! Call(_capability_.[[Resolve]], *undefined*, « *undefined* »).\n              1. Assert: _stack_ is empty.\n            1. Return _capability_.[[Promise]].\n          ",
      {
        "normalizedName" : "Record[CyclicModuleRecord].Evaluate",
        "name" : "Record[CyclicModuleRecord].Evaluate",
        "htmlId" : "sec-moduleevaluation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "CyclicModuleRecord",
          "Evaluate"
        ]
      }
    ]
  ],
  [
    1650,
    [
      "GeneratorExpression[0,1].InstantiateGeneratorFunctionExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ],
        [
          "name",
          true,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Assert: _name_ is not present.\n        1. Set _name_ to StringValue of |BindingIdentifier|.\n        1. Let _outerEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).\n        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |GeneratorExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).\n        1. Return _closure_.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,1].InstantiateGeneratorFunctionExpression",
        "name" : "GeneratorExpression[0,1].InstantiateGeneratorFunctionExpression",
        "htmlId" : "sec-runtime-semantics-instantiategeneratorfunctionexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateGeneratorFunctionExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1645,
    [
      "AsyncMethod[0,0].MethodDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncMethod[0]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ],
        [
          "enumerable",
          false,
          "Boolean"
        ]
      ],
      "\n        1. Let _propKey_ be ? Evaluation of |ClassElementName|.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncMethod|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform MakeMethod(_closure_, _object_).\n        1. Perform SetFunctionName(_closure_, _propKey_).\n        1. Return ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_).\n      ",
      {
        "normalizedName" : "AsyncMethod[0,0].MethodDefinitionEvaluation",
        "name" : "AsyncMethod[0,0].MethodDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-methoddefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MethodDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1921,
    [
      "ImportDeclaration[0,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportDeclaration[0]]"
        ]
      ],
      "\n          1. Return ModuleRequests of |FromClause|.\n        ",
      {
        "normalizedName" : "ImportDeclaration[0,0].ModuleRequests",
        "name" : "ImportDeclaration[0,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ImportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "import"
              },
              {
                "type" : "nonterminal",
                "value" : "ImportClause"
              },
              {
                "type" : "nonterminal",
                "value" : "FromClause"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1601,
    [
      "FormalParameters[0,0].ExpectedArgumentCount",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameters[0]]"
        ]
      ],
      "\n        1. Return 0.\n      ",
      {
        "normalizedName" : "FormalParameters[0,0].ExpectedArgumentCount",
        "name" : "FormalParameters[0,0].ExpectedArgumentCount",
        "htmlId" : "sec-static-semantics-expectedargumentcount",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExpectedArgumentCount",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FormalParameters",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1386,
    [
      "AssignmentExpression[6,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[6]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |LeftHandSideExpression|.\n        1. [id=\"step-assignmentexpression-evaluation-lgcl-and-getvalue\"] Let _lval_ be ? GetValue(_lref_).\n        1. Let _lbool_ be ToBoolean(_lval_).\n        1. If _lbool_ is *false*, return _lval_.\n        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then\n          1. Let _rval_ be ? NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].\n        1. Else,\n          1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _rval_ be ? GetValue(_rref_).\n        1. [id=\"step-assignmentexpression-evaluation-lgcl-and-putvalue\"] Perform ? PutValue(_lref_, _rval_).\n        1. Return _rval_.\n      ",
      {
        "normalizedName" : "AssignmentExpression[6,0].Evaluation",
        "name" : "AssignmentExpression[6,0].Evaluation",
        "htmlId" : "sec-assignment-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "&&="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    301,
    [
      "CaseClause[0,1].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the LexicallyDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "CaseClause[0,1].LexicallyDeclaredNames",
        "name" : "CaseClause[0,1].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2082,
    [
      "INTRINSICS.Function",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the active function object.\n          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.\n          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~normal~, _parameterArgs_, _bodyArg_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Function",
        "name" : "INTRINSICS.Function",
        "htmlId" : "sec-function-p1-p2-pn-body",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1724,
    [
      "AsyncMethod[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncMethod[0]]"
        ]
      ],
      "\n        1. Return ContainsArguments of |ClassElementName|.\n      ",
      {
        "normalizedName" : "AsyncMethod[0,0].ContainsArguments",
        "name" : "AsyncMethod[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1475,
    [
      "ForStatement[2,2].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n          1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.\n          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.\n          1. For each element _dn_ of _boundNames_, do\n            1. If _isConst_ is *true*, then\n              1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).\n            1. Else,\n              1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).\n          1. Set the running execution context's LexicalEnvironment to _loopEnv_.\n          1. Let _forDcl_ be Completion(Evaluation of |LexicalDeclaration|).\n          1. If _forDcl_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n            1. Return ? _forDcl_.\n          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be a new empty List.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).\n          1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n          1. Return ? _bodyResult_.\n        ",
      {
        "normalizedName" : "ForStatement[2,2].ForLoopEvaluation",
        "name" : "ForStatement[2,2].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    320,
    [
      "StatementListItem[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[0]]"
        ]
      ],
      "\n        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return LexicallyScopedDeclarations of |LabelledStatement|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "StatementListItem[0,0].LexicallyScopedDeclarations",
        "name" : "StatementListItem[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2173,
    [
      "msFromTime",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. Return 𝔽(ℝ(_t_) modulo ℝ(msPerSecond)).\n        ",
      {
        "normalizedName" : "msFromTime",
        "name" : "msFromTime",
        "htmlId" : "sec-msfromtime",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    565,
    [
      "TryStatement[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.\n        1. If _hasDuplicates_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of |Catch| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "TryStatement[0,0].ContainsDuplicateLabels",
        "name" : "TryStatement[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1366,
    [
      "RelationalExpression[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[2]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _r_ be ? IsLessThan(_rval_, _lval_, *false*).\n        1. If _r_ is *undefined*, return *false*. Otherwise, return _r_.\n      ",
      {
        "normalizedName" : "RelationalExpression[2,0].Evaluation",
        "name" : "RelationalExpression[2,0].Evaluation",
        "htmlId" : "sec-relational-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : ">"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2400,
    [
      "CharacterClassEscape[3,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[3]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `s`</emu-grammar>.\n          1. Return CharacterComplement(_rer_, _S_).\n        ",
      {
        "normalizedName" : "CharacterClassEscape[3,0].CompileToCharSet",
        "name" : "CharacterClassEscape[3,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "S"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1529,
    [
      "DefaultClause[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "DefaultClause[0,0].Evaluation",
        "name" : "DefaultClause[0,0].Evaluation",
        "htmlId" : "sec-switch-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1967,
    [
      "ImportSpecifier[0,0].ImportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportSpecifier[0]]"
        ],
        [
          "module",
          false,
          "String"
        ]
      ],
      "\n          1. Let _localName_ be the sole element of BoundNames of |ImportedBinding|.\n          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _localName_, [[LocalName]]: _localName_ }.\n          1. Return « _entry_ ».\n        ",
      {
        "normalizedName" : "ImportSpecifier[0,0].ImportEntriesForModule",
        "name" : "ImportSpecifier[0,0].ImportEntriesForModule",
        "htmlId" : "sec-static-semantics-importentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ImportSpecifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportedBinding"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2067,
    [
      "INTRINSICS.Object.seal",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _O_ is not an Object, return _O_.\n          1. Let _status_ be ? SetIntegrityLevel(_O_, ~sealed~).\n          1. If _status_ is *false*, throw a *TypeError* exception.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.seal",
        "name" : "INTRINSICS.Object.seal",
        "htmlId" : "sec-object.seal",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2825,
    [
      "INTRINSICS.AsyncFunction",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the active function object.\n          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.\n          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~async~, _parameterArgs_, _bodyArg_).\n        ",
      {
        "normalizedName" : "INTRINSICS.AsyncFunction",
        "name" : "INTRINSICS.AsyncFunction",
        "htmlId" : "sec-async-function-constructor-arguments",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2819,
    [
      "AsyncGeneratorYield",
      0,
      [
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _genContext_ be the running execution context.\n          1. Assert: _genContext_ is the execution context of a generator.\n          1. Let _generator_ be the value of the Generator component of _genContext_.\n          1. Assert: GetGeneratorKind() is ~async~.\n          1. Let _completion_ be NormalCompletion(_value_).\n          1. Assert: The execution context stack has at least two elements.\n          1. Let _previousContext_ be the second to top element of the execution context stack.\n          1. Let _previousRealm_ be _previousContext_'s Realm.\n          1. Perform AsyncGeneratorCompleteStep(_generator_, _completion_, *false*, _previousRealm_).\n          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].\n          1. If _queue_ is not empty, then\n            1. NOTE: Execution continues without suspending the generator.\n            1. Let _toYield_ be the first element of _queue_.\n            1. Let _resumptionValue_ be Completion(_toYield_.[[Completion]]).\n            1. Return ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_).\n          1. Else,\n            1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-yield~.\n            1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. Let _callerContext_ be the running execution context.\n            1. Resume _callerContext_ passing *undefined*. If _genContext_ is ever resumed again, let _resumptionValue_ be the Completion Record with which it is resumed.\n            1. Assert: If control reaches here, then _genContext_ is the running execution context again.\n            1. Return ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_).\n        ",
      {
        "normalizedName" : "AsyncGeneratorYield",
        "name" : "AsyncGeneratorYield",
        "htmlId" : "sec-asyncgeneratoryield",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    436,
    [
      "DoWhileStatement[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[DoWhileStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "DoWhileStatement[0,0].VarScopedDeclarations",
        "name" : "DoWhileStatement[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DoWhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "do"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1803,
    [
      "ForInOfStatement[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[1,0].HasCallInTailPosition",
        "name" : "ForInOfStatement[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2136,
    [
      "INTRINSICS.Math.cos",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite, return *NaN*.\n          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of the cosine of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.cos",
        "name" : "INTRINSICS.Math.cos",
        "htmlId" : "sec-math.cos",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    37,
    [
      "__IS_ARRAY_INDEX__",
      8,
      [
        [
          "P",
          false,
          "ESValue"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1904,
    [
      "OptionalChain[9,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[9]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "OptionalChain[9,0].HasCallInTailPosition",
        "name" : "OptionalChain[9,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 9,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1518,
    [
      "WithStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[WithStatement[0]]"
        ]
      ],
      "\n        1. Let _val_ be ? Evaluation of |Expression|.\n        1. Let _obj_ be ? ToObject(? GetValue(_val_)).\n        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _newEnv_ be NewObjectEnvironment(_obj_, *true*, _oldEnv_).\n        1. Set the running execution context's LexicalEnvironment to _newEnv_.\n        1. Let _C_ be Completion(Evaluation of |Statement|).\n        1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n        1. Return ? UpdateEmpty(_C_, *undefined*).\n      ",
      {
        "normalizedName" : "WithStatement[0,0].Evaluation",
        "name" : "WithStatement[0,0].Evaluation",
        "htmlId" : "sec-with-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WithStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "with"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1265,
    [
      "PropertyDefinitionList[1,0].PropertyNameList",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyDefinitionList[1]]"
        ]
      ],
      "\n          1. Let _list_ be PropertyNameList of |PropertyDefinitionList|.\n          1. Let _propName_ be PropName of |PropertyDefinition|.\n          1. If _propName_ is ~empty~, return _list_.\n          1. Return the list-concatenation of _list_ and « _propName_ ».\n        ",
      {
        "normalizedName" : "PropertyDefinitionList[1,0].PropertyNameList",
        "name" : "PropertyDefinitionList[1,0].PropertyNameList",
        "htmlId" : "sec-static-semantics-propertynamelist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyNameList",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "PropertyDefinitionList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PropertyDefinitionList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "PropertyDefinition"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1703,
    [
      "FunctionDeclaration[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[0,0].ContainsArguments",
        "name" : "FunctionDeclaration[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2531,
    [
      "INTRINSICS.TypedArray.from",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the *this* value.\n          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n          1. If _mapfn_ is *undefined*, then\n            1. Let _mapping_ be *false*.\n          1. Else,\n            1. If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.\n            1. Let _mapping_ be *true*.\n          1. Let _usingIterator_ be ? GetMethod(_source_, @@iterator).\n          1. If _usingIterator_ is not *undefined*, then\n            1. Let _values_ be ? IteratorToList(? GetIteratorFromMethod(_source_, _usingIterator_)).\n            1. Let _len_ be the number of elements in _values_.\n            1. Let _targetObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).\n            1. Let _k_ be 0.\n            1. Repeat, while _k_ < _len_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Let _kValue_ be the first element of _values_.\n              1. Remove the first element from _values_.\n              1. If _mapping_ is *true*, then\n                1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, « _kValue_, 𝔽(_k_) »).\n              1. Else,\n                1. Let _mappedValue_ be _kValue_.\n              1. Perform ? Set(_targetObj_, _Pk_, _mappedValue_, *true*).\n              1. Set _k_ to _k_ + 1.\n            1. Assert: _values_ is now an empty List.\n            1. Return _targetObj_.\n          1. NOTE: _source_ is not an Iterable so assume it is already an array-like object.\n          1. Let _arrayLike_ be ! ToObject(_source_).\n          1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).\n          1. Let _targetObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).\n            1. If _mapping_ is *true*, then\n              1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, « _kValue_, 𝔽(_k_) »).\n            1. Else,\n              1. Let _mappedValue_ be _kValue_.\n            1. Perform ? Set(_targetObj_, _Pk_, _mappedValue_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _targetObj_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.from",
        "name" : "INTRINSICS.TypedArray.from",
        "htmlId" : "sec-%typedarray%.from",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2405,
    [
      "UnicodePropertyValueExpression[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[UnicodePropertyValueExpression[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _ps_ be the source text matched by |UnicodePropertyName|.\n          1. Let _p_ be UnicodeMatchProperty(_rer_, _ps_).\n          1. Assert: _p_ is a Unicode property name or property alias listed in the “Property name and aliases” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref>.\n          1. Let _vs_ be the source text matched by |UnicodePropertyValue|.\n          1. Let _v_ be UnicodeMatchPropertyValue(_p_, _vs_).\n          1. Let _A_ be the CharSet containing all Unicode code points whose character database definition includes the property _p_ with value _v_.\n          1. Return MaybeSimpleCaseFolding(_rer_, _A_).\n        ",
      {
        "normalizedName" : "UnicodePropertyValueExpression[0,0].CompileToCharSet",
        "name" : "UnicodePropertyValueExpression[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "UnicodePropertyValueExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "UnicodePropertyName"
              },
              {
                "type" : "terminal",
                "value" : "="
              },
              {
                "type" : "nonterminal",
                "value" : "UnicodePropertyValue"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1228,
    [
      "IdentifierName[1,0].StringValue",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierName[1]]"
        ]
      ],
      "\n        1. Let _idTextUnescaped_ be IdentifierCodePoints of |IdentifierName|.\n        1. Return CodePointsToString(_idTextUnescaped_).\n      ",
      {
        "normalizedName" : "IdentifierName[1,0].StringValue",
        "name" : "IdentifierName[1,0].StringValue",
        "htmlId" : "sec-static-semantics-stringvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IdentifierName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierPart"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1623,
    [
      "ConciseBody[0,0].EvaluateConciseBody",
      2,
      [
        [
          "this",
          false,
          "Ast[ConciseBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).\n        1. Return ? Evaluation of |ExpressionBody|.\n      ",
      {
        "normalizedName" : "ConciseBody[0,0].EvaluateConciseBody",
        "name" : "ConciseBody[0,0].EvaluateConciseBody",
        "htmlId" : "sec-runtime-semantics-evaluateconcisebody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateConciseBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1482,
    [
      "MemberExpression[3,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[3]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "MemberExpression[3,0].IsDestructuring",
        "name" : "MemberExpression[3,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    25,
    [
      "RequireObjectCoercible",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1254,
    [
      "ElementList[3,0].ArrayAccumulation",
      2,
      [
        [
          "this",
          false,
          "Ast[ElementList[3]]"
        ],
        [
          "array",
          false,
          "Record[Array]"
        ],
        [
          "nextIndex",
          false,
          "Int"
        ]
      ],
      "\n          1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.\n        ",
      {
        "normalizedName" : "ElementList[3,0].ArrayAccumulation",
        "name" : "ElementList[3,0].ArrayAccumulation",
        "htmlId" : "sec-runtime-semantics-arrayaccumulation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArrayAccumulation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "SpreadElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    651,
    [
      "IfStatement[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "IfStatement[1,0].ContainsUndefinedContinueTarget",
        "name" : "IfStatement[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    257,
    [
      "ImportClause[4,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportClause[4]]"
        ]
      ],
      "\n        1. Let _names1_ be the BoundNames of |ImportedDefaultBinding|.\n        1. Let _names2_ be the BoundNames of |NamedImports|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ImportClause[4,0].BoundNames",
        "name" : "ImportClause[4,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ImportClause",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportedDefaultBinding"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "NamedImports"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1287,
    [
      "GetTemplateObject",
      0,
      [
        [
          "templateLiteral",
          false,
          "Ast"
        ]
      ],
      "\n          1. Let _realm_ be the current Realm Record.\n          1. Let _templateRegistry_ be _realm_.[[TemplateMap]].\n          1. For each element _e_ of _templateRegistry_, do\n            1. If _e_.[[Site]] is the same Parse Node as _templateLiteral_, then\n              1. Return _e_.[[Array]].\n          1. Let _rawStrings_ be TemplateStrings of _templateLiteral_ with argument *true*.\n          1. Assert: _rawStrings_ is a List of Strings.\n          1. Let _cookedStrings_ be TemplateStrings of _templateLiteral_ with argument *false*.\n          1. Let _count_ be the number of elements in the List _cookedStrings_.\n          1. Assert: _count_ ≤ 2<sup>32</sup> - 1.\n          1. Let _template_ be ! ArrayCreate(_count_).\n          1. Let _rawObj_ be ! ArrayCreate(_count_).\n          1. Let _index_ be 0.\n          1. Repeat, while _index_ < _count_,\n            1. Let _prop_ be ! ToString(𝔽(_index_)).\n            1. Let _cookedValue_ be _cookedStrings_[_index_].\n            1. Perform ! DefinePropertyOrThrow(_template_, _prop_, PropertyDescriptor { [[Value]]: _cookedValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).\n            1. Let _rawValue_ be the String value _rawStrings_[_index_].\n            1. Perform ! DefinePropertyOrThrow(_rawObj_, _prop_, PropertyDescriptor { [[Value]]: _rawValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).\n            1. Set _index_ to _index_ + 1.\n          1. Perform ! SetIntegrityLevel(_rawObj_, ~frozen~).\n          1. Perform ! DefinePropertyOrThrow(_template_, *\"raw\"*, PropertyDescriptor { [[Value]]: _rawObj_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n          1. Perform ! SetIntegrityLevel(_template_, ~frozen~).\n          1. Append the Record { [[Site]]: _templateLiteral_, [[Array]]: _template_ } to _realm_.[[TemplateMap]].\n          1. Return _template_.\n        ",
      {
        "normalizedName" : "GetTemplateObject",
        "name" : "GetTemplateObject",
        "htmlId" : "sec-gettemplateobject",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    570,
    [
      "ClassStaticBlockStatementList[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockStatementList[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassStaticBlockStatementList[0,0].ContainsDuplicateLabels",
        "name" : "ClassStaticBlockStatementList[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStaticBlockStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2269,
    [
      "INTRINSICS.String.prototype.toWellFormed",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _strLen_ be the length of _S_.\n          1. Let _k_ be 0.\n          1. Let _result_ be the empty String.\n          1. Repeat, while _k_ < _strLen_,\n            1. Let _cp_ be CodePointAt(_S_, _k_).\n            1. If _cp_.[[IsUnpairedSurrogate]] is *true*, then\n              1. Set _result_ to the string-concatenation of _result_ and 0xFFFD (REPLACEMENT CHARACTER).\n            1. Else,\n              1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(_cp_.[[CodePoint]]).\n            1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.toWellFormed",
        "name" : "INTRINSICS.String.prototype.toWellFormed",
        "htmlId" : "sec-string.prototype.towellformed",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1992,
    [
      "ExportDeclaration[3,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[3]]"
        ]
      ],
      "\n          1. Return the BoundNames of |Declaration|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[3,0].ExportedNames",
        "name" : "ExportDeclaration[3,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2654,
    [
      "AllocateSharedArrayBuffer",
      0,
      [
        [
          "constructor",
          false,
          "Record[Constructor]"
        ],
        [
          "byteLength",
          false,
          "Int[0+]"
        ],
        [
          "maxByteLength",
          true,
          "Enum[~empty~] | Int[0+]"
        ]
      ],
      "\n          1. Let _slots_ be « [[ArrayBufferData]] ».\n          1. If _maxByteLength_ is present and _maxByteLength_ is not ~empty~, let _allocatingGrowableBuffer_ be *true*; otherwise let _allocatingGrowableBuffer_ be *false*.\n          1. If _allocatingGrowableBuffer_ is *true*, then\n            1. If _byteLength_ > _maxByteLength_, throw a *RangeError* exception.\n            1. Append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to _slots_.\n          1. Else,\n            1. Append [[ArrayBufferByteLength]] to _slots_.\n          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *\"%SharedArrayBuffer.prototype%\"*, _slots_).\n          1. If _allocatingGrowableBuffer_ is *true*, let _allocLength_ be _maxByteLength_; otherwise let _allocLength_ be _byteLength_.\n          1. Let _block_ be ? CreateSharedByteDataBlock(_allocLength_).\n          1. Set _obj_.[[ArrayBufferData]] to _block_.\n          1. If _allocatingGrowableBuffer_ is *true*, then\n            1. Assert: _byteLength_ ≤ _maxByteLength_.\n            1. Let _byteLengthBlock_ be ? CreateSharedByteDataBlock(8).\n            1. Perform SetValueInBuffer(_byteLengthBlock_, 0, ~biguint64~, ℤ(_byteLength_), *true*, ~seq-cst~).\n            1. Set _obj_.[[ArrayBufferByteLengthData]] to _byteLengthBlock_.\n            1. Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.\n          1. Else,\n            1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "AllocateSharedArrayBuffer",
        "name" : "AllocateSharedArrayBuffer",
        "htmlId" : "sec-allocatesharedarraybuffer",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    389,
    [
      "ForInOfStatement[8,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[8]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForInOfStatement[8,0].VarDeclaredNames",
        "name" : "ForInOfStatement[8,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1628,
    [
      "MethodDefinition[4,0].HasDirectSuper",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[4]]"
        ]
      ],
      "\n        1. Return |FunctionBody| Contains |SuperCall|.\n      ",
      {
        "normalizedName" : "MethodDefinition[4,0].HasDirectSuper",
        "name" : "MethodDefinition[4,0].HasDirectSuper",
        "htmlId" : "sec-static-semantics-hasdirectsuper",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasDirectSuper",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "get"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    52,
    [
      "Number::bitwiseNOT",
      1,
      [
        [
          "x",
          false,
          "Number"
        ]
      ],
      "\n            1. Let _oldValue_ be ! ToInt32(_x_).\n            1. Return the result of applying bitwise complement to _oldValue_. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.\n          ",
      {
        "normalizedName" : "Number::bitwiseNOT",
        "name" : "Number::bitwiseNOT",
        "htmlId" : "sec-numeric-types-number-bitwiseNOT",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    724,
    [
      "PrimaryExpression[10,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[10]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[10,0].IsFunctionDefinition",
        "name" : "PrimaryExpression[10,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 10,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RegularExpressionLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1055,
    [
      "NewDeclarativeEnvironment",
      0,
      [
        [
          "E",
          false,
          "Record[EnvironmentRecord] | Null"
        ]
      ],
      "\n          1. Let _env_ be a new Declarative Environment Record containing no bindings.\n          1. Set _env_.[[OuterEnv]] to _E_.\n          1. Return _env_.\n        ",
      {
        "normalizedName" : "NewDeclarativeEnvironment",
        "name" : "NewDeclarativeEnvironment",
        "htmlId" : "sec-newdeclarativeenvironment",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1409,
    [
      "AssignmentRestProperty[0,0].RestDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentRestProperty[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "excludedNames",
          false,
          "List[Record[Symbol] | String]"
        ]
      ],
      "\n          1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.\n          1. Let _restObj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).\n          1. Return ? PutValue(_lref_, _restObj_).\n        ",
      {
        "normalizedName" : "AssignmentRestProperty[0,0].RestDestructuringAssignmentEvaluation",
        "name" : "AssignmentRestProperty[0,0].RestDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-restdestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "RestDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AssignmentRestProperty",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "..."
              },
              {
                "type" : "nonterminal",
                "value" : "DestructuringAssignmentTarget"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    14,
    [
      "INTRINSICS.ReferenceError",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1709,
    [
      "GeneratorExpression[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,0].ContainsArguments",
        "name" : "GeneratorExpression[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2603,
    [
      "INTRINSICS.Set",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Set.prototype%\"*, « [[SetData]] »).\n          1. Set _set_.[[SetData]] to a new empty List.\n          1. If _iterable_ is either *undefined* or *null*, return _set_.\n          1. Let _adder_ be ? Get(_set_, *\"add\"*).\n          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.\n          1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).\n          1. Repeat,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is ~done~, return _set_.\n            1. Let _status_ be Completion(Call(_adder_, _set_, « _next_ »)).\n            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Set",
        "name" : "INTRINSICS.Set",
        "htmlId" : "sec-set-iterable",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2328,
    [
      "ClassStringDisjunctionContents[1,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStringDisjunctionContents[1]]"
        ]
      ],
      "\n          1. If MayContainStrings of the |ClassString| is *true*, return *true*.\n          1. Return MayContainStrings of the |ClassStringDisjunctionContents|.\n        ",
      {
        "normalizedName" : "ClassStringDisjunctionContents[1,0].MayContainStrings",
        "name" : "ClassStringDisjunctionContents[1,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassStringDisjunctionContents",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassString"
              },
              {
                "type" : "terminal",
                "value" : "|"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassStringDisjunctionContents"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1792,
    [
      "ForStatement[0,6].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[0,6].HasCallInTailPosition",
        "name" : "ForStatement[0,6].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 6,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1430,
    [
      "StatementList[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ]
      ],
      "\n        1. Let _sl_ be ? Evaluation of |StatementList|.\n        1. Let _s_ be Completion(Evaluation of |StatementListItem|).\n        1. Return ? UpdateEmpty(_s_, _sl_).\n      ",
      {
        "normalizedName" : "StatementList[1,0].Evaluation",
        "name" : "StatementList[1,0].Evaluation",
        "htmlId" : "sec-block-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2735,
    [
      "INTRINSICS.WeakRef.prototype.deref",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _weakRef_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_weakRef_, [[WeakRefTarget]]).\n          1. Return WeakRefDeref(_weakRef_).\n        ",
      {
        "normalizedName" : "INTRINSICS.WeakRef.prototype.deref",
        "name" : "INTRINSICS.WeakRef.prototype.deref",
        "htmlId" : "sec-weak-ref.prototype.deref",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2814,
    [
      "AsyncGeneratorCompleteStep",
      0,
      [
        [
          "generator",
          false,
          "Record[AsyncGenerator]"
        ],
        [
          "completion",
          false,
          "Completion"
        ],
        [
          "done",
          false,
          "Boolean"
        ],
        [
          "realm",
          true,
          "Record[RealmRecord]"
        ]
      ],
      "\n          1. Assert: _generator_.[[AsyncGeneratorQueue]] is not empty.\n          1. Let _next_ be the first element of _generator_.[[AsyncGeneratorQueue]].\n          1. Remove the first element from _generator_.[[AsyncGeneratorQueue]].\n          1. Let _promiseCapability_ be _next_.[[Capability]].\n          1. Let _value_ be _completion_.[[Value]].\n          1. If _completion_ is a throw completion, then\n            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _value_ »).\n          1. Else,\n            1. Assert: _completion_ is a normal completion.\n            1. If _realm_ is present, then\n              1. Let _oldRealm_ be the running execution context's Realm.\n              1. Set the running execution context's Realm to _realm_.\n              1. Let _iteratorResult_ be CreateIterResultObject(_value_, _done_).\n              1. Set the running execution context's Realm to _oldRealm_.\n            1. Else,\n              1. Let _iteratorResult_ be CreateIterResultObject(_value_, _done_).\n            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncGeneratorCompleteStep",
        "name" : "AsyncGeneratorCompleteStep",
        "htmlId" : "sec-asyncgeneratorcompletestep",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1985,
    [
      "ModuleItem[0,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ModuleItem[0,0].ExportedNames",
        "name" : "ModuleItem[0,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2039,
    [
      "INTRINSICS.encodeURIComponent",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _componentString_ be ? ToString(_uriComponent_).\n          1. Let _extraUnescaped_ be the empty String.\n          1. Return ? Encode(_componentString_, _extraUnescaped_).\n        ",
      {
        "normalizedName" : "INTRINSICS.encodeURIComponent",
        "name" : "INTRINSICS.encodeURIComponent",
        "htmlId" : "sec-encodeuricomponent-uricomponent",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    184,
    [
      "CopyDataProperties",
      0,
      [
        [
          "target",
          false,
          "Record[Object]"
        ],
        [
          "source",
          false,
          "ESValue"
        ],
        [
          "excludedItems",
          false,
          "List[Record[Symbol] | String]"
        ]
      ],
      "\n        1. If _source_ is either *undefined* or *null*, return ~unused~.\n        1. Let _from_ be ! ToObject(_source_).\n        1. Let _keys_ be ? <emu-meta effects=\"user-code\">_from_.[[OwnPropertyKeys]]</emu-meta>().\n        1. For each element _nextKey_ of _keys_, do\n          1. Let _excluded_ be *false*.\n          1. For each element _e_ of _excludedItems_, do\n            1. If SameValue(_e_, _nextKey_) is *true*, then\n              1. Set _excluded_ to *true*.\n          1. If _excluded_ is *false*, then\n            1. Let _desc_ be ? <emu-meta effects=\"user-code\">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_).\n            1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then\n              1. Let _propValue_ be ? Get(_from_, _nextKey_).\n              1. Perform ! CreateDataPropertyOrThrow(_target_, _nextKey_, _propValue_).\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "CopyDataProperties",
        "name" : "CopyDataProperties",
        "htmlId" : "sec-copydataproperties",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2698,
    [
      "LeaveCriticalSection",
      0,
      [
        [
          "WL",
          false,
          "Record[WaiterListRecord]"
        ]
      ],
      "\n          1. Assert: The surrounding agent is in the critical section for _WL_.\n          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n          1. Let _leaveEvent_ be a new Synchronize event.\n          1. Append _leaveEvent_ to _eventsRecord_.[[EventList]].\n          1. Set _WL_.[[MostRecentLeaveEvent]] to _leaveEvent_.\n          1. Leave the critical section for _WL_.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "LeaveCriticalSection",
        "name" : "LeaveCriticalSection",
        "htmlId" : "sec-leavecriticalsection",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1760,
    [
      "AsyncConciseBody[0,0].EvaluateAsyncConciseBody",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncConciseBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n        1. Let _declResult_ be Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)).\n        1. If _declResult_ is an abrupt completion, then\n          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _declResult_.[[Value]] »).\n        1. Else,\n          1. Perform AsyncFunctionStart(_promiseCapability_, |ExpressionBody|).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _promiseCapability_.[[Promise]], [[Target]]: ~empty~ }.\n      ",
      {
        "normalizedName" : "AsyncConciseBody[0,0].EvaluateAsyncConciseBody",
        "name" : "AsyncConciseBody[0,0].EvaluateAsyncConciseBody",
        "htmlId" : "sec-runtime-semantics-evaluateasyncconcisebody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateAsyncConciseBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1660,
    [
      "AsyncGeneratorExpression[0,1].InstantiateAsyncGeneratorFunctionExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ],
        [
          "name",
          true,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Assert: _name_ is not present.\n        1. Set _name_ to StringValue of |BindingIdentifier|.\n        1. Let _outerEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).\n        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).\n        1. Return _closure_.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,1].InstantiateAsyncGeneratorFunctionExpression",
        "name" : "AsyncGeneratorExpression[0,1].InstantiateAsyncGeneratorFunctionExpression",
        "htmlId" : "sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateAsyncGeneratorFunctionExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1298,
    [
      "PrimaryExpression[12,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[12]]"
        ]
      ],
      "\n          1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n          1. Return ? Evaluation of _expr_.\n        ",
      {
        "normalizedName" : "PrimaryExpression[12,0].Evaluation",
        "name" : "PrimaryExpression[12,0].Evaluation",
        "htmlId" : "sec-grouping-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 12,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2667,
    [
      "SetViewValue",
      0,
      [
        [
          "view",
          false,
          "ESValue"
        ],
        [
          "requestIndex",
          false,
          "ESValue"
        ],
        [
          "isLittleEndian",
          false,
          "ESValue"
        ],
        [
          "type",
          false,
          "Unknown[\"TypedArrayElementType\"]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Perform ? RequireInternalSlot(_view_, [[DataView]]).\n          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _getIndex_ be ? ToIndex(_requestIndex_).\n          1. If IsBigIntElementType(_type_) is *true*, let _numberValue_ be ? ToBigInt(_value_).\n          1. Otherwise, let _numberValue_ be ? ToNumber(_value_).\n          1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).\n          1. Let _viewOffset_ be _view_.[[ByteOffset]].\n          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~).\n          1. NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.\n          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.\n          1. Let _viewSize_ be GetViewByteLength(_viewRecord_).\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. If _getIndex_ + _elementSize_ > _viewSize_, throw a *RangeError* exception.\n          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.\n          1. Perform SetValueInBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, _numberValue_, *false*, ~unordered~, _isLittleEndian_).\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "SetViewValue",
        "name" : "SetViewValue",
        "htmlId" : "sec-setviewvalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    719,
    [
      "PrimaryExpression[0,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[0,0].IsFunctionDefinition",
        "name" : "PrimaryExpression[0,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "this"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2339,
    [
      "RegExpIdentifierStart[1,0].RegExpIdentifierCodePoint",
      2,
      [
        [
          "this",
          false,
          "Ast[RegExpIdentifierStart[1]]"
        ]
      ],
      "\n          1. Return the code point whose numeric value is the CharacterValue of |RegExpUnicodeEscapeSequence|.\n        ",
      {
        "normalizedName" : "RegExpIdentifierStart[1,0].RegExpIdentifierCodePoint",
        "name" : "RegExpIdentifierStart[1,0].RegExpIdentifierCodePoint",
        "htmlId" : "sec-regexpidentifiercodepoint",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "RegExpIdentifierCodePoint",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "RegExpIdentifierStart",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "\\"
              },
              {
                "type" : "nonterminal",
                "value" : "RegExpUnicodeEscapeSequence"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    785,
    [
      "GeneratorExpression[0,1].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,1].IsFunctionDefinition",
        "name" : "GeneratorExpression[0,1].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2755,
    [
      "RejectPromise",
      0,
      [
        [
          "promise",
          false,
          "Record[Promise]"
        ],
        [
          "reason",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Assert: The value of _promise_.[[PromiseState]] is ~pending~.\n          1. Let _reactions_ be _promise_.[[PromiseRejectReactions]].\n          1. Set _promise_.[[PromiseResult]] to _reason_.\n          1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.\n          1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.\n          1. Set _promise_.[[PromiseState]] to ~rejected~.\n          1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *\"reject\"*).\n          1. Perform TriggerPromiseReactions(_reactions_, _reason_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "RejectPromise",
        "name" : "RejectPromise",
        "htmlId" : "sec-rejectpromise",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    372,
    [
      "ForStatement[0,4].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,4].VarDeclaredNames",
        "name" : "ForStatement[0,4].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 4,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    504,
    [
      "LabelledItem[1,0].TopLevelVarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[1]]"
        ]
      ],
      "\n        1. Return BoundNames of |FunctionDeclaration|.\n      ",
      {
        "normalizedName" : "LabelledItem[1,0].TopLevelVarDeclaredNames",
        "name" : "LabelledItem[1,0].TopLevelVarDeclaredNames",
        "htmlId" : "sec-static-semantics-toplevelvardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelVarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1871,
    [
      "MemberExpression[4,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[4]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[4,0].HasCallInTailPosition",
        "name" : "MemberExpression[4,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SuperProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    110,
    [
      "OrdinaryToPrimitive",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "hint",
          false,
          "Enum[~number~, ~string~]"
        ]
      ],
      "\n          1. If _hint_ is ~string~, then\n            1. Let _methodNames_ be « *\"toString\"*, *\"valueOf\"* ».\n          1. Else,\n            1. Let _methodNames_ be « *\"valueOf\"*, *\"toString\"* ».\n          1. For each element _name_ of _methodNames_, do\n            1. Let _method_ be ? Get(_O_, _name_).\n            1. If IsCallable(_method_) is *true*, then\n              1. Let _result_ be ? Call(_method_, _O_).\n              1. If _result_ is not an Object, return _result_.\n          1. Throw a *TypeError* exception.\n        ",
      {
        "normalizedName" : "OrdinaryToPrimitive",
        "name" : "OrdinaryToPrimitive",
        "htmlId" : "sec-ordinarytoprimitive",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2708,
    [
      "EnqueueAtomicsWaitAsyncTimeoutJob",
      0,
      [
        [
          "WL",
          false,
          "Record[WaiterListRecord]"
        ],
        [
          "waiterRecord",
          false,
          "Record[WaiterRecord]"
        ]
      ],
      "\n          1. Let _timeoutJob_ be a new Job Abstract Closure with no parameters that captures _WL_ and _waiterRecord_ and performs the following steps when called:\n            1. Perform EnterCriticalSection(_WL_).\n            1. If _WL_.[[Waiters]] contains _waiterRecord_, then\n              1. Let _timeOfJobExecution_ be the time value (UTC) identifying the current time.\n              1. Assert: ℝ(_timeOfJobExecution_) ≥ _waiterRecord_.[[TimeoutTime]] (ignoring potential non-monotonicity of time values).\n              1. Set _waiterRecord_.[[Result]] to *\"timed-out\"*.\n              1. Perform RemoveWaiter(_WL_, _waiterRecord_).\n              1. Perform NotifyWaiter(_WL_, _waiterRecord_).\n            1. Perform LeaveCriticalSection(_WL_).\n            1. Return ~unused~.\n          1. Let _now_ be the time value (UTC) identifying the current time.\n          1. Let _currentRealm_ be the current Realm Record.\n          1. Perform HostEnqueueTimeoutJob(_timeoutJob_, _currentRealm_, 𝔽(_waiterRecord_.[[TimeoutTime]]) - _now_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "EnqueueAtomicsWaitAsyncTimeoutJob",
        "name" : "EnqueueAtomicsWaitAsyncTimeoutJob",
        "htmlId" : "sec-enqueueatomicswaitasynctimeoutjob",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1907,
    [
      "MemberExpression[3,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[3]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. If this |MemberExpression| is _call_, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[3,0].HasCallInTailPosition",
        "name" : "MemberExpression[3,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2501,
    [
      "INTRINSICS.Array.prototype.join",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If _separator_ is *undefined*, let _sep_ be *\",\"*.\n          1. Else, let _sep_ be ? ToString(_separator_).\n          1. Let _R_ be the empty String.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _sep_.\n            1. Let _element_ be ? Get(_O_, ! ToString(𝔽(_k_))).\n            1. If _element_ is either *undefined* or *null*, let _next_ be the empty String; otherwise, let _next_ be ? ToString(_element_).\n            1. Set _R_ to the string-concatenation of _R_ and _next_.\n            1. Set _k_ to _k_ + 1.\n          1. Return _R_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.join",
        "name" : "INTRINSICS.Array.prototype.join",
        "htmlId" : "sec-array.prototype.join",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1330,
    [
      "OptionalChain[0,0].ChainEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[0]]"
        ],
        [
          "baseValue",
          false,
          "ESValue"
        ],
        [
          "baseReference",
          false,
          "ESValue | Record[ReferenceRecord]"
        ]
      ],
      "\n          1. Let _thisChain_ be this |OptionalChain|.\n          1. Let _tailCall_ be IsInTailPosition(_thisChain_).\n          1. Return ? EvaluateCall(_baseValue_, _baseReference_, |Arguments|, _tailCall_).\n        ",
      {
        "normalizedName" : "OptionalChain[0,0].ChainEvaluation",
        "name" : "OptionalChain[0,0].ChainEvaluation",
        "htmlId" : "sec-optional-chaining-chain-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ChainEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "?."
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2444,
    [
      "ParsePattern",
      0,
      [
        [
          "patternText",
          false,
          "Unknown[\"SequenceOfUnicodeCodePoint\"]"
        ],
        [
          "u",
          false,
          "Boolean"
        ],
        [
          "v",
          false,
          "Boolean"
        ]
      ],
      "\n          1. If _v_ is *true* and _u_ is *true*, then\n            1. Let _parseResult_ be a List containing one or more *SyntaxError* objects.\n          1. Else if _v_ is *true*, then\n            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|).\n          1. Else if _u_ is *true*, then\n            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).\n          1. Else,\n            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).\n          1. Return _parseResult_.\n        ",
      {
        "normalizedName" : "ParsePattern",
        "name" : "ParsePattern",
        "htmlId" : "sec-parsepattern",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1860,
    [
      "UnaryExpression[6,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[6]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[6,0].HasCallInTailPosition",
        "name" : "UnaryExpression[6,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "~"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1264,
    [
      "PropertyDefinitionList[0,0].PropertyNameList",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyDefinitionList[0]]"
        ]
      ],
      "\n          1. Let _propName_ be PropName of |PropertyDefinition|.\n          1. If _propName_ is ~empty~, return a new empty List.\n          1. Return « _propName_ ».\n        ",
      {
        "normalizedName" : "PropertyDefinitionList[0,0].PropertyNameList",
        "name" : "PropertyDefinitionList[0,0].PropertyNameList",
        "htmlId" : "sec-static-semantics-propertynamelist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyNameList",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "PropertyDefinitionList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PropertyDefinition"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2217,
    [
      "INTRINSICS.Date.prototype.setUTCFullYear",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>.\n          1. Let _y_ be ? ToNumber(_year_).\n          1. If _month_ is not present, let _m_ be MonthFromTime(_t_); otherwise, let _m_ be ? ToNumber(_month_).\n          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise, let _dt_ be ? ToNumber(_date_).\n          1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).\n          1. Let _v_ be TimeClip(_newDate_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setUTCFullYear",
        "name" : "INTRINSICS.Date.prototype.setUTCFullYear",
        "htmlId" : "sec-date.prototype.setutcfullyear",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    587,
    [
      "WhileStatement[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[WhileStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "WhileStatement[0,0].ContainsUndefinedBreakTarget",
        "name" : "WhileStatement[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1323,
    [
      "ArgumentList[3,0].ArgumentListEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArgumentList[3]]"
        ]
      ],
      "\n          1. Let _precedingArgs_ be ? ArgumentListEvaluation of |ArgumentList|.\n          1. Let _spreadRef_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _iteratorRecord_ be ? GetIterator(? GetValue(_spreadRef_), ~sync~).\n          1. Repeat,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is ~done~, return _precedingArgs_.\n            1. Append _next_ to _precedingArgs_.\n        ",
      {
        "normalizedName" : "ArgumentList[3,0].ArgumentListEvaluation",
        "name" : "ArgumentList[3,0].ArgumentListEvaluation",
        "htmlId" : "sec-runtime-semantics-argumentlistevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArgumentListEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ArgumentList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArgumentList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "terminal",
                "value" : "..."
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    619,
    [
      "CaseBlock[1,1].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,1].ContainsUndefinedBreakTarget",
        "name" : "CaseBlock[1,1].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    838,
    [
      "AsyncGeneratorExpression[0,1].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,1].Contains",
        "name" : "AsyncGeneratorExpression[0,1].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1511,
    [
      "INTRINSICS.ForInIteratorPrototype.next",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n              1. Let _O_ be the *this* value.\n              1. Assert: _O_ is an Object.\n              1. Assert: _O_ has all of the internal slots of a For-In Iterator Instance (<emu-xref href=\"#sec-properties-of-for-in-iterator-instances\"></emu-xref>).\n              1. Let _object_ be _O_.[[Object]].\n              1. Repeat,\n                1. If _O_.[[ObjectWasVisited]] is *false*, then\n                  1. Let _keys_ be ? <emu-meta effects=\"user-code\">_object_.[[OwnPropertyKeys]]()</emu-meta>.\n                  1. For each element _key_ of _keys_, do\n                    1. If _key_ is a String, then\n                      1. Append _key_ to _O_.[[RemainingKeys]].\n                  1. Set _O_.[[ObjectWasVisited]] to *true*.\n                1. Repeat, while _O_.[[RemainingKeys]] is not empty,\n                  1. Let _r_ be the first element of _O_.[[RemainingKeys]].\n                  1. Remove the first element from _O_.[[RemainingKeys]].\n                  1. If there does not exist an element _v_ of _O_.[[VisitedKeys]] such that SameValue(_r_, _v_) is *true*, then\n                    1. Let _desc_ be ? <emu-meta effects=\"user-code\">_object_.[[GetOwnProperty]]</emu-meta>(_r_).\n                    1. If _desc_ is not *undefined*, then\n                      1. Append _r_ to _O_.[[VisitedKeys]].\n                      1. If _desc_.[[Enumerable]] is *true*, return CreateIterResultObject(_r_, *false*).\n                1. Set _object_ to ? <emu-meta effects=\"user-code\">_object_.[[GetPrototypeOf]]()</emu-meta>.\n                1. Set _O_.[[Object]] to _object_.\n                1. Set _O_.[[ObjectWasVisited]] to *false*.\n                1. If _object_ is *null*, return CreateIterResultObject(*undefined*, *true*).\n            ",
      {
        "normalizedName" : "INTRINSICS.ForInIteratorPrototype.next",
        "name" : "INTRINSICS.ForInIteratorPrototype.next",
        "htmlId" : "sec-%foriniteratorprototype%.next",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2274,
    [
      "INTRINSICS.String.prototype.valueOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return ? ThisStringValue(*this* value).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.valueOf",
        "name" : "INTRINSICS.String.prototype.valueOf",
        "htmlId" : "sec-string.prototype.valueof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    917,
    [
      "MemberExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[1]]"
        ]
      ],
      "\n        1. Return ~simple~.\n      ",
      {
        "normalizedName" : "MemberExpression[1,0].AssignmentTargetType",
        "name" : "MemberExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    702,
    [
      "ModuleItem[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ModuleItem[0,0].ContainsUndefinedContinueTarget",
        "name" : "ModuleItem[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    751,
    [
      "AdditiveExpression[2,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AdditiveExpression[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AdditiveExpression[2,0].IsFunctionDefinition",
        "name" : "AdditiveExpression[2,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "AdditiveExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              },
              {
                "type" : "terminal",
                "value" : "-"
              },
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    802,
    [
      "PrimaryExpression[9,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[9]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[9,0].IsIdentifierRef",
        "name" : "PrimaryExpression[9,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 9,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    125,
    [
      "StrUnsignedDecimalLiteral[1,3].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StrUnsignedDecimalLiteral[1]]"
        ]
      ],
      "\n            1. Let _a_ be MV of the first |DecimalDigits|.\n            1. If the second |DecimalDigits| is present, then\n              1. Let _b_ be MV of the second |DecimalDigits|.\n              1. Let _n_ be the number of code points in the second |DecimalDigits|.\n            1. Else,\n              1. Let _b_ be 0.\n              1. Let _n_ be 0.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Return RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>).\n          ",
      {
        "normalizedName" : "StrUnsignedDecimalLiteral[1,3].StringNumericValue",
        "name" : "StrUnsignedDecimalLiteral[1,3].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "StrUnsignedDecimalLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "nonterminal",
                "value" : "ExponentPart"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    344,
    [
      "ModuleItemList[1,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be LexicallyScopedDeclarations of |ModuleItemList|.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |ModuleItem|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "ModuleItemList[1,0].LexicallyScopedDeclarations",
        "name" : "ModuleItemList[1,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2682,
    [
      "INTRINSICS.DataView.prototype.setBigInt64",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~bigint64~, _value_).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.setBigInt64",
        "name" : "INTRINSICS.DataView.prototype.setBigInt64",
        "htmlId" : "sec-dataview.prototype.setbigint64",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1826,
    [
      "AssignmentExpression[5,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[5]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[5,0].HasCallInTailPosition",
        "name" : "AssignmentExpression[5,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentOperator"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1313,
    [
      "EvaluateCall",
      0,
      [
        [
          "func",
          false,
          "ESValue"
        ],
        [
          "ref",
          false,
          "ESValue | Record[ReferenceRecord]"
        ],
        [
          "arguments",
          false,
          "Ast"
        ],
        [
          "tailPosition",
          false,
          "Boolean"
        ]
      ],
      "\n          1. If _ref_ is a Reference Record, then\n            1. If IsPropertyReference(_ref_) is *true*, then\n              1. Let _thisValue_ be GetThisValue(_ref_).\n            1. Else,\n              1. Let _refEnv_ be _ref_.[[Base]].\n              1. Assert: _refEnv_ is an Environment Record.\n              1. Let _thisValue_ be _refEnv_.WithBaseObject().\n          1. Else,\n            1. Let _thisValue_ be *undefined*.\n          1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.\n          1. If _func_ is not an Object, throw a *TypeError* exception.\n          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.\n          1. If _tailPosition_ is *true*, perform PrepareForTailCall().\n          1. Return ? Call(_func_, _thisValue_, _argList_).\n        ",
      {
        "normalizedName" : "EvaluateCall",
        "name" : "EvaluateCall",
        "htmlId" : "sec-evaluatecall",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1279,
    [
      "PrimaryExpression[10,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[10]]"
        ]
      ],
      "\n          1. Let _pattern_ be CodePointsToString(BodyText of |RegularExpressionLiteral|).\n          1. Let _flags_ be CodePointsToString(FlagText of |RegularExpressionLiteral|).\n          1. Return ! RegExpCreate(_pattern_, _flags_).\n        ",
      {
        "normalizedName" : "PrimaryExpression[10,0].Evaluation",
        "name" : "PrimaryExpression[10,0].Evaluation",
        "htmlId" : "sec-regular-expression-literals-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 10,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RegularExpressionLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2185,
    [
      "TimeClip",
      0,
      [
        [
          "time",
          false,
          "Number"
        ]
      ],
      "\n          1. If _time_ is not finite, return *NaN*.\n          1. If abs(ℝ(_time_)) > 8.64 × 10<sup>15</sup>, return *NaN*.\n          1. Return 𝔽(! ToIntegerOrInfinity(_time_)).\n        ",
      {
        "normalizedName" : "TimeClip",
        "name" : "TimeClip",
        "htmlId" : "sec-timeclip",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1577,
    [
      "FormalParameters[0,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameters[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FormalParameters[0,0].ContainsExpression",
        "name" : "FormalParameters[0,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FormalParameters",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1455,
    [
      "IterationStatement[0,0].LoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[IterationStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Return ? DoWhileLoopEvaluation of |DoWhileStatement| with argument _labelSet_.\n        ",
      {
        "normalizedName" : "IterationStatement[0,0].LoopEvaluation",
        "name" : "IterationStatement[0,0].LoopEvaluation",
        "htmlId" : "sec-runtime-semantics-loopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IterationStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DoWhileStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2562,
    [
      "INTRINSICS.TypedArray.prototype.some",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n            1. If _testResult_ is *true*, return *true*.\n            1. Set _k_ to _k_ + 1.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.some",
        "name" : "INTRINSICS.TypedArray.prototype.some",
        "htmlId" : "sec-%typedarray%.prototype.some",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2488,
    [
      "INTRINSICS.Array.prototype.fill",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _k_ be 0.\n          1. Else if _relativeStart_ < 0, let _k_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _k_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _final_ be 0.\n          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _final_ be min(_relativeEnd_, _len_).\n          1. Repeat, while _k_ < _final_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Perform ? Set(_O_, _Pk_, _value_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.fill",
        "name" : "INTRINSICS.Array.prototype.fill",
        "htmlId" : "sec-array.prototype.fill",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1832,
    [
      "BitwiseORExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[BitwiseORExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "BitwiseORExpression[1,0].HasCallInTailPosition",
        "name" : "BitwiseORExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BitwiseORExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BitwiseORExpression"
              },
              {
                "type" : "terminal",
                "value" : "|"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseXORExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    934,
    [
      "CallExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "CallExpression[1,0].AssignmentTargetType",
        "name" : "CallExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SuperCall"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    357,
    [
      "Statement[8,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[8]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[8,0].VarDeclaredNames",
        "name" : "Statement[8,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ReturnStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1191,
    [
      "Record[ProxyExoticObject].GetPrototypeOf",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"getPrototypeOf\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[GetPrototypeOf]]</emu-meta>().\n        1. Let _handlerProto_ be ? Call(_trap_, _handler_, « _target_ »).\n        1. If _handlerProto_ is not an Object and _handlerProto_ is not *null*, throw a *TypeError* exception.\n        1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n        1. If _extensibleTarget_ is *true*, return _handlerProto_.\n        1. Let _targetProto_ be ? <emu-meta effects=\"user-code\">_target_.[[GetPrototypeOf]]</emu-meta>().\n        1. If SameValue(_handlerProto_, _targetProto_) is *false*, throw a *TypeError* exception.\n        1. Return _handlerProto_.\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].GetPrototypeOf",
        "name" : "Record[ProxyExoticObject].GetPrototypeOf",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-getprototypeof",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[GetPrototypeOf]]"
        ]
      }
    ]
  ],
  [
    2466,
    [
      "INTRINSICS.get RegExp.prototype.unicodeSets",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0076 (LATIN SMALL LETTER V).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get RegExp.prototype.unicodeSets",
        "name" : "INTRINSICS.get RegExp.prototype.unicodeSets",
        "htmlId" : "sec-get-regexp.prototype.unicodesets",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2126,
    [
      "INTRINSICS.Math.acos",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is *NaN*, _n_ > *1*<sub>𝔽</sub>, or _n_ < *-1*<sub>𝔽</sub>, return *NaN*.\n          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of the inverse cosine of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.acos",
        "name" : "INTRINSICS.Math.acos",
        "htmlId" : "sec-math.acos",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    196,
    [
      "IteratorNext",
      0,
      [
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "value",
          true,
          "ESValue"
        ]
      ],
      "\n        1. If _value_ is not present, then\n          1. Let _result_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).\n        1. Else,\n          1. Let _result_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _value_ »).\n        1. If _result_ is not an Object, throw a *TypeError* exception.\n        1. Return _result_.\n      ",
      {
        "normalizedName" : "IteratorNext",
        "name" : "IteratorNext",
        "htmlId" : "sec-iteratornext",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1462,
    [
      "ForStatement[0,1].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        ",
      {
        "normalizedName" : "ForStatement[0,1].ForLoopEvaluation",
        "name" : "ForStatement[0,1].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1059,
    [
      "NewModuleEnvironment",
      0,
      [
        [
          "E",
          false,
          "Record[EnvironmentRecord]"
        ]
      ],
      "\n          1. Let _env_ be a new Module Environment Record containing no bindings.\n          1. Set _env_.[[OuterEnv]] to _E_.\n          1. Return _env_.\n        ",
      {
        "normalizedName" : "NewModuleEnvironment",
        "name" : "NewModuleEnvironment",
        "htmlId" : "sec-newmoduleenvironment",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1132,
    [
      "SetFunctionLength",
      0,
      [
        [
          "F",
          false,
          "Record[FunctionObject]"
        ],
        [
          "length",
          false,
          "Int[0+] | +INF"
        ]
      ],
      "\n        1. Assert: _F_ is an extensible object that does not have a *\"length\"* own property.\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "SetFunctionLength",
        "name" : "SetFunctionLength",
        "htmlId" : "sec-setfunctionlength",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    949,
    [
      "UnaryExpression[2,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[2]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "UnaryExpression[2,0].AssignmentTargetType",
        "name" : "UnaryExpression[2,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "void"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2745,
    [
      "INTRINSICS.AsyncFromSyncIteratorPrototype.throw",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _O_ be the *this* value.\n            1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.\n            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n            1. Let _syncIterator_ be _O_.[[SyncIteratorRecord]].[[Iterator]].\n            1. Let _throw_ be Completion(GetMethod(_syncIterator_, *\"throw\"*)).\n            1. IfAbruptRejectPromise(_throw_, _promiseCapability_).\n            1. If _throw_ is *undefined*, then\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _value_ »).\n              1. Return _promiseCapability_.[[Promise]].\n            1. If _value_ is present, then\n              1. Let _result_ be Completion(Call(_throw_, _syncIterator_, « _value_ »)).\n            1. Else,\n              1. Let _result_ be Completion(Call(_throw_, _syncIterator_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n            1. If _result_ is not an Object, then\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).\n              1. Return _promiseCapability_.[[Promise]].\n            1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_).\n          ",
      {
        "normalizedName" : "INTRINSICS.AsyncFromSyncIteratorPrototype.throw",
        "name" : "INTRINSICS.AsyncFromSyncIteratorPrototype.throw",
        "htmlId" : "sec-%asyncfromsynciteratorprototype%.throw",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2571,
    [
      "INTRINSICS.get TypedArray.prototype[@@toStringTag]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. If _O_ is not an Object, return *undefined*.\n          1. If _O_ does not have a [[TypedArrayName]] internal slot, return *undefined*.\n          1. Let _name_ be _O_.[[TypedArrayName]].\n          1. Assert: _name_ is a String.\n          1. Return _name_.\n        ",
      {
        "normalizedName" : "INTRINSICS.get TypedArray.prototype[@@toStringTag]",
        "name" : "INTRINSICS.get TypedArray.prototype[@@toStringTag]",
        "htmlId" : "sec-get-%typedarray%.prototype-@@tostringtag",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2356,
    [
      "Assertion[1,0].CompileAssertion",
      2,
      [
        [
          "this",
          false,
          "Ast[Assertion[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _e_ be _x_.[[EndIndex]].\n            1. Let _InputLength_ be the number of elements in _Input_.\n            1. If _e_ = _InputLength_, or if _rer_.[[Multiline]] is *true* and the character _Input_[_e_] is matched by |LineTerminator|, then\n              1. Return _c_(_x_).\n            1. Return ~failure~.\n        ",
      {
        "normalizedName" : "Assertion[1,0].CompileAssertion",
        "name" : "Assertion[1,0].CompileAssertion",
        "htmlId" : "sec-compileassertion",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAssertion",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Assertion",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "$"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    157,
    [
      "IsLessThan",
      0,
      [
        [
          "x",
          false,
          "ESValue"
        ],
        [
          "y",
          false,
          "ESValue"
        ],
        [
          "LeftFirst",
          false,
          "Boolean"
        ]
      ],
      "\n        1. If _LeftFirst_ is *true*, then\n          1. Let _px_ be ? ToPrimitive(_x_, ~number~).\n          1. Let _py_ be ? ToPrimitive(_y_, ~number~).\n        1. Else,\n          1. NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.\n          1. Let _py_ be ? ToPrimitive(_y_, ~number~).\n          1. Let _px_ be ? ToPrimitive(_x_, ~number~).\n        1. [id=\"step-arc-string-check\"] If _px_ is a String and _py_ is a String, then\n          1. Let _lx_ be the length of _px_.\n          1. Let _ly_ be the length of _py_.\n          1. For each integer _i_ such that 0 ≤ _i_ < min(_lx_, _ly_), in ascending order, do\n            1. Let _cx_ be the numeric value of the code unit at index _i_ within _px_.\n            1. Let _cy_ be the numeric value of the code unit at index _i_ within _py_.\n            1. If _cx_ < _cy_, return *true*.\n            1. If _cx_ > _cy_, return *false*.\n          1. If _lx_ < _ly_, return *true*. Otherwise, return *false*.\n        1. Else,\n          1. If _px_ is a BigInt and _py_ is a String, then\n            1. Let _ny_ be StringToBigInt(_py_).\n            1. If _ny_ is *undefined*, return *undefined*.\n            1. Return BigInt::lessThan(_px_, _ny_).\n          1. If _px_ is a String and _py_ is a BigInt, then\n            1. Let _nx_ be StringToBigInt(_px_).\n            1. If _nx_ is *undefined*, return *undefined*.\n            1. Return BigInt::lessThan(_nx_, _py_).\n          1. NOTE: Because _px_ and _py_ are primitive values, evaluation order is not important.\n          1. Let _nx_ be ? <emu-meta suppress-effects=\"user-code\">ToNumeric(_px_)</emu-meta>.\n          1. Let _ny_ be ? <emu-meta suppress-effects=\"user-code\">ToNumeric(_py_)</emu-meta>.\n          1. If Type(_nx_) is Type(_ny_), then\n            1. If _nx_ is a Number, then\n              1. Return Number::lessThan(_nx_, _ny_).\n            1. Else,\n              1. Assert: _nx_ is a BigInt.\n              1. Return BigInt::lessThan(_nx_, _ny_).\n          1. Assert: _nx_ is a BigInt and _ny_ is a Number, or _nx_ is a Number and _ny_ is a BigInt.\n          1. If _nx_ or _ny_ is *NaN*, return *undefined*.\n          1. If _nx_ is *-∞*<sub>𝔽</sub> or _ny_ is *+∞*<sub>𝔽</sub>, return *true*.\n          1. If _nx_ is *+∞*<sub>𝔽</sub> or _ny_ is *-∞*<sub>𝔽</sub>, return *false*.\n          1. If ℝ(_nx_) < ℝ(_ny_), return *true*; otherwise return *false*.\n      ",
      {
        "normalizedName" : "IsLessThan",
        "name" : "IsLessThan",
        "htmlId" : "sec-islessthan",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2703,
    [
      "NotifyWaiter",
      0,
      [
        [
          "WL",
          false,
          "Record[WaiterListRecord]"
        ],
        [
          "waiterRecord",
          false,
          "Record[WaiterRecord]"
        ]
      ],
      "\n          1. Assert: The surrounding agent is in the critical section for _WL_.\n          1. If _waiterRecord_.[[PromiseCapability]] is ~blocking~, then\n            1. Wake the agent whose signifier is _waiterRecord_.[[AgentSignifier]] from suspension.\n            1. NOTE: This causes the agent to resume execution in SuspendThisAgent.\n          1. Else if AgentSignifier() is _waiterRecord_.[[AgentSignifier]], then\n            1. Let _promiseCapability_ be _waiterRecord_.[[PromiseCapability]].\n            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _waiterRecord_.[[Result]] »).\n          1. Else,\n            1. Perform EnqueueResolveInAgentJob(_waiterRecord_.[[AgentSignifier]], _waiterRecord_.[[PromiseCapability]], _waiterRecord_.[[Result]]).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "NotifyWaiter",
        "name" : "NotifyWaiter",
        "htmlId" : "sec-notifywaiter",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    542,
    [
      "ForInOfStatement[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[0,0].ContainsDuplicateLabels",
        "name" : "ForInOfStatement[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    460,
    [
      "ForInOfStatement[1,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be « |ForBinding| ».\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[1,0].VarScopedDeclarations",
        "name" : "ForInOfStatement[1,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    559,
    [
      "CaseClause[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CaseClause[0,0].ContainsDuplicateLabels",
        "name" : "CaseClause[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1800,
    [
      "ForStatement[2,2].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[2,2].HasCallInTailPosition",
        "name" : "ForStatement[2,2].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2857,
    [
      "ValueOfReadEvent",
      0,
      [
        [
          "execution",
          false,
          "Unknown[\"CandidateExecution\"]"
        ],
        [
          "R",
          false,
          "Unknown[\"ReadSharedMemoryOrReadModifyWriteSharedMemoryEvent\"]"
        ]
      ],
      "\n        1. Let _Ws_ be _execution_.[[ReadsBytesFrom]](_R_).\n        1. Assert: _Ws_ is a List of WriteSharedMemory or ReadModifyWriteSharedMemory events with length equal to _R_.[[ElementSize]].\n        1. Return ComposeWriteEventBytes(_execution_, _R_.[[ByteIndex]], _Ws_).\n      ",
      {
        "normalizedName" : "ValueOfReadEvent",
        "name" : "ValueOfReadEvent",
        "htmlId" : "sec-valueofreadevent",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2767,
    [
      "PerformPromiseAllSettled",
      0,
      [
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "constructor",
          false,
          "Record[Constructor]"
        ],
        [
          "resultCapability",
          false,
          "Record[PromiseCapabilityRecord]"
        ],
        [
          "promiseResolve",
          false,
          "Record[FunctionObject]"
        ]
      ],
      "\n            1. Let _values_ be a new empty List.\n            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.\n            1. Let _index_ be 0.\n            1. Repeat,\n              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n              1. If _next_ is ~done~, then\n                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n                1. If _remainingElementsCount_.[[Value]] = 0, then\n                  1. Let _valuesArray_ be CreateArrayFromList(_values_).\n                  1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n                1. Return _resultCapability_.[[Promise]].\n              1. Append *undefined* to _values_.\n              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).\n              1. Let _stepsFulfilled_ be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-resolve-element-functions\" title></emu-xref>.\n              1. Let _lengthFulfilled_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.allsettled-resolve-element-functions\" title></emu-xref>.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_stepsFulfilled_, _lengthFulfilled_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).\n              1. Let _alreadyCalled_ be the Record { [[Value]]: *false* }.\n              1. Set _onFulfilled_.[[AlreadyCalled]] to _alreadyCalled_.\n              1. Set _onFulfilled_.[[Index]] to _index_.\n              1. Set _onFulfilled_.[[Values]] to _values_.\n              1. Set _onFulfilled_.[[Capability]] to _resultCapability_.\n              1. Set _onFulfilled_.[[RemainingElements]] to _remainingElementsCount_.\n              1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-reject-element-functions\" title></emu-xref>.\n              1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.allsettled-reject-element-functions\" title></emu-xref>.\n              1. Let _onRejected_ be CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).\n              1. Set _onRejected_.[[AlreadyCalled]] to _alreadyCalled_.\n              1. Set _onRejected_.[[Index]] to _index_.\n              1. Set _onRejected_.[[Values]] to _values_.\n              1. Set _onRejected_.[[Capability]] to _resultCapability_.\n              1. Set _onRejected_.[[RemainingElements]] to _remainingElementsCount_.\n              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.\n              1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _onFulfilled_, _onRejected_ »).\n              1. Set _index_ to _index_ + 1.\n          ",
      {
        "normalizedName" : "PerformPromiseAllSettled",
        "name" : "PerformPromiseAllSettled",
        "htmlId" : "sec-performpromiseallsettled",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2158,
    [
      "INTRINSICS.Math.trunc",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ < *1*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ < *-0*<sub>𝔽</sub> and _n_ > *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n          1. Return the integral Number nearest _n_ in the direction of *+0*<sub>𝔽</sub>.\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.trunc",
        "name" : "INTRINSICS.Math.trunc",
        "htmlId" : "sec-math.trunc",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2852,
    [
      "INTRINSICS.Proxy.revocable",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _proxy_ be ? ProxyCreate(_target_, _handler_).\n          1. Let _revokerClosure_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _F_ be the active function object.\n            1. Let _p_ be _F_.[[RevocableProxy]].\n            1. If _p_ is *null*, return *undefined*.\n            1. Set _F_.[[RevocableProxy]] to *null*.\n            1. Assert: _p_ is a Proxy exotic object.\n            1. Set _p_.[[ProxyTarget]] to *null*.\n            1. Set _p_.[[ProxyHandler]] to *null*.\n            1. Return *undefined*.\n          1. Let _revoker_ be CreateBuiltinFunction(_revokerClosure_, 0, *\"\"*, « [[RevocableProxy]] »).\n          1. Set _revoker_.[[RevocableProxy]] to _proxy_.\n          1. Let _result_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ! CreateDataPropertyOrThrow(_result_, *\"proxy\"*, _proxy_).\n          1. Perform ! CreateDataPropertyOrThrow(_result_, *\"revoke\"*, _revoker_).\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Proxy.revocable",
        "name" : "INTRINSICS.Proxy.revocable",
        "htmlId" : "sec-proxy.revocable",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1232,
    [
      "IdentifierReference[2,0].StringValue",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierReference[2]]"
        ]
      ],
      "\n        1. Return *\"await\"*.\n      ",
      {
        "normalizedName" : "IdentifierReference[2,0].StringValue",
        "name" : "IdentifierReference[2,0].StringValue",
        "htmlId" : "sec-static-semantics-stringvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringValue",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "IdentifierReference",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "await"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1847,
    [
      "AdditiveExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[AdditiveExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AdditiveExpression[1,0].HasCallInTailPosition",
        "name" : "AdditiveExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AdditiveExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              },
              {
                "type" : "terminal",
                "value" : "+"
              },
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1545,
    [
      "Statement[9,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[9]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |Statement|.\n      ",
      {
        "normalizedName" : "Statement[9,0].LabelledEvaluation",
        "name" : "Statement[9,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 9,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "WithStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2420,
    [
      "NestedClass[1,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[NestedClass[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.\n          1. Return CharacterComplement(_rer_, _A_).\n        ",
      {
        "normalizedName" : "NestedClass[1,0].CompileToCharSet",
        "name" : "NestedClass[1,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "NestedClass",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "[^"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassContents"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1922,
    [
      "ModuleSpecifier[0,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleSpecifier[0]]"
        ]
      ],
      "\n          1. Return a List whose sole element is the SV of |StringLiteral|.\n        ",
      {
        "normalizedName" : "ModuleSpecifier[0,0].ModuleRequests",
        "name" : "ModuleSpecifier[0,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleSpecifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StringLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    817,
    [
      "ParenthesizedExpression[0,0].NamedEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ParenthesizedExpression[0]]"
        ],
        [
          "name",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Assert: IsAnonymousFunctionDefinition(|Expression|) is *true*.\n        1. Return ? NamedEvaluation of |Expression| with argument _name_.\n      ",
      {
        "normalizedName" : "ParenthesizedExpression[0,0].NamedEvaluation",
        "name" : "ParenthesizedExpression[0,0].NamedEvaluation",
        "htmlId" : "sec-runtime-semantics-namedevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NamedEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ParenthesizedExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2691,
    [
      "INTRINSICS.DataView.prototype.setUint32",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~uint32~, _value_).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.setUint32",
        "name" : "INTRINSICS.DataView.prototype.setUint32",
        "htmlId" : "sec-dataview.prototype.setuint32",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    902,
    [
      "BindingElement[1,1].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElement[1]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _v_ be *undefined*.\n        1. If _iteratorRecord_.[[Done]] is *false*, then\n          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is not ~done~, then\n            1. Set _v_ to _next_.\n        1. If |Initializer| is present and _v_ is *undefined*, then\n          1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n          1. Set _v_ to ? GetValue(_defaultValue_).\n        1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.\n      ",
      {
        "normalizedName" : "BindingElement[1,1].IteratorBindingInitialization",
        "name" : "BindingElement[1,1].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "BindingElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2713,
    [
      "INTRINSICS.Atomics.add",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _type_ be TypedArrayElementType(_typedArray_).\n        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n        1. Let _add_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _type_ and _isLittleEndian_ and performs the following steps atomically when called:\n          1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).\n          1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).\n          1. If _x_ is a Number, then\n            1. Let _sum_ be Number::add(_x_, _y_).\n          1. Else,\n            1. Assert: _x_ is a BigInt.\n            1. Let _sum_ be BigInt::add(_x_, _y_).\n          1. Let _sumBytes_ be NumericToRawBytes(_type_, _sum_, _isLittleEndian_).\n          1. Assert: _sumBytes_, _xBytes_, and _yBytes_ have the same number of elements.\n          1. Return _sumBytes_.\n        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _add_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.add",
        "name" : "INTRINSICS.Atomics.add",
        "htmlId" : "sec-atomics.add",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    638,
    [
      "Statement[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[1,0].ContainsUndefinedContinueTarget",
        "name" : "Statement[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "VariableStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    853,
    [
      "SuperProperty[1,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[SuperProperty[1]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. If _symbol_ is the |ReservedWord| `super`, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "SuperProperty[1,0].Contains",
        "name" : "SuperProperty[1,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "SuperProperty",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "super"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1892,
    [
      "CoalesceExpression[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CoalesceExpression[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_.\n      ",
      {
        "normalizedName" : "CoalesceExpression[0,0].HasCallInTailPosition",
        "name" : "CoalesceExpression[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CoalesceExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoalesceExpressionHead"
              },
              {
                "type" : "terminal",
                "value" : "??"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseORExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1379,
    [
      "BitwiseORExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BitwiseORExpression[1]]"
        ]
      ],
      "\n        1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseORExpression|, `|`, |BitwiseXORExpression|).\n      ",
      {
        "normalizedName" : "BitwiseORExpression[1,0].Evaluation",
        "name" : "BitwiseORExpression[1,0].Evaluation",
        "htmlId" : "sec-binary-bitwise-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BitwiseORExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BitwiseORExpression"
              },
              {
                "type" : "terminal",
                "value" : "|"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseXORExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2169,
    [
      "WeekDay",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. Return 𝔽(ℝ(Day(_t_) + *4*<sub>𝔽</sub>) modulo 7).\n        ",
      {
        "normalizedName" : "WeekDay",
        "name" : "WeekDay",
        "htmlId" : "sec-weekday",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2403,
    [
      "CharacterClassEscape[6,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[6]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return CompileToCharSet of |UnicodePropertyValueExpression| with argument _rer_.\n        ",
      {
        "normalizedName" : "CharacterClassEscape[6,0].CompileToCharSet",
        "name" : "CharacterClassEscape[6,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "p{"
              },
              {
                "type" : "nonterminal",
                "value" : "UnicodePropertyValueExpression"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1087,
    [
      "OrdinaryIsExtensible",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Return _O_.[[Extensible]].\n        ",
      {
        "normalizedName" : "OrdinaryIsExtensible",
        "name" : "OrdinaryIsExtensible",
        "htmlId" : "sec-ordinaryisextensible",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1514,
    [
      "BreakStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BreakStatement[0]]"
        ]
      ],
      "\n        1. Return Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.\n      ",
      {
        "normalizedName" : "BreakStatement[0,0].Evaluation",
        "name" : "BreakStatement[0,0].Evaluation",
        "htmlId" : "sec-break-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BreakStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "break"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    189,
    [
      "PrivateSet",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[PrivateName]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _entry_ be PrivateElementFind(_O_, _P_).\n        1. If _entry_ is ~empty~, throw a *TypeError* exception.\n        1. If _entry_.[[Kind]] is ~field~, then\n          1. Set _entry_.[[Value]] to _value_.\n        1. Else if _entry_.[[Kind]] is ~method~, then\n          1. Throw a *TypeError* exception.\n        1. Else,\n          1. Assert: _entry_.[[Kind]] is ~accessor~.\n          1. If _entry_.[[Set]] is *undefined*, throw a *TypeError* exception.\n          1. Let _setter_ be _entry_.[[Set]].\n          1. Perform ? Call(_setter_, _O_, « _value_ »).\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "PrivateSet",
        "name" : "PrivateSet",
        "htmlId" : "sec-privateset",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    20,
    [
      "INTRINSICS.URIError",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1147,
    [
      "Record[StringExoticObject].OwnPropertyKeys",
      4,
      [
        [
          "O",
          false,
          "Record[StringExoticObject]"
        ]
      ],
      "\n          1. Let _keys_ be a new empty List.\n          1. Let _str_ be _O_.[[StringData]].\n          1. Assert: _str_ is a String.\n          1. Let _len_ be the length of _str_.\n          1. For each integer _i_ such that 0 ≤ _i_ < _len_, in ascending order, do\n            1. Append ! ToString(𝔽(_i_)) to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is an array index and ! ToIntegerOrInfinity(_P_) ≥ _len_, in ascending numeric index order, do\n            1. Append _P_ to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is a String and _P_ is not an array index, in ascending chronological order of property creation, do\n            1. Append _P_ to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is a Symbol, in ascending chronological order of property creation, do\n            1. Append _P_ to _keys_.\n          1. Return _keys_.\n        ",
      {
        "normalizedName" : "Record[StringExoticObject].OwnPropertyKeys",
        "name" : "Record[StringExoticObject].OwnPropertyKeys",
        "htmlId" : "sec-string-exotic-objects-ownpropertykeys",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "StringExoticObject",
          "[[OwnPropertyKeys]]"
        ]
      }
    ]
  ],
  [
    1247,
    [
      "Elision[1,0].ArrayAccumulation",
      2,
      [
        [
          "this",
          false,
          "Ast[Elision[1]]"
        ],
        [
          "array",
          false,
          "Record[Array]"
        ],
        [
          "nextIndex",
          false,
          "Int"
        ]
      ],
      "\n          1. Return ? ArrayAccumulation of |Elision| with arguments _array_ and (_nextIndex_ + 1).\n        ",
      {
        "normalizedName" : "Elision[1,0].ArrayAccumulation",
        "name" : "Elision[1,0].ArrayAccumulation",
        "htmlId" : "sec-runtime-semantics-arrayaccumulation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArrayAccumulation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Elision",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "terminal",
                "value" : ","
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2049,
    [
      "INTRINSICS.Object.entries",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Let _entryList_ be ? EnumerableOwnProperties(_obj_, ~key+value~).\n          1. Return CreateArrayFromList(_entryList_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.entries",
        "name" : "INTRINSICS.Object.entries",
        "htmlId" : "sec-object.entries",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2552,
    [
      "INTRINSICS.TypedArray.prototype.lastIndexOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.\n          1. If _fromIndex_ is present, let _n_ be ? ToIntegerOrInfinity(_fromIndex_); else let _n_ be _len_ - 1.\n          1. If _n_ = -∞, return *-1*<sub>𝔽</sub>.\n          1. If _n_ ≥ 0, then\n            1. Let _k_ be min(_n_, _len_ - 1).\n          1. Else,\n            1. Let _k_ be _len_ + _n_.\n          1. Repeat, while _k_ ≥ 0,\n            1. Let _kPresent_ be ! HasProperty(_O_, ! ToString(𝔽(_k_))).\n            1. If _kPresent_ is *true*, then\n              1. Let _elementK_ be ! Get(_O_, ! ToString(𝔽(_k_))).\n              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).\n            1. Set _k_ to _k_ - 1.\n          1. Return *-1*<sub>𝔽</sub>.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.lastIndexOf",
        "name" : "INTRINSICS.TypedArray.prototype.lastIndexOf",
        "htmlId" : "sec-%typedarray%.prototype.lastindexof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1319,
    [
      "Arguments[0,0].ArgumentListEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Arguments[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "Arguments[0,0].ArgumentListEvaluation",
        "name" : "Arguments[0,0].ArgumentListEvaluation",
        "htmlId" : "sec-runtime-semantics-argumentlistevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArgumentListEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Arguments",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ")"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1704,
    [
      "FunctionDeclaration[1,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[1,0].ContainsArguments",
        "name" : "FunctionDeclaration[1,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    421,
    [
      "ModuleItem[1,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[1]]"
        ]
      ],
      "\n        1. If |ExportDeclaration| is `export` |VariableStatement|, return BoundNames of |ExportDeclaration|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ModuleItem[1,0].VarDeclaredNames",
        "name" : "ModuleItem[1,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    870,
    [
      "FieldDefinition[0,1].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[FieldDefinition[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      ",
      {
        "normalizedName" : "FieldDefinition[0,1].ComputedPropertyContains",
        "name" : "FieldDefinition[0,1].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FieldDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1890,
    [
      "LogicalANDExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[LogicalANDExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_.\n      ",
      {
        "normalizedName" : "LogicalANDExpression[1,0].HasCallInTailPosition",
        "name" : "LogicalANDExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LogicalANDExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LogicalANDExpression"
              },
              {
                "type" : "terminal",
                "value" : "&&"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseORExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1479,
    [
      "MemberExpression[0,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[0]]"
        ]
      ],
      "\n          1. If |PrimaryExpression| is either an |ObjectLiteral| or an |ArrayLiteral|, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "MemberExpression[0,0].IsDestructuring",
        "name" : "MemberExpression[0,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PrimaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1609,
    [
      "AsyncArrowBindingIdentifier[0,0].ExpectedArgumentCount",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowBindingIdentifier[0]]"
        ]
      ],
      "\n        1. Return 1.\n      ",
      {
        "normalizedName" : "AsyncArrowBindingIdentifier[0,0].ExpectedArgumentCount",
        "name" : "AsyncArrowBindingIdentifier[0,0].ExpectedArgumentCount",
        "htmlId" : "sec-static-semantics-expectedargumentcount",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExpectedArgumentCount",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncArrowBindingIdentifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    969,
    [
      "RelationalExpression[7,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[7]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "RelationalExpression[7,0].AssignmentTargetType",
        "name" : "RelationalExpression[7,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    93,
    [
      "IsSuperReference",
      0,
      [
        [
          "V",
          false,
          "Record[ReferenceRecord]"
        ]
      ],
      "\n          1. If _V_.[[ThisValue]] is not ~empty~, return *true*; otherwise return *false*.\n        ",
      {
        "normalizedName" : "IsSuperReference",
        "name" : "IsSuperReference",
        "htmlId" : "sec-issuperreference",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2373,
    [
      "Atom[1,0].CompileAtom",
      2,
      [
        [
          "this",
          false,
          "Ast[Atom[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Let _A_ be AllCharacters(_rer_).\n          1. If _rer_.[[DotAll]] is not *true*, then\n            1. Remove from _A_ all characters corresponding to a code point on the right-hand side of the |LineTerminator| production.\n          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).\n        ",
      {
        "normalizedName" : "Atom[1,0].CompileAtom",
        "name" : "Atom[1,0].CompileAtom",
        "htmlId" : "sec-compileatom",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAtom",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Atom",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "."
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    606,
    [
      "ForInOfStatement[2,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[2,0].ContainsUndefinedBreakTarget",
        "name" : "ForInOfStatement[2,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1347,
    [
      "UpdateExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[1]]"
        ]
      ],
      "\n          1. Let _lhs_ be ? Evaluation of |LeftHandSideExpression|.\n          1. Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).\n          1. If _oldValue_ is a Number, then\n            1. Let _newValue_ be Number::add(_oldValue_, *1*<sub>𝔽</sub>).\n          1. Else,\n            1. Assert: _oldValue_ is a BigInt.\n            1. Let _newValue_ be BigInt::add(_oldValue_, *1*<sub>ℤ</sub>).\n          1. Perform ? PutValue(_lhs_, _newValue_).\n          1. Return _oldValue_.\n        ",
      {
        "normalizedName" : "UpdateExpression[1,0].Evaluation",
        "name" : "UpdateExpression[1,0].Evaluation",
        "htmlId" : "sec-postfix-increment-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "++"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1572,
    [
      "BindingElement[1,1].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElement[1]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "BindingElement[1,1].ContainsExpression",
        "name" : "BindingElement[1,1].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "BindingElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1013,
    [
      "Record[DeclarativeEnvironmentRecord].GetBindingValue",
      3,
      [
        [
          "envRec",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "S",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Assert: _envRec_ has a binding for _N_.\n            1. If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.\n            1. Return the value currently bound to _N_ in _envRec_.\n          ",
      {
        "normalizedName" : "Record[DeclarativeEnvironmentRecord].GetBindingValue",
        "name" : "Record[DeclarativeEnvironmentRecord].GetBindingValue",
        "htmlId" : "sec-declarative-environment-records-getbindingvalue-n-s",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "DeclarativeEnvironmentRecord",
          "GetBindingValue"
        ]
      }
    ]
  ],
  [
    284,
    [
      "AsyncFunctionDeclaration[1,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionDeclaration[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncFunctionDeclaration[1,0].IsConstantDeclaration",
        "name" : "AsyncFunctionDeclaration[1,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncFunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    770,
    [
      "LogicalORExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[LogicalORExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "LogicalORExpression[1,0].IsFunctionDefinition",
        "name" : "LogicalORExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LogicalORExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LogicalORExpression"
              },
              {
                "type" : "terminal",
                "value" : "||"
              },
              {
                "type" : "nonterminal",
                "value" : "LogicalANDExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1741,
    [
      "ClassTail[0,3].ClassDefinitionEvaluation:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.\n        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n        1. If |ClassBody| is present, then\n          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do\n            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then\n              1. Assert: This is only possible for getter/setter pairs.\n            1. Else,\n              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.\n              1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n        1. If |ClassHeritage| is not present, then\n          1. Let _protoParent_ be %Object.prototype%.\n          1. Let _constructorParent_ be %Function.prototype%.\n        1. Else,\n          1. Set the running execution context's LexicalEnvironment to _classEnv_.\n          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).\n          1. Set the running execution context's LexicalEnvironment to _env_.\n          1. Let _superclass_ be ? GetValue(? _superclassRef_).\n          1. If _superclass_ is *null*, then\n            1. Let _protoParent_ be *null*.\n            1. Let _constructorParent_ be %Function.prototype%.\n          1. Else if IsConstructor(_superclass_) is *false*, then\n            1. Throw a *TypeError* exception.\n          1. Else,\n            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.\n            1. Let _constructorParent_ be _superclass_.\n        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n        1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n        1. Set the running execution context's LexicalEnvironment to _classEnv_.\n        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.\n        1. If _constructor_ is ~empty~, then\n          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n            1. If NewTarget is *undefined*, throw a *TypeError* exception.\n            1. Let _F_ be the active function object.\n            1. If _F_.[[ConstructorKind]] is ~derived~, then\n              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n            1. Else,\n              1. NOTE: This branch behaves similarly to `constructor() {}`.\n              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n            1. Perform ? InitializeInstanceElements(_result_, _F_).\n            1. Return _result_.\n          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n        1. Else,\n          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n          1. Let _F_ be _constructorInfo_.[[Closure]].\n          1. Perform MakeClassConstructor(_F_).\n          1. Perform SetFunctionName(_F_, _className_).\n        1. Perform MakeConstructor(_F_, *false*, _proto_).\n        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n        1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n        1. If |ClassBody| is not present, let _elements_ be a new empty List.\n        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n        1. Let _instancePrivateMethods_ be a new empty List.\n        1. Let _staticPrivateMethods_ be a new empty List.\n        1. Let _instanceFields_ be a new empty List.\n        1. Let _staticElements_ be a new empty List.\n        1. For each |ClassElement| _e_ of _elements_, do\n          1. If IsStatic of _e_ is *false*, then\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n          1. Else,\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n          1. If _element_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _env_.\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _element_.\n          1. Set _element_ to ! _element_.\n          1. If _element_ is a PrivateElement, then\n            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n            1. Else, let _container_ be _staticPrivateMethods_.\n            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.\n              1. If _element_.[[Get]] is *undefined*, then\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n              1. Else,\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n              1. Replace _pe_ in _container_ with _combined_.\n            1. Else,\n              1. Append _element_ to _container_.\n          1. Else if _element_ is a ClassFieldDefinition Record, then\n            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n            1. Else, append _element_ to _staticElements_.\n          1. Else if _element_ is a ClassStaticBlockDefinition Record, then\n            1. Append _element_ to _staticElements_.\n        1. Set the running execution context's LexicalEnvironment to _env_.\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n        1. Set _F_.[[Fields]] to _instanceFields_.\n        1. For each PrivateElement _method_ of _staticPrivateMethods_, do\n          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n        1. For each element _elementRecord_ of _staticElements_, do\n          1. If _elementRecord_ is a ClassFieldDefinition Record, then\n            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n          1. Else,\n            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.\n            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n          1. If _result_ is an abrupt completion, then\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _result_.\n        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "ClassTail[0,3].ClassDefinitionEvaluation",
        "name" : "ClassTail[0,3].ClassDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-classdefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1398,
    [
      "ArrayAssignmentPattern[0,1].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayAssignmentPattern[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. If |Elision| is present, then\n            1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n            1. If _status_ is an abrupt completion, then\n              1. Assert: _iteratorRecord_.[[Done]] is *true*.\n              1. Return ? _status_.\n          1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "ArrayAssignmentPattern[0,1].DestructuringAssignmentEvaluation",
        "name" : "ArrayAssignmentPattern[0,1].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ArrayAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    881,
    [
      "BindingIdentifier[2,0].BindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingIdentifier[2]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Return ? InitializeBoundName(*\"await\"*, _value_, _environment_).\n      ",
      {
        "normalizedName" : "BindingIdentifier[2,0].BindingInitialization",
        "name" : "BindingIdentifier[2,0].BindingInitialization",
        "htmlId" : "sec-runtime-semantics-bindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "BindingIdentifier",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "await"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    416,
    [
      "AsyncConciseBody[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncConciseBody[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "AsyncConciseBody[0,0].VarDeclaredNames",
        "name" : "AsyncConciseBody[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1115,
    [
      "ConciseBody[0,0].EvaluateBody",
      2,
      [
        [
          "this",
          false,
          "Ast[ConciseBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Return ? EvaluateConciseBody of |ConciseBody| with arguments _functionObject_ and _argumentsList_.\n        ",
      {
        "normalizedName" : "ConciseBody[0,0].EvaluateBody",
        "name" : "ConciseBody[0,0].EvaluateBody",
        "htmlId" : "sec-runtime-semantics-evaluatebody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2635,
    [
      "IsBigIntElementType",
      0,
      [
        [
          "type",
          false,
          "Unknown[\"TypedArrayElementType\"]"
        ]
      ],
      "\n          1. If _type_ is either ~biguint64~ or ~bigint64~, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "IsBigIntElementType",
        "name" : "IsBigIntElementType",
        "htmlId" : "sec-isbigintelementtype",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    325,
    [
      "CaseBlock[1,2].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _declarations1_ be the LexicallyScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the LexicallyScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,2].LexicallyScopedDeclarations",
        "name" : "CaseBlock[1,2].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1931,
    [
      "InnerModuleLoading",
      0,
      [
        [
          "state",
          false,
          "Record[GraphLoadingStateRecord]"
        ],
        [
          "module",
          false,
          "Record[ModuleRecord]"
        ]
      ],
      "\n              1. Assert: _state_.[[IsLoading]] is *true*.\n              1. If _module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then\n                1. Append _module_ to _state_.[[Visited]].\n                1. Let _requestedModulesCount_ be the number of elements in _module_.[[RequestedModules]].\n                1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] + _requestedModulesCount_.\n                1. For each String _required_ of _module_.[[RequestedModules]], do\n                  1. If _module_.[[LoadedModules]] contains a Record whose [[Specifier]] is _required_, then\n                    1. Let _record_ be that Record.\n                    1. Perform InnerModuleLoading(_state_, _record_.[[Module]]).\n                  1. Else,\n                    1. Perform HostLoadImportedModule(_module_, _required_, _state_.[[HostDefined]], _state_).\n                    1. NOTE: HostLoadImportedModule will call FinishLoadingImportedModule, which re-enters the graph loading process through ContinueModuleLoading.\n                  1. If _state_.[[IsLoading]] is *false*, return ~unused~.\n              1. Assert: _state_.[[PendingModulesCount]] ≥ 1.\n              1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] - 1.\n              1. If _state_.[[PendingModulesCount]] = 0, then\n                1. Set _state_.[[IsLoading]] to *false*.\n                1. For each Cyclic Module Record _loaded_ of _state_.[[Visited]], do\n                  1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.\n                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, « *undefined* »).\n              1. Return ~unused~.\n            ",
      {
        "normalizedName" : "InnerModuleLoading",
        "name" : "InnerModuleLoading",
        "htmlId" : "sec-InnerModuleLoading",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    152,
    [
      "IsRegExp",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If _argument_ is not an Object, return *false*.\n        1. Let _matcher_ be ? Get(_argument_, @@match).\n        1. If _matcher_ is not *undefined*, return ToBoolean(_matcher_).\n        1. If _argument_ has a [[RegExpMatcher]] internal slot, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "IsRegExp",
        "name" : "IsRegExp",
        "htmlId" : "sec-isregexp",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1568,
    [
      "BindingElementList[1,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElementList[1]]"
        ]
      ],
      "\n        1. Let _has_ be ContainsExpression of |BindingElementList|.\n        1. If _has_ is *true*, return *true*.\n        1. Return ContainsExpression of |BindingElisionElement|.\n      ",
      {
        "normalizedName" : "BindingElementList[1,0].ContainsExpression",
        "name" : "BindingElementList[1,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElisionElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2520,
    [
      "INTRINSICS.Array.prototype.toSorted:clo0",
      6,
      [
        [
          "x",
          false,
          "Unknown"
        ],
        [
          "y",
          false,
          "Unknown"
        ]
      ],
      "\n          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _A_ be ? ArrayCreate(_len_).\n          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n            1. Return ? CompareArrayElements(_x_, _y_, _comparefn_).\n          1. Let _sortedList_ be ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).\n          1. Let _j_ be 0.\n          1. Repeat, while _j_ < _len_,\n            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_]).\n            1. Set _j_ to _j_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.toSorted",
        "name" : "INTRINSICS.Array.prototype.toSorted",
        "htmlId" : "sec-array.prototype.tosorted",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2730,
    [
      "QuoteJSONString",
      0,
      [
        [
          "value",
          false,
          "String"
        ]
      ],
      "\n          1. Let _product_ be the String value consisting solely of the code unit 0x0022 (QUOTATION MARK).\n          1. For each code point _C_ of StringToCodePoints(_value_), do\n            1. If _C_ is listed in the “Code Point” column of <emu-xref href=\"#table-json-single-character-escapes\"></emu-xref>, then\n              1. Set _product_ to the string-concatenation of _product_ and the escape sequence for _C_ as specified in the “Escape Sequence” column of the corresponding row.\n            1. Else if _C_ has a numeric value less than 0x0020 (SPACE) or _C_ has the same numeric value as a leading surrogate or trailing surrogate, then\n              1. Let _unit_ be the code unit whose numeric value is the numeric value of _C_.\n              1. Set _product_ to the string-concatenation of _product_ and UnicodeEscape(_unit_).\n            1. Else,\n              1. Set _product_ to the string-concatenation of _product_ and UTF16EncodeCodePoint(_C_).\n          1. Set _product_ to the string-concatenation of _product_ and the code unit 0x0022 (QUOTATION MARK).\n          1. Return _product_.\n        ",
      {
        "normalizedName" : "QuoteJSONString",
        "name" : "QuoteJSONString",
        "htmlId" : "sec-quotejsonstring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    228,
    [
      "ArrayBindingPattern[2,3].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[2]]"
        ]
      ],
      "\n        1. Let _names1_ be BoundNames of |BindingElementList|.\n        1. Let _names2_ be BoundNames of |BindingRestElement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[2,3].BoundNames",
        "name" : "ArrayBindingPattern[2,3].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 3,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2024,
    [
      "ExportDeclaration[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[2]]"
        ]
      ],
      "\n          1. Return ? Evaluation of |VariableStatement|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[2,0].Evaluation",
        "name" : "ExportDeclaration[2,0].Evaluation",
        "htmlId" : "sec-exports-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1641,
    [
      "MethodDefinition[4,0].MethodDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[4]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ],
        [
          "enumerable",
          false,
          "Boolean"
        ]
      ],
      "\n        1. Let _propKey_ be ? Evaluation of |ClassElementName|.\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |MethodDefinition|.\n        1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.\n        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform MakeMethod(_closure_, _object_).\n        1. Perform SetFunctionName(_closure_, _propKey_, *\"get\"*).\n        1. If _propKey_ is a Private Name, then\n          1. Return PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: _closure_, [[Set]]: *undefined* }.\n        1. Else,\n          1. Let _desc_ be the PropertyDescriptor { [[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.\n          1. Perform ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).\n          1. Return ~unused~.\n      ",
      {
        "normalizedName" : "MethodDefinition[4,0].MethodDefinitionEvaluation",
        "name" : "MethodDefinition[4,0].MethodDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-methoddefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MethodDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "get"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    289,
    [
      "ExportDeclaration[6,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[6]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ExportDeclaration[6,0].IsConstantDeclaration",
        "name" : "ExportDeclaration[6,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1773,
    [
      "Statement[11,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[11]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[11,0].HasCallInTailPosition",
        "name" : "Statement[11,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 11,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ThrowStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    448,
    [
      "ForStatement[1,2].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "ForStatement[1,2].VarScopedDeclarations",
        "name" : "ForStatement[1,2].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2301,
    [
      "HexTrailSurrogate[0,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[HexTrailSurrogate[0]]"
        ]
      ],
      "\n          1. Return the MV of |Hex4Digits|.\n        ",
      {
        "normalizedName" : "HexTrailSurrogate[0,0].CharacterValue",
        "name" : "HexTrailSurrogate[0,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "HexTrailSurrogate",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Hex4Digits"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1815,
    [
      "CaseClause[0,1].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CaseClause[0,1].HasCallInTailPosition",
        "name" : "CaseClause[0,1].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1494,
    [
      "ForDeclaration[0,0].ForDeclarationBindingInstantiation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForDeclaration[0]]"
        ],
        [
          "environment",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ]
      ],
      "\n          1. For each element _name_ of the BoundNames of |ForBinding|, do\n            1. If IsConstantDeclaration of |LetOrConst| is *true*, then\n              1. Perform ! _environment_.CreateImmutableBinding(_name_, *true*).\n            1. Else,\n              1. Perform ! _environment_.CreateMutableBinding(_name_, *false*).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "ForDeclaration[0,0].ForDeclarationBindingInstantiation",
        "name" : "ForDeclaration[0,0].ForDeclarationBindingInstantiation",
        "htmlId" : "sec-runtime-semantics-fordeclarationbindinginstantiation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForDeclarationBindingInstantiation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LetOrConst"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    57,
    [
      "Number::add",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. If _x_ is *NaN* or _y_ is *NaN*, return *NaN*.\n            1. If _x_ is *+∞*<sub>𝔽</sub> and _y_ is *-∞*<sub>𝔽</sub>, return *NaN*.\n            1. If _x_ is *-∞*<sub>𝔽</sub> and _y_ is *+∞*<sub>𝔽</sub>, return *NaN*.\n            1. If _x_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return _x_.\n            1. If _y_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return _y_.\n            1. Assert: _x_ and _y_ are both finite.\n            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n            1. Return 𝔽(ℝ(_x_) + ℝ(_y_)).\n          ",
      {
        "normalizedName" : "Number::add",
        "name" : "Number::add",
        "htmlId" : "sec-numeric-types-number-add",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    316,
    [
      "ModuleItem[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |ImportDeclaration|.\n      ",
      {
        "normalizedName" : "ModuleItem[0,0].LexicallyDeclaredNames",
        "name" : "ModuleItem[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1362,
    [
      "ShiftExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ShiftExpression[1]]"
        ]
      ],
      "\n          1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `<<`, |AdditiveExpression|).\n        ",
      {
        "normalizedName" : "ShiftExpression[1,0].Evaluation",
        "name" : "ShiftExpression[1,0].Evaluation",
        "htmlId" : "sec-left-shift-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ShiftExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              },
              {
                "type" : "terminal",
                "value" : "<<"
              },
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1963,
    [
      "ImportedDefaultBinding[0,0].ImportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportedDefaultBinding[0]]"
        ],
        [
          "module",
          false,
          "String"
        ]
      ],
      "\n          1. Let _localName_ be the sole element of BoundNames of |ImportedBinding|.\n          1. Let _defaultEntry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: *\"default\"*, [[LocalName]]: _localName_ }.\n          1. Return « _defaultEntry_ ».\n        ",
      {
        "normalizedName" : "ImportedDefaultBinding[0,0].ImportEntriesForModule",
        "name" : "ImportedDefaultBinding[0,0].ImportEntriesForModule",
        "htmlId" : "sec-static-semantics-importentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ImportedDefaultBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportedBinding"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    78,
    [
      "BigInt::unsignedRightShift",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. Throw a *TypeError* exception.\n          ",
      {
        "normalizedName" : "BigInt::unsignedRightShift",
        "name" : "BigInt::unsignedRightShift",
        "htmlId" : "sec-numeric-types-bigint-unsignedRightShift",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1875,
    [
      "PrimaryExpression[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[0,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "this"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1778,
    [
      "ForInOfStatement[3,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[3]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ForInOfStatement[3,0].HasCallInTailPosition",
        "name" : "ForInOfStatement[3,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2388,
    [
      "NonemptyClassRanges[1,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[NonemptyClassRanges[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of |ClassAtom| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of |NonemptyClassRangesNoDash| with argument _rer_.\n          1. Return the union of CharSets _A_ and _B_.\n        ",
      {
        "normalizedName" : "NonemptyClassRanges[1,0].CompileToCharSet",
        "name" : "NonemptyClassRanges[1,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "NonemptyClassRanges",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassAtom"
              },
              {
                "type" : "nonterminal",
                "value" : "NonemptyClassRangesNoDash"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2533,
    [
      "INTRINSICS.get TypedArray[@@species]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return the *this* value.\n        ",
      {
        "normalizedName" : "INTRINSICS.get TypedArray[@@species]",
        "name" : "INTRINSICS.get TypedArray[@@species]",
        "htmlId" : "sec-get-%typedarray%-@@species",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1100,
    [
      "Record[OrdinaryObject].Set",
      4,
      [
        [
          "O",
          false,
          "Record[OrdinaryObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_).\n      ",
      {
        "normalizedName" : "Record[OrdinaryObject].Set",
        "name" : "Record[OrdinaryObject].Set",
        "htmlId" : "sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "OrdinaryObject",
          "[[Set]]"
        ]
      }
    ]
  ],
  [
    261,
    [
      "ExportDeclaration[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ExportDeclaration[0,0].BoundNames",
        "name" : "ExportDeclaration[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "ExportFromClause"
              },
              {
                "type" : "nonterminal",
                "value" : "FromClause"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    29,
    [
      "ToBigInt",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _prim_ be ? ToPrimitive(_argument_, ~number~).\n        1. Return the value that _prim_ corresponds to in <emu-xref href=\"#table-tobigint\"></emu-xref>.\n      ",
      {
        "normalizedName" : "ToBigInt",
        "name" : "ToBigInt",
        "htmlId" : "sec-tobigint",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2829,
    [
      "AsyncBlockStart:cont2",
      7,
      [
        [
          "result",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Assert: _promiseCapability_ is a PromiseCapability Record.\n          1. Let _runningContext_ be the running execution context.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _promiseCapability_ and _asyncBody_ and performs the following steps when called:\n            1. Let _acAsyncContext_ be the running execution context.\n            1. Let _result_ be Completion(Evaluation of _asyncBody_).\n            1. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.\n            1. Remove _acAsyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. If _result_ is a normal completion, then\n              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).\n            1. Else if _result_ is a return completion, then\n              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] »).\n            1. Else,\n              1. Assert: _result_ is a throw completion.\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] »).\n            1. [id=\"step-asyncblockstart-return-undefined\"] Return ~unused~.\n          1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta>. Let _result_ be the value returned by the resumed computation.\n          1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.\n          1. Assert: _result_ is a normal completion with a value of ~unused~. The possible sources of this value are Await or, if the async function doesn't await anything, step <emu-xref href=\"#step-asyncblockstart-return-undefined\"></emu-xref> above.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncBlockStart",
        "name" : "AsyncBlockStart",
        "htmlId" : "sec-asyncblockstart",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : true,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    789,
    [
      "AsyncFunctionExpression[0,1].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,1].IsFunctionDefinition",
        "name" : "AsyncFunctionExpression[0,1].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2650,
    [
      "INTRINSICS.ArrayBuffer.prototype.resize",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).\n          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. Let _newByteLength_ be ? ToIndex(_newLength_).\n          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. If _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.\n          1. Let _hostHandled_ be ? HostResizeArrayBuffer(_O_, _newByteLength_).\n          1. If _hostHandled_ is ~handled~, return *undefined*.\n          1. Let _oldBlock_ be _O_.[[ArrayBufferData]].\n          1. Let _newBlock_ be ? CreateByteDataBlock(_newByteLength_).\n          1. Let _copyLength_ be min(_newByteLength_, _O_.[[ArrayBufferByteLength]]).\n          1. Perform CopyDataBlockBytes(_newBlock_, 0, _oldBlock_, 0, _copyLength_).\n          1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as in-place growth or shrinkage.\n          1. Set _O_.[[ArrayBufferData]] to _newBlock_.\n          1. Set _O_.[[ArrayBufferByteLength]] to _newByteLength_.\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "INTRINSICS.ArrayBuffer.prototype.resize",
        "name" : "INTRINSICS.ArrayBuffer.prototype.resize",
        "htmlId" : "sec-arraybuffer.prototype.resize",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    238,
    [
      "ForDeclaration[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForDeclaration[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |ForBinding|.\n      ",
      {
        "normalizedName" : "ForDeclaration[0,0].BoundNames",
        "name" : "ForDeclaration[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LetOrConst"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2777,
    [
      "PromiseResolve",
      0,
      [
        [
          "C",
          false,
          "Record[Constructor]"
        ],
        [
          "x",
          false,
          "ESValue"
        ]
      ],
      "\n            1. If IsPromise(_x_) is *true*, then\n              1. Let _xConstructor_ be ? Get(_x_, *\"constructor\"*).\n              1. If SameValue(_xConstructor_, _C_) is *true*, return _x_.\n            1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n            1. Perform ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _x_ »).\n            1. Return _promiseCapability_.[[Promise]].\n          ",
      {
        "normalizedName" : "PromiseResolve",
        "name" : "PromiseResolve",
        "htmlId" : "sec-promise-resolve",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2456,
    [
      "INTRINSICS.get RegExp.prototype.multiline",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x006D (LATIN SMALL LETTER M).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get RegExp.prototype.multiline",
        "name" : "INTRINSICS.get RegExp.prototype.multiline",
        "htmlId" : "sec-get-regexp.prototype.multiline",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2007,
    [
      "ExportDeclaration[3,0].ExportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[3]]"
        ]
      ],
      "\n          1. Let _entries_ be a new empty List.\n          1. Let _names_ be the BoundNames of |Declaration|.\n          1. For each element _name_ of _names_, do\n            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.\n          1. Return _entries_.\n        ",
      {
        "normalizedName" : "ExportDeclaration[3,0].ExportEntries",
        "name" : "ExportDeclaration[3,0].ExportEntries",
        "htmlId" : "sec-static-semantics-exportentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntries",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2178,
    [
      "SystemTimeZoneIdentifier",
      0,
      [
      ],
      "\n          1. If the implementation only supports the UTC time zone, return *\"UTC\"*.\n          1. Let _systemTimeZoneString_ be the String representing the host environment's current time zone, either a primary time zone identifier or an offset time zone identifier.\n          1. Return _systemTimeZoneString_.\n        ",
      {
        "normalizedName" : "SystemTimeZoneIdentifier",
        "name" : "SystemTimeZoneIdentifier",
        "htmlId" : "sec-systemtimezoneidentifier",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2222,
    [
      "INTRINSICS.Date.prototype.setUTCSeconds",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _s_ be ? ToNumber(_sec_).\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).\n          1. Let _v_ be TimeClip(_date_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setUTCSeconds",
        "name" : "INTRINSICS.Date.prototype.setUTCSeconds",
        "htmlId" : "sec-date.prototype.setutcseconds",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    216,
    [
      "VariableDeclaration[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[VariableDeclaration[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingIdentifier|.\n      ",
      {
        "normalizedName" : "VariableDeclaration[0,0].BoundNames",
        "name" : "VariableDeclaration[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "VariableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1489,
    [
      "LeftHandSideExpression[2,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[LeftHandSideExpression[2]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "LeftHandSideExpression[2,0].IsDestructuring",
        "name" : "LeftHandSideExpression[2,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "LeftHandSideExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2237,
    [
      "INTRINSICS.String.fromCodePoint",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _result_ be the empty String.\n          1. For each element _next_ of _codePoints_, do\n            1. Let _nextCP_ be ? ToNumber(_next_).\n            1. If IsIntegralNumber(_nextCP_) is *false*, throw a *RangeError* exception.\n            1. If ℝ(_nextCP_) < 0 or ℝ(_nextCP_) > 0x10FFFF, throw a *RangeError* exception.\n            1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(ℝ(_nextCP_)).\n          1. Assert: If _codePoints_ is empty, then _result_ is the empty String.\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.fromCodePoint",
        "name" : "INTRINSICS.String.fromCodePoint",
        "htmlId" : "sec-string.fromcodepoint",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1415,
    [
      "Elision[1,0].IteratorDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Elision[1]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n          1. If _iteratorRecord_.[[Done]] is *false*, then\n            1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).\n            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.\n            1. ReturnIfAbrupt(_next_).\n            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "Elision[1,0].IteratorDestructuringAssignmentEvaluation",
        "name" : "Elision[1,0].IteratorDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Elision",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "terminal",
                "value" : ","
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    475,
    [
      "LabelledStatement[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |LabelledItem|.\n      ",
      {
        "normalizedName" : "LabelledStatement[0,0].VarScopedDeclarations",
        "name" : "LabelledStatement[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelledItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    924,
    [
      "PrimaryExpression[3,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[3]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "PrimaryExpression[3,0].AssignmentTargetType",
        "name" : "PrimaryExpression[3,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrayLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2616,
    [
      "INTRINSICS.WeakMap",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%WeakMap.prototype%\"*, « [[WeakMapData]] »).\n          1. Set _map_.[[WeakMapData]] to a new empty List.\n          1. If _iterable_ is either *undefined* or *null*, return _map_.\n          1. Let _adder_ be ? Get(_map_, *\"set\"*).\n          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.\n          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).\n        ",
      {
        "normalizedName" : "INTRINSICS.WeakMap",
        "name" : "INTRINSICS.WeakMap",
        "htmlId" : "sec-weakmap-iterable",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1946,
    [
      "Record[SourceTextModuleRecord].InitializeEnvironment",
      3,
      [
        [
          "module",
          false,
          "Record[SourceTextModuleRecord]"
        ]
      ],
      "\n            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do\n              1. Assert: _e_.[[ExportName]] is not *null*.\n              1. Let _resolution_ be _module_.ResolveExport(_e_.[[ExportName]]).\n              1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.\n              1. Assert: _resolution_ is a ResolvedBinding Record.\n            1. Assert: All named exports from _module_ are resolvable.\n            1. Let _realm_ be _module_.[[Realm]].\n            1. Assert: _realm_ is not *undefined*.\n            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).\n            1. Set _module_.[[Environment]] to _env_.\n            1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do\n              1. Let _importedModule_ be GetImportedModule(_module_, _in_.[[ModuleRequest]]).\n              1. If _in_.[[ImportName]] is ~namespace-object~, then\n                1. Let _namespace_ be GetModuleNamespace(_importedModule_).\n                1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).\n                1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).\n              1. Else,\n                1. Let _resolution_ be _importedModule_.ResolveExport(_in_.[[ImportName]]).\n                1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.\n                1. If _resolution_.[[BindingName]] is ~namespace~, then\n                  1. Let _namespace_ be GetModuleNamespace(_resolution_.[[Module]]).\n                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).\n                  1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).\n                1. Else,\n                  1. Perform _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).\n            1. Let _moduleContext_ be a new ECMAScript code execution context.\n            1. Set the Function of _moduleContext_ to *null*.\n            1. Assert: _module_.[[Realm]] is not *undefined*.\n            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].\n            1. Set the ScriptOrModule of _moduleContext_ to _module_.\n            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].\n            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].\n            1. Set the PrivateEnvironment of _moduleContext_ to *null*.\n            1. Set _module_.[[Context]] to _moduleContext_.\n            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.\n            1. Let _code_ be _module_.[[ECMAScriptCode]].\n            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.\n            1. Let _declaredVarNames_ be a new empty List.\n            1. For each element _d_ of _varDeclarations_, do\n              1. For each element _dn_ of the BoundNames of _d_, do\n                1. If _declaredVarNames_ does not contain _dn_, then\n                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).\n                  1. Perform ! _env_.InitializeBinding(_dn_, *undefined*).\n                  1. Append _dn_ to _declaredVarNames_.\n            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.\n            1. Let _privateEnv_ be *null*.\n            1. For each element _d_ of _lexDeclarations_, do\n              1. For each element _dn_ of the BoundNames of _d_, do\n                1. If IsConstantDeclaration of _d_ is *true*, then\n                  1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).\n                1. Else,\n                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).\n                1. If _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then\n                  1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.\n                  1. Perform ! _env_.InitializeBinding(_dn_, _fo_).\n            1. Remove _moduleContext_ from the execution context stack.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[SourceTextModuleRecord].InitializeEnvironment",
        "name" : "Record[SourceTextModuleRecord].InitializeEnvironment",
        "htmlId" : "sec-source-text-module-record-initialize-environment",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "SourceTextModuleRecord",
          "InitializeEnvironment"
        ]
      }
    ]
  ],
  [
    1465,
    [
      "ForStatement[0,4].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        ",
      {
        "normalizedName" : "ForStatement[0,4].ForLoopEvaluation",
        "name" : "ForStatement[0,4].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 4,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    492,
    [
      "ModuleItem[1,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[1]]"
        ]
      ],
      "\n        1. If |ExportDeclaration| is `export` |VariableStatement|, return VarScopedDeclarations of |VariableStatement|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ModuleItem[1,0].VarScopedDeclarations",
        "name" : "ModuleItem[1,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    164,
    [
      "CreateDataProperty",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "V",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _newDesc_ be the PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n        1. Return ? <emu-meta effects=\"user-code\">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _newDesc_).\n      ",
      {
        "normalizedName" : "CreateDataProperty",
        "name" : "CreateDataProperty",
        "htmlId" : "sec-createdataproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1302,
    [
      "MemberExpression[7,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[7]]"
        ]
      ],
      "\n          1. Let _baseReference_ be ? Evaluation of |MemberExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.\n          1. Return MakePrivateReference(_baseValue_, _fieldNameString_).\n        ",
      {
        "normalizedName" : "MemberExpression[7,0].Evaluation",
        "name" : "MemberExpression[7,0].Evaluation",
        "htmlId" : "sec-property-accessors-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    756,
    [
      "RelationalExpression[2,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[2,0].IsFunctionDefinition",
        "name" : "RelationalExpression[2,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : ">"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1664,
    [
      "ClassElement[1,0].ClassElementKind",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[1]]"
        ]
      ],
      "\n        1. Return ~non-constructor-method~.\n      ",
      {
        "normalizedName" : "ClassElement[1,0].ClassElementKind",
        "name" : "ClassElement[1,0].ClassElementKind",
        "htmlId" : "sec-static-semantics-classelementkind",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassElementKind",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "static"
              },
              {
                "type" : "nonterminal",
                "value" : "MethodDefinition"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2794,
    [
      "GeneratorStart:cont1",
      7,
      [
      ],
      "\n          1. Assert: The value of _generator_.[[GeneratorState]] is *undefined*.\n          1. Let _genContext_ be the running execution context.\n          1. Set the Generator component of _genContext_ to _generator_.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:\n            1. Let _acGenContext_ be the running execution context.\n            1. Let _acGenerator_ be the Generator component of _acGenContext_.\n            1. If _generatorBody_ is a Parse Node, then\n              1. Let _result_ be Completion(Evaluation of _generatorBody_).\n            1. Else,\n              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.\n              1. Let _result_ be _generatorBody_().\n            1. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.\n            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. Set _acGenerator_.[[GeneratorState]] to ~completed~.\n            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _acGenerator_ can be discarded at this point.\n            1. If _result_ is a normal completion, then\n              1. Let _resultValue_ be *undefined*.\n            1. Else if _result_ is a return completion, then\n              1. Let _resultValue_ be _result_.[[Value]].\n            1. Else,\n              1. Assert: _result_ is a throw completion.\n              1. Return ? _result_.\n            1. Return CreateIterResultObject(_resultValue_, *true*).\n          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Set _generator_.[[GeneratorContext]] to _genContext_.\n          1. Set _generator_.[[GeneratorState]] to ~suspended-start~.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "GeneratorStart",
        "name" : "GeneratorStart",
        "htmlId" : "sec-generatorstart",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : true,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2324,
    [
      "ClassIntersection[0,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassIntersection[0]]"
        ]
      ],
      "\n          1. If MayContainStrings of the first |ClassSetOperand| is *false*, return *false*.\n          1. If MayContainStrings of the second |ClassSetOperand| is *false*, return *false*.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "ClassIntersection[0,0].MayContainStrings",
        "name" : "ClassIntersection[0,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassIntersection",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              },
              {
                "type" : "terminal",
                "value" : "&&"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1714,
    [
      "AsyncGeneratorExpression[0,1].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,1].ContainsArguments",
        "name" : "AsyncGeneratorExpression[0,1].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2027,
    [
      "ExportDeclaration[5,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[5]]"
        ]
      ],
      "\n          1. Let _value_ be ? BindingClassDeclarationEvaluation of |ClassDeclaration|.\n          1. Let _className_ be the sole element of BoundNames of |ClassDeclaration|.\n          1. If _className_ is *\"\\*default\\*\"*, then\n            1. Let _env_ be the running execution context's LexicalEnvironment.\n            1. Perform ? InitializeBoundName(*\"\\*default\\*\"*, _value_, _env_).\n          1. Return ~empty~.\n        ",
      {
        "normalizedName" : "ExportDeclaration[5,0].Evaluation",
        "name" : "ExportDeclaration[5,0].Evaluation",
        "htmlId" : "sec-exports-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2105,
    [
      "INTRINSICS.AggregateError",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.\n            1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%AggregateError.prototype%\"*, « [[ErrorData]] »).\n            1. If _message_ is not *undefined*, then\n              1. Let _msg_ be ? ToString(_message_).\n              1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *\"message\"*, _msg_).\n            1. Perform ? InstallErrorCause(_O_, _options_).\n            1. Let _errorsList_ be ? IteratorToList(? GetIterator(_errors_, ~sync~)).\n            1. Perform ! DefinePropertyOrThrow(_O_, *\"errors\"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errorsList_) }).\n            1. Return _O_.\n          ",
      {
        "normalizedName" : "INTRINSICS.AggregateError",
        "name" : "INTRINSICS.AggregateError",
        "htmlId" : "sec-aggregate-error",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1811,
    [
      "CaseBlock[1,2].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Let _has_ be *false*.\n        1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.\n        1. Return _has_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,2].HasCallInTailPosition",
        "name" : "CaseBlock[1,2].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    179,
    [
      "Invoke",
      0,
      [
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "argumentsList",
          true,
          "List[ESValue]"
        ]
      ],
      "\n        1. If _argumentsList_ is not present, set _argumentsList_ to a new empty List.\n        1. Let _func_ be ? GetV(_V_, _P_).\n        1. Return ? Call(_func_, _V_, _argumentsList_).\n      ",
      {
        "normalizedName" : "Invoke",
        "name" : "Invoke",
        "htmlId" : "sec-invoke",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1450,
    [
      "EmptyStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[EmptyStatement[0]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "EmptyStatement[0,0].Evaluation",
        "name" : "EmptyStatement[0,0].Evaluation",
        "htmlId" : "sec-empty-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "EmptyStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2090,
    [
      "INTRINSICS.Boolean.prototype.valueOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return ? ThisBooleanValue(*this* value).\n        ",
      {
        "normalizedName" : "INTRINSICS.Boolean.prototype.valueOf",
        "name" : "INTRINSICS.Boolean.prototype.valueOf",
        "htmlId" : "sec-boolean.prototype.valueof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    591,
    [
      "ForStatement[0,3].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,3].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[0,3].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1373,
    [
      "EqualityExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[1]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |EqualityExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Return ? IsLooselyEqual(_rval_, _lval_).\n      ",
      {
        "normalizedName" : "EqualityExpression[1,0].Evaluation",
        "name" : "EqualityExpression[1,0].Evaluation",
        "htmlId" : "sec-equality-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "=="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    443,
    [
      "ForStatement[0,5].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,5].VarScopedDeclarations",
        "name" : "ForStatement[0,5].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 5,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1911,
    [
      "Script[0,1].IsStrict",
      2,
      [
        [
          "this",
          false,
          "Ast[Script[0]]"
        ]
      ],
      "\n        1. If |ScriptBody| is present and the Directive Prologue of |ScriptBody| contains a Use Strict Directive, return *true*; otherwise, return *false*.\n      ",
      {
        "normalizedName" : "Script[0,1].IsStrict",
        "name" : "Script[0,1].IsStrict",
        "htmlId" : "sec-static-semantics-isstrict",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsStrict",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "Script",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ScriptBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2782,
    [
      "INTRINSICS.Promise.prototype.finally:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _promise_ be the *this* value.\n          1. If _promise_ is not an Object, throw a *TypeError* exception.\n          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).\n          1. Assert: IsConstructor(_C_) is *true*.\n          1. If IsCallable(_onFinally_) is *false*, then\n            1. Let _thenFinally_ be _onFinally_.\n            1. Let _catchFinally_ be _onFinally_.\n          1. Else,\n            1. Let _thenFinallyClosure_ be a new Abstract Closure with parameters (_value_) that captures _onFinally_ and _C_ and performs the following steps when called:\n              1. Let _result_ be ? Call(_onFinally_, *undefined*).\n              1. Let _p_ be ? PromiseResolve(_C_, _result_).\n              1. Let _returnValue_ be a new Abstract Closure with no parameters that captures _value_ and performs the following steps when called:\n                1. Return _value_.\n              1. Let _valueThunk_ be CreateBuiltinFunction(_returnValue_, 0, *\"\"*, « »).\n              1. Return ? Invoke(_p_, *\"then\"*, « _valueThunk_ »).\n            1. Let _thenFinally_ be CreateBuiltinFunction(_thenFinallyClosure_, 1, *\"\"*, « »).\n            1. Let _catchFinallyClosure_ be a new Abstract Closure with parameters (_reason_) that captures _onFinally_ and _C_ and performs the following steps when called:\n              1. Let _result_ be ? Call(_onFinally_, *undefined*).\n              1. Let _p_ be ? PromiseResolve(_C_, _result_).\n              1. Let _throwReason_ be a new Abstract Closure with no parameters that captures _reason_ and performs the following steps when called:\n                1. Return ThrowCompletion(_reason_).\n              1. Let _thrower_ be CreateBuiltinFunction(_throwReason_, 0, *\"\"*, « »).\n              1. Return ? Invoke(_p_, *\"then\"*, « _thrower_ »).\n            1. Let _catchFinally_ be CreateBuiltinFunction(_catchFinallyClosure_, 1, *\"\"*, « »).\n          1. Return ? Invoke(_promise_, *\"then\"*, « _thenFinally_, _catchFinally_ »).\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.prototype.finally",
        "name" : "INTRINSICS.Promise.prototype.finally",
        "htmlId" : "sec-promise.prototype.finally",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1040,
    [
      "Record[GlobalEnvironmentRecord].HasSuperBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ]
      ],
      "\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].HasSuperBinding",
        "name" : "Record[GlobalEnvironmentRecord].HasSuperBinding",
        "htmlId" : "sec-global-environment-records-hassuperbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "HasSuperBinding"
        ]
      }
    ]
  ],
  [
    1109,
    [
      "GetPrototypeFromConstructor",
      0,
      [
        [
          "constructor",
          false,
          "Record[FunctionObject]"
        ],
        [
          "intrinsicDefaultProto",
          false,
          "String"
        ]
      ],
      "\n        1. Assert: _intrinsicDefaultProto_ is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.\n        1. Let _proto_ be ? Get(_constructor_, *\"prototype\"*).\n        1. If _proto_ is not an Object, then\n          1. Let _realm_ be ? GetFunctionRealm(_constructor_).\n          1. Set _proto_ to _realm_'s intrinsic object named _intrinsicDefaultProto_.\n        1. Return _proto_.\n      ",
      {
        "normalizedName" : "GetPrototypeFromConstructor",
        "name" : "GetPrototypeFromConstructor",
        "htmlId" : "sec-getprototypefromconstructor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1632,
    [
      "AsyncMethod[0,0].HasDirectSuper",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncMethod[0]]"
        ]
      ],
      "\n        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.\n        1. Return |AsyncFunctionBody| Contains |SuperCall|.\n      ",
      {
        "normalizedName" : "AsyncMethod[0,0].HasDirectSuper",
        "name" : "AsyncMethod[0,0].HasDirectSuper",
        "htmlId" : "sec-static-semantics-hasdirectsuper",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasDirectSuper",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    321,
    [
      "StatementListItem[1,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[1]]"
        ]
      ],
      "\n        1. Return a List whose sole element is DeclarationPart of |Declaration|.\n      ",
      {
        "normalizedName" : "StatementListItem[1,0].LexicallyScopedDeclarations",
        "name" : "StatementListItem[1,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2469,
    [
      "AdvanceStringIndex",
      0,
      [
        [
          "S",
          false,
          "String"
        ],
        [
          "index",
          false,
          "Int[0+]"
        ],
        [
          "unicode",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Assert: _index_ ≤ 2<sup>53</sup> - 1.\n          1. If _unicode_ is *false*, return _index_ + 1.\n          1. Let _length_ be the length of _S_.\n          1. If _index_ + 1 ≥ _length_, return _index_ + 1.\n          1. Let _cp_ be CodePointAt(_S_, _index_).\n          1. Return _index_ + _cp_.[[CodeUnitCount]].\n        ",
      {
        "normalizedName" : "AdvanceStringIndex",
        "name" : "AdvanceStringIndex",
        "htmlId" : "sec-advancestringindex",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    376,
    [
      "ForStatement[1,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ]
      ],
      "\n        1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n        1. Let _names2_ be VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ForStatement[1,0].VarDeclaredNames",
        "name" : "ForStatement[1,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2259,
    [
      "INTRINSICS.String.prototype.replace",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. If _searchValue_ is neither *undefined* nor *null*, then\n            1. Let _replacer_ be ? GetMethod(_searchValue_, @@replace).\n            1. If _replacer_ is not *undefined*, then\n              1. Return ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »).\n          1. Let _string_ be ? ToString(_O_).\n          1. Let _searchString_ be ? ToString(_searchValue_).\n          1. Let _functionalReplace_ be IsCallable(_replaceValue_).\n          1. If _functionalReplace_ is *false*, then\n            1. Set _replaceValue_ to ? ToString(_replaceValue_).\n          1. Let _searchLength_ be the length of _searchString_.\n          1. Let _position_ be StringIndexOf(_string_, _searchString_, 0).\n          1. If _position_ = -1, return _string_.\n          1. Let _preceding_ be the substring of _string_ from 0 to _position_.\n          1. Let _following_ be the substring of _string_ from _position_ + _searchLength_.\n          1. If _functionalReplace_ is *true*, then\n            1. Let _replacement_ be ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_position_), _string_ »)).\n          1. Else,\n            1. Assert: _replaceValue_ is a String.\n            1. Let _captures_ be a new empty List.\n            1. Let _replacement_ be ! GetSubstitution(_searchString_, _string_, _position_, _captures_, *undefined*, _replaceValue_).\n          1. Return the string-concatenation of _preceding_, _replacement_, and _following_.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.replace",
        "name" : "INTRINSICS.String.prototype.replace",
        "htmlId" : "sec-string.prototype.replace",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1418,
    [
      "AssignmentRestElement[0,0].IteratorDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentRestElement[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.\n          1. Let _A_ be ! ArrayCreate(0).\n          1. Let _n_ be 0.\n          1. Repeat, while _iteratorRecord_.[[Done]] is *false*,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is not ~done~, then\n              1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_).\n              1. Set _n_ to _n_ + 1.\n          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n            1. Return ? PutValue(_lref_, _A_).\n          1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n          1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _A_.\n        ",
      {
        "normalizedName" : "AssignmentRestElement[0,0].IteratorDestructuringAssignmentEvaluation",
        "name" : "AssignmentRestElement[0,0].IteratorDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AssignmentRestElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "..."
              },
              {
                "type" : "nonterminal",
                "value" : "DestructuringAssignmentTarget"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2451,
    [
      "INTRINSICS.get RegExp.prototype.global",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0067 (LATIN SMALL LETTER G).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get RegExp.prototype.global",
        "name" : "INTRINSICS.get RegExp.prototype.global",
        "htmlId" : "sec-get-regexp.prototype.global",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2236,
    [
      "INTRINSICS.String.fromCharCode",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _result_ be the empty String.\n          1. For each element _next_ of _codeUnits_, do\n            1. Let _nextCU_ be the code unit whose numeric value is ℝ(? ToUint16(_next_)).\n            1. Set _result_ to the string-concatenation of _result_ and _nextCU_.\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.fromCharCode",
        "name" : "INTRINSICS.String.fromCharCode",
        "htmlId" : "sec-string.fromcharcode",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    623,
    [
      "CaseClause[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CaseClause[0,0].ContainsUndefinedBreakTarget",
        "name" : "CaseClause[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    646,
    [
      "StatementListItem[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "StatementListItem[1,0].ContainsUndefinedContinueTarget",
        "name" : "StatementListItem[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    253,
    [
      "CoverCallExpressionAndAsyncArrowHead[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CoverCallExpressionAndAsyncArrowHead[0]]"
        ]
      ],
      "\n        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n        1. Return the BoundNames of _head_.\n      ",
      {
        "normalizedName" : "CoverCallExpressionAndAsyncArrowHead[0,0].BoundNames",
        "name" : "CoverCallExpressionAndAsyncArrowHead[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CoverCallExpressionAndAsyncArrowHead",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1334,
    [
      "OptionalChain[5,0].ChainEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[5]]"
        ],
        [
          "baseValue",
          false,
          "ESValue"
        ],
        [
          "baseReference",
          false,
          "ESValue | Record[ReferenceRecord]"
        ]
      ],
      "\n          1. Let _optionalChain_ be |OptionalChain|.\n          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n          1. Let _newValue_ be ? GetValue(_newReference_).\n          1. Let _thisChain_ be this |OptionalChain|.\n          1. Let _tailCall_ be IsInTailPosition(_thisChain_).\n          1. Return ? EvaluateCall(_newValue_, _newReference_, |Arguments|, _tailCall_).\n        ",
      {
        "normalizedName" : "OptionalChain[5,0].ChainEvaluation",
        "name" : "OptionalChain[5,0].ChainEvaluation",
        "htmlId" : "sec-optional-chaining-chain-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ChainEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    211,
    [
      "BindingList[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be the BoundNames of |BindingList|.\n        1. Let _names2_ be the BoundNames of |LexicalBinding|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "BindingList[1,0].BoundNames",
        "name" : "BindingList[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalBinding"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1682,
    [
      "MemberExpression[7,0].AllPrivateIdentifiersValid",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[7]]"
        ],
        [
          "names",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If _names_ contains the StringValue of |PrivateIdentifier|, then\n          1. Return AllPrivateIdentifiersValid of |MemberExpression| with argument _names_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[7,0].AllPrivateIdentifiersValid",
        "name" : "MemberExpression[7,0].AllPrivateIdentifiersValid",
        "htmlId" : "sec-static-semantics-allprivateidentifiersvalid",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AllPrivateIdentifiersValid",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    485,
    [
      "ConciseBody[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ConciseBody[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ConciseBody[0,0].VarScopedDeclarations",
        "name" : "ConciseBody[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1136,
    [
      "BuiltinCallOrConstruct",
      0,
      [
        [
          "F",
          false,
          "Record[BuiltinFunctionObject]"
        ],
        [
          "thisArgument",
          false,
          "ESValue | Enum[~uninitialized~]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "newTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _callerContext_ be the running execution context.\n        1. If _callerContext_ is not already suspended, suspend _callerContext_.\n        1. Let _calleeContext_ be a new execution context.\n        1. Set the Function of _calleeContext_ to _F_.\n        1. Let _calleeRealm_ be _F_.[[Realm]].\n        1. Set the Realm of _calleeContext_ to _calleeRealm_.\n        1. Set the ScriptOrModule of _calleeContext_ to *null*.\n        1. Perform any necessary implementation-defined initialization of _calleeContext_.\n        1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.\n        1. [id=\"step-call-builtin-function-result\"] Let _result_ be the Completion Record that is <emu-meta effects=\"user-code\">the result of evaluating</emu-meta> _F_ in a manner that conforms to the specification of _F_. If _thisArgument_ is ~uninitialized~, the *this* value is uninitialized; otherwise, _thisArgument_ provides the *this* value. _argumentsList_ provides the named parameters. _newTarget_ provides the NewTarget value.\n        1. NOTE: If _F_ is defined in this document, “the specification of _F_” is the behaviour specified for it via algorithm steps or other means.\n        1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n        1. Return ? _result_.\n      ",
      {
        "normalizedName" : "BuiltinCallOrConstruct",
        "name" : "BuiltinCallOrConstruct",
        "htmlId" : "sec-builtincallorconstruct",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    834,
    [
      "GeneratorExpression[0,1].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,1].Contains",
        "name" : "GeneratorExpression[0,1].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1858,
    [
      "UnaryExpression[4,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[4]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[4,0].HasCallInTailPosition",
        "name" : "UnaryExpression[4,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "+"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1864,
    [
      "CallExpression[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CallExpression[2,0].HasCallInTailPosition",
        "name" : "CallExpression[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportCall"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2122,
    [
      "INTRINSICS.BigInt.prototype.toString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _x_ be ? ThisBigIntValue(*this* value).\n          1. If _radix_ is *undefined*, let _radixMV_ be 10.\n          1. Else, let _radixMV_ be ? ToIntegerOrInfinity(_radix_).\n          1. If _radixMV_ is not in the inclusive interval from 2 to 36, throw a *RangeError* exception.\n          1. Return BigInt::toString(_x_, _radixMV_).\n        ",
      {
        "normalizedName" : "INTRINSICS.BigInt.prototype.toString",
        "name" : "INTRINSICS.BigInt.prototype.toString",
        "htmlId" : "sec-bigint.prototype.tostring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    106,
    [
      "CreateByteDataBlock",
      0,
      [
        [
          "size",
          false,
          "Int[0+]"
        ]
      ],
      "\n          1. If _size_ > 2<sup>53</sup> - 1, throw a *RangeError* exception.\n          1. Let _db_ be a new Data Block value consisting of _size_ bytes. If it is impossible to create such a Data Block, throw a *RangeError* exception.\n          1. Set all of the bytes of _db_ to 0.\n          1. Return _db_.\n        ",
      {
        "normalizedName" : "CreateByteDataBlock",
        "name" : "CreateByteDataBlock",
        "htmlId" : "sec-createbytedatablock",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1828,
    [
      "AssignmentExpression[7,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[7]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[7,0].HasCallInTailPosition",
        "name" : "AssignmentExpression[7,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "||="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1978,
    [
      "ExportDeclaration[6,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[6]]"
        ]
      ],
      "\n          1. Return the BoundNames of this |ExportDeclaration|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[6,0].ExportedBindings",
        "name" : "ExportDeclaration[6,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    121,
    [
      "StrUnsignedDecimalLiteral[0,0].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StrUnsignedDecimalLiteral[0]]"
        ]
      ],
      "\n            1. Return *+∞*<sub>𝔽</sub>.\n          ",
      {
        "normalizedName" : "StrUnsignedDecimalLiteral[0,0].StringNumericValue",
        "name" : "StrUnsignedDecimalLiteral[0,0].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "StrUnsignedDecimalLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "Infinity"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    514,
    [
      "Statement[6,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[6]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[6,0].ContainsDuplicateLabels",
        "name" : "Statement[6,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ContinueStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1151,
    [
      "Record[ArgumentsExoticObject].DefineOwnProperty",
      4,
      [
        [
          "args",
          false,
          "Record[ArgumentsExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Desc",
          false,
          "Record[PropertyDescriptor]"
        ]
      ],
      "\n          1. Let _map_ be _args_.[[ParameterMap]].\n          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n          1. Let _newArgDesc_ be _Desc_.\n          1. If _isMapped_ is *true* and IsDataDescriptor(_Desc_) is *true*, then\n            1. If _Desc_ does not have a [[Value]] field, _Desc_ has a [[Writable]] field, and _Desc_.[[Writable]] is *false*, then\n              1. Set _newArgDesc_ to a copy of _Desc_.\n              1. Set _newArgDesc_.[[Value]] to ! Get(_map_, _P_).\n          1. Let _allowed_ be ! OrdinaryDefineOwnProperty(_args_, _P_, _newArgDesc_).\n          1. If _allowed_ is *false*, return *false*.\n          1. If _isMapped_ is *true*, then\n            1. If IsAccessorDescriptor(_Desc_) is *true*, then\n              1. Perform ! _map_.[[Delete]](_P_).\n            1. Else,\n              1. If _Desc_ has a [[Value]] field, then\n                1. Assert: The following Set will succeed, since formal parameters mapped by arguments objects are always writable.\n                1. Perform ! Set(_map_, _P_, _Desc_.[[Value]], *false*).\n              1. If _Desc_ has a [[Writable]] field and _Desc_.[[Writable]] is *false*, then\n                1. Perform ! _map_.[[Delete]](_P_).\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "Record[ArgumentsExoticObject].DefineOwnProperty",
        "name" : "Record[ArgumentsExoticObject].DefineOwnProperty",
        "htmlId" : "sec-arguments-exotic-objects-defineownproperty-p-desc",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ArgumentsExoticObject",
          "[[DefineOwnProperty]]"
        ]
      }
    ]
  ],
  [
    937,
    [
      "CallExpression[6,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[6]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "CallExpression[6,0].AssignmentTargetType",
        "name" : "CallExpression[6,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2291,
    [
      "ClassEscape[0,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassEscape[0]]"
        ]
      ],
      "\n          1. Return the numeric value of U+0008 (BACKSPACE).\n        ",
      {
        "normalizedName" : "ClassEscape[0,0].CharacterValue",
        "name" : "ClassEscape[0,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "b"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1383,
    [
      "ConditionalExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ConditionalExpression[1]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |ShortCircuitExpression|.\n        1. Let _lval_ be ToBoolean(? GetValue(_lref_)).\n        1. If _lval_ is *true*, then\n          1. Let _trueRef_ be ? Evaluation of the first |AssignmentExpression|.\n          1. Return ? GetValue(_trueRef_).\n        1. Else,\n          1. Let _falseRef_ be ? Evaluation of the second |AssignmentExpression|.\n          1. Return ? GetValue(_falseRef_).\n      ",
      {
        "normalizedName" : "ConditionalExpression[1,0].Evaluation",
        "name" : "ConditionalExpression[1,0].Evaluation",
        "htmlId" : "sec-conditional-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ConditionalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShortCircuitExpression"
              },
              {
                "type" : "terminal",
                "value" : "?"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    574,
    [
      "Statement[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[1,0].ContainsUndefinedBreakTarget",
        "name" : "Statement[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "VariableStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2254,
    [
      "INTRINSICS.String.prototype.padStart",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Return ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~start~).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.padStart",
        "name" : "INTRINSICS.String.prototype.padStart",
        "htmlId" : "sec-string.prototype.padstart",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1020,
    [
      "Record[ObjectEnvironmentRecord].InitializeBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[ObjectEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "V",
          false,
          "ESValue"
        ]
      ],
      "\n            1. Perform ? <emu-meta effects=\"user-code\">_envRec_.SetMutableBinding</emu-meta>(_N_, _V_, *false*).\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[ObjectEnvironmentRecord].InitializeBinding",
        "name" : "Record[ObjectEnvironmentRecord].InitializeBinding",
        "htmlId" : "sec-object-environment-records-initializebinding-n-v",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ObjectEnvironmentRecord",
          "InitializeBinding"
        ]
      }
    ]
  ],
  [
    348,
    [
      "ExportDeclaration[2,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[2]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ExportDeclaration[2,0].LexicallyScopedDeclarations",
        "name" : "ExportDeclaration[2,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1677,
    [
      "ClassElementList[0,0].NonConstructorElements",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementList[0]]"
        ]
      ],
      "\n        1. If ClassElementKind of |ClassElement| is ~non-constructor-method~, then\n          1. Return « |ClassElement| ».\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ClassElementList[0,0].NonConstructorElements",
        "name" : "ClassElementList[0,0].NonConstructorElements",
        "htmlId" : "sec-static-semantics-nonconstructorelements",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NonConstructorElements",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2540,
    [
      "INTRINSICS.TypedArray.prototype.every",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n            1. If _testResult_ is *false*, return *false*.\n            1. Set _k_ to _k_ + 1.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.every",
        "name" : "INTRINSICS.TypedArray.prototype.every",
        "htmlId" : "sec-%typedarray%.prototype.every",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2034,
    [
      "INTRINSICS.parseFloat",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _inputString_ be ? ToString(_string_).\n        1. Let _trimmedString_ be ! TrimString(_inputString_, ~start~).\n        1. Let _trimmed_ be StringToCodePoints(_trimmedString_).\n        1. Let _trimmedPrefix_ be the longest prefix of _trimmed_ that satisfies the syntax of a |StrDecimalLiteral|, which might be _trimmed_ itself. If there is no such prefix, return *NaN*.\n        1. Let _parsedNumber_ be ParseText(_trimmedPrefix_, |StrDecimalLiteral|).\n        1. Assert: _parsedNumber_ is a Parse Node.\n        1. Return StringNumericValue of _parsedNumber_.\n      ",
      {
        "normalizedName" : "INTRINSICS.parseFloat",
        "name" : "INTRINSICS.parseFloat",
        "htmlId" : "sec-parsefloat-string",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1960,
    [
      "ImportDeclaration[1,0].ImportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportDeclaration[1]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ImportDeclaration[1,0].ImportEntries",
        "name" : "ImportDeclaration[1,0].ImportEntries",
        "htmlId" : "sec-static-semantics-importentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntries",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ImportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "import"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleSpecifier"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2555,
    [
      "INTRINSICS.TypedArray.prototype.reduce",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Let _accumulator_ be *undefined*.\n          1. If _initialValue_ is present, then\n            1. Set _accumulator_ to _initialValue_.\n          1. Else,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Set _accumulator_ to ! Get(_O_, _Pk_).\n            1. Set _k_ to _k_ + 1.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).\n            1. Set _k_ to _k_ + 1.\n          1. Return _accumulator_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.reduce",
        "name" : "INTRINSICS.TypedArray.prototype.reduce",
        "htmlId" : "sec-%typedarray%.prototype.reduce",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    806,
    [
      "MemberExpression[1,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[1,0].IsIdentifierRef",
        "name" : "MemberExpression[1,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    84,
    [
      "BigIntBitwiseOp",
      0,
      [
        [
          "op",
          false,
          "Unknown[\"`&`,`^`,Or``\"]"
        ],
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. Set _x_ to ℝ(_x_).\n            1. Set _y_ to ℝ(_y_).\n            1. Let _result_ be 0.\n            1. Let _shift_ be 0.\n            1. Repeat, until (_x_ = 0 or _x_ = -1) and (_y_ = 0 or _y_ = -1),\n              1. Let _xDigit_ be _x_ modulo 2.\n              1. Let _yDigit_ be _y_ modulo 2.\n              1. If _op_ is `&`, then\n                1. Set _result_ to _result_ + 2<sup>_shift_</sup> × BinaryAnd(_xDigit_, _yDigit_).\n              1. Else if _op_ is `|`, then\n                1. Set _result_ to _result_ + 2<sup>_shift_</sup> × BinaryOr(_xDigit_, _yDigit_).\n              1. Else,\n                1. Assert: _op_ is `^`.\n                1. Set _result_ to _result_ + 2<sup>_shift_</sup> × BinaryXor(_xDigit_, _yDigit_).\n              1. Set _shift_ to _shift_ + 1.\n              1. Set _x_ to (_x_ - _xDigit_) / 2.\n              1. Set _y_ to (_y_ - _yDigit_) / 2.\n            1. If _op_ is `&`, then\n              1. Let _tmp_ be BinaryAnd(_x_ modulo 2, _y_ modulo 2).\n            1. Else if _op_ is `|`, then\n              1. Let _tmp_ be BinaryOr(_x_ modulo 2, _y_ modulo 2).\n            1. Else,\n              1. Assert: _op_ is `^`.\n              1. Let _tmp_ be BinaryXor(_x_ modulo 2, _y_ modulo 2).\n            1. If _tmp_ ≠ 0, then\n              1. Set _result_ to _result_ - 2<sup>_shift_</sup>.\n              1. NOTE: This extends the sign.\n            1. Return the BigInt value for _result_.\n          ",
      {
        "normalizedName" : "BigIntBitwiseOp",
        "name" : "BigIntBitwiseOp",
        "htmlId" : "sec-bigintbitwiseop",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1581,
    [
      "ArrowParameters[1,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowParameters[1]]"
        ]
      ],
      "\n        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return ContainsExpression of _formals_.\n      ",
      {
        "normalizedName" : "ArrowParameters[1,0].ContainsExpression",
        "name" : "ArrowParameters[1,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ArrowParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    353,
    [
      "Statement[2,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[2]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[2,0].VarDeclaredNames",
        "name" : "Statement[2,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EmptyStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2335,
    [
      "RegExpIdentifierName[0,0].RegExpIdentifierCodePoints",
      2,
      [
        [
          "this",
          false,
          "Ast[RegExpIdentifierName[0]]"
        ]
      ],
      "\n          1. Let _cp_ be RegExpIdentifierCodePoint of |RegExpIdentifierStart|.\n          1. Return « _cp_ ».\n        ",
      {
        "normalizedName" : "RegExpIdentifierName[0,0].RegExpIdentifierCodePoints",
        "name" : "RegExpIdentifierName[0,0].RegExpIdentifierCodePoints",
        "htmlId" : "sec-regexpidentifiercodepoints",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "RegExpIdentifierCodePoints",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "RegExpIdentifierName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RegExpIdentifierStart"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    966,
    [
      "RelationalExpression[4,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[4]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "RelationalExpression[4,0].AssignmentTargetType",
        "name" : "RelationalExpression[4,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : ">="
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1183,
    [
      "Record[ModuleNamespaceExoticObject].HasProperty",
      4,
      [
        [
          "O",
          false,
          "Record[ModuleNamespaceExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. If _P_ is a Symbol, return ! OrdinaryHasProperty(_O_, _P_).\n          1. Let _exports_ be _O_.[[Exports]].\n          1. If _exports_ contains _P_, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "Record[ModuleNamespaceExoticObject].HasProperty",
        "name" : "Record[ModuleNamespaceExoticObject].HasProperty",
        "htmlId" : "sec-module-namespace-exotic-objects-hasproperty-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleNamespaceExoticObject",
          "[[HasProperty]]"
        ]
      }
    ]
  ],
  [
    1283,
    [
      "TemplateSpans[1,0].TemplateStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateSpans[1]]"
        ],
        [
          "raw",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Let _middle_ be TemplateStrings of |TemplateMiddleList| with argument _raw_.\n          1. Let _tail_ be « TemplateString(|TemplateTail|, _raw_) ».\n          1. Return the list-concatenation of _middle_ and _tail_.\n        ",
      {
        "normalizedName" : "TemplateSpans[1,0].TemplateStrings",
        "name" : "TemplateSpans[1,0].TemplateStrings",
        "htmlId" : "sec-static-semantics-templatestrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TemplateStrings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TemplateSpans",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateMiddleList"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2073,
    [
      "INTRINSICS.Object.prototype.toLocaleString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Return ? Invoke(_O_, *\"toString\"*).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.prototype.toLocaleString",
        "name" : "INTRINSICS.Object.prototype.toLocaleString",
        "htmlId" : "sec-object.prototype.tolocalestring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1051,
    [
      "Record[ModuleEnvironmentRecord].HasThisBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[ModuleEnvironmentRecord]"
        ]
      ],
      "\n            1. Return *true*.\n          ",
      {
        "normalizedName" : "Record[ModuleEnvironmentRecord].HasThisBinding",
        "name" : "Record[ModuleEnvironmentRecord].HasThisBinding",
        "htmlId" : "sec-module-environment-records-hasthisbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleEnvironmentRecord",
          "HasThisBinding"
        ]
      }
    ]
  ],
  [
    821,
    [
      "AsyncFunctionExpression[0,0].NamedEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ],
        [
          "name",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Return InstantiateAsyncFunctionExpression of |AsyncFunctionExpression| with argument _name_.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,0].NamedEvaluation",
        "name" : "AsyncFunctionExpression[0,0].NamedEvaluation",
        "htmlId" : "sec-runtime-semantics-namedevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NamedEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2017,
    [
      "NamedExports[0,0].ReferencedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[NamedExports[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "NamedExports[0,0].ReferencedBindings",
        "name" : "NamedExports[0,0].ReferencedBindings",
        "htmlId" : "sec-static-semantics-referencedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ReferencedBindings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NamedExports",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    905,
    [
      "FormalParameters[0,0].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameters[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "FormalParameters[0,0].IteratorBindingInitialization",
        "name" : "FormalParameters[0,0].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FormalParameters",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    480,
    [
      "Catch[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Catch[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Block|.\n      ",
      {
        "normalizedName" : "Catch[0,0].VarScopedDeclarations",
        "name" : "Catch[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Catch",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "catch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "CatchParameter"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    660,
    [
      "ForStatement[0,6].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[0,6].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[0,6].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 6,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1433,
    [
      "BindingList[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingList[1]]"
        ]
      ],
      "\n          1. Perform ? Evaluation of |BindingList|.\n          1. Return ? Evaluation of |LexicalBinding|.\n        ",
      {
        "normalizedName" : "BindingList[1,0].Evaluation",
        "name" : "BindingList[1,0].Evaluation",
        "htmlId" : "sec-let-and-const-declarations-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalBinding"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1600,
    [
      "FormalParameterList[1,0].HasInitializer",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameterList[1]]"
        ]
      ],
      "\n        1. If HasInitializer of |FormalParameterList| is *true*, return *true*.\n        1. Return HasInitializer of |FormalParameter|.\n      ",
      {
        "normalizedName" : "FormalParameterList[1,0].HasInitializer",
        "name" : "FormalParameterList[1,0].HasInitializer",
        "htmlId" : "sec-static-semantics-hasinitializer",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasInitializer",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FormalParameterList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameterList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    507,
    [
      "StatementListItem[1,0].TopLevelVarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[1]]"
        ]
      ],
      "\n        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>, then\n          1. Let _declaration_ be DeclarationPart of |HoistableDeclaration|.\n          1. Return « _declaration_ ».\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "StatementListItem[1,0].TopLevelVarScopedDeclarations",
        "name" : "StatementListItem[1,0].TopLevelVarScopedDeclarations",
        "htmlId" : "sec-static-semantics-toplevelvarscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelVarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2762,
    [
      "INTRINSICS.Promise.all",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the *this* value.\n          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).\n          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).\n          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).\n          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).\n          1. Let _result_ be Completion(PerformPromiseAll(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).\n          1. If _result_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Return ? _result_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.all",
        "name" : "INTRINSICS.Promise.all",
        "htmlId" : "sec-promise.all",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    602,
    [
      "ForStatement[2,2].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[2,2].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[2,2].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2508,
    [
      "INTRINSICS.Array.prototype.reduceRight",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.\n          1. Let _k_ be _len_ - 1.\n          1. Let _accumulator_ be *undefined*.\n          1. If _initialValue_ is present, then\n            1. Set _accumulator_ to _initialValue_.\n          1. Else,\n            1. Let _kPresent_ be *false*.\n            1. Repeat, while _kPresent_ is *false* and _k_ ≥ 0,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).\n              1. If _kPresent_ is *true*, then\n                1. Set _accumulator_ to ? Get(_O_, _Pk_).\n              1. Set _k_ to _k_ - 1.\n            1. If _kPresent_ is *false*, throw a *TypeError* exception.\n          1. Repeat, while _k_ ≥ 0,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).\n            1. Set _k_ to _k_ - 1.\n          1. Return _accumulator_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.reduceRight",
        "name" : "INTRINSICS.Array.prototype.reduceRight",
        "htmlId" : "sec-array.prototype.reduceright",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    981,
    [
      "AssignmentExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "AssignmentExpression[1,0].AssignmentTargetType",
        "name" : "AssignmentExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "YieldExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    766,
    [
      "BitwiseANDExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[BitwiseANDExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "BitwiseANDExpression[1,0].IsFunctionDefinition",
        "name" : "BitwiseANDExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BitwiseANDExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BitwiseANDExpression"
              },
              {
                "type" : "terminal",
                "value" : "&"
              },
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2058,
    [
      "INTRINSICS.Object.getPrototypeOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Return ? <emu-meta effects=\"user-code\">_obj_.[[GetPrototypeOf]]()</emu-meta>.\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.getPrototypeOf",
        "name" : "INTRINSICS.Object.getPrototypeOf",
        "htmlId" : "sec-object.getprototypeof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    147,
    [
      "IsCallable",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If _argument_ is not an Object, return *false*.\n        1. If _argument_ has a [[Call]] internal method, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "IsCallable",
        "name" : "IsCallable",
        "htmlId" : "sec-iscallable",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1843,
    [
      "RelationalExpression[7,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[7]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[7,0].HasCallInTailPosition",
        "name" : "RelationalExpression[7,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1169,
    [
      "TypedArrayCreate",
      0,
      [
        [
          "prototype",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Let _internalSlotsList_ be « [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] ».\n          1. Let _A_ be MakeBasicObject(_internalSlotsList_).\n          1. Set _A_.[[GetOwnProperty]] as specified in <emu-xref href=\"#sec-typedarray-getownproperty\"></emu-xref>.\n          1. Set _A_.[[HasProperty]] as specified in <emu-xref href=\"#sec-typedarray-hasproperty\"></emu-xref>.\n          1. Set _A_.[[DefineOwnProperty]] as specified in <emu-xref href=\"#sec-typedarray-defineownproperty\"></emu-xref>.\n          1. Set _A_.[[Get]] as specified in <emu-xref href=\"#sec-typedarray-get\"></emu-xref>.\n          1. Set _A_.[[Set]] as specified in <emu-xref href=\"#sec-typedarray-set\"></emu-xref>.\n          1. Set _A_.[[Delete]] as specified in <emu-xref href=\"#sec-typedarray-delete\"></emu-xref>.\n          1. Set _A_.[[OwnPropertyKeys]] as specified in <emu-xref href=\"#sec-typedarray-ownpropertykeys\"></emu-xref>.\n          1. Set _A_.[[Prototype]] to _prototype_.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "TypedArrayCreate",
        "name" : "TypedArrayCreate",
        "htmlId" : "sec-typedarraycreate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    397,
    [
      "CaseBlock[1,1].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _names1_ be the VarDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be VarDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the VarDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,1].VarDeclaredNames",
        "name" : "CaseBlock[1,1].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    687,
    [
      "CaseBlock[1,3].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "CaseBlock[1,3].ContainsUndefinedContinueTarget",
        "name" : "CaseBlock[1,3].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2367,
    [
      "QuantifierPrefix[1,0].CompileQuantifierPrefix",
      2,
      [
        [
          "this",
          false,
          "Ast[QuantifierPrefix[1]]"
        ]
      ],
      "\n          1. Return the Record { [[Min]]: 1, [[Max]]: +∞ }.\n        ",
      {
        "normalizedName" : "QuantifierPrefix[1,0].CompileQuantifierPrefix",
        "name" : "QuantifierPrefix[1,0].CompileQuantifierPrefix",
        "htmlId" : "sec-compilequantifierprefix",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileQuantifierPrefix",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "QuantifierPrefix",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "+"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2437,
    [
      "ClassString[0,0].CompileClassSetString",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassString[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return an empty sequence of characters.\n        ",
      {
        "normalizedName" : "ClassString[0,0].CompileClassSetString",
        "name" : "ClassString[0,0].CompileClassSetString",
        "htmlId" : "sec-compileclasssetstring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileClassSetString",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassString",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1928,
    [
      "ExportDeclaration[5,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[5]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ExportDeclaration[5,0].ModuleRequests",
        "name" : "ExportDeclaration[5,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1377,
    [
      "BitwiseANDExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BitwiseANDExpression[1]]"
        ]
      ],
      "\n        1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseANDExpression|, `&`, |EqualityExpression|).\n      ",
      {
        "normalizedName" : "BitwiseANDExpression[1,0].Evaluation",
        "name" : "BitwiseANDExpression[1,0].Evaluation",
        "htmlId" : "sec-binary-bitwise-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BitwiseANDExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BitwiseANDExpression"
              },
              {
                "type" : "terminal",
                "value" : "&"
              },
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    280,
    [
      "GeneratorDeclaration[1,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorDeclaration[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "GeneratorDeclaration[1,0].IsConstantDeclaration",
        "name" : "GeneratorDeclaration[1,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "GeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2618,
    [
      "INTRINSICS.WeakMap.prototype.get",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).\n          1. If CanBeHeldWeakly(_key_) is *false*, return *undefined*.\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "INTRINSICS.WeakMap.prototype.get",
        "name" : "INTRINSICS.WeakMap.prototype.get",
        "htmlId" : "sec-weakmap.prototype.get",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2833,
    [
      "Await:clo1:cont0",
      7,
      [
      ],
      "\n          1. Let _asyncContext_ be the running execution context.\n          1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).\n          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_v_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using NormalCompletion(_v_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using ThrowCompletion(_reason_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n          1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n          1. Let _callerContext_ be the running execution context.\n          1. Resume _callerContext_ passing ~empty~. If _asyncContext_ is ever resumed again, let _completion_ be the Completion Record with which it is resumed.\n          1. Assert: If control reaches here, then _asyncContext_ is the running execution context again.\n          1. Return _completion_.\n        ",
      {
        "normalizedName" : "Await",
        "name" : "Await",
        "htmlId" : "await",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : true,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2281,
    [
      "DecimalEscape[0,0].CapturingGroupNumber",
      2,
      [
        [
          "this",
          false,
          "Ast[DecimalEscape[0]]"
        ]
      ],
      "\n          1. Return the MV of |NonZeroDigit|.\n        ",
      {
        "normalizedName" : "DecimalEscape[0,0].CapturingGroupNumber",
        "name" : "DecimalEscape[0,0].CapturingGroupNumber",
        "htmlId" : "sec-patterns-static-semantics-capturing-group-number",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CapturingGroupNumber",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DecimalEscape",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NonZeroDigit"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1215,
    [
      "UnicodeEscapeSequence[0,0].IdentifierCodePoint",
      2,
      [
        [
          "this",
          false,
          "Ast[UnicodeEscapeSequence[0]]"
        ]
      ],
      "\n          1. Return the code point whose numeric value is the MV of |Hex4Digits|.\n        ",
      {
        "normalizedName" : "UnicodeEscapeSequence[0,0].IdentifierCodePoint",
        "name" : "UnicodeEscapeSequence[0,0].IdentifierCodePoint",
        "htmlId" : "sec-identifiercodepoint",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IdentifierCodePoint",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "UnicodeEscapeSequence",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "u"
              },
              {
                "type" : "nonterminal",
                "value" : "Hex4Digits"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    61,
    [
      "Number::unsignedRightShift",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. Let _lnum_ be ! ToUint32(_x_).\n            1. Let _rnum_ be ! ToUint32(_y_).\n            1. Let _shiftCount_ be ℝ(_rnum_) modulo 32.\n            1. Return the result of performing a zero-filling right shift of _lnum_ by _shiftCount_ bits. Vacated bits are filled with zero. The mathematical value of the result is exactly representable as a 32-bit unsigned bit string.\n          ",
      {
        "normalizedName" : "Number::unsignedRightShift",
        "name" : "Number::unsignedRightShift",
        "htmlId" : "sec-numeric-types-number-unsignedRightShift",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    634,
    [
      "ClassStaticBlockStatementList[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockStatementList[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassStaticBlockStatementList[0,0].ContainsUndefinedBreakTarget",
        "name" : "ClassStaticBlockStatementList[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStaticBlockStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1896,
    [
      "OptionalExpression[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalExpression[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |OptionalChain| with argument _call_.\n      ",
      {
        "normalizedName" : "OptionalExpression[0,0].HasCallInTailPosition",
        "name" : "OptionalExpression[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "OptionalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    877,
    [
      "AsyncFunctionDeclaration[0,0].InstantiateFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionDeclaration[0]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Return InstantiateAsyncFunctionObject of |AsyncFunctionDeclaration| with arguments _env_ and _privateEnv_.\n      ",
      {
        "normalizedName" : "AsyncFunctionDeclaration[0,0].InstantiateFunctionObject",
        "name" : "AsyncFunctionDeclaration[0,0].InstantiateFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiatefunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    692,
    [
      "DefaultClause[0,1].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "DefaultClause[0,1].ContainsUndefinedContinueTarget",
        "name" : "DefaultClause[0,1].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2190,
    [
      "INTRINSICS.Date.prototype.getDate",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return DateFromTime(LocalTime(_t_)).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getDate",
        "name" : "INTRINSICS.Date.prototype.getDate",
        "htmlId" : "sec-date.prototype.getdate",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    734,
    [
      "LeftHandSideExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[LeftHandSideExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "LeftHandSideExpression[1,0].IsFunctionDefinition",
        "name" : "LeftHandSideExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LeftHandSideExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    221,
    [
      "ArrayBindingPattern[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[0,0].BoundNames",
        "name" : "ArrayBindingPattern[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1447,
    [
      "BindingElement[1,1].KeyedBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElement[1]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ],
        [
          "propertyName",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. Let _v_ be ? GetV(_value_, _propertyName_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n            1. Set _v_ to ? GetValue(_defaultValue_).\n          1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.\n        ",
      {
        "normalizedName" : "BindingElement[1,1].KeyedBindingInitialization",
        "name" : "BindingElement[1,1].KeyedBindingInitialization",
        "htmlId" : "sec-runtime-semantics-keyedbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "KeyedBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "BindingElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2483,
    [
      "INTRINSICS.Array.prototype.concat",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).\n          1. Let _n_ be 0.\n          1. Prepend _O_ to _items_.\n          1. For each element _E_ of _items_, do\n            1. Let _spreadable_ be ? IsConcatSpreadable(_E_).\n            1. If _spreadable_ is *true*, then\n              1. Let _len_ be ? LengthOfArrayLike(_E_).\n              1. If _n_ + _len_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n              1. Let _k_ be 0.\n              1. Repeat, while _k_ < _len_,\n                1. Let _Pk_ be ! ToString(𝔽(_k_)).\n                1. Let _exists_ be ? HasProperty(_E_, _Pk_).\n                1. If _exists_ is *true*, then\n                  1. Let _subElement_ be ? Get(_E_, _Pk_).\n                  1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _subElement_).\n                1. Set _n_ to _n_ + 1.\n                1. Set _k_ to _k_ + 1.\n            1. Else,\n              1. NOTE: _E_ is added as a single item rather than spread.\n              1. If _n_ ≥ 2<sup>53</sup> - 1, throw a *TypeError* exception.\n              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _E_).\n              1. Set _n_ to _n_ + 1.\n          1. [id=\"step-array-proto-concat-set-length\"] Perform ? Set(_A_, *\"length\"*, 𝔽(_n_), *true*).\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.concat",
        "name" : "INTRINSICS.Array.prototype.concat",
        "htmlId" : "sec-array.prototype.concat",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    293,
    [
      "StatementListItem[1,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[1]]"
        ]
      ],
      "\n        1. Return the BoundNames of |Declaration|.\n      ",
      {
        "normalizedName" : "StatementListItem[1,0].LexicallyDeclaredNames",
        "name" : "StatementListItem[1,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    956,
    [
      "ExponentiationExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[ExponentiationExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "ExponentiationExpression[1,0].AssignmentTargetType",
        "name" : "ExponentiationExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExponentiationExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "UpdateExpression"
              },
              {
                "type" : "terminal",
                "value" : "**"
              },
              {
                "type" : "nonterminal",
                "value" : "ExponentiationExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    866,
    [
      "ClassElement[4,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[4]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassElement[4,0].ComputedPropertyContains",
        "name" : "ClassElement[4,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassStaticBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1886,
    [
      "PrimaryExpression[11,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[11]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[11,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[11,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 11,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1072,
    [
      "HostMakeJobCallback",
      0,
      [
        [
          "callback",
          false,
          "Record[FunctionObject]"
        ]
      ],
      "\n        1. Return the JobCallback Record { [[Callback]]: _callback_, [[HostDefined]]: ~empty~ }.\n      ",
      {
        "normalizedName" : "HostMakeJobCallback",
        "name" : "HostMakeJobCallback",
        "htmlId" : "sec-hostmakejobcallback",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2530,
    [
      "INTRINSICS.TypedArray",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Throw a *TypeError* exception.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray",
        "name" : "INTRINSICS.TypedArray",
        "htmlId" : "sec-%typedarray%",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    453,
    [
      "ForStatement[2,3].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[2,3].VarScopedDeclarations",
        "name" : "ForStatement[2,3].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2523,
    [
      "INTRINSICS.Array.prototype.toString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _array_ be ? ToObject(*this* value).\n          1. Let _func_ be ? Get(_array_, *\"join\"*).\n          1. If IsCallable(_func_) is *false*, set _func_ to the intrinsic function %Object.prototype.toString%.\n          1. Return ? Call(_func_, _array_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.toString",
        "name" : "INTRINSICS.Array.prototype.toString",
        "htmlId" : "sec-array.prototype.tostring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1796,
    [
      "ForStatement[1,2].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[1,2].HasCallInTailPosition",
        "name" : "ForStatement[1,2].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1119,
    [
      "AsyncConciseBody[0,0].EvaluateBody",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncConciseBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Return ? EvaluateAsyncConciseBody of |AsyncConciseBody| with arguments _functionObject_ and _argumentsList_.\n        ",
      {
        "normalizedName" : "AsyncConciseBody[0,0].EvaluateBody",
        "name" : "AsyncConciseBody[0,0].EvaluateBody",
        "htmlId" : "sec-runtime-semantics-evaluatebody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    132,
    [
      "ToInt32",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n        1. Let _int_ be truncate(ℝ(_number_)).\n        1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.\n        1. If _int32bit_ ≥ 2<sup>31</sup>, return 𝔽(_int32bit_ - 2<sup>32</sup>); otherwise return 𝔽(_int32bit_).\n      ",
      {
        "normalizedName" : "ToInt32",
        "name" : "ToInt32",
        "htmlId" : "sec-toint32",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1622,
    [
      "ConciseBody[1,0].ConciseBodyContainsUseStrict",
      2,
      [
        [
          "this",
          false,
          "Ast[ConciseBody[1]]"
        ]
      ],
      "\n        1. Return FunctionBodyContainsUseStrict of |FunctionBody|.\n      ",
      {
        "normalizedName" : "ConciseBody[1,0].ConciseBodyContainsUseStrict",
        "name" : "ConciseBody[1,0].ConciseBodyContainsUseStrict",
        "htmlId" : "sec-static-semantics-concisebodycontainsusestrict",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ConciseBodyContainsUseStrict",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ConciseBody",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2424,
    [
      "ClassStringDisjunctionContents[1,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStringDisjunctionContents[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _s_ be CompileClassSetString of |ClassString| with argument _rer_.\n          1. Let _A_ be the CharSet containing the one string _s_.\n          1. Let _B_ be CompileToCharSet of |ClassStringDisjunctionContents| with argument _rer_.\n          1. Return the union of CharSets _A_ and _B_.\n        ",
      {
        "normalizedName" : "ClassStringDisjunctionContents[1,0].CompileToCharSet",
        "name" : "ClassStringDisjunctionContents[1,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassStringDisjunctionContents",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassString"
              },
              {
                "type" : "terminal",
                "value" : "|"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassStringDisjunctionContents"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    774,
    [
      "AssignmentExpression[4,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[4]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[4,0].IsFunctionDefinition",
        "name" : "AssignmentExpression[4,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2371,
    [
      "QuantifierPrefix[5,0].CompileQuantifierPrefix",
      2,
      [
        [
          "this",
          false,
          "Ast[QuantifierPrefix[5]]"
        ]
      ],
      "\n          1. Let _i_ be the MV of the first |DecimalDigits|.\n          1. Let _j_ be the MV of the second |DecimalDigits|.\n          1. Return the Record { [[Min]]: _i_, [[Max]]: _j_ }.\n        ",
      {
        "normalizedName" : "QuantifierPrefix[5,0].CompileQuantifierPrefix",
        "name" : "QuantifierPrefix[5,0].CompileQuantifierPrefix",
        "htmlId" : "sec-compilequantifierprefix",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileQuantifierPrefix",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "QuantifierPrefix",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1394,
    [
      "ObjectAssignmentPattern[1,0].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectAssignmentPattern[1]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Perform ? RequireObjectCoercible(_value_).\n          1. Let _excludedNames_ be a new empty List.\n          1. Return ? RestDestructuringAssignmentEvaluation of |AssignmentRestProperty| with arguments _value_ and _excludedNames_.\n        ",
      {
        "normalizedName" : "ObjectAssignmentPattern[1,0].DestructuringAssignmentEvaluation",
        "name" : "ObjectAssignmentPattern[1,0].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ObjectAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentRestProperty"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2772,
    [
      "INTRINSICS.yet:`Promise.any`RejectElementFunction",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _F_ be the active function object.\n            1. If _F_.[[AlreadyCalled]] is *true*, return *undefined*.\n            1. Set _F_.[[AlreadyCalled]] to *true*.\n            1. Let _index_ be _F_.[[Index]].\n            1. Let _errors_ be _F_.[[Errors]].\n            1. Let _promiseCapability_ be _F_.[[Capability]].\n            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].\n            1. Set _errors_[_index_] to _x_.\n            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n            1. If _remainingElementsCount_.[[Value]] = 0, then\n              1. Let _error_ be a newly created *AggregateError* object.\n              1. Perform ! DefinePropertyOrThrow(_error_, *\"errors\"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }).\n              1. Return ? Call(_promiseCapability_.[[Reject]], *undefined*, « _error_ »).\n            1. Return *undefined*.\n          ",
      {
        "normalizedName" : "INTRINSICS.yet:Promise.anyRejectElementFunction",
        "name" : "INTRINSICS.yet:`Promise.any`RejectElementFunction",
        "htmlId" : "sec-promise.any-reject-element-functions",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    396,
    [
      "CaseBlock[1,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _names1_ be the VarDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be VarDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the VarDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,0].VarDeclaredNames",
        "name" : "CaseBlock[1,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1526,
    [
      "SwitchStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[SwitchStatement[0]]"
        ]
      ],
      "\n        1. Let _exprRef_ be ? Evaluation of |Expression|.\n        1. Let _switchValue_ be ? GetValue(_exprRef_).\n        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n        1. Perform BlockDeclarationInstantiation(|CaseBlock|, _blockEnv_).\n        1. Set the running execution context's LexicalEnvironment to _blockEnv_.\n        1. Let _R_ be Completion(CaseBlockEvaluation of |CaseBlock| with argument _switchValue_).\n        1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n        1. Return _R_.\n      ",
      {
        "normalizedName" : "SwitchStatement[0,0].Evaluation",
        "name" : "SwitchStatement[0,0].Evaluation",
        "htmlId" : "sec-switch-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SwitchStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "switch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2137,
    [
      "INTRINSICS.Math.cosh",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is *NaN*, return *NaN*.\n          1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of the hyperbolic cosine of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.cosh",
        "name" : "INTRINSICS.Math.cosh",
        "htmlId" : "sec-math.cosh",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    89,
    [
      "ThrowCompletion",
      0,
      [
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Return Completion Record { [[Type]]: ~throw~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n        ",
      {
        "normalizedName" : "ThrowCompletion",
        "name" : "ThrowCompletion",
        "htmlId" : "sec-throwcompletion",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1351,
    [
      "UnaryExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[1]]"
        ]
      ],
      "\n          1. Let _ref_ be ? Evaluation of |UnaryExpression|.\n          1. If _ref_ is not a Reference Record, return *true*.\n          1. If IsUnresolvableReference(_ref_) is *true*, then\n            1. Assert: _ref_.[[Strict]] is *false*.\n            1. Return *true*.\n          1. If IsPropertyReference(_ref_) is *true*, then\n            1. Assert: IsPrivateReference(_ref_) is *false*.\n            1. If IsSuperReference(_ref_) is *true*, throw a *ReferenceError* exception.\n            1. [id=\"step-delete-operator-toobject\"] Let _baseObj_ be ? ToObject(_ref_.[[Base]]).\n            1. Let _deleteStatus_ be ? <emu-meta effects=\"user-code\">_baseObj_.[[Delete]]</emu-meta>(_ref_.[[ReferencedName]]).\n            1. If _deleteStatus_ is *false* and _ref_.[[Strict]] is *true*, throw a *TypeError* exception.\n            1. Return _deleteStatus_.\n          1. Else,\n            1. Let _base_ be _ref_.[[Base]].\n            1. Assert: _base_ is an Environment Record.\n            1. Return ? <emu-meta effects=\"user-code\">_base_.DeleteBinding</emu-meta>(_ref_.[[ReferencedName]]).\n        ",
      {
        "normalizedName" : "UnaryExpression[1,0].Evaluation",
        "name" : "UnaryExpression[1,0].Evaluation",
        "htmlId" : "sec-delete-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "delete"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    133,
    [
      "ToUint32",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n        1. Let _int_ be truncate(ℝ(_number_)).\n        1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.\n        1. [id=\"step-touint32-return\"] Return 𝔽(_int32bit_).\n      ",
      {
        "normalizedName" : "ToUint32",
        "name" : "ToUint32",
        "htmlId" : "sec-touint32",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2002,
    [
      "ModuleItem[0,0].ExportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ModuleItem[0,0].ExportEntries",
        "name" : "ModuleItem[0,0].ExportEntries",
        "htmlId" : "sec-static-semantics-exportentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntries",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    998,
    [
      "MethodDefinition[4,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[4]]"
        ]
      ],
      "\n        1. Return PropName of |ClassElementName|.\n      ",
      {
        "normalizedName" : "MethodDefinition[4,0].PropName",
        "name" : "MethodDefinition[4,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "get"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2809,
    [
      "AsyncGeneratorStart:clo0",
      6,
      [
      ],
      "\n          1. Assert: _generator_.[[AsyncGeneratorState]] is *undefined*.\n          1. Let _genContext_ be the running execution context.\n          1. Set the Generator component of _genContext_ to _generator_.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:\n            1. Let _acGenContext_ be the running execution context.\n            1. Let _acGenerator_ be the Generator component of _acGenContext_.\n            1. If _generatorBody_ is a Parse Node, then\n              1. Let _result_ be Completion(Evaluation of _generatorBody_).\n            1. Else,\n              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.\n              1. Let _result_ be Completion(_generatorBody_()).\n            1. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.\n            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. Set _acGenerator_.[[AsyncGeneratorState]] to ~completed~.\n            1. If _result_ is a normal completion, set _result_ to NormalCompletion(*undefined*).\n            1. If _result_ is a return completion, set _result_ to NormalCompletion(_result_.[[Value]]).\n            1. Perform AsyncGeneratorCompleteStep(_acGenerator_, _result_, *true*).\n            1. Perform AsyncGeneratorDrainQueue(_acGenerator_).\n            1. Return *undefined*.\n          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Set _generator_.[[AsyncGeneratorContext]] to _genContext_.\n          1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-start~.\n          1. Set _generator_.[[AsyncGeneratorQueue]] to a new empty List.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncGeneratorStart",
        "name" : "AsyncGeneratorStart",
        "htmlId" : "sec-asyncgeneratorstart",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2242,
    [
      "INTRINSICS.String.prototype.codePointAt",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).\n          1. Let _size_ be the length of _S_.\n          1. If _position_ < 0 or _position_ ≥ _size_, return *undefined*.\n          1. Let _cp_ be CodePointAt(_S_, _position_).\n          1. Return 𝔽(_cp_.[[CodePoint]]).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.codePointAt",
        "name" : "INTRINSICS.String.prototype.codePointAt",
        "htmlId" : "sec-string.prototype.codepointat",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    411,
    [
      "FunctionStatementList[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,0].VarDeclaredNames",
        "name" : "FunctionStatementList[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1345,
    [
      "NewTarget[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[NewTarget[0]]"
        ]
      ],
      "\n          1. Return GetNewTarget().\n        ",
      {
        "normalizedName" : "NewTarget[0,0].Evaluation",
        "name" : "NewTarget[0,0].Evaluation",
        "htmlId" : "sec-meta-properties-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NewTarget",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "terminal",
                "value" : "target"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    988,
    [
      "AssignmentExpression[8,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[8]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "AssignmentExpression[8,0].AssignmentTargetType",
        "name" : "AssignmentExpression[8,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "??="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2799,
    [
      "GeneratorResumeAbrupt:cont0",
      7,
      [
        [
          "result",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).\n          1. If _state_ is ~suspended-start~, then\n            1. Set _generator_.[[GeneratorState]] to ~completed~.\n            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.\n            1. Set _state_ to ~completed~.\n          1. If _state_ is ~completed~, then\n            1. If _abruptCompletion_ is a return completion, then\n              1. Return CreateIterResultObject(_abruptCompletion_.[[Value]], *true*).\n            1. Return ? _abruptCompletion_.\n          1. Assert: _state_ is ~suspended-yield~.\n          1. Let _genContext_ be _generator_.[[GeneratorContext]].\n          1. Let _methodContext_ be the running execution context.\n          1. Suspend _methodContext_.\n          1. Set _generator_.[[GeneratorState]] to ~executing~.\n          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _genContext_</emu-meta> using _abruptCompletion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.\n          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.\n          1. Return ? _result_.\n        ",
      {
        "normalizedName" : "GeneratorResumeAbrupt",
        "name" : "GeneratorResumeAbrupt",
        "htmlId" : "sec-generatorresumeabrupt",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : true,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2286,
    [
      "ClassEscape[1,0].IsCharacterClass",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassEscape[1]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ClassEscape[1,0].IsCharacterClass",
        "name" : "ClassEscape[1,0].IsCharacterClass",
        "htmlId" : "sec-patterns-static-semantics-is-character-class",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsCharacterClass",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "-"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2639,
    [
      "GetValueFromBuffer",
      0,
      [
        [
          "arrayBuffer",
          false,
          "Record[ArrayBuffer | SharedArrayBuffer]"
        ],
        [
          "byteIndex",
          false,
          "Int[0+]"
        ],
        [
          "type",
          false,
          "Unknown[\"TypedArrayElementType\"]"
        ],
        [
          "isTypedArray",
          false,
          "Boolean"
        ],
        [
          "order",
          false,
          "Enum[~seq-cst~, ~unordered~]"
        ],
        [
          "isLittleEndian",
          true,
          "Boolean"
        ]
      ],
      "\n          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.\n          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.\n          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then\n            1. Assert: _block_ is a Shared Data Block.\n            1. Let _rawValue_ be GetRawBytesFromSharedBlock(_block_, _byteIndex_, _type_, _isTypedArray_, _order_).\n          1. Else,\n            1. Let _rawValue_ be a List whose elements are bytes from _block_ at indices in the interval from _byteIndex_ (inclusive) to _byteIndex_ + _elementSize_ (exclusive).\n          1. Assert: The number of elements in _rawValue_ is _elementSize_.\n          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n          1. Return RawBytesToNumeric(_type_, _rawValue_, _isLittleEndian_).\n        ",
      {
        "normalizedName" : "GetValueFromBuffer",
        "name" : "GetValueFromBuffer",
        "htmlId" : "sec-getvaluefrombuffer",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2750,
    [
      "INTRINSICS.yet:PromiseResolveFunction",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _F_ be the active function object.\n            1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.\n            1. Let _promise_ be _F_.[[Promise]].\n            1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].\n            1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.\n            1. Set _alreadyResolved_.[[Value]] to *true*.\n            1. If SameValue(_resolution_, _promise_) is *true*, then\n              1. Let _selfResolutionError_ be a newly created *TypeError* object.\n              1. Perform RejectPromise(_promise_, _selfResolutionError_).\n              1. Return *undefined*.\n            1. If _resolution_ is not an Object, then\n              1. Perform FulfillPromise(_promise_, _resolution_).\n              1. Return *undefined*.\n            1. Let _then_ be Completion(Get(_resolution_, *\"then\"*)).\n            1. If _then_ is an abrupt completion, then\n              1. Perform RejectPromise(_promise_, _then_.[[Value]]).\n              1. Return *undefined*.\n            1. Let _thenAction_ be _then_.[[Value]].\n            1. If IsCallable(_thenAction_) is *false*, then\n              1. Perform FulfillPromise(_promise_, _resolution_).\n              1. Return *undefined*.\n            1. Let _thenJobCallback_ be HostMakeJobCallback(_thenAction_).\n            1. Let _job_ be NewPromiseResolveThenableJob(_promise_, _resolution_, _thenJobCallback_).\n            1. Perform HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]).\n            1. Return *undefined*.\n          ",
      {
        "normalizedName" : "INTRINSICS.yet:PromiseResolveFunction",
        "name" : "INTRINSICS.yet:PromiseResolveFunction",
        "htmlId" : "sec-promise-resolve-functions",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    243,
    [
      "FormalParameterList[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameterList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be BoundNames of |FormalParameterList|.\n        1. Let _names2_ be BoundNames of |FormalParameter|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "FormalParameterList[1,0].BoundNames",
        "name" : "FormalParameterList[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FormalParameterList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameterList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1405,
    [
      "AssignmentPropertyList[1,0].PropertyDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentPropertyList[1]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _propertyNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.\n          1. Let _nextNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentProperty| with argument _value_.\n          1. Return the list-concatenation of _propertyNames_ and _nextNames_.\n        ",
      {
        "normalizedName" : "AssignmentPropertyList[1,0].PropertyDestructuringAssignmentEvaluation",
        "name" : "AssignmentPropertyList[1,0].PropertyDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-propertydestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AssignmentPropertyList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AssignmentPropertyList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    116,
    [
      "StringNumericLiteral[1,1].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StringNumericLiteral[1]]"
        ]
      ],
      "\n            1. Return StringNumericValue of |StrNumericLiteral|.\n          ",
      {
        "normalizedName" : "StringNumericLiteral[1,1].StringNumericValue",
        "name" : "StringNumericLiteral[1,1].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "StringNumericLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StrNumericLiteral"
              },
              {
                "type" : "nonterminal",
                "value" : "StrWhiteSpace"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2103,
    [
      "INTRINSICS.Error.prototype.toString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. If _O_ is not an Object, throw a *TypeError* exception.\n          1. Let _name_ be ? Get(_O_, *\"name\"*).\n          1. If _name_ is *undefined*, set _name_ to *\"Error\"*; otherwise set _name_ to ? ToString(_name_).\n          1. Let _msg_ be ? Get(_O_, *\"message\"*).\n          1. If _msg_ is *undefined*, set _msg_ to the empty String; otherwise set _msg_ to ? ToString(_msg_).\n          1. If _name_ is the empty String, return _msg_.\n          1. If _msg_ is the empty String, return _name_.\n          1. Return the string-concatenation of _name_, the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and _msg_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Error.prototype.toString",
        "name" : "INTRINSICS.Error.prototype.toString",
        "htmlId" : "sec-error.prototype.tostring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1943,
    [
      "ParseModule",
      0,
      [
        [
          "sourceText",
          false,
          "Unknown[\"ECMAScriptSourceText\"]"
        ],
        [
          "realm",
          false,
          "Record[RealmRecord]"
        ],
        [
          "hostDefined",
          false,
          "Unknown[\"Anything\"]"
        ]
      ],
      "\n            1. Let _body_ be ParseText(_sourceText_, |Module|).\n            1. If _body_ is a List of errors, return _body_.\n            1. Let _requestedModules_ be the ModuleRequests of _body_.\n            1. Let _importEntries_ be ImportEntries of _body_.\n            1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).\n            1. Let _indirectExportEntries_ be a new empty List.\n            1. Let _localExportEntries_ be a new empty List.\n            1. Let _starExportEntries_ be a new empty List.\n            1. Let _exportEntries_ be ExportEntries of _body_.\n            1. For each ExportEntry Record _ee_ of _exportEntries_, do\n              1. If _ee_.[[ModuleRequest]] is *null*, then\n                1. If _importedBoundNames_ does not contain _ee_.[[LocalName]], then\n                  1. Append _ee_ to _localExportEntries_.\n                1. Else,\n                  1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is _ee_.[[LocalName]].\n                  1. If _ie_.[[ImportName]] is ~namespace-object~, then\n                    1. NOTE: This is a re-export of an imported module namespace object.\n                    1. Append _ee_ to _localExportEntries_.\n                  1. Else,\n                    1. NOTE: This is a re-export of a single name.\n                    1. Append the ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.\n              1. Else if _ee_.[[ImportName]] is ~all-but-default~, then\n                1. Assert: _ee_.[[ExportName]] is *null*.\n                1. Append _ee_ to _starExportEntries_.\n              1. Else,\n                1. Append _ee_ to _indirectExportEntries_.\n            1. Let _async_ be _body_ Contains `await`.\n            1. Return Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluation]]: *false*, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: « », [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[LoadedModules]]: « », [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSIndex]]: ~empty~, [[DFSAncestorIndex]]: ~empty~ }.\n          ",
      {
        "normalizedName" : "ParseModule",
        "name" : "ParseModule",
        "htmlId" : "sec-parsemodule",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    428,
    [
      "Statement[13,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[13]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[13,0].VarScopedDeclarations",
        "name" : "Statement[13,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 13,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DebuggerStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1201,
    [
      "Record[ProxyExoticObject].OwnPropertyKeys",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"ownKeys\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[OwnPropertyKeys]]()</emu-meta>.\n        1. Let _trapResultArray_ be ? Call(_trap_, _handler_, « _target_ »).\n        1. Let _trapResult_ be ? CreateListFromArrayLike(_trapResultArray_, « String, Symbol »).\n        1. If _trapResult_ contains any duplicate entries, throw a *TypeError* exception.\n        1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n        1. Let _targetKeys_ be ? <emu-meta effects=\"user-code\">_target_.[[OwnPropertyKeys]]()</emu-meta>.\n        1. Assert: _targetKeys_ is a List of property keys.\n        1. Assert: _targetKeys_ contains no duplicate entries.\n        1. Let _targetConfigurableKeys_ be a new empty List.\n        1. Let _targetNonconfigurableKeys_ be a new empty List.\n        1. For each element _key_ of _targetKeys_, do\n          1. Let _desc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_key_).\n          1. If _desc_ is not *undefined* and _desc_.[[Configurable]] is *false*, then\n            1. Append _key_ to _targetNonconfigurableKeys_.\n          1. Else,\n            1. Append _key_ to _targetConfigurableKeys_.\n        1. If _extensibleTarget_ is *true* and _targetNonconfigurableKeys_ is empty, then\n          1. Return _trapResult_.\n        1. Let _uncheckedResultKeys_ be a List whose elements are the elements of _trapResult_.\n        1. For each element _key_ of _targetNonconfigurableKeys_, do\n          1. If _uncheckedResultKeys_ does not contain _key_, throw a *TypeError* exception.\n          1. Remove _key_ from _uncheckedResultKeys_.\n        1. If _extensibleTarget_ is *true*, return _trapResult_.\n        1. For each element _key_ of _targetConfigurableKeys_, do\n          1. If _uncheckedResultKeys_ does not contain _key_, throw a *TypeError* exception.\n          1. Remove _key_ from _uncheckedResultKeys_.\n        1. If _uncheckedResultKeys_ is not empty, throw a *TypeError* exception.\n        1. Return _trapResult_.\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].OwnPropertyKeys",
        "name" : "Record[ProxyExoticObject].OwnPropertyKeys",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[OwnPropertyKeys]]"
        ]
      }
    ]
  ],
  [
    2804,
    [
      "Yield",
      0,
      [
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _generatorKind_ be GetGeneratorKind().\n          1. If _generatorKind_ is ~async~, return ? AsyncGeneratorYield(? Await(_value_)).\n          1. Otherwise, return ? GeneratorYield(CreateIterResultObject(_value_, *false*)).\n        ",
      {
        "normalizedName" : "Yield",
        "name" : "Yield",
        "htmlId" : "sec-yield",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1,
    [
      "BigInt::leftShift",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. If _y_ < *0*<sub>ℤ</sub>, then\n              1. Return ℤ(floor(ℝ(_x_) / 2<sup>-ℝ(_y_)</sup>)).\n            1. Return _x_ × *2*<sub>ℤ</sub><sup>_y_</sup>.\n          ",
      {
        "normalizedName" : "BigInt::leftShift",
        "name" : "BigInt::leftShift",
        "htmlId" : "sec-numeric-types-bigint-leftShift",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1104,
    [
      "OrdinaryDelete",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. If _desc_ is *undefined*, return *true*.\n          1. If _desc_.[[Configurable]] is *true*, then\n            1. Remove the own property with name _P_ from _O_.\n            1. Return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "OrdinaryDelete",
        "name" : "OrdinaryDelete",
        "htmlId" : "sec-ordinarydelete",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1697,
    [
      "MethodDefinition[5,0].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[5]]"
        ]
      ],
      "\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      ",
      {
        "normalizedName" : "MethodDefinition[5,0].PrivateBoundIdentifiers",
        "name" : "MethodDefinition[5,0].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "set"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "PropertySetParameterList"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1242,
    [
      "Literal[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Literal[0]]"
        ]
      ],
      "\n          1. Return *null*.\n        ",
      {
        "normalizedName" : "Literal[0,0].Evaluation",
        "name" : "Literal[0,0].Evaluation",
        "htmlId" : "sec-literals-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Literal",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NullLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    265,
    [
      "ExportDeclaration[4,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[4]]"
        ]
      ],
      "\n        1. Let _declarationNames_ be the BoundNames of |HoistableDeclaration|.\n        1. If _declarationNames_ does not include the element *\"\\*default\\*\"*, append *\"\\*default\\*\"* to _declarationNames_.\n        1. Return _declarationNames_.\n      ",
      {
        "normalizedName" : "ExportDeclaration[4,0].BoundNames",
        "name" : "ExportDeclaration[4,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "HoistableDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    849,
    [
      "AsyncArrowFunction[1,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowFunction[1]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.\n        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n        1. If _head_ Contains _symbol_ is *true*, return *true*.\n        1. Return |AsyncConciseBody| Contains _symbol_.\n      ",
      {
        "normalizedName" : "AsyncArrowFunction[1,0].Contains",
        "name" : "AsyncArrowFunction[1,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncArrowFunction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverCallExpressionAndAsyncArrowHead"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2392,
    [
      "ClassAtom[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassAtom[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return the CharSet containing the single character `-` U+002D (HYPHEN-MINUS).\n        ",
      {
        "normalizedName" : "ClassAtom[0,0].CompileToCharSet",
        "name" : "ClassAtom[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassAtom",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "-"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2154,
    [
      "INTRINSICS.Math.sinh",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n          1. Return an implementation-approximated Number value representing the result of the hyperbolic sine of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.sinh",
        "name" : "INTRINSICS.Math.sinh",
        "htmlId" : "sec-math.sinh",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1521,
    [
      "CaseBlock[1,0].CaseBlockEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "input",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _V_ be *undefined*.\n        1. If the first |CaseClauses| is present, then\n          1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _A_ be a new empty List.\n        1. Let _found_ be *false*.\n        1. For each |CaseClause| _C_ of _A_, do\n          1. If _found_ is *false*, then\n            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n          1. If _found_ is *true*, then\n            1. Let _R_ be Completion(Evaluation of _C_).\n            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n            1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Let _foundInB_ be *false*.\n        1. If the second |CaseClauses| is present, then\n          1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _B_ be a new empty List.\n        1. If _found_ is *false*, then\n          1. For each |CaseClause| _C_ of _B_, do\n            1. If _foundInB_ is *false*, then\n              1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).\n            1. If _foundInB_ is *true*, then\n              1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n              1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n              1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. If _foundInB_ is *true*, return _V_.\n        1. Let _defaultR_ be Completion(Evaluation of |DefaultClause|).\n        1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].\n        1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).\n        1. NOTE: The following is another complete iteration of the second |CaseClauses|.\n        1. For each |CaseClause| _C_ of _B_, do\n          1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n          1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n          1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Return _V_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,0].CaseBlockEvaluation",
        "name" : "CaseBlock[1,0].CaseBlockEvaluation",
        "htmlId" : "sec-runtime-semantics-caseblockevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CaseBlockEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    527,
    [
      "ForStatement[0,1].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,1].ContainsDuplicateLabels",
        "name" : "ForStatement[0,1].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    312,
    [
      "AsyncConciseBody[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncConciseBody[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "AsyncConciseBody[0,0].LexicallyDeclaredNames",
        "name" : "AsyncConciseBody[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    74,
    [
      "BigInt::remainder",
      1,
      [
        [
          "n",
          false,
          "BigInt"
        ],
        [
          "d",
          false,
          "BigInt"
        ]
      ],
      "\n            1. If _d_ is *0*<sub>ℤ</sub>, throw a *RangeError* exception.\n            1. If _n_ is *0*<sub>ℤ</sub>, return *0*<sub>ℤ</sub>.\n            1. Let _quotient_ be ℝ(_n_) / ℝ(_d_).\n            1. Let _q_ be ℤ(truncate(_quotient_)).\n            1. Return _n_ - (_d_ × _q_).\n          ",
      {
        "normalizedName" : "BigInt::remainder",
        "name" : "BigInt::remainder",
        "htmlId" : "sec-numeric-types-bigint-remainder",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2718,
    [
      "INTRINSICS.Atomics.load",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).\n        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).\n        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n        1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n        1. Return GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.load",
        "name" : "INTRINSICS.Atomics.load",
        "htmlId" : "sec-atomics.load",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2205,
    [
      "INTRINSICS.Date.prototype.getUTCMinutes",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return MinFromTime(_t_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getUTCMinutes",
        "name" : "INTRINSICS.Date.prototype.getUTCMinutes",
        "htmlId" : "sec-date.prototype.getutcminutes",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1696,
    [
      "MethodDefinition[4,0].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[4]]"
        ]
      ],
      "\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      ",
      {
        "normalizedName" : "MethodDefinition[4,0].PrivateBoundIdentifiers",
        "name" : "MethodDefinition[4,0].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "get"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    206,
    [
      "IteratorToList",
      0,
      [
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n        1. Let _values_ be a new empty List.\n        1. Repeat,\n          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is ~done~, then\n            1. Return _values_.\n          1. Append _next_ to _values_.\n      ",
      {
        "normalizedName" : "IteratorToList",
        "name" : "IteratorToList",
        "htmlId" : "sec-iteratortolist",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2586,
    [
      "INTRINSICS.Map",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Map.prototype%\"*, « [[MapData]] »).\n          1. Set _map_.[[MapData]] to a new empty List.\n          1. If _iterable_ is either *undefined* or *null*, return _map_.\n          1. Let _adder_ be ? Get(_map_, *\"set\"*).\n          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.\n          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Map",
        "name" : "INTRINSICS.Map",
        "htmlId" : "sec-map-iterable",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1975,
    [
      "ExportDeclaration[3,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[3]]"
        ]
      ],
      "\n          1. Return the BoundNames of |Declaration|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[3,0].ExportedBindings",
        "name" : "ExportDeclaration[3,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1564,
    [
      "ArrayBindingPattern[2,2].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[2]]"
        ]
      ],
      "\n        1. Return ContainsExpression of |BindingElementList|.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[2,2].ContainsExpression",
        "name" : "ArrayBindingPattern[2,2].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 2,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1863,
    [
      "CallExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CallExpression[1,0].HasCallInTailPosition",
        "name" : "CallExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SuperCall"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2011,
    [
      "ExportFromClause[0,0].ExportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportFromClause[0]]"
        ],
        [
          "module",
          false,
          "String | Null"
        ]
      ],
      "\n          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all-but-default~, [[LocalName]]: *null*, [[ExportName]]: *null* }.\n          1. Return « _entry_ ».\n        ",
      {
        "normalizedName" : "ExportFromClause[0,0].ExportEntriesForModule",
        "name" : "ExportFromClause[0,0].ExportEntriesForModule",
        "htmlId" : "sec-static-semantics-exportentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportFromClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "*"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    292,
    [
      "StatementListItem[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[0]]"
        ]
      ],
      "\n        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return LexicallyDeclaredNames of |LabelledStatement|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "StatementListItem[0,0].LexicallyDeclaredNames",
        "name" : "StatementListItem[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2204,
    [
      "INTRINSICS.Date.prototype.getUTCMilliseconds",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return msFromTime(_t_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getUTCMilliseconds",
        "name" : "INTRINSICS.Date.prototype.getUTCMilliseconds",
        "htmlId" : "sec-date.prototype.getutcmilliseconds",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2118,
    [
      "INTRINSICS.BigInt",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is not *undefined*, throw a *TypeError* exception.\n          1. Let _prim_ be ? ToPrimitive(_value_, ~number~).\n          1. If _prim_ is a Number, return ? NumberToBigInt(_prim_).\n          1. Otherwise, return ? <emu-meta suppress-effects=\"user-code\">ToBigInt(_prim_)</emu-meta>.\n        ",
      {
        "normalizedName" : "INTRINSICS.BigInt",
        "name" : "INTRINSICS.BigInt",
        "htmlId" : "sec-bigint-constructor-number-value",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    810,
    [
      "MemberExpression[5,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[5]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[5,0].IsIdentifierRef",
        "name" : "MemberExpression[5,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MetaProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1338,
    [
      "ImportCall[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportCall[0]]"
        ]
      ],
      "\n          1. Let _referrer_ be GetActiveScriptOrModule().\n          1. If _referrer_ is *null*, set _referrer_ to the current Realm Record.\n          1. Let _argRef_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _specifier_ be ? GetValue(_argRef_).\n          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n          1. Let _specifierString_ be Completion(ToString(_specifier_)).\n          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).\n          1. Perform HostLoadImportedModule(_referrer_, _specifierString_, ~empty~, _promiseCapability_).\n          1. Return _promiseCapability_.[[Promise]].\n        ",
      {
        "normalizedName" : "ImportCall[0,0].Evaluation",
        "name" : "ImportCall[0,0].Evaluation",
        "htmlId" : "sec-import-call-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ImportCall",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "import"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    381,
    [
      "ForStatement[2,1].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[2,1].VarDeclaredNames",
        "name" : "ForStatement[2,1].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2047,
    [
      "ObjectDefineProperties",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "Properties",
          false,
          "ESValue"
        ]
      ],
      "\n            1. Let _props_ be ? ToObject(_Properties_).\n            1. Let _keys_ be ? <emu-meta effects=\"user-code\">_props_.[[OwnPropertyKeys]]()</emu-meta>.\n            1. Let _descriptors_ be a new empty List.\n            1. For each element _nextKey_ of _keys_, do\n              1. Let _propDesc_ be ? <emu-meta effects=\"user-code\">_props_.[[GetOwnProperty]]</emu-meta>(_nextKey_).\n              1. If _propDesc_ is not *undefined* and _propDesc_.[[Enumerable]] is *true*, then\n                1. Let _descObj_ be ? Get(_props_, _nextKey_).\n                1. Let _desc_ be ? ToPropertyDescriptor(_descObj_).\n                1. Append the Record { [[Key]]: _nextKey_, [[Descriptor]]: _desc_ } to _descriptors_.\n            1. For each element _property_ of _descriptors_, do\n              1. Perform ? DefinePropertyOrThrow(_O_, _property_.[[Key]], _property_.[[Descriptor]]).\n            1. Return _O_.\n          ",
      {
        "normalizedName" : "ObjectDefineProperties",
        "name" : "ObjectDefineProperties",
        "htmlId" : "sec-objectdefineproperties",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    307,
    [
      "FunctionStatementList[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,0].LexicallyDeclaredNames",
        "name" : "FunctionStatementList[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1651,
    [
      "GeneratorExpression[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return InstantiateGeneratorFunctionExpression of |GeneratorExpression|.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,0].Evaluation",
        "name" : "GeneratorExpression[0,0].Evaluation",
        "htmlId" : "sec-generator-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1074,
    [
      "InitializeHostDefinedRealm",
      0,
      [
      ],
      "\n      1. Let _realm_ be CreateRealm().\n      1. Let _newContext_ be a new execution context.\n      1. Set the Function of _newContext_ to *null*.\n      1. Set the Realm of _newContext_ to _realm_.\n      1. Set the ScriptOrModule of _newContext_ to *null*.\n      1. Push _newContext_ onto the execution context stack; _newContext_ is now the running execution context.\n      1. If the host requires use of an exotic object to serve as _realm_'s global object, let _global_ be such an object created in a host-defined manner. Otherwise, let _global_ be *undefined*, indicating that an ordinary object should be created as the global object.\n      1. If the host requires that the `this` binding in _realm_'s global scope return an object other than the global object, let _thisValue_ be such an object created in a host-defined manner. Otherwise, let _thisValue_ be *undefined*, indicating that _realm_'s global `this` binding should be the global object.\n      1. Perform SetRealmGlobalObject(_realm_, _global_, _thisValue_).\n      1. Let _globalObj_ be ? SetDefaultGlobalBindings(_realm_).\n      1. Create any host-defined global object properties on _globalObj_.\n      1. Return ~unused~.\n    ",
      {
        "normalizedName" : "InitializeHostDefinedRealm",
        "name" : "InitializeHostDefinedRealm",
        "htmlId" : "sec-initializehostdefinedrealm",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1604,
    [
      "FormalParameterList[0,0].ExpectedArgumentCount",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameterList[0]]"
        ]
      ],
      "\n        1. If HasInitializer of |FormalParameter| is *true*, return 0.\n        1. Return 1.\n      ",
      {
        "normalizedName" : "FormalParameterList[0,0].ExpectedArgumentCount",
        "name" : "FormalParameterList[0,0].ExpectedArgumentCount",
        "htmlId" : "sec-static-semantics-expectedargumentcount",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExpectedArgumentCount",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FormalParameterList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1206,
    [
      "UTF16EncodeCodePoint",
      0,
      [
        [
          "cp",
          false,
          "Unknown[\"UnicodeCodePoint\"]"
        ]
      ],
      "\n        1. Assert: 0 ≤ _cp_ ≤ 0x10FFFF.\n        1. If _cp_ ≤ 0xFFFF, return the String value consisting of the code unit whose numeric value is _cp_.\n        1. Let _cu1_ be the code unit whose numeric value is floor((_cp_ - 0x10000) / 0x400) + 0xD800.\n        1. Let _cu2_ be the code unit whose numeric value is ((_cp_ - 0x10000) modulo 0x400) + 0xDC00.\n        1. Return the string-concatenation of _cu1_ and _cu2_.\n      ",
      {
        "normalizedName" : "UTF16EncodeCodePoint",
        "name" : "UTF16EncodeCodePoint",
        "htmlId" : "sec-utf16encodecodepoint",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    6,
    [
      "HostGetImportMetaProperties",
      0,
      [
        [
          "moduleRecord",
          false,
          "Record[ModuleRecord]"
        ]
      ],
      "",
      null
    ]
  ],
  [
    233,
    [
      "BindingProperty[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingProperty[1]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingElement|.\n      ",
      {
        "normalizedName" : "BindingProperty[1,0].BoundNames",
        "name" : "BindingProperty[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingProperty",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PropertyName"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    452,
    [
      "ForStatement[2,2].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[2,2].VarScopedDeclarations",
        "name" : "ForStatement[2,2].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    920,
    [
      "MemberExpression[7,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[7]]"
        ]
      ],
      "\n        1. Return ~simple~.\n      ",
      {
        "normalizedName" : "MemberExpression[7,0].AssignmentTargetType",
        "name" : "MemberExpression[7,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    248,
    [
      "AsyncGeneratorDeclaration[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorDeclaration[1]]"
        ]
      ],
      "\n        1. Return « *\"\\*default\\*\"* ».\n      ",
      {
        "normalizedName" : "AsyncGeneratorDeclaration[1,0].BoundNames",
        "name" : "AsyncGeneratorDeclaration[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncGeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    60,
    [
      "Number::signedRightShift",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. Let _lnum_ be ! ToInt32(_x_).\n            1. Let _rnum_ be ! ToUint32(_y_).\n            1. Let _shiftCount_ be ℝ(_rnum_) modulo 32.\n            1. Return the result of performing a sign-extending right shift of _lnum_ by _shiftCount_ bits. The most significant bit is propagated. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.\n          ",
      {
        "normalizedName" : "Number::signedRightShift",
        "name" : "Number::signedRightShift",
        "htmlId" : "sec-numeric-types-number-signedRightShift",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    380,
    [
      "ForStatement[2,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[2,0].VarDeclaredNames",
        "name" : "ForStatement[2,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    117,
    [
      "StringNumericLiteral[1,2].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StringNumericLiteral[1]]"
        ]
      ],
      "\n            1. Return StringNumericValue of |StrNumericLiteral|.\n          ",
      {
        "normalizedName" : "StringNumericLiteral[1,2].StringNumericValue",
        "name" : "StringNumericLiteral[1,2].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "StringNumericLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StrWhiteSpace"
              },
              {
                "type" : "nonterminal",
                "value" : "StrNumericLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    512,
    [
      "Statement[2,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[2,0].ContainsDuplicateLabels",
        "name" : "Statement[2,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EmptyStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    942,
    [
      "ImportMeta[0,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportMeta[0]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "ImportMeta[0,0].AssignmentTargetType",
        "name" : "ImportMeta[0,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ImportMeta",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "import"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "terminal",
                "value" : "meta"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    439,
    [
      "ForStatement[0,1].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,1].VarScopedDeclarations",
        "name" : "ForStatement[0,1].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    678,
    [
      "ForInOfStatement[8,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[8]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForInOfStatement[8,0].ContainsUndefinedContinueTarget",
        "name" : "ForInOfStatement[8,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2473,
    [
      "MakeMatchIndicesIndexPairArray",
      0,
      [
        [
          "S",
          false,
          "String"
        ],
        [
          "indices",
          false,
          "List[Record[MatchRecord] | Undefined]"
        ],
        [
          "groupNames",
          false,
          "List[String | Undefined]"
        ],
        [
          "hasGroups",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Let _n_ be the number of elements in _indices_.\n          1. Assert: _n_ < 2<sup>32</sup> - 1.\n          1. Assert: _groupNames_ has _n_ - 1 elements.\n          1. NOTE: The _groupNames_ List contains elements aligned with the _indices_ List starting at _indices_[1].\n          1. Let _A_ be ! ArrayCreate(_n_).\n          1. If _hasGroups_ is *true*, then\n            1. Let _groups_ be OrdinaryObjectCreate(*null*).\n          1. Else,\n            1. Let _groups_ be *undefined*.\n          1. Perform ! CreateDataPropertyOrThrow(_A_, *\"groups\"*, _groups_).\n          1. For each integer _i_ such that 0 ≤ _i_ < _n_, in ascending order, do\n            1. Let _matchIndices_ be _indices_[_i_].\n            1. If _matchIndices_ is not *undefined*, then\n              1. Let _matchIndexPair_ be GetMatchIndexPair(_S_, _matchIndices_).\n            1. Else,\n              1. Let _matchIndexPair_ be *undefined*.\n            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _matchIndexPair_).\n            1. If _i_ > 0 and _groupNames_[_i_ - 1] is not *undefined*, then\n              1. Assert: _groups_ is not *undefined*.\n              1. Perform ! CreateDataPropertyOrThrow(_groups_, _groupNames_[_i_ - 1], _matchIndexPair_).\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "MakeMatchIndicesIndexPairArray",
        "name" : "MakeMatchIndicesIndexPairArray",
        "htmlId" : "sec-makematchindicesindexpairarray",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    270,
    [
      "HoistableDeclaration[2,0].DeclarationPart",
      2,
      [
        [
          "this",
          false,
          "Ast[HoistableDeclaration[2]]"
        ]
      ],
      "\n        1. Return |AsyncFunctionDeclaration|.\n      ",
      {
        "normalizedName" : "HoistableDeclaration[2,0].DeclarationPart",
        "name" : "HoistableDeclaration[2,0].DeclarationPart",
        "htmlId" : "sec-static-semantics-declarationpart",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DeclarationPart",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "HoistableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    529,
    [
      "ForStatement[0,3].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,3].ContainsDuplicateLabels",
        "name" : "ForStatement[0,3].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1691,
    [
      "ClassElementName[0,0].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementName[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ClassElementName[0,0].PrivateBoundIdentifiers",
        "name" : "ClassElementName[0,0].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassElementName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PropertyName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2574,
    [
      "TypedArrayCreateSameType",
      0,
      [
        [
          "exemplar",
          false,
          "Record[TypedArray]"
        ],
        [
          "argumentList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Let _constructor_ be the intrinsic object associated with the constructor name _exemplar_.[[TypedArrayName]] in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref>.\n          1. Let _result_ be ? TypedArrayCreateFromConstructor(_constructor_, _argumentList_).\n          1. Assert: _result_ has [[TypedArrayName]] and [[ContentType]] internal slots.\n          1. Assert: _result_.[[ContentType]] is _exemplar_.[[ContentType]].\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "TypedArrayCreateSameType",
        "name" : "TypedArrayCreateSameType",
        "htmlId" : "sec-typedarray-create-same-type",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1438,
    [
      "VariableDeclarationList[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[VariableDeclarationList[1]]"
        ]
      ],
      "\n          1. Perform ? Evaluation of |VariableDeclarationList|.\n          1. Return ? Evaluation of |VariableDeclaration|.\n        ",
      {
        "normalizedName" : "VariableDeclarationList[1,0].Evaluation",
        "name" : "VariableDeclarationList[1,0].Evaluation",
        "htmlId" : "sec-variable-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "VariableDeclarationList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    661,
    [
      "ForStatement[0,7].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[0,7].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[0,7].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 7,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    546,
    [
      "ForInOfStatement[4,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[4]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[4,0].ContainsDuplicateLabels",
        "name" : "ForInOfStatement[4,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    793,
    [
      "PrimaryExpression[1,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[1]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[1,0].IsIdentifierRef",
        "name" : "PrimaryExpression[1,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierReference"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2646,
    [
      "INTRINSICS.get ArrayBuffer.prototype.byteLength",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>𝔽</sub>.\n          1. Let _length_ be _O_.[[ArrayBufferByteLength]].\n          1. Return 𝔽(_length_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get ArrayBuffer.prototype.byteLength",
        "name" : "INTRINSICS.get ArrayBuffer.prototype.byteLength",
        "htmlId" : "sec-get-arraybuffer.prototype.bytelength",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    925,
    [
      "PrimaryExpression[4,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[4]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "PrimaryExpression[4,0].AssignmentTargetType",
        "name" : "PrimaryExpression[4,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ObjectLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    85,
    [
      "BigInt::bitwiseAND",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. Return BigIntBitwiseOp(`&`, _x_, _y_).\n          ",
      {
        "normalizedName" : "BigInt::bitwiseAND",
        "name" : "BigInt::bitwiseAND",
        "htmlId" : "sec-numeric-types-bigint-bitwiseAND",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1306,
    [
      "EvaluatePropertyAccessWithExpressionKey",
      0,
      [
        [
          "baseValue",
          false,
          "ESValue"
        ],
        [
          "expression",
          false,
          "Ast[Expression]"
        ],
        [
          "strict",
          false,
          "Boolean"
        ]
      ],
      "\n        1. Let _propertyNameReference_ be ? Evaluation of _expression_.\n        1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).\n        1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).\n        1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.\n      ",
      {
        "normalizedName" : "EvaluatePropertyAccessWithExpressionKey",
        "name" : "EvaluatePropertyAccessWithExpressionKey",
        "htmlId" : "sec-evaluate-property-access-with-expression-key",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    201,
    [
      "IteratorClose",
      0,
      [
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "completion",
          false,
          "Completion"
        ]
      ],
      "\n        1. Assert: _iteratorRecord_.[[Iterator]] is an Object.\n        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].\n        1. Let _innerResult_ be Completion(GetMethod(_iterator_, *\"return\"*)).\n        1. If _innerResult_ is a normal completion, then\n          1. Let _return_ be _innerResult_.[[Value]].\n          1. If _return_ is *undefined*, return ? _completion_.\n          1. Set _innerResult_ to Completion(Call(_return_, _iterator_)).\n        1. If _completion_ is a throw completion, return ? _completion_.\n        1. If _innerResult_ is a throw completion, return ? _innerResult_.\n        1. If _innerResult_.[[Value]] is not an Object, throw a *TypeError* exception.\n        1. Return ? _completion_.\n      ",
      {
        "normalizedName" : "IteratorClose",
        "name" : "IteratorClose",
        "htmlId" : "sec-iteratorclose",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1199,
    [
      "Record[ProxyExoticObject].Set",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"set\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_).\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _V_, _Receiver_ »)).\n        1. If _booleanTrapResult_ is *false*, return *false*.\n        1. Let _targetDesc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. If _targetDesc_ is not *undefined* and _targetDesc_.[[Configurable]] is *false*, then\n          1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Writable]] is *false*, then\n            1. If SameValue(_V_, _targetDesc_.[[Value]]) is *false*, throw a *TypeError* exception.\n          1. If IsAccessorDescriptor(_targetDesc_) is *true*, then\n            1. If _targetDesc_.[[Set]] is *undefined*, throw a *TypeError* exception.\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].Set",
        "name" : "Record[ProxyExoticObject].Set",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[Set]]"
        ]
      }
    ]
  ],
  [
    2364,
    [
      "Quantifier[0,0].CompileQuantifier",
      2,
      [
        [
          "this",
          false,
          "Ast[Quantifier[0]]"
        ]
      ],
      "\n          1. Let _qp_ be CompileQuantifierPrefix of |QuantifierPrefix|.\n          1. Return the Record { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *true* }.\n        ",
      {
        "normalizedName" : "Quantifier[0,0].CompileQuantifier",
        "name" : "Quantifier[0,0].CompileQuantifier",
        "htmlId" : "sec-compilequantifier",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileQuantifier",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Quantifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "QuantifierPrefix"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2164,
    [
      "YearFromTime",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. [declared=\"y\"] Return the largest integral Number _y_ (closest to +∞) such that TimeFromYear(_y_) ≤ _t_.\n        ",
      {
        "normalizedName" : "YearFromTime",
        "name" : "YearFromTime",
        "htmlId" : "sec-yearfromtime",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1153,
    [
      "Record[ArgumentsExoticObject].Set",
      4,
      [
        [
          "args",
          false,
          "Record[ArgumentsExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If SameValue(_args_, _Receiver_) is *false*, then\n            1. Let _isMapped_ be *false*.\n          1. Else,\n            1. Let _map_ be _args_.[[ParameterMap]].\n            1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n          1. If _isMapped_ is *true*, then\n            1. Assert: The following Set will succeed, since formal parameters mapped by arguments objects are always writable.\n            1. Perform ! Set(_map_, _P_, _V_, *false*).\n          1. Return ? OrdinarySet(_args_, _P_, _V_, _Receiver_).\n        ",
      {
        "normalizedName" : "Record[ArgumentsExoticObject].Set",
        "name" : "Record[ArgumentsExoticObject].Set",
        "htmlId" : "sec-arguments-exotic-objects-set-p-v-receiver",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ArgumentsExoticObject",
          "[[Set]]"
        ]
      }
    ]
  ],
  [
    761,
    [
      "RelationalExpression[7,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[7]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[7,0].IsFunctionDefinition",
        "name" : "RelationalExpression[7,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1470,
    [
      "ForStatement[1,1].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Perform ? Evaluation of |VariableDeclarationList|.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        ",
      {
        "normalizedName" : "ForStatement[1,1].ForLoopEvaluation",
        "name" : "ForStatement[1,1].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1915,
    [
      "GlobalDeclarationInstantiation",
      0,
      [
        [
          "script",
          false,
          "Ast[Script]"
        ],
        [
          "env",
          false,
          "Record[GlobalEnvironmentRecord]"
        ]
      ],
      "\n        1. Let _lexNames_ be the LexicallyDeclaredNames of _script_.\n        1. Let _varNames_ be the VarDeclaredNames of _script_.\n        1. For each element _name_ of _lexNames_, do\n          1. If _env_.HasVarDeclaration(_name_) is *true*, throw a *SyntaxError* exception.\n          1. If _env_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.\n          1. Let _hasRestrictedGlobal_ be ? _env_.HasRestrictedGlobalProperty(_name_).\n          1. If _hasRestrictedGlobal_ is *true*, throw a *SyntaxError* exception.\n        1. For each element _name_ of _varNames_, do\n          1. If _env_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.\n        1. Let _varDeclarations_ be the VarScopedDeclarations of _script_.\n        1. Let _functionsToInitialize_ be a new empty List.\n        1. Let _declaredFunctionNames_ be a new empty List.\n        1. For each element _d_ of _varDeclarations_, in reverse List order, do\n          1. If _d_ is not either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then\n            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.\n            1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.\n            1. Let _fn_ be the sole element of the BoundNames of _d_.\n            1. If _declaredFunctionNames_ does not contain _fn_, then\n              1. Let _fnDefinable_ be ? _env_.CanDeclareGlobalFunction(_fn_).\n              1. If _fnDefinable_ is *false*, throw a *TypeError* exception.\n              1. Append _fn_ to _declaredFunctionNames_.\n              1. Insert _d_ as the first element of _functionsToInitialize_.\n        1. Let _declaredVarNames_ be a new empty List.\n        1. For each element _d_ of _varDeclarations_, do\n          1. If _d_ is either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then\n            1. For each String _vn_ of the BoundNames of _d_, do\n              1. If _declaredFunctionNames_ does not contain _vn_, then\n                1. Let _vnDefinable_ be ? _env_.CanDeclareGlobalVar(_vn_).\n                1. If _vnDefinable_ is *false*, throw a *TypeError* exception.\n                1. If _declaredVarNames_ does not contain _vn_, then\n                  1. Append _vn_ to _declaredVarNames_.\n        1. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.\n        1. [id=\"step-globaldeclarationinstantiation-web-compat-insertion-point\"] NOTE: Annex <emu-xref href=\"#sec-web-compat-globaldeclarationinstantiation\"></emu-xref> adds additional steps at this point.\n        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _script_.\n        1. Let _privateEnv_ be *null*.\n        1. For each element _d_ of _lexDeclarations_, do\n          1. NOTE: Lexically declared names are only instantiated here but not initialized.\n          1. For each element _dn_ of the BoundNames of _d_, do\n            1. If IsConstantDeclaration of _d_ is *true*, then\n              1. Perform ? <emu-meta effects=\"user-code\">_env_.CreateImmutableBinding</emu-meta>(_dn_, *true*).\n            1. Else,\n              1. Perform ? <emu-meta effects=\"user-code\">_env_.CreateMutableBinding</emu-meta>(_dn_, *false*).\n        1. For each Parse Node _f_ of _functionsToInitialize_, do\n          1. Let _fn_ be the sole element of the BoundNames of _f_.\n          1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _env_ and _privateEnv_.\n          1. Perform ? <emu-meta effects=\"user-code\">_env_.CreateGlobalFunctionBinding</emu-meta>(_fn_, _fo_, *false*).\n        1. For each String _vn_ of _declaredVarNames_, do\n          1. Perform ? <emu-meta effects=\"user-code\">_env_.CreateGlobalVarBinding</emu-meta>(_vn_, *false*).\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "GlobalDeclarationInstantiation",
        "name" : "GlobalDeclarationInstantiation",
        "htmlId" : "sec-globaldeclarationinstantiation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1708,
    [
      "GeneratorDeclaration[1,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorDeclaration[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "GeneratorDeclaration[1,0].ContainsArguments",
        "name" : "GeneratorDeclaration[1,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "GeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2093,
    [
      "INTRINSICS.Symbol.for",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _stringKey_ be ? ToString(_key_).\n          1. For each element _e_ of the GlobalSymbolRegistry List, do\n            1. If SameValue(_e_.[[Key]], _stringKey_) is *true*, return _e_.[[Symbol]].\n          1. Assert: GlobalSymbolRegistry does not currently contain an entry for _stringKey_.\n          1. Let _newSymbol_ be a new Symbol whose [[Description]] is _stringKey_.\n          1. Append the Record { [[Key]]: _stringKey_, [[Symbol]]: _newSymbol_ } to the GlobalSymbolRegistry List.\n          1. Return _newSymbol_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Symbol.for",
        "name" : "INTRINSICS.Symbol.for",
        "htmlId" : "sec-symbol.for",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1783,
    [
      "IfStatement[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "IfStatement[1,0].HasCallInTailPosition",
        "name" : "IfStatement[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2737,
    [
      "INTRINSICS.FinalizationRegistry",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. If IsCallable(_cleanupCallback_) is *false*, throw a *TypeError* exception.\n          1. Let _finalizationRegistry_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%FinalizationRegistry.prototype%\"*, « [[Realm]], [[CleanupCallback]], [[Cells]] »).\n          1. Let _fn_ be the active function object.\n          1. Set _finalizationRegistry_.[[Realm]] to _fn_.[[Realm]].\n          1. Set _finalizationRegistry_.[[CleanupCallback]] to HostMakeJobCallback(_cleanupCallback_).\n          1. Set _finalizationRegistry_.[[Cells]] to a new empty List.\n          1. Return _finalizationRegistry_.\n        ",
      {
        "normalizedName" : "INTRINSICS.FinalizationRegistry",
        "name" : "INTRINSICS.FinalizationRegistry",
        "htmlId" : "sec-finalization-registry-cleanup-callback",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    220,
    [
      "ObjectBindingPattern[3,1].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectBindingPattern[3]]"
        ]
      ],
      "\n        1. Let _names1_ be BoundNames of |BindingPropertyList|.\n        1. Let _names2_ be BoundNames of |BindingRestProperty|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ObjectBindingPattern[3,1].BoundNames",
        "name" : "ObjectBindingPattern[3,1].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 1,
            "astName" : "ObjectBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingPropertyList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestProperty"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    366,
    [
      "DoWhileStatement[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[DoWhileStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "DoWhileStatement[0,0].VarDeclaredNames",
        "name" : "DoWhileStatement[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DoWhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "do"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1311,
    [
      "CallExpression[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[0]]"
        ]
      ],
      "\n          1. Let _expr_ be the |CallMemberExpression| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n          1. Let _memberExpr_ be the |MemberExpression| of _expr_.\n          1. Let _arguments_ be the |Arguments| of _expr_.\n          1. Let _ref_ be ? Evaluation of _memberExpr_.\n          1. Let _func_ be ? GetValue(_ref_).\n          1. If _ref_ is a Reference Record, IsPropertyReference(_ref_) is *false*, and _ref_.[[ReferencedName]] is *\"eval\"*, then\n            1. If SameValue(_func_, %eval%) is *true*, then\n              1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.\n              1. If _argList_ has no elements, return *undefined*.\n              1. Let _evalArg_ be the first element of _argList_.\n              1. If the source text matched by this |CallExpression| is strict mode code, let _strictCaller_ be *true*. Otherwise let _strictCaller_ be *false*.\n              1. [id=\"step-callexpression-evaluation-direct-eval\"] Return ? PerformEval(_evalArg_, _strictCaller_, *true*).\n          1. Let _thisCall_ be this |CallExpression|.\n          1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n          1. Return ? EvaluateCall(_func_, _ref_, _arguments_, _tailCall_).\n        ",
      {
        "normalizedName" : "CallExpression[0,0].Evaluation",
        "name" : "CallExpression[0,0].Evaluation",
        "htmlId" : "sec-function-calls-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverCallExpressionAndAsyncArrowHead"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    534,
    [
      "ForStatement[1,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[1,0].ContainsDuplicateLabels",
        "name" : "ForStatement[1,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2232,
    [
      "INTRINSICS.Date.prototype.toUTCString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _tv_ be _dateObject_.[[DateValue]].\n          1. If _tv_ is *NaN*, return *\"Invalid Date\"*.\n          1. Let _weekday_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-day-names\"></emu-xref> with the Number WeekDay(_tv_).\n          1. Let _month_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-month-names\"></emu-xref> with the Number MonthFromTime(_tv_).\n          1. Let _day_ be ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2).\n          1. Let _yv_ be YearFromTime(_tv_).\n          1. If _yv_ is *+0*<sub>𝔽</sub> or _yv_ > *+0*<sub>𝔽</sub>, let _yearSign_ be the empty String; otherwise, let _yearSign_ be *\"-\"*.\n          1. Let _paddedYear_ be ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4).\n          1. Return the string-concatenation of _weekday_, *\",\"*, the code unit 0x0020 (SPACE), _day_, the code unit 0x0020 (SPACE), _month_, the code unit 0x0020 (SPACE), _yearSign_, _paddedYear_, the code unit 0x0020 (SPACE), and TimeString(_tv_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.toUTCString",
        "name" : "INTRINSICS.Date.prototype.toUTCString",
        "htmlId" : "sec-date.prototype.toutcstring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2296,
    [
      "CharacterEscape[3,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterEscape[3]]"
        ]
      ],
      "\n          1. Return the MV of |HexEscapeSequence|.\n        ",
      {
        "normalizedName" : "CharacterEscape[3,0].CharacterValue",
        "name" : "CharacterEscape[3,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "CharacterEscape",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "HexEscapeSequence"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2307,
    [
      "CharacterClassEscape[0,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[0]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "CharacterClassEscape[0,0].MayContainStrings",
        "name" : "CharacterClassEscape[0,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "d"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2641,
    [
      "SetValueInBuffer",
      0,
      [
        [
          "arrayBuffer",
          false,
          "Record[ArrayBuffer | SharedArrayBuffer]"
        ],
        [
          "byteIndex",
          false,
          "Int[0+]"
        ],
        [
          "type",
          false,
          "Unknown[\"TypedArrayElementType\"]"
        ],
        [
          "value",
          false,
          "Number | BigInt"
        ],
        [
          "isTypedArray",
          false,
          "Boolean"
        ],
        [
          "order",
          false,
          "Enum[~init~, ~seq-cst~, ~unordered~]"
        ],
        [
          "isLittleEndian",
          true,
          "Boolean"
        ]
      ],
      "\n          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.\n          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.\n          1. Assert: _value_ is a BigInt if IsBigIntElementType(_type_) is *true*; otherwise, _value_ is a Number.\n          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n          1. Let _rawBytes_ be NumericToRawBytes(_type_, _value_, _isLittleEndian_).\n          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then\n            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n            1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n            1. If _isTypedArray_ is *true* and IsNoTearConfiguration(_type_, _order_) is *true*, let _noTear_ be *true*; otherwise let _noTear_ be *false*.\n            1. Append WriteSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_ } to _eventsRecord_.[[EventList]].\n          1. Else,\n            1. Store the individual bytes of _rawBytes_ into _block_, starting at _block_[_byteIndex_].\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "SetValueInBuffer",
        "name" : "SetValueInBuffer",
        "htmlId" : "sec-setvalueinbuffer",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    102,
    [
      "IsGenericDescriptor",
      0,
      [
        [
          "Desc",
          false,
          "Record[PropertyDescriptor] | Undefined"
        ]
      ],
      "\n          1. If _Desc_ is *undefined*, return *false*.\n          1. If IsAccessorDescriptor(_Desc_) is *true*, return *false*.\n          1. If IsDataDescriptor(_Desc_) is *true*, return *false*.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "IsGenericDescriptor",
        "name" : "IsGenericDescriptor",
        "htmlId" : "sec-isgenericdescriptor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2083,
    [
      "CreateDynamicFunction",
      0,
      [
        [
          "constructor",
          false,
          "Record[Constructor]"
        ],
        [
          "newTarget",
          false,
          "Record[Constructor]"
        ],
        [
          "kind",
          false,
          "Enum[~async-generator~, ~async~, ~generator~, ~normal~]"
        ],
        [
          "parameterArgs",
          false,
          "List[ESValue]"
        ],
        [
          "bodyArg",
          false,
          "ESValue"
        ]
      ],
      "\n            1. If _newTarget_ is *undefined*, set _newTarget_ to _constructor_.\n            1. If _kind_ is ~normal~, then\n              1. Let _prefix_ be *\"function\"*.\n              1. Let _exprSym_ be the grammar symbol |FunctionExpression|.\n              1. Let _bodySym_ be the grammar symbol |FunctionBody[~Yield, ~Await]|.\n              1. Let _parameterSym_ be the grammar symbol |FormalParameters[~Yield, ~Await]|.\n              1. Let _fallbackProto_ be *\"%Function.prototype%\"*.\n            1. Else if _kind_ is ~generator~, then\n              1. Let _prefix_ be *\"function\\*\"*.\n              1. Let _exprSym_ be the grammar symbol |GeneratorExpression|.\n              1. Let _bodySym_ be the grammar symbol |GeneratorBody|.\n              1. Let _parameterSym_ be the grammar symbol |FormalParameters[+Yield, ~Await]|.\n              1. Let _fallbackProto_ be *\"%GeneratorFunction.prototype%\"*.\n            1. Else if _kind_ is ~async~, then\n              1. Let _prefix_ be *\"async function\"*.\n              1. Let _exprSym_ be the grammar symbol |AsyncFunctionExpression|.\n              1. Let _bodySym_ be the grammar symbol |AsyncFunctionBody|.\n              1. Let _parameterSym_ be the grammar symbol |FormalParameters[~Yield, +Await]|.\n              1. Let _fallbackProto_ be *\"%AsyncFunction.prototype%\"*.\n            1. Else,\n              1. Assert: _kind_ is ~async-generator~.\n              1. Let _prefix_ be *\"async function\\*\"*.\n              1. Let _exprSym_ be the grammar symbol |AsyncGeneratorExpression|.\n              1. Let _bodySym_ be the grammar symbol |AsyncGeneratorBody|.\n              1. Let _parameterSym_ be the grammar symbol |FormalParameters[+Yield, +Await]|.\n              1. Let _fallbackProto_ be *\"%AsyncGeneratorFunction.prototype%\"*.\n            1. Let _argCount_ be the number of elements in _parameterArgs_.\n            1. Let _parameterStrings_ be a new empty List.\n            1. For each element _arg_ of _parameterArgs_, do\n              1. Append ? ToString(_arg_) to _parameterStrings_.\n            1. Let _bodyString_ be ? ToString(_bodyArg_).\n            1. Let _currentRealm_ be the current Realm Record.\n            1. Perform ? HostEnsureCanCompileStrings(_currentRealm_, _parameterStrings_, _bodyString_, *false*).\n            1. Let _P_ be the empty String.\n            1. If _argCount_ > 0, then\n              1. Set _P_ to _parameterStrings_[0].\n              1. Let _k_ be 1.\n              1. Repeat, while _k_ < _argCount_,\n                1. Let _nextArgString_ be _parameterStrings_[_k_].\n                1. Set _P_ to the string-concatenation of _P_, *\",\"* (a comma), and _nextArgString_.\n                1. Set _k_ to _k_ + 1.\n            1. Let _bodyParseString_ be the string-concatenation of 0x000A (LINE FEED), _bodyString_, and 0x000A (LINE FEED).\n            1. Let _sourceString_ be the string-concatenation of _prefix_, *\" anonymous(\"*, _P_, 0x000A (LINE FEED), *\") {\"*, _bodyParseString_, and *\"}\"*.\n            1. Let _sourceText_ be StringToCodePoints(_sourceString_).\n            1. Let _parameters_ be ParseText(StringToCodePoints(_P_), _parameterSym_).\n            1. If _parameters_ is a List of errors, throw a *SyntaxError* exception.\n            1. Let _body_ be ParseText(StringToCodePoints(_bodyParseString_), _bodySym_).\n            1. If _body_ is a List of errors, throw a *SyntaxError* exception.\n            1. NOTE: The parameters and body are parsed separately to ensure that each is valid alone. For example, `new Function(\"/*\", \"*/ ) {\")` does not evaluate to a function.\n            1. NOTE: If this step is reached, _sourceText_ must have the syntax of _exprSym_ (although the reverse implication does not hold). The purpose of the next two steps is to enforce any Early Error rules which apply to _exprSym_ directly.\n            1. Let _expr_ be ParseText(_sourceText_, _exprSym_).\n            1. If _expr_ is a List of errors, throw a *SyntaxError* exception.\n            1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _fallbackProto_).\n            1. Let _env_ be _currentRealm_.[[GlobalEnv]].\n            1. Let _privateEnv_ be *null*.\n            1. Let _F_ be OrdinaryFunctionCreate(_proto_, _sourceText_, _parameters_, _body_, ~non-lexical-this~, _env_, _privateEnv_).\n            1. Perform SetFunctionName(_F_, *\"anonymous\"*).\n            1. If _kind_ is ~generator~, then\n              1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n              1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n            1. Else if _kind_ is ~async-generator~, then\n              1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n              1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n            1. Else if _kind_ is ~normal~, then\n              1. Perform MakeConstructor(_F_).\n            1. NOTE: Functions whose _kind_ is ~async~ are not constructible and do not have a [[Construct]] internal method or a *\"prototype\"* property.\n            1. Return _F_.\n          ",
      {
        "normalizedName" : "CreateDynamicFunction",
        "name" : "CreateDynamicFunction",
        "htmlId" : "sec-createdynamicfunction",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1067,
    [
      "ResolveBinding",
      0,
      [
        [
          "name",
          false,
          "String"
        ],
        [
          "env",
          true,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. If _env_ is not present or _env_ is *undefined*, then\n          1. Set _env_ to the running execution context's LexicalEnvironment.\n        1. Assert: _env_ is an Environment Record.\n        1. If the source text matched by the syntactic production that is being evaluated is contained in strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n        1. Return ? GetIdentifierReference(_env_, _name_, _strict_).\n      ",
      {
        "normalizedName" : "ResolveBinding",
        "name" : "ResolveBinding",
        "htmlId" : "sec-resolvebinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1736,
    [
      "ClassTail[0,0].ClassDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassTail[0]]"
        ],
        [
          "classBinding",
          false,
          "String | Undefined"
        ],
        [
          "className",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.\n        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n        1. If |ClassBody| is present, then\n          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do\n            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then\n              1. Assert: This is only possible for getter/setter pairs.\n            1. Else,\n              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.\n              1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n        1. If |ClassHeritage| is not present, then\n          1. Let _protoParent_ be %Object.prototype%.\n          1. Let _constructorParent_ be %Function.prototype%.\n        1. Else,\n          1. Set the running execution context's LexicalEnvironment to _classEnv_.\n          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).\n          1. Set the running execution context's LexicalEnvironment to _env_.\n          1. Let _superclass_ be ? GetValue(? _superclassRef_).\n          1. If _superclass_ is *null*, then\n            1. Let _protoParent_ be *null*.\n            1. Let _constructorParent_ be %Function.prototype%.\n          1. Else if IsConstructor(_superclass_) is *false*, then\n            1. Throw a *TypeError* exception.\n          1. Else,\n            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.\n            1. Let _constructorParent_ be _superclass_.\n        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n        1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n        1. Set the running execution context's LexicalEnvironment to _classEnv_.\n        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.\n        1. If _constructor_ is ~empty~, then\n          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n            1. If NewTarget is *undefined*, throw a *TypeError* exception.\n            1. Let _F_ be the active function object.\n            1. If _F_.[[ConstructorKind]] is ~derived~, then\n              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n            1. Else,\n              1. NOTE: This branch behaves similarly to `constructor() {}`.\n              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n            1. Perform ? InitializeInstanceElements(_result_, _F_).\n            1. Return _result_.\n          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n        1. Else,\n          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n          1. Let _F_ be _constructorInfo_.[[Closure]].\n          1. Perform MakeClassConstructor(_F_).\n          1. Perform SetFunctionName(_F_, _className_).\n        1. Perform MakeConstructor(_F_, *false*, _proto_).\n        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n        1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n        1. If |ClassBody| is not present, let _elements_ be a new empty List.\n        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n        1. Let _instancePrivateMethods_ be a new empty List.\n        1. Let _staticPrivateMethods_ be a new empty List.\n        1. Let _instanceFields_ be a new empty List.\n        1. Let _staticElements_ be a new empty List.\n        1. For each |ClassElement| _e_ of _elements_, do\n          1. If IsStatic of _e_ is *false*, then\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n          1. Else,\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n          1. If _element_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _env_.\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _element_.\n          1. Set _element_ to ! _element_.\n          1. If _element_ is a PrivateElement, then\n            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n            1. Else, let _container_ be _staticPrivateMethods_.\n            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.\n              1. If _element_.[[Get]] is *undefined*, then\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n              1. Else,\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n              1. Replace _pe_ in _container_ with _combined_.\n            1. Else,\n              1. Append _element_ to _container_.\n          1. Else if _element_ is a ClassFieldDefinition Record, then\n            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n            1. Else, append _element_ to _staticElements_.\n          1. Else if _element_ is a ClassStaticBlockDefinition Record, then\n            1. Append _element_ to _staticElements_.\n        1. Set the running execution context's LexicalEnvironment to _env_.\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n        1. Set _F_.[[Fields]] to _instanceFields_.\n        1. For each PrivateElement _method_ of _staticPrivateMethods_, do\n          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n        1. For each element _elementRecord_ of _staticElements_, do\n          1. If _elementRecord_ is a ClassFieldDefinition Record, then\n            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n          1. Else,\n            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.\n            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n          1. If _result_ is an abrupt completion, then\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _result_.\n        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "ClassTail[0,0].ClassDefinitionEvaluation",
        "name" : "ClassTail[0,0].ClassDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-classdefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassTail",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2496,
    [
      "FlattenIntoArray",
      0,
      [
        [
          "target",
          false,
          "Record[Object]"
        ],
        [
          "source",
          false,
          "Record[Object]"
        ],
        [
          "sourceLen",
          false,
          "Int[0+]"
        ],
        [
          "start",
          false,
          "Int[0+]"
        ],
        [
          "depth",
          false,
          "Int[0+] | +INF"
        ],
        [
          "mapperFunction",
          true,
          "Record[FunctionObject]"
        ],
        [
          "thisArg",
          true,
          "ESValue"
        ]
      ],
      "\n            1. Assert: If _mapperFunction_ is present, then IsCallable(_mapperFunction_) is *true*, _thisArg_ is present, and _depth_ is 1.\n            1. Let _targetIndex_ be _start_.\n            1. Let _sourceIndex_ be *+0*<sub>𝔽</sub>.\n            1. Repeat, while ℝ(_sourceIndex_) < _sourceLen_,\n              1. Let _P_ be ! ToString(_sourceIndex_).\n              1. Let _exists_ be ? HasProperty(_source_, _P_).\n              1. If _exists_ is *true*, then\n                1. Let _element_ be ? Get(_source_, _P_).\n                1. If _mapperFunction_ is present, then\n                  1. Set _element_ to ? Call(_mapperFunction_, _thisArg_, « _element_, _sourceIndex_, _source_ »).\n                1. Let _shouldFlatten_ be *false*.\n                1. If _depth_ > 0, then\n                  1. Set _shouldFlatten_ to ? IsArray(_element_).\n                1. If _shouldFlatten_ is *true*, then\n                  1. If _depth_ = +∞, let _newDepth_ be +∞.\n                  1. Else, let _newDepth_ be _depth_ - 1.\n                  1. Let _elementLen_ be ? LengthOfArrayLike(_element_).\n                  1. Set _targetIndex_ to ? FlattenIntoArray(_target_, _element_, _elementLen_, _targetIndex_, _newDepth_).\n                1. Else,\n                  1. If _targetIndex_ ≥ 2<sup>53</sup> - 1, throw a *TypeError* exception.\n                  1. Perform ? CreateDataPropertyOrThrow(_target_, ! ToString(𝔽(_targetIndex_)), _element_).\n                  1. Set _targetIndex_ to _targetIndex_ + 1.\n              1. Set _sourceIndex_ to _sourceIndex_ + *1*<sub>𝔽</sub>.\n            1. Return _targetIndex_.\n          ",
      {
        "normalizedName" : "FlattenIntoArray",
        "name" : "FlattenIntoArray",
        "htmlId" : "sec-flattenintoarray",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2621,
    [
      "INTRINSICS.WeakSet",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%WeakSet.prototype%\"*, « [[WeakSetData]] »).\n          1. Set _set_.[[WeakSetData]] to a new empty List.\n          1. If _iterable_ is either *undefined* or *null*, return _set_.\n          1. Let _adder_ be ? Get(_set_, *\"add\"*).\n          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.\n          1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).\n          1. Repeat,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is ~done~, return _set_.\n            1. Let _status_ be Completion(Call(_adder_, _set_, « _next_ »)).\n            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).\n        ",
      {
        "normalizedName" : "INTRINSICS.WeakSet",
        "name" : "INTRINSICS.WeakSet",
        "htmlId" : "sec-weakset-iterable",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2790,
    [
      "INTRINSICS.GeneratorFunction.prototype.prototype.next",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return ? GeneratorResume(*this* value, _value_, ~empty~).\n        ",
      {
        "normalizedName" : "INTRINSICS.GeneratorFunction.prototype.prototype.next",
        "name" : "INTRINSICS.GeneratorFunction.prototype.prototype.next",
        "htmlId" : "sec-generator.prototype.next",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2660,
    [
      "INTRINSICS.get SharedArrayBuffer.prototype.growable",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n          1. If IsFixedLengthArrayBuffer(_O_) is *false*, return *true*; otherwise return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.get SharedArrayBuffer.prototype.growable",
        "name" : "INTRINSICS.get SharedArrayBuffer.prototype.growable",
        "htmlId" : "sec-get-sharedarraybuffer.prototype.growable",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1768,
    [
      "Statement[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[1,0].HasCallInTailPosition",
        "name" : "Statement[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "VariableStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    714,
    [
      "GeneratorExpression[0,1].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,1].HasName",
        "name" : "GeneratorExpression[0,1].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1868,
    [
      "NewExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[NewExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "NewExpression[1,0].HasCallInTailPosition",
        "name" : "NewExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "NewExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "nonterminal",
                "value" : "NewExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2382,
    [
      "CharacterSetMatcher",
      0,
      [
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "A",
          false,
          "Record[CharSet]"
        ],
        [
          "invert",
          false,
          "Boolean"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n            1. If _rer_.[[UnicodeSets]] is *true*, then\n              1. Assert: _invert_ is *false*.\n              1. Assert: Every CharSetElement of _A_ consists of a single character.\n            1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_, _A_, _invert_, and _direction_ and performs the following steps when called:\n              1. Assert: _x_ is a MatchState.\n              1. Assert: _c_ is a MatcherContinuation.\n              1. Let _Input_ be _x_.[[Input]].\n              1. Let _e_ be _x_.[[EndIndex]].\n              1. If _direction_ is ~forward~, let _f_ be _e_ + 1.\n              1. Else, let _f_ be _e_ - 1.\n              1. Let _InputLength_ be the number of elements in _Input_.\n              1. If _f_ < 0 or _f_ > _InputLength_, return ~failure~.\n              1. Let _index_ be min(_e_, _f_).\n              1. Let _ch_ be the character _Input_[_index_].\n              1. Let _cc_ be Canonicalize(_rer_, _ch_).\n              1. If there exists a CharSetElement in _A_ containing exactly one character _a_ such that Canonicalize(_rer_, _a_) is _cc_, let _found_ be *true*. Otherwise, let _found_ be *false*.\n              1. If _invert_ is *false* and _found_ is *false*, return ~failure~.\n              1. If _invert_ is *true* and _found_ is *true*, return ~failure~.\n              1. Let _cap_ be _x_.[[Captures]].\n              1. Let _y_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }.\n              1. Return _c_(_y_).\n          ",
      {
        "normalizedName" : "CharacterSetMatcher",
        "name" : "CharacterSetMatcher",
        "htmlId" : "sec-runtime-semantics-charactersetmatcher-abstract-operation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2061,
    [
      "INTRINSICS.Object.is",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return SameValue(_value1_, _value2_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.is",
        "name" : "INTRINSICS.Object.is",
        "htmlId" : "sec-object.is",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2773,
    [
      "INTRINSICS.Promise.race",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the *this* value.\n          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).\n          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).\n          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).\n          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).\n          1. Let _result_ be Completion(PerformPromiseRace(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).\n          1. If _result_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Return ? _result_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.race",
        "name" : "INTRINSICS.Promise.race",
        "htmlId" : "sec-promise.race",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2000,
    [
      "Module[0,0].ExportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[Module[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "Module[0,0].ExportEntries",
        "name" : "Module[0,0].ExportEntries",
        "htmlId" : "sec-static-semantics-exportentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntries",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Module",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1636,
    [
      "MethodDefinition[3,0].SpecialMethod",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[3]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "MethodDefinition[3,0].SpecialMethod",
        "name" : "MethodDefinition[3,0].SpecialMethod",
        "htmlId" : "sec-static-semantics-specialmethod",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "SpecialMethod",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorMethod"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1047,
    [
      "Record[GlobalEnvironmentRecord].CanDeclareGlobalFunction",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ]
      ],
      "\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n            1. Let _existingProp_ be ? <emu-meta effects=\"user-code\">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_).\n            1. If _existingProp_ is *undefined*, return ? IsExtensible(_globalObject_).\n            1. If _existingProp_.[[Configurable]] is *true*, return *true*.\n            1. If IsDataDescriptor(_existingProp_) is *true* and _existingProp_ has attribute values { [[Writable]]: *true*, [[Enumerable]]: *true* }, return *true*.\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].CanDeclareGlobalFunction",
        "name" : "Record[GlobalEnvironmentRecord].CanDeclareGlobalFunction",
        "htmlId" : "sec-candeclareglobalfunction",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "CanDeclareGlobalFunction"
        ]
      }
    ]
  ],
  [
    1730,
    [
      "ClassElement[3,0].ClassElementEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[3]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Return ? ClassFieldDefinitionEvaluation of |FieldDefinition| with argument _object_.\n      ",
      {
        "normalizedName" : "ClassElement[3,0].ClassElementEvaluation",
        "name" : "ClassElement[3,0].ClassElementEvaluation",
        "htmlId" : "sec-static-semantics-classelementevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassElementEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "static"
              },
              {
                "type" : "nonterminal",
                "value" : "FieldDefinition"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    798,
    [
      "PrimaryExpression[5,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[5]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[5,0].IsIdentifierRef",
        "name" : "PrimaryExpression[5,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1057,
    [
      "NewFunctionEnvironment",
      0,
      [
        [
          "F",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "newTarget",
          false,
          "Record[Object] | Undefined"
        ]
      ],
      "\n          1. Let _env_ be a new Function Environment Record containing no bindings.\n          1. Set _env_.[[FunctionObject]] to _F_.\n          1. If _F_.[[ThisMode]] is ~lexical~, set _env_.[[ThisBindingStatus]] to ~lexical~.\n          1. Else, set _env_.[[ThisBindingStatus]] to ~uninitialized~.\n          1. Set _env_.[[NewTarget]] to _newTarget_.\n          1. Set _env_.[[OuterEnv]] to _F_.[[Environment]].\n          1. Return _env_.\n        ",
      {
        "normalizedName" : "NewFunctionEnvironment",
        "name" : "NewFunctionEnvironment",
        "htmlId" : "sec-newfunctionenvironment",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1163,
    [
      "Record[TypedArray].DefineOwnProperty",
      4,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Desc",
          false,
          "Record[PropertyDescriptor]"
        ]
      ],
      "\n          1. If _P_ is a String, then\n            1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n            1. If _numericIndex_ is not *undefined*, then\n              1. If IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *false*.\n              1. If _Desc_ has a [[Configurable]] field and _Desc_.[[Configurable]] is *false*, return *false*.\n              1. If _Desc_ has an [[Enumerable]] field and _Desc_.[[Enumerable]] is *false*, return *false*.\n              1. If IsAccessorDescriptor(_Desc_) is *true*, return *false*.\n              1. If _Desc_ has a [[Writable]] field and _Desc_.[[Writable]] is *false*, return *false*.\n              1. If _Desc_ has a [[Value]] field, perform ? TypedArraySetElement(_O_, _numericIndex_, _Desc_.[[Value]]).\n              1. Return *true*.\n          1. Return ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).\n        ",
      {
        "normalizedName" : "Record[TypedArray].DefineOwnProperty",
        "name" : "Record[TypedArray].DefineOwnProperty",
        "htmlId" : "sec-typedarray-defineownproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "TypedArray",
          "[[DefineOwnProperty]]"
        ]
      }
    ]
  ],
  [
    424,
    [
      "Statement[6,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[6]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[6,0].VarScopedDeclarations",
        "name" : "Statement[6,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ContinueStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2606,
    [
      "INTRINSICS.Set.prototype.clear",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n          1. For each element _e_ of _S_.[[SetData]], do\n            1. Replace the element of _S_.[[SetData]] whose value is _e_ with an element whose value is ~empty~.\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Set.prototype.clear",
        "name" : "INTRINSICS.Set.prototype.clear",
        "htmlId" : "sec-set.prototype.clear",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    429,
    [
      "Block[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Block[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Block[0,0].VarScopedDeclarations",
        "name" : "Block[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Block",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2528,
    [
      "CreateArrayIterator",
      0,
      [
        [
          "array",
          false,
          "Record[Object]"
        ],
        [
          "kind",
          false,
          "Enum[~key+value~, ~key~, ~value~]"
        ]
      ],
      "\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _kind_ and _array_ and performs the following steps when called:\n            1. Let _index_ be 0.\n            1. Repeat,\n              1. If _array_ has a [[TypedArrayName]] internal slot, then\n                1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_array_, ~seq-cst~).\n                1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n                1. Let _len_ be TypedArrayLength(_taRecord_).\n              1. Else,\n                1. Let _len_ be ? LengthOfArrayLike(_array_).\n              1. If _index_ ≥ _len_, return NormalCompletion(*undefined*).\n              1. Let _indexNumber_ be 𝔽(_index_).\n              1. If _kind_ is ~key~, then\n                1. Let _result_ be _indexNumber_.\n              1. Else,\n                1. Let _elementKey_ be ! ToString(_indexNumber_).\n                1. Let _elementValue_ be ? Get(_array_, _elementKey_).\n                1. If _kind_ is ~value~, then\n                  1. Let _result_ be _elementValue_.\n                1. Else,\n                  1. Assert: _kind_ is ~key+value~.\n                  1. Let _result_ be CreateArrayFromList(« _indexNumber_, _elementValue_ »).\n              1. Perform ? GeneratorYield(CreateIterResultObject(_result_, *false*)).\n              1. Set _index_ to _index_ + 1.\n          1. Return CreateIteratorFromClosure(_closure_, *\"%ArrayIteratorPrototype%\"*, %ArrayIteratorPrototype%).\n        ",
      {
        "normalizedName" : "CreateArrayIterator",
        "name" : "CreateArrayIterator",
        "htmlId" : "sec-createarrayiterator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1274,
    [
      "PropertyDefinition[4,0].PropertyDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyDefinition[4]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Let _exprValue_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _fromValue_ be ? GetValue(_exprValue_).\n          1. Let _excludedNames_ be a new empty List.\n          1. Perform ? CopyDataProperties(_object_, _fromValue_, _excludedNames_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "PropertyDefinition[4,0].PropertyDefinitionEvaluation",
        "name" : "PropertyDefinition[4,0].PropertyDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-propertydefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "PropertyDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "..."
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2441,
    [
      "RegExpCreate",
      0,
      [
        [
          "P",
          false,
          "ESValue"
        ],
        [
          "F",
          false,
          "String | Undefined"
        ]
      ],
      "\n          1. Let _obj_ be ! RegExpAlloc(%RegExp%).\n          1. Return ? RegExpInitialize(_obj_, _P_, _F_).\n        ",
      {
        "normalizedName" : "RegExpCreate",
        "name" : "RegExpCreate",
        "htmlId" : "sec-regexpcreate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2673,
    [
      "INTRINSICS.DataView.prototype.getBigUint64",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~biguint64~).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.getBigUint64",
        "name" : "INTRINSICS.DataView.prototype.getBigUint64",
        "htmlId" : "sec-dataview.prototype.getbiguint64",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2589,
    [
      "INTRINSICS.get Map[@@species]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return the *this* value.\n        ",
      {
        "normalizedName" : "INTRINSICS.get Map[@@species]",
        "name" : "INTRINSICS.get Map[@@species]",
        "htmlId" : "sec-get-map-@@species",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    334,
    [
      "LabelledItem[1,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[1]]"
        ]
      ],
      "\n        1. Return « |FunctionDeclaration| ».\n      ",
      {
        "normalizedName" : "LabelledItem[1,0].LexicallyScopedDeclarations",
        "name" : "LabelledItem[1,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2705,
    [
      "EnqueueResolveInAgentJob",
      0,
      [
        [
          "agentSignifier",
          false,
          "Unknown[\"AgentSignifier\"]"
        ],
        [
          "promiseCapability",
          false,
          "Record[PromiseCapabilityRecord]"
        ],
        [
          "resolution",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _resolveJob_ be a new Job Abstract Closure with no parameters that captures _agentSignifier_, _promiseCapability_, and _resolution_ and performs the following steps when called:\n            1. Assert: AgentSignifier() is _agentSignifier_.\n            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _resolution_ »).\n            1. Return ~unused~.\n          1. Let _realmInTargetAgent_ be ! GetFunctionRealm(_promiseCapability_.[[Resolve]]).\n          1. Assert: _agentSignifier_ is _realmInTargetAgent_.[[AgentSignifier]].\n          1. Perform HostEnqueueGenericJob(_resolveJob_, _realmInTargetAgent_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "EnqueueResolveInAgentJob",
        "name" : "EnqueueResolveInAgentJob",
        "htmlId" : "sec-enqueueresolveinagentjob",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2264,
    [
      "INTRINSICS.String.prototype.split",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. If _separator_ is neither *undefined* nor *null*, then\n            1. Let _splitter_ be ? GetMethod(_separator_, @@split).\n            1. If _splitter_ is not *undefined*, then\n              1. Return ? Call(_splitter_, _separator_, « _O_, _limit_ »).\n          1. Let _S_ be ? ToString(_O_).\n          1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1; else let _lim_ be ℝ(? ToUint32(_limit_)).\n          1. Let _R_ be ? ToString(_separator_).\n          1. If _lim_ = 0, then\n            1. Return CreateArrayFromList(« »).\n          1. If _separator_ is *undefined*, then\n            1. Return CreateArrayFromList(« _S_ »).\n          1. Let _separatorLength_ be the length of _R_.\n          1. If _separatorLength_ = 0, then\n            1. Let _head_ be the substring of _S_ from 0 to _lim_.\n            1. Let _codeUnits_ be a List consisting of the sequence of code units that are the elements of _head_.\n            1. Return CreateArrayFromList(_codeUnits_).\n          1. If _S_ is the empty String, return CreateArrayFromList(« _S_ »).\n          1. Let _substrings_ be a new empty List.\n          1. Let _i_ be 0.\n          1. Let _j_ be StringIndexOf(_S_, _R_, 0).\n          1. Repeat, while _j_ ≠ -1,\n            1. Let _T_ be the substring of _S_ from _i_ to _j_.\n            1. Append _T_ to _substrings_.\n            1. If the number of elements in _substrings_ is _lim_, return CreateArrayFromList(_substrings_).\n            1. Set _i_ to _j_ + _separatorLength_.\n            1. Set _j_ to StringIndexOf(_S_, _R_, _i_).\n          1. Let _T_ be the substring of _S_ from _i_.\n          1. Append _T_ to _substrings_.\n          1. Return CreateArrayFromList(_substrings_).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.split",
        "name" : "INTRINSICS.String.prototype.split",
        "htmlId" : "sec-string.prototype.split",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2409,
    [
      "ClassUnion[1,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassUnion[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of |ClassSetOperand| with argument _rer_.\n          1. If |ClassUnion| is present, then\n            1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.\n            1. Return the union of CharSets _A_ and _B_.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "ClassUnion[1,0].CompileToCharSet",
        "name" : "ClassUnion[1,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassUnion",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1387,
    [
      "AssignmentExpression[7,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[7]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |LeftHandSideExpression|.\n        1. [id=\"step-assignmentexpression-evaluation-lgcl-or-getvalue\"] Let _lval_ be ? GetValue(_lref_).\n        1. Let _lbool_ be ToBoolean(_lval_).\n        1. If _lbool_ is *true*, return _lval_.\n        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then\n          1. Let _rval_ be ? NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].\n        1. Else,\n          1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _rval_ be ? GetValue(_rref_).\n        1. [id=\"step-assignmentexpression-evaluation-lgcl-or-putvalue\"] Perform ? PutValue(_lref_, _rval_).\n        1. Return _rval_.\n      ",
      {
        "normalizedName" : "AssignmentExpression[7,0].Evaluation",
        "name" : "AssignmentExpression[7,0].Evaluation",
        "htmlId" : "sec-assignment-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "||="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1900,
    [
      "OptionalChain[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "OptionalChain[2,0].HasCallInTailPosition",
        "name" : "OptionalChain[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "?."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1723,
    [
      "AsyncGeneratorMethod[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorMethod[0]]"
        ]
      ],
      "\n        1. Return ContainsArguments of |ClassElementName|.\n      ",
      {
        "normalizedName" : "AsyncGeneratorMethod[0,0].ContainsArguments",
        "name" : "AsyncGeneratorMethod[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    910,
    [
      "AsyncArrowBindingIdentifier[0,0].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowBindingIdentifier[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _v_ be *undefined*.\n        1. Assert: _iteratorRecord_.[[Done]] is *false*.\n        1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n        1. If _next_ is not ~done~, then\n          1. Set _v_ to _next_.\n        1. Return ? BindingInitialization of |BindingIdentifier| with arguments _v_ and _environment_.\n      ",
      {
        "normalizedName" : "AsyncArrowBindingIdentifier[0,0].IteratorBindingInitialization",
        "name" : "AsyncArrowBindingIdentifier[0,0].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncArrowBindingIdentifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    957,
    [
      "MultiplicativeExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[MultiplicativeExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "MultiplicativeExpression[1,0].AssignmentTargetType",
        "name" : "MultiplicativeExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "MultiplicativeExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeOperator"
              },
              {
                "type" : "nonterminal",
                "value" : "ExponentiationExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1223,
    [
      "DecimalBigIntegerLiteral[1,1].NumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[DecimalBigIntegerLiteral[1]]"
        ]
      ],
      "\n          1. Let _n_ be the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.\n          1. Let _mv_ be (the MV of |NonZeroDigit| × 10<sup>_n_</sup>) plus the MV of |DecimalDigits|.\n          1. Return ℤ(_mv_).\n        ",
      {
        "normalizedName" : "DecimalBigIntegerLiteral[1,1].NumericValue",
        "name" : "DecimalBigIntegerLiteral[1,1].NumericValue",
        "htmlId" : "sec-numericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NumericValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "DecimalBigIntegerLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NonZeroDigit"
              },
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "nonterminal",
                "value" : "BigIntLiteralSuffix"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    894,
    [
      "ArrayBindingPattern[2,2].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[2]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.\n        1. Return ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[2,2].IteratorBindingInitialization",
        "name" : "ArrayBindingPattern[2,2].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 2,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    746,
    [
      "UnaryExpression[7,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[7]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[7,0].IsFunctionDefinition",
        "name" : "UnaryExpression[7,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "!"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1091,
    [
      "OrdinaryGetOwnProperty",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. If _O_ does not have an own property with key _P_, return *undefined*.\n          1. Let _D_ be a newly created Property Descriptor with no fields.\n          1. Let _X_ be _O_'s own property whose key is _P_.\n          1. If _X_ is a data property, then\n            1. Set _D_.[[Value]] to the value of _X_'s [[Value]] attribute.\n            1. Set _D_.[[Writable]] to the value of _X_'s [[Writable]] attribute.\n          1. Else,\n            1. Assert: _X_ is an accessor property.\n            1. Set _D_.[[Get]] to the value of _X_'s [[Get]] attribute.\n            1. Set _D_.[[Set]] to the value of _X_'s [[Set]] attribute.\n          1. Set _D_.[[Enumerable]] to the value of _X_'s [[Enumerable]] attribute.\n          1. Set _D_.[[Configurable]] to the value of _X_'s [[Configurable]] attribute.\n          1. Return _D_.\n        ",
      {
        "normalizedName" : "OrdinaryGetOwnProperty",
        "name" : "OrdinaryGetOwnProperty",
        "htmlId" : "sec-ordinarygetownproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2601,
    [
      "CreateMapIterator",
      0,
      [
        [
          "map",
          false,
          "ESValue"
        ],
        [
          "kind",
          false,
          "Enum[~key+value~, ~key~, ~value~]"
        ]
      ],
      "\n          1. Perform ? RequireInternalSlot(_map_, [[MapData]]).\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _map_ and _kind_ and performs the following steps when called:\n            1. Let _entries_ be _map_.[[MapData]].\n            1. Let _index_ be 0.\n            1. Let _numEntries_ be the number of elements in _entries_.\n            1. Repeat, while _index_ < _numEntries_,\n              1. Let _e_ be _entries_[_index_].\n              1. Set _index_ to _index_ + 1.\n              1. If _e_.[[Key]] is not ~empty~, then\n                1. If _kind_ is ~key~, then\n                  1. Let _result_ be _e_.[[Key]].\n                1. Else if _kind_ is ~value~, then\n                  1. Let _result_ be _e_.[[Value]].\n                1. Else,\n                  1. Assert: _kind_ is ~key+value~.\n                  1. Let _result_ be CreateArrayFromList(« _e_.[[Key]], _e_.[[Value]] »).\n                1. Perform ? GeneratorYield(CreateIterResultObject(_result_, *false*)).\n                1. NOTE: The number of elements in _entries_ may have increased while execution of this abstract operation was paused by Yield.\n                1. Set _numEntries_ to the number of elements in _entries_.\n            1. Return NormalCompletion(*undefined*).\n          1. Return CreateIteratorFromClosure(_closure_, *\"%MapIteratorPrototype%\"*, %MapIteratorPrototype%).\n        ",
      {
        "normalizedName" : "CreateMapIterator",
        "name" : "CreateMapIterator",
        "htmlId" : "sec-createmapiterator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2428,
    [
      "ClassSetCharacter[3,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSetCharacter[3]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return the CharSet containing the single character U+0008 (BACKSPACE).\n        ",
      {
        "normalizedName" : "ClassSetCharacter[3,0].CompileToCharSet",
        "name" : "ClassSetCharacter[3,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ClassSetCharacter",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "\\b"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2733,
    [
      "SerializeJSONArray",
      0,
      [
        [
          "state",
          false,
          "Record[JSONSerializationRecord]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If _state_.[[Stack]] contains _value_, throw a *TypeError* exception because the structure is cyclical.\n          1. Append _value_ to _state_.[[Stack]].\n          1. Let _stepback_ be _state_.[[Indent]].\n          1. Set _state_.[[Indent]] to the string-concatenation of _state_.[[Indent]] and _state_.[[Gap]].\n          1. Let _partial_ be a new empty List.\n          1. Let _len_ be ? LengthOfArrayLike(_value_).\n          1. Let _index_ be 0.\n          1. Repeat, while _index_ < _len_,\n            1. Let _strP_ be ? SerializeJSONProperty(_state_, ! ToString(𝔽(_index_)), _value_).\n            1. If _strP_ is *undefined*, then\n              1. Append *\"null\"* to _partial_.\n            1. Else,\n              1. Append _strP_ to _partial_.\n            1. Set _index_ to _index_ + 1.\n          1. If _partial_ is empty, then\n            1. Let _final_ be *\"[]\"*.\n          1. Else,\n            1. If _state_.[[Gap]] is the empty String, then\n              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.\n              1. Let _final_ be the string-concatenation of *\"[\"*, _properties_, and *\"]\"*.\n            1. Else,\n              1. Let _separator_ be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and _state_.[[Indent]].\n              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.\n              1. Let _final_ be the string-concatenation of *\"[\"*, the code unit 0x000A (LINE FEED), _state_.[[Indent]], _properties_, the code unit 0x000A (LINE FEED), _stepback_, and *\"]\"*.\n          1. Remove the last element of _state_.[[Stack]].\n          1. Set _state_.[[Indent]] to _stepback_.\n          1. Return _final_.\n        ",
      {
        "normalizedName" : "SerializeJSONArray",
        "name" : "SerializeJSONArray",
        "htmlId" : "sec-serializejsonarray",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    825,
    [
      "ClassExpression[0,0].NamedEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassExpression[0]]"
        ],
        [
          "name",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and _name_.\n        1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.\n        1. Return _value_.\n      ",
      {
        "normalizedName" : "ClassExpression[0,0].NamedEvaluation",
        "name" : "ClassExpression[0,0].NamedEvaluation",
        "htmlId" : "sec-runtime-semantics-namedevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NamedEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1343,
    [
      "MemberExpression[3,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[3]]"
        ]
      ],
      "\n          1. Let _tagRef_ be ? Evaluation of |MemberExpression|.\n          1. Let _tagFunc_ be ? GetValue(_tagRef_).\n          1. Let _thisCall_ be this |MemberExpression|.\n          1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n          1. Return ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_).\n        ",
      {
        "normalizedName" : "MemberExpression[3,0].Evaluation",
        "name" : "MemberExpression[3,0].Evaluation",
        "htmlId" : "sec-tagged-templates-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2560,
    [
      "SetTypedArrayFromArrayLike",
      0,
      [
        [
          "target",
          false,
          "Record[TypedArray]"
        ],
        [
          "targetOffset",
          false,
          "Int[0+] | +INF"
        ],
        [
          "source",
          false,
          "Unknown[\"ECMAScriptLanguageValue,ButNotATypedArray\"]"
        ]
      ],
      "\n            1. Let _targetRecord_ be MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~).\n            1. If IsTypedArrayOutOfBounds(_targetRecord_) is *true*, throw a *TypeError* exception.\n            1. Let _targetLength_ be TypedArrayLength(_targetRecord_).\n            1. Let _src_ be ? ToObject(_source_).\n            1. Let _srcLength_ be ? LengthOfArrayLike(_src_).\n            1. If _targetOffset_ = +∞, throw a *RangeError* exception.\n            1. If _srcLength_ + _targetOffset_ > _targetLength_, throw a *RangeError* exception.\n            1. Let _k_ be 0.\n            1. Repeat, while _k_ < _srcLength_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Let _value_ be ? Get(_src_, _Pk_).\n              1. Let _targetIndex_ be 𝔽(_targetOffset_ + _k_).\n              1. Perform ? TypedArraySetElement(_target_, _targetIndex_, _value_).\n              1. Set _k_ to _k_ + 1.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "SetTypedArrayFromArrayLike",
        "name" : "SetTypedArrayFromArrayLike",
        "htmlId" : "sec-settypedarrayfromarraylike",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2805,
    [
      "CreateIteratorFromClosure",
      0,
      [
        [
          "closure",
          false,
          "Clo"
        ],
        [
          "generatorBrand",
          false,
          "Enum[~empty~] | String"
        ],
        [
          "generatorPrototype",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. NOTE: _closure_ can contain uses of the Yield operation to yield an IteratorResult object.\n          1. Let _internalSlotsList_ be « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] ».\n          1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).\n          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.\n          1. Set _generator_.[[GeneratorState]] to *undefined*.\n          1. Let _callerContext_ be the running execution context.\n          1. Let _calleeContext_ be a new execution context.\n          1. Set the Function of _calleeContext_ to *null*.\n          1. Set the Realm of _calleeContext_ to the current Realm Record.\n          1. Set the ScriptOrModule of _calleeContext_ to _callerContext_'s ScriptOrModule.\n          1. If _callerContext_ is not already suspended, suspend _callerContext_.\n          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.\n          1. Perform GeneratorStart(_generator_, _closure_).\n          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n          1. Return _generator_.\n        ",
      {
        "normalizedName" : "CreateIteratorFromClosure",
        "name" : "CreateIteratorFromClosure",
        "htmlId" : "sec-createiteratorfromclosure",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2249,
    [
      "INTRINSICS.String.prototype.localeCompare",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _thatValue_ be ? ToString(_that_).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.localeCompare",
        "name" : "INTRINSICS.String.prototype.localeCompare",
        "htmlId" : "sec-string.prototype.localecompare",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1021,
    [
      "Record[ObjectEnvironmentRecord].SetMutableBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[ObjectEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "S",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n            1. Let _stillExists_ be ? HasProperty(_bindingObject_, _N_).\n            1. If _stillExists_ is *false* and _S_ is *true*, throw a *ReferenceError* exception.\n            1. Perform ? Set(_bindingObject_, _N_, _V_, _S_).\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[ObjectEnvironmentRecord].SetMutableBinding",
        "name" : "Record[ObjectEnvironmentRecord].SetMutableBinding",
        "htmlId" : "sec-object-environment-records-setmutablebinding-n-v-s",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ObjectEnvironmentRecord",
          "SetMutableBinding"
        ]
      }
    ]
  ],
  [
    778,
    [
      "AssignmentExpression[8,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[8]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[8,0].IsFunctionDefinition",
        "name" : "AssignmentExpression[8,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "??="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1042,
    [
      "Record[GlobalEnvironmentRecord].GetThisBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ]
      ],
      "\n            1. Return _envRec_.[[GlobalThisValue]].\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].GetThisBinding",
        "name" : "Record[GlobalEnvironmentRecord].GetThisBinding",
        "htmlId" : "sec-global-environment-records-getthisbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "GetThisBinding"
        ]
      }
    ]
  ],
  [
    952,
    [
      "UnaryExpression[5,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[5]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "UnaryExpression[5,0].AssignmentTargetType",
        "name" : "UnaryExpression[5,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "-"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2541,
    [
      "INTRINSICS.TypedArray.prototype.fill",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If _O_.[[ContentType]] is ~bigint~, set _value_ to ? ToBigInt(_value_).\n          1. Otherwise, set _value_ to ? ToNumber(_value_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _startIndex_ be 0.\n          1. Else if _relativeStart_ < 0, let _startIndex_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _startIndex_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _endIndex_ be 0.\n          1. Else if _relativeEnd_ < 0, let _endIndex_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _endIndex_ be min(_relativeEnd_, _len_).\n          1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n          1. Set _len_ to TypedArrayLength(_taRecord_).\n          1. Set _endIndex_ to min(_endIndex_, _len_).\n          1. Let _k_ be _startIndex_.\n          1. Repeat, while _k_ < _endIndex_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Perform ! Set(_O_, _Pk_, _value_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.fill",
        "name" : "INTRINSICS.TypedArray.prototype.fill",
        "htmlId" : "sec-%typedarray%.prototype.fill",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1519,
    [
      "CaseBlock[0,0].CaseBlockEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[0]]"
        ],
        [
          "input",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Return *undefined*.\n      ",
      {
        "normalizedName" : "CaseBlock[0,0].CaseBlockEvaluation",
        "name" : "CaseBlock[0,0].CaseBlockEvaluation",
        "htmlId" : "sec-runtime-semantics-caseblockevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CaseBlockEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2596,
    [
      "INTRINSICS.Map.prototype.keys",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Return ? CreateMapIterator(_M_, ~key~).\n        ",
      {
        "normalizedName" : "INTRINSICS.Map.prototype.keys",
        "name" : "INTRINSICS.Map.prototype.keys",
        "htmlId" : "sec-map.prototype.keys",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2277,
    [
      "INTRINSICS.String.prototype[@@iterator]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _s_ be ? ToString(_O_).\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _s_ and performs the following steps when called:\n            1. Let _len_ be the length of _s_.\n            1. Let _position_ be 0.\n            1. Repeat, while _position_ < _len_,\n              1. Let _cp_ be CodePointAt(_s_, _position_).\n              1. Let _nextIndex_ be _position_ + _cp_.[[CodeUnitCount]].\n              1. Let _resultString_ be the substring of _s_ from _position_ to _nextIndex_.\n              1. Set _position_ to _nextIndex_.\n              1. Perform ? GeneratorYield(CreateIterResultObject(_resultString_, *false*)).\n            1. Return *undefined*.\n          1. Return CreateIteratorFromClosure(_closure_, *\"%StringIteratorPrototype%\"*, %StringIteratorPrototype%).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype[@@iterator]",
        "name" : "INTRINSICS.String.prototype[@@iterator]",
        "htmlId" : "sec-string.prototype-@@iterator",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1355,
    [
      "UnaryExpression[5,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[5]]"
        ]
      ],
      "\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).\n          1. If _oldValue_ is a Number, then\n            1. Return Number::unaryMinus(_oldValue_).\n          1. Else,\n            1. Assert: _oldValue_ is a BigInt.\n            1. Return BigInt::unaryMinus(_oldValue_).\n        ",
      {
        "normalizedName" : "UnaryExpression[5,0].Evaluation",
        "name" : "UnaryExpression[5,0].Evaluation",
        "htmlId" : "sec-unary-minus-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "-"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1580,
    [
      "ArrowParameters[0,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowParameters[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ArrowParameters[0,0].ContainsExpression",
        "name" : "ArrowParameters[0,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrowParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1255,
    [
      "ElementList[3,1].ArrayAccumulation",
      2,
      [
        [
          "this",
          false,
          "Ast[ElementList[3]]"
        ],
        [
          "array",
          false,
          "Record[Array]"
        ],
        [
          "nextIndex",
          false,
          "Int"
        ]
      ],
      "\n          1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.\n        ",
      {
        "normalizedName" : "ElementList[3,1].ArrayAccumulation",
        "name" : "ElementList[3,1].ArrayAccumulation",
        "htmlId" : "sec-runtime-semantics-arrayaccumulation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArrayAccumulation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 1,
            "astName" : "ElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "SpreadElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    302,
    [
      "DefaultClause[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the LexicallyDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "DefaultClause[0,0].LexicallyDeclaredNames",
        "name" : "DefaultClause[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    260,
    [
      "ImportSpecifier[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportSpecifier[1]]"
        ]
      ],
      "\n        1. Return the BoundNames of |ImportedBinding|.\n      ",
      {
        "normalizedName" : "ImportSpecifier[1,0].BoundNames",
        "name" : "ImportSpecifier[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ImportSpecifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              },
              {
                "type" : "terminal",
                "value" : "as"
              },
              {
                "type" : "nonterminal",
                "value" : "ImportedBinding"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1123,
    [
      "Record[ECMAScriptFunctionObject].Construct",
      4,
      [
        [
          "F",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "newTarget",
          false,
          "Record[Constructor]"
        ]
      ],
      "\n        1. Let _callerContext_ be the running execution context.\n        1. Let _kind_ be _F_.[[ConstructorKind]].\n        1. If _kind_ is ~base~, then\n          1. Let _thisArgument_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%Object.prototype%\"*).\n        1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, _newTarget_).\n        1. Assert: _calleeContext_ is now the running execution context.\n        1. If _kind_ is ~base~, then\n          1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).\n          1. Let _initializeResult_ be Completion(InitializeInstanceElements(_thisArgument_, _F_)).\n          1. If _initializeResult_ is an abrupt completion, then\n            1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n            1. Return ? _initializeResult_.\n        1. Let _constructorEnv_ be the LexicalEnvironment of _calleeContext_.\n        1. Let _result_ be Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_)).\n        1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n        1. If _result_ is a return completion, then\n          1. If _result_.[[Value]] is an Object, return _result_.[[Value]].\n          1. If _kind_ is ~base~, return _thisArgument_.\n          1. If _result_.[[Value]] is not *undefined*, throw a *TypeError* exception.\n        1. Else,\n          1. ReturnIfAbrupt(_result_).\n        1. Let _thisBinding_ be ? _constructorEnv_.GetThisBinding().\n        1. Assert: _thisBinding_ is an Object.\n        1. Return _thisBinding_.\n      ",
      {
        "normalizedName" : "Record[ECMAScriptFunctionObject].Construct",
        "name" : "Record[ECMAScriptFunctionObject].Construct",
        "htmlId" : "sec-ecmascript-function-objects-construct-argumentslist-newtarget",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ECMAScriptFunctionObject",
          "[[Construct]]"
        ]
      }
    ]
  ],
  [
    862,
    [
      "MethodDefinition[5,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[5]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      ",
      {
        "normalizedName" : "MethodDefinition[5,0].ComputedPropertyContains",
        "name" : "MethodDefinition[5,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "set"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "PropertySetParameterList"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    349,
    [
      "ExportDeclaration[3,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[3]]"
        ]
      ],
      "\n        1. Return a List whose sole element is DeclarationPart of |Declaration|.\n      ",
      {
        "normalizedName" : "ExportDeclaration[3,0].LexicallyScopedDeclarations",
        "name" : "ExportDeclaration[3,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1570,
    [
      "BindingElisionElement[0,1].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElisionElement[0]]"
        ]
      ],
      "\n        1. Return ContainsExpression of |BindingElement|.\n      ",
      {
        "normalizedName" : "BindingElisionElement[0,1].ContainsExpression",
        "name" : "BindingElisionElement[0,1].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "BindingElisionElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1174,
    [
      "TypedArrayGetElement",
      0,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "index",
          false,
          "Number"
        ]
      ],
      "\n          1. If IsValidIntegerIndex(_O_, _index_) is *false*, return *undefined*.\n          1. Let _offset_ be _O_.[[ByteOffset]].\n          1. Let _elementSize_ be TypedArrayElementSize(_O_).\n          1. Let _byteIndexInBuffer_ be (ℝ(_index_) × _elementSize_) + _offset_.\n          1. Let _elementType_ be TypedArrayElementType(_O_).\n          1. Return GetValueFromBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, *true*, ~unordered~).\n        ",
      {
        "normalizedName" : "TypedArrayGetElement",
        "name" : "TypedArrayGetElement",
        "htmlId" : "sec-typedarraygetelement",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    28,
    [
      "StringToNumber",
      0,
      [
        [
          "str",
          false,
          "String"
        ]
      ],
      "\n            1. Let _text_ be StringToCodePoints(_str_).\n            1. Let _literal_ be ParseText(_text_, |StringNumericLiteral|).\n            1. If _literal_ is a List of errors, return *NaN*.\n            1. Return StringNumericValue of _literal_.\n          ",
      {
        "normalizedName" : "StringToNumber",
        "name" : "StringToNumber",
        "htmlId" : "sec-stringtonumber",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1676,
    [
      "ClassElement[5,0].IsStatic",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[5]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassElement[5,0].IsStatic",
        "name" : "ClassElement[5,0].IsStatic",
        "htmlId" : "sec-static-semantics-isstatic",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsStatic",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2133,
    [
      "INTRINSICS.Math.cbrt",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n          1. Return an implementation-approximated Number value representing the result of the cube root of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.cbrt",
        "name" : "INTRINSICS.Math.cbrt",
        "htmlId" : "sec-math.cbrt",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    38,
    [
      "__NEW_ERROR_OBJ__",
      8,
      [
        [
          "proto",
          false,
          "String"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1217,
    [
      "NumericLiteral[0,0].NumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[NumericLiteral[0]]"
        ]
      ],
      "\n          1. Return RoundMVResult(MV of |DecimalLiteral|).\n        ",
      {
        "normalizedName" : "NumericLiteral[0,0].NumericValue",
        "name" : "NumericLiteral[0,0].NumericValue",
        "htmlId" : "sec-numericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NumericValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NumericLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DecimalLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    598,
    [
      "ForStatement[1,2].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[1,2].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[1,2].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2147,
    [
      "INTRINSICS.Math.log2",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n          1. If _n_ < *-0*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the base 2 logarithm of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.log2",
        "name" : "INTRINSICS.Math.log2",
        "htmlId" : "sec-math.log2",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    160,
    [
      "MakeBasicObject",
      0,
      [
        [
          "internalSlotsList",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _obj_ be a newly created object with an internal slot for each name in _internalSlotsList_.\n        1. Set _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots\"></emu-xref>.\n        1. Assert: If the caller will not be overriding both _obj_'s [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then _internalSlotsList_ contains [[Prototype]].\n        1. Assert: If the caller will not be overriding all of _obj_'s [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then _internalSlotsList_ contains [[Extensible]].\n        1. If _internalSlotsList_ contains [[Extensible]], set _obj_.[[Extensible]] to *true*.\n        1. Return _obj_.\n      ",
      {
        "normalizedName" : "MakeBasicObject",
        "name" : "MakeBasicObject",
        "htmlId" : "sec-makebasicobject",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1502,
    [
      "ForInOfStatement[7,0].ForInOfLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[7]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~).\n          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_, ~async~).\n        ",
      {
        "normalizedName" : "ForInOfStatement[7,0].ForInOfLoopEvaluation",
        "name" : "ForInOfStatement[7,0].ForInOfLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forinofloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForInOfLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1751,
    [
      "AsyncFunctionDeclaration[1,0].InstantiateAsyncFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionDeclaration[1]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Let _sourceText_ be the source text matched by |AsyncFunctionDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, *\"default\"*).\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "AsyncFunctionDeclaration[1,0].InstantiateAsyncFunctionObject",
        "name" : "AsyncFunctionDeclaration[1,0].InstantiateAsyncFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiateasyncfunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateAsyncFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncFunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    820,
    [
      "AsyncGeneratorExpression[0,0].NamedEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ],
        [
          "name",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Return InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression| with argument _name_.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,0].NamedEvaluation",
        "name" : "AsyncGeneratorExpression[0,0].NamedEvaluation",
        "htmlId" : "sec-runtime-semantics-namedevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NamedEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    561,
    [
      "DefaultClause[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "DefaultClause[0,0].ContainsDuplicateLabels",
        "name" : "DefaultClause[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1666,
    [
      "ClassElement[3,0].ClassElementKind",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[3]]"
        ]
      ],
      "\n        1. Return ~non-constructor-method~.\n      ",
      {
        "normalizedName" : "ClassElement[3,0].ClassElementKind",
        "name" : "ClassElement[3,0].ClassElementKind",
        "htmlId" : "sec-static-semantics-classelementkind",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassElementKind",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "static"
              },
              {
                "type" : "nonterminal",
                "value" : "FieldDefinition"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    392,
    [
      "ForInOfStatement[7,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[7]]"
        ]
      ],
      "\n        1. Let _names1_ be the BoundNames of |ForBinding|.\n        1. Let _names2_ be the VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[7,0].VarDeclaredNames",
        "name" : "ForInOfStatement[7,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1487,
    [
      "NewExpression[1,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[NewExpression[1]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "NewExpression[1,0].IsDestructuring",
        "name" : "NewExpression[1,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "NewExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "nonterminal",
                "value" : "NewExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    297,
    [
      "CaseBlock[1,2].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _names1_ be the LexicallyDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be LexicallyDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the LexicallyDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,2].LexicallyDeclaredNames",
        "name" : "CaseBlock[1,2].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    70,
    [
      "BigInt::unaryMinus",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ]
      ],
      "\n            1. If _x_ is *0*<sub>ℤ</sub>, return *0*<sub>ℤ</sub>.\n            1. Return -_x_.\n          ",
      {
        "normalizedName" : "BigInt::unaryMinus",
        "name" : "BigInt::unaryMinus",
        "htmlId" : "sec-numeric-types-bigint-unaryMinus",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    192,
    [
      "AddValueToKeyedGroup",
      0,
      [
        [
          "groups",
          false,
          "Unknown[\"ListOfRecordsWithFields[[Key]](anECMAScriptLanguageValue)And[[Elements]](aListOfECMAScriptLanguageValues)\"]"
        ],
        [
          "key",
          false,
          "ESValue"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n        1. For each Record { [[Key]], [[Elements]] } _g_ of _groups_, do\n          1. If SameValue(_g_.[[Key]], _key_) is *true*, then\n            1. Assert: Exactly one element of _groups_ meets this criterion.\n            1. Append _value_ to _g_.[[Elements]].\n            1. Return ~unused~.\n        1. Let _group_ be the Record { [[Key]]: _key_, [[Elements]]: « _value_ » }.\n        1. Append _group_ to _groups_.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "AddValueToKeyedGroup",
        "name" : "AddValueToKeyedGroup",
        "htmlId" : "sec-add-value-to-keyed-group",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    407,
    [
      "TryStatement[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[0]]"
        ]
      ],
      "\n        1. Let _names1_ be VarDeclaredNames of |Block|.\n        1. Let _names2_ be VarDeclaredNames of |Catch|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "TryStatement[0,0].VarDeclaredNames",
        "name" : "TryStatement[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    693,
    [
      "LabelledStatement[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _label_ be the StringValue of |LabelIdentifier|.\n        1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».\n        1. Return ContainsUndefinedContinueTarget of |LabelledItem| with arguments _iterationSet_ and _newLabelSet_.\n      ",
      {
        "normalizedName" : "LabelledStatement[0,0].ContainsUndefinedContinueTarget",
        "name" : "LabelledStatement[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelledItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    630,
    [
      "TryStatement[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of |Finally| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "TryStatement[1,0].ContainsUndefinedBreakTarget",
        "name" : "TryStatement[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1824,
    [
      "AssignmentExpression[3,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[3]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[3,0].HasCallInTailPosition",
        "name" : "AssignmentExpression[3,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncArrowFunction"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    275,
    [
      "LetOrConst[0,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[LetOrConst[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "LetOrConst[0,0].IsConstantDeclaration",
        "name" : "LetOrConst[0,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LetOrConst",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "let"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    788,
    [
      "AsyncFunctionExpression[0,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,0].IsFunctionDefinition",
        "name" : "AsyncFunctionExpression[0,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2150,
    [
      "INTRINSICS.Math.pow",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Set _base_ to ? ToNumber(_base_).\n          1. Set _exponent_ to ? ToNumber(_exponent_).\n          1. Return Number::exponentiate(_base_, _exponent_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.pow",
        "name" : "INTRINSICS.Math.pow",
        "htmlId" : "sec-math.pow",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1370,
    [
      "RelationalExpression[6,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[6]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. If _rval_ is not an Object, throw a *TypeError* exception.\n        1. Return ? HasProperty(_rval_, ? ToPropertyKey(_lval_)).\n      ",
      {
        "normalizedName" : "RelationalExpression[6,0].Evaluation",
        "name" : "RelationalExpression[6,0].Evaluation",
        "htmlId" : "sec-relational-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    137,
    [
      "ToUint8",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n        1. Let _int_ be truncate(ℝ(_number_)).\n        1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.\n        1. Return 𝔽(_int8bit_).\n      ",
      {
        "normalizedName" : "ToUint8",
        "name" : "ToUint8",
        "htmlId" : "sec-touint8",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    21,
    [
      "INTRINSICS.print",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Object] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1619,
    [
      "FunctionExpression[0,1].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ]
      ],
      "\n        1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression|.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,1].Evaluation",
        "name" : "FunctionExpression[0,1].Evaluation",
        "htmlId" : "sec-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2032,
    [
      "INTRINSICS.isFinite",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _num_ be ? ToNumber(_number_).\n        1. If _num_ is not finite, return *false*.\n        1. Otherwise, return *true*.\n      ",
      {
        "normalizedName" : "INTRINSICS.isFinite",
        "name" : "INTRINSICS.isFinite",
        "htmlId" : "sec-isfinite-number",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    165,
    [
      "CreateDataPropertyOrThrow",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "V",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _success_ be ? CreateDataProperty(_O_, _P_, _V_).\n        1. If _success_ is *false*, throw a *TypeError* exception.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "CreateDataPropertyOrThrow",
        "name" : "CreateDataPropertyOrThrow",
        "htmlId" : "sec-createdatapropertyorthrow",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    815,
    [
      "LeftHandSideExpression[2,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[LeftHandSideExpression[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "LeftHandSideExpression[2,0].IsIdentifierRef",
        "name" : "LeftHandSideExpression[2,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "LeftHandSideExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2132,
    [
      "INTRINSICS.Math.atan2",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _ny_ be ? ToNumber(_y_).\n          1. Let _nx_ be ? ToNumber(_x_).\n          1. If _ny_ is *NaN* or _nx_ is *NaN*, return *NaN*.\n          1. If _ny_ is *+∞*<sub>𝔽</sub>, then\n            1. If _nx_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing π / 4.\n            1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing 3π / 4.\n            1. Return an implementation-approximated Number value representing π / 2.\n          1. If _ny_ is *-∞*<sub>𝔽</sub>, then\n            1. If _nx_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π / 4.\n            1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -3π / 4.\n            1. Return an implementation-approximated Number value representing -π / 2.\n          1. If _ny_ is *+0*<sub>𝔽</sub>, then\n            1. If _nx_ > *+0*<sub>𝔽</sub> or _nx_ is *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n            1. Return an implementation-approximated Number value representing π.\n          1. If _ny_ is *-0*<sub>𝔽</sub>, then\n            1. If _nx_ > *+0*<sub>𝔽</sub> or _nx_ is *+0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n            1. Return an implementation-approximated Number value representing -π.\n          1. Assert: _ny_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.\n          1. If _ny_ > *+0*<sub>𝔽</sub>, then\n            1. If _nx_ is *+∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n            1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing π.\n            1. If _nx_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return an implementation-approximated Number value representing π / 2.\n          1. If _ny_ < *-0*<sub>𝔽</sub>, then\n            1. If _nx_ is *+∞*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n            1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π.\n            1. If _nx_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π / 2.\n          1. Assert: _nx_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.\n          1. Let _r_ be the inverse tangent of abs(ℝ(_ny_) / ℝ(_nx_)).\n          1. If _nx_ < *-0*<sub>𝔽</sub>, then\n            1. If _ny_ > *+0*<sub>𝔽</sub>, set _r_ to π - _r_.\n            1. Else, set _r_ to -π + _r_.\n          1. Else,\n            1. If _ny_ < *-0*<sub>𝔽</sub>, set _r_ to -_r_.\n          1. Return an implementation-approximated Number value representing _r_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.atan2",
        "name" : "INTRINSICS.Math.atan2",
        "htmlId" : "sec-math.atan2",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2414,
    [
      "ClassSubtraction[1,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSubtraction[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of the |ClassSubtraction| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of the |ClassSetOperand| with argument _rer_.\n          1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _B_.\n        ",
      {
        "normalizedName" : "ClassSubtraction[1,0].CompileToCharSet",
        "name" : "ClassSubtraction[1,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassSubtraction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSubtraction"
              },
              {
                "type" : "terminal",
                "value" : "--"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    729,
    [
      "MemberExpression[4,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[4]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[4,0].IsFunctionDefinition",
        "name" : "MemberExpression[4,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SuperProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2396,
    [
      "ClassEscape[3,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassEscape[3]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _cv_ be the CharacterValue of this |ClassEscape|.\n          1. Let _c_ be the character whose character value is _cv_.\n          1. Return the CharSet containing the single character _c_.\n        ",
      {
        "normalizedName" : "ClassEscape[3,0].CompileToCharSet",
        "name" : "ClassEscape[3,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ClassEscape",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CharacterEscape"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    33,
    [
      "__CLAMP__",
      8,
      [
        [
          "target",
          false,
          "Math | INF"
        ],
        [
          "lower",
          false,
          "Math"
        ],
        [
          "upper",
          false,
          "Math"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1238,
    [
      "IdentifierReference[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierReference[0]]"
        ]
      ],
      "\n        1. Return ? ResolveBinding(StringValue of |Identifier|).\n      ",
      {
        "normalizedName" : "IdentifierReference[0,0].Evaluation",
        "name" : "IdentifierReference[0,0].Evaluation",
        "htmlId" : "sec-identifiers-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IdentifierReference",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Identifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2015,
    [
      "ExportSpecifier[0,0].ExportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportSpecifier[0]]"
        ],
        [
          "module",
          false,
          "String | Null"
        ]
      ],
      "\n          1. Let _sourceName_ be the StringValue of |ModuleExportName|.\n          1. If _module_ is *null*, then\n            1. Let _localName_ be _sourceName_.\n            1. Let _importName_ be *null*.\n          1. Else,\n            1. Let _localName_ be *null*.\n            1. Let _importName_ be _sourceName_.\n          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _sourceName_ }.\n        ",
      {
        "normalizedName" : "ExportSpecifier[0,0].ExportEntriesForModule",
        "name" : "ExportSpecifier[0,0].ExportEntriesForModule",
        "htmlId" : "sec-static-semantics-exportentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportSpecifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1883,
    [
      "PrimaryExpression[8,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[8]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[8,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[8,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1560,
    [
      "ArrayBindingPattern[0,2].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[0,2].ContainsExpression",
        "name" : "ArrayBindingPattern[0,2].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 2,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    197,
    [
      "IteratorComplete",
      0,
      [
        [
          "iterResult",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Return ToBoolean(? Get(_iterResult_, *\"done\"*)).\n      ",
      {
        "normalizedName" : "IteratorComplete",
        "name" : "IteratorComplete",
        "htmlId" : "sec-iteratorcomplete",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1920,
    [
      "ModuleItem[2,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[2]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ModuleItem[2,0].ModuleRequests",
        "name" : "ModuleItem[2,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1951,
    [
      "Module[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Module[0]]"
        ]
      ],
      "\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "Module[0,0].Evaluation",
        "name" : "Module[0,0].Evaluation",
        "htmlId" : "sec-module-semantics-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Module",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    92,
    [
      "IsUnresolvableReference",
      0,
      [
        [
          "V",
          false,
          "Record[ReferenceRecord]"
        ]
      ],
      "\n          1. If _V_.[[Base]] is ~unresolvable~, return *true*; otherwise return *false*.\n        ",
      {
        "normalizedName" : "IsUnresolvableReference",
        "name" : "IsUnresolvableReference",
        "htmlId" : "sec-isunresolvablereference",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1423,
    [
      "HoistableDeclaration[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[HoistableDeclaration[2]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "HoistableDeclaration[2,0].Evaluation",
        "name" : "HoistableDeclaration[2,0].Evaluation",
        "htmlId" : "sec-statement-semantics-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "HoistableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    916,
    [
      "CallExpression[7,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[7]]"
        ]
      ],
      "\n        1. Return ~simple~.\n      ",
      {
        "normalizedName" : "CallExpression[7,0].AssignmentTargetType",
        "name" : "CallExpression[7,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    467,
    [
      "CaseBlock[1,1].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _declarations1_ be the VarScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be VarScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the VarScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,1].VarScopedDeclarations",
        "name" : "CaseBlock[1,1].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2445,
    [
      "INTRINSICS.RegExp",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _patternIsRegExp_ be ? IsRegExp(_pattern_).\n          1. If NewTarget is *undefined*, then\n            1. Let _newTarget_ be the active function object.\n            1. If _patternIsRegExp_ is *true* and _flags_ is *undefined*, then\n              1. Let _patternConstructor_ be ? Get(_pattern_, *\"constructor\"*).\n              1. If SameValue(_newTarget_, _patternConstructor_) is *true*, return _pattern_.\n          1. Else,\n            1. Let _newTarget_ be NewTarget.\n          1. If _pattern_ is an Object and _pattern_ has a [[RegExpMatcher]] internal slot, then\n            1. Let _P_ be _pattern_.[[OriginalSource]].\n            1. If _flags_ is *undefined*, let _F_ be _pattern_.[[OriginalFlags]].\n            1. Else, let _F_ be _flags_.\n          1. Else if _patternIsRegExp_ is *true*, then\n            1. Let _P_ be ? Get(_pattern_, *\"source\"*).\n            1. If _flags_ is *undefined*, then\n              1. Let _F_ be ? Get(_pattern_, *\"flags\"*).\n            1. Else,\n              1. Let _F_ be _flags_.\n          1. Else,\n            1. Let _P_ be _pattern_.\n            1. Let _F_ be _flags_.\n          1. Let _O_ be ? RegExpAlloc(_newTarget_).\n          1. Return ? RegExpInitialize(_O_, _P_, _F_).\n        ",
      {
        "normalizedName" : "INTRINSICS.RegExp",
        "name" : "INTRINSICS.RegExp",
        "htmlId" : "sec-regexp-pattern-flags",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2464,
    [
      "INTRINSICS.RegExp.prototype.toString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. If _R_ is not an Object, throw a *TypeError* exception.\n          1. Let _pattern_ be ? ToString(? Get(_R_, *\"source\"*)).\n          1. Let _flags_ be ? ToString(? Get(_R_, *\"flags\"*)).\n          1. Let _result_ be the string-concatenation of *\"/\"*, _pattern_, *\"/\"*, and _flags_.\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "INTRINSICS.RegExp.prototype.toString",
        "name" : "INTRINSICS.RegExp.prototype.toString",
        "htmlId" : "sec-regexp.prototype.tostring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1938,
    [
      "ExecuteAsyncModule:clo1",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n              1. Assert: _module_.[[Status]] is either ~evaluating~ or ~evaluating-async~.\n              1. Assert: _module_.[[HasTLA]] is *true*.\n              1. Let _capability_ be ! NewPromiseCapability(%Promise%).\n              1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and performs the following steps when called:\n                1. Perform AsyncModuleExecutionFulfilled(_module_).\n                1. Return *undefined*.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *\"\"*, « »).\n              1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_error_) that captures _module_ and performs the following steps when called:\n                1. Perform AsyncModuleExecutionRejected(_module_, _error_).\n                1. Return *undefined*.\n              1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 0, *\"\"*, « »).\n              1. Perform PerformPromiseThen(_capability_.[[Promise]], _onFulfilled_, _onRejected_).\n              1. Perform ! <emu-meta effects=\"user-code\">_module_.ExecuteModule</emu-meta>(_capability_).\n              1. Return ~unused~.\n            ",
      {
        "normalizedName" : "ExecuteAsyncModule",
        "name" : "ExecuteAsyncModule",
        "htmlId" : "sec-execute-async-module",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2758,
    [
      "NewPromiseReactionJob",
      0,
      [
        [
          "reaction",
          false,
          "Record[PromiseReactionRecord]"
        ],
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _reaction_ and _argument_ and performs the following steps when called:\n            1. Let _promiseCapability_ be _reaction_.[[Capability]].\n            1. Let _type_ be _reaction_.[[Type]].\n            1. Let _handler_ be _reaction_.[[Handler]].\n            1. If _handler_ is ~empty~, then\n              1. If _type_ is ~fulfill~, then\n                1. Let _handlerResult_ be NormalCompletion(_argument_).\n              1. Else,\n                1. Assert: _type_ is ~reject~.\n                1. Let _handlerResult_ be ThrowCompletion(_argument_).\n            1. Else,\n              1. Let _handlerResult_ be Completion(HostCallJobCallback(_handler_, *undefined*, « _argument_ »)).\n            1. If _promiseCapability_ is *undefined*, then\n              1. Assert: _handlerResult_ is not an abrupt completion.\n              1. Return ~empty~.\n            1. Assert: _promiseCapability_ is a PromiseCapability Record.\n            1. If _handlerResult_ is an abrupt completion, then\n              1. Return ? Call(_promiseCapability_.[[Reject]], *undefined*, « _handlerResult_.[[Value]] »).\n            1. Else,\n              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _handlerResult_.[[Value]] »).\n          1. Let _handlerRealm_ be *null*.\n          1. If _reaction_.[[Handler]] is not ~empty~, then\n            1. Let _getHandlerRealmResult_ be Completion(GetFunctionRealm(_reaction_.[[Handler]].[[Callback]])).\n            1. If _getHandlerRealmResult_ is a normal completion, set _handlerRealm_ to _getHandlerRealmResult_.[[Value]].\n            1. Else, set _handlerRealm_ to the current Realm Record.\n            1. NOTE: _handlerRealm_ is never *null* unless the handler is *undefined*. When the handler is a revoked Proxy and no ECMAScript code runs, _handlerRealm_ is used to create error objects.\n          1. Return the Record { [[Job]]: _job_, [[Realm]]: _handlerRealm_ }.\n        ",
      {
        "normalizedName" : "NewPromiseReactionJob",
        "name" : "NewPromiseReactionJob",
        "htmlId" : "sec-newpromisereactionjob",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    229,
    [
      "BindingPropertyList[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingPropertyList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be BoundNames of |BindingPropertyList|.\n        1. Let _names2_ be BoundNames of |BindingProperty|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "BindingPropertyList[1,0].BoundNames",
        "name" : "BindingPropertyList[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingPropertyList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPropertyList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "BindingProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    847,
    [
      "ArrowParameters[1,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowParameters[1]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return _formals_ Contains _symbol_.\n      ",
      {
        "normalizedName" : "ArrowParameters[1,0].Contains",
        "name" : "ArrowParameters[1,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ArrowParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    566,
    [
      "TryStatement[1,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.\n        1. If _hasDuplicates_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "TryStatement[1,0].ContainsDuplicateLabels",
        "name" : "TryStatement[1,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    484,
    [
      "ClassStaticBlockStatementList[0,1].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockStatementList[0]]"
        ]
      ],
      "\n        1. Return the TopLevelVarScopedDeclarations of |StatementList|.\n      ",
      {
        "normalizedName" : "ClassStaticBlockStatementList[0,1].VarScopedDeclarations",
        "name" : "ClassStaticBlockStatementList[0,1].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ClassStaticBlockStatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1032,
    [
      "Record[GlobalEnvironmentRecord].HasBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ]
      ],
      "\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, return *true*.\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Return ? <emu-meta effects=\"user-code\">_ObjRec_.HasBinding</emu-meta>(_N_).\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].HasBinding",
        "name" : "Record[GlobalEnvironmentRecord].HasBinding",
        "htmlId" : "sec-global-environment-records-hasbinding-n",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "HasBinding"
        ]
      }
    ]
  ],
  [
    252,
    [
      "AsyncFunctionDeclaration[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionDeclaration[1]]"
        ]
      ],
      "\n        1. Return « *\"\\*default\\*\"* ».\n      ",
      {
        "normalizedName" : "AsyncFunctionDeclaration[1,0].BoundNames",
        "name" : "AsyncFunctionDeclaration[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncFunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1837,
    [
      "RelationalExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[1,0].HasCallInTailPosition",
        "name" : "RelationalExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "<"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1602,
    [
      "FormalParameters[1,0].ExpectedArgumentCount",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameters[1]]"
        ]
      ],
      "\n        1. Return 0.\n      ",
      {
        "normalizedName" : "FormalParameters[1,0].ExpectedArgumentCount",
        "name" : "FormalParameters[1,0].ExpectedArgumentCount",
        "htmlId" : "sec-static-semantics-expectedargumentcount",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExpectedArgumentCount",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FormalParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionRestParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    361,
    [
      "StatementList[1,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be VarDeclaredNames of |StatementList|.\n        1. Let _names2_ be VarDeclaredNames of |StatementListItem|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "StatementList[1,0].VarDeclaredNames",
        "name" : "StatementList[1,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1365,
    [
      "RelationalExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[1]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _r_ be ? IsLessThan(_lval_, _rval_, *true*).\n        1. If _r_ is *undefined*, return *false*. Otherwise, return _r_.\n      ",
      {
        "normalizedName" : "RelationalExpression[1,0].Evaluation",
        "name" : "RelationalExpression[1,0].Evaluation",
        "htmlId" : "sec-relational-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "<"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2628,
    [
      "IsDetachedBuffer",
      0,
      [
        [
          "arrayBuffer",
          false,
          "Record[ArrayBuffer | SharedArrayBuffer]"
        ]
      ],
      "\n          1. If _arrayBuffer_.[[ArrayBufferData]] is *null*, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "IsDetachedBuffer",
        "name" : "IsDetachedBuffer",
        "htmlId" : "sec-isdetachedbuffer",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    65,
    [
      "Number::sameValueZero",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. If _x_ is *NaN* and _y_ is *NaN*, return *true*.\n            1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *true*.\n            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *true*.\n            1. If _x_ is _y_, return *true*.\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "Number::sameValueZero",
        "name" : "Number::sameValueZero",
        "htmlId" : "sec-numeric-types-number-sameValueZero",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2670,
    [
      "INTRINSICS.get DataView.prototype.byteLength",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.\n          1. Let _size_ be GetViewByteLength(_viewRecord_).\n          1. Return 𝔽(_size_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get DataView.prototype.byteLength",
        "name" : "INTRINSICS.get DataView.prototype.byteLength",
        "htmlId" : "sec-get-dataview.prototype.bytelength",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    625,
    [
      "DefaultClause[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "DefaultClause[0,0].ContainsUndefinedBreakTarget",
        "name" : "DefaultClause[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2433,
    [
      "MaybeSimpleCaseFolding",
      0,
      [
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "A",
          false,
          "Record[CharSet]"
        ]
      ],
      "\n            1. If _rer_.[[UnicodeSets]] is *false* or _rer_.[[IgnoreCase]] is *false*, return _A_.\n            1. Let _B_ be a new empty CharSet.\n            1. For each CharSetElement _s_ of _A_, do\n              1. Let _t_ be an empty sequence of characters.\n              1. For each single code point _cp_ in _s_, do\n                1. Append scf(_cp_) to _t_.\n              1. Add _t_ to _B_.\n            1. Return _B_.\n          ",
      {
        "normalizedName" : "MaybeSimpleCaseFolding",
        "name" : "MaybeSimpleCaseFolding",
        "htmlId" : "sec-maybesimplecasefolding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2477,
    [
      "INTRINSICS.Array",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.\n          1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, *\"%Array.prototype%\"*).\n          1. Let _numberOfArgs_ be the number of elements in _values_.\n          1. If _numberOfArgs_ = 0, then\n            1. Return ! ArrayCreate(0, _proto_).\n          1. Else if _numberOfArgs_ = 1, then\n            1. Let _len_ be _values_[0].\n            1. Let _array_ be ! ArrayCreate(0, _proto_).\n            1. If _len_ is not a Number, then\n              1. Perform ! CreateDataPropertyOrThrow(_array_, *\"0\"*, _len_).\n              1. Let _intLen_ be *1*<sub>𝔽</sub>.\n            1. Else,\n              1. Let _intLen_ be ! ToUint32(_len_).\n              1. If SameValueZero(_intLen_, _len_) is *false*, throw a *RangeError* exception.\n            1. Perform ! Set(_array_, *\"length\"*, _intLen_, *true*).\n            1. Return _array_.\n          1. Else,\n            1. Assert: _numberOfArgs_ ≥ 2.\n            1. Let _array_ be ? ArrayCreate(_numberOfArgs_, _proto_).\n            1. Let _k_ be 0.\n            1. Repeat, while _k_ < _numberOfArgs_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Let _itemK_ be _values_[_k_].\n              1. Perform ! CreateDataPropertyOrThrow(_array_, _Pk_, _itemK_).\n              1. Set _k_ to _k_ + 1.\n            1. Assert: The mathematical value of _array_'s *\"length\"* property is _numberOfArgs_.\n            1. Return _array_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array",
        "name" : "INTRINSICS.Array",
        "htmlId" : "sec-array",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1968,
    [
      "ImportSpecifier[1,0].ImportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportSpecifier[1]]"
        ],
        [
          "module",
          false,
          "String"
        ]
      ],
      "\n          1. Let _importName_ be the StringValue of |ModuleExportName|.\n          1. Let _localName_ be the StringValue of |ImportedBinding|.\n          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_ }.\n          1. Return « _entry_ ».\n        ",
      {
        "normalizedName" : "ImportSpecifier[1,0].ImportEntriesForModule",
        "name" : "ImportSpecifier[1,0].ImportEntriesForModule",
        "htmlId" : "sec-static-semantics-importentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ImportSpecifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              },
              {
                "type" : "terminal",
                "value" : "as"
              },
              {
                "type" : "nonterminal",
                "value" : "ImportedBinding"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2565,
    [
      "INTRINSICS.TypedArray.prototype.subarray",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].\n          1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, then\n            1. Let _srcLength_ be 0.\n          1. Else,\n            1. Let _srcLength_ be TypedArrayLength(_srcRecord_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _startIndex_ be 0.\n          1. Else if _relativeStart_ < 0, let _startIndex_ be max(_srcLength_ + _relativeStart_, 0).\n          1. Else, let _startIndex_ be min(_relativeStart_, _srcLength_).\n          1. Let _elementSize_ be TypedArrayElementSize(_O_).\n          1. Let _srcByteOffset_ be _O_.[[ByteOffset]].\n          1. Let _beginByteOffset_ be _srcByteOffset_ + (_startIndex_ × _elementSize_).\n          1. If _O_.[[ArrayLength]] is ~auto~ and _end_ is *undefined*, then\n            1. Let _argumentsList_ be « _buffer_, 𝔽(_beginByteOffset_) ».\n          1. Else,\n            1. If _end_ is *undefined*, let _relativeEnd_ be _srcLength_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n            1. If _relativeEnd_ = -∞, let _endIndex_ be 0.\n            1. Else if _relativeEnd_ < 0, let _endIndex_ be max(_srcLength_ + _relativeEnd_, 0).\n            1. Else, let _endIndex_ be min(_relativeEnd_, _srcLength_).\n            1. Let _newLength_ be max(_endIndex_ - _startIndex_, 0).\n            1. Let _argumentsList_ be « _buffer_, 𝔽(_beginByteOffset_), 𝔽(_newLength_) ».\n          1. Return ? TypedArraySpeciesCreate(_O_, _argumentsList_).\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.subarray",
        "name" : "INTRINSICS.TypedArray.prototype.subarray",
        "htmlId" : "sec-%typedarray%.prototype.subarray",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    879,
    [
      "BindingIdentifier[0,0].BindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingIdentifier[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _name_ be StringValue of |Identifier|.\n        1. Return ? InitializeBoundName(_name_, _value_, _environment_).\n      ",
      {
        "normalizedName" : "BindingIdentifier[0,0].BindingInitialization",
        "name" : "BindingIdentifier[0,0].BindingInitialization",
        "htmlId" : "sec-runtime-semantics-bindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BindingIdentifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Identifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    852,
    [
      "MemberExpression[2,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[2]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. If |MemberExpression| Contains _symbol_ is *true*, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[2,0].Contains",
        "name" : "MemberExpression[2,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2663,
    [
      "MakeDataViewWithBufferWitnessRecord",
      0,
      [
        [
          "obj",
          false,
          "Record[DataView]"
        ],
        [
          "order",
          false,
          "Enum[~seq-cst~, ~unordered~]"
        ]
      ],
      "\n          1. Let _buffer_ be _obj_.[[ViewedArrayBuffer]].\n          1. If IsDetachedBuffer(_buffer_) is *true*, then\n            1. Let _byteLength_ be ~detached~.\n          1. Else,\n            1. Let _byteLength_ be ArrayBufferByteLength(_buffer_, _order_).\n          1. Return the DataView With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ }.\n        ",
      {
        "normalizedName" : "MakeDataViewWithBufferWitnessRecord",
        "name" : "MakeDataViewWithBufferWitnessRecord",
        "htmlId" : "sec-makedataviewwithbufferwitnessrecord",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1555,
    [
      "DebuggerStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[DebuggerStatement[0]]"
        ]
      ],
      "\n        1. If an implementation-defined debugging facility is available and enabled, then\n          1. Perform an implementation-defined debugging action.\n          1. Return a new implementation-defined Completion Record.\n        1. Else,\n          1. Return ~empty~.\n      ",
      {
        "normalizedName" : "DebuggerStatement[0,0].Evaluation",
        "name" : "DebuggerStatement[0,0].Evaluation",
        "htmlId" : "sec-debugger-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DebuggerStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "debugger"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2332,
    [
      "NonEmptyClassString[0,1].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[NonEmptyClassString[0]]"
        ]
      ],
      "\n          1. If |NonEmptyClassString| is present, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "NonEmptyClassString[0,1].MayContainStrings",
        "name" : "NonEmptyClassString[0,1].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "NonEmptyClassString",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetCharacter"
              },
              {
                "type" : "nonterminal",
                "value" : "NonEmptyClassString"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2826,
    [
      "AsyncFunctionStart",
      0,
      [
        [
          "promiseCapability",
          false,
          "Record[PromiseCapabilityRecord]"
        ],
        [
          "asyncFunctionBody",
          false,
          "Ast[ExpressionBody | FunctionBody]"
        ]
      ],
      "\n          1. Let _runningContext_ be the running execution context.\n          1. Let _asyncContext_ be a copy of _runningContext_.\n          1. NOTE: Copying the execution state is required for AsyncBlockStart to resume its execution. It is ill-defined to resume a currently executing context.\n          1. Perform AsyncBlockStart(_promiseCapability_, _asyncFunctionBody_, _asyncContext_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncFunctionStart",
        "name" : "AsyncFunctionStart",
        "htmlId" : "sec-async-functions-abstract-operations-async-function-start",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    435,
    [
      "IfStatement[1,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[1]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "IfStatement[1,0].VarScopedDeclarations",
        "name" : "IfStatement[1,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2820,
    [
      "AsyncGeneratorAwaitReturn:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].\n          1. Assert: _queue_ is not empty.\n          1. Let _next_ be the first element of _queue_.\n          1. Let _completion_ be Completion(_next_.[[Completion]]).\n          1. Assert: _completion_ is a return completion.\n          1. Let _promise_ be ? PromiseResolve(%Promise%, _completion_.[[Value]]).\n          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_value_) that captures _generator_ and performs the following steps when called:\n            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n            1. Let _result_ be NormalCompletion(_value_).\n            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).\n            1. Perform AsyncGeneratorDrainQueue(_generator_).\n            1. Return *undefined*.\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _generator_ and performs the following steps when called:\n            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n            1. Let _result_ be ThrowCompletion(_reason_).\n            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).\n            1. Perform AsyncGeneratorDrainQueue(_generator_).\n            1. Return *undefined*.\n          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncGeneratorAwaitReturn",
        "name" : "AsyncGeneratorAwaitReturn",
        "htmlId" : "sec-asyncgeneratorawaitreturn",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    97,
    [
      "GetThisValue",
      0,
      [
        [
          "V",
          false,
          "Record[ReferenceRecord]"
        ]
      ],
      "\n          1. Assert: IsPropertyReference(_V_) is *true*.\n          1. If IsSuperReference(_V_) is *true*, return _V_.[[ThisValue]]; otherwise return _V_.[[Base]].\n        ",
      {
        "normalizedName" : "GetThisValue",
        "name" : "GetThisValue",
        "htmlId" : "sec-getthisvalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    329,
    [
      "CaseClause[0,1].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the LexicallyScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "CaseClause[0,1].LexicallyScopedDeclarations",
        "name" : "CaseClause[0,1].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1178,
    [
      "Record[ModuleNamespaceExoticObject].SetPrototypeOf",
      4,
      [
        [
          "O",
          false,
          "Record[ModuleNamespaceExoticObject]"
        ],
        [
          "V",
          false,
          "Record[Object] | Null"
        ]
      ],
      "\n          1. Return ! SetImmutablePrototype(_O_, _V_).\n        ",
      {
        "normalizedName" : "Record[ModuleNamespaceExoticObject].SetPrototypeOf",
        "name" : "Record[ModuleNamespaceExoticObject].SetPrototypeOf",
        "htmlId" : "sec-module-namespace-exotic-objects-setprototypeof-v",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleNamespaceExoticObject",
          "[[SetPrototypeOf]]"
        ]
      }
    ]
  ],
  [
    1888,
    [
      "Expression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[Expression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |AssignmentExpression| with argument _call_.\n      ",
      {
        "normalizedName" : "Expression[1,0].HasCallInTailPosition",
        "name" : "Expression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Expression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1296,
    [
      "TemplateMiddleList[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateMiddleList[0]]"
        ]
      ],
      "\n          1. Let _head_ be the TV of |TemplateMiddle| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.\n          1. Let _subRef_ be ? Evaluation of |Expression|.\n          1. Let _sub_ be ? GetValue(_subRef_).\n          1. Let _middle_ be ? ToString(_sub_).\n          1. Return the string-concatenation of _head_ and _middle_.\n        ",
      {
        "normalizedName" : "TemplateMiddleList[0,0].Evaluation",
        "name" : "TemplateMiddleList[0,0].Evaluation",
        "htmlId" : "sec-template-literals-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TemplateMiddleList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateMiddle"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    665,
    [
      "ForStatement[1,3].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[1,3].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[1,3].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1687,
    [
      "RelationalExpression[7,0].AllPrivateIdentifiersValid",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[7]]"
        ],
        [
          "names",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If _names_ contains the StringValue of |PrivateIdentifier|, then\n          1. Return AllPrivateIdentifiersValid of |ShiftExpression| with argument _names_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[7,0].AllPrivateIdentifiersValid",
        "name" : "RelationalExpression[7,0].AllPrivateIdentifiersValid",
        "htmlId" : "sec-static-semantics-allprivateidentifiersvalid",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AllPrivateIdentifiersValid",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1457,
    [
      "IterationStatement[2,0].LoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[IterationStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Return ? ForLoopEvaluation of |ForStatement| with argument _labelSet_.\n        ",
      {
        "normalizedName" : "IterationStatement[2,0].LoopEvaluation",
        "name" : "IterationStatement[2,0].LoopEvaluation",
        "htmlId" : "sec-runtime-semantics-loopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "IterationStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ForStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2068,
    [
      "INTRINSICS.Object.setPrototypeOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Set _O_ to ? RequireObjectCoercible(_O_).\n          1. If _proto_ is not an Object and _proto_ is not *null*, throw a *TypeError* exception.\n          1. If _O_ is not an Object, return _O_.\n          1. Let _status_ be ? <emu-meta effects=\"user-code\">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_).\n          1. If _status_ is *false*, throw a *TypeError* exception.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.setPrototypeOf",
        "name" : "INTRINSICS.Object.setPrototypeOf",
        "htmlId" : "sec-object.setprototypeof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1819,
    [
      "TryStatement[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Finally| with argument _call_.\n      ",
      {
        "normalizedName" : "TryStatement[1,0].HasCallInTailPosition",
        "name" : "TryStatement[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1624,
    [
      "ArrowFunction[0,0].InstantiateArrowFunctionExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowFunction[0]]"
        ],
        [
          "name",
          true,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |ArrowFunction|.\n        1. [id=\"step-arrowfunction-evaluation-functioncreate\"] Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |ArrowParameters|, |ConciseBody|, ~lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Return _closure_.\n      ",
      {
        "normalizedName" : "ArrowFunction[0,0].InstantiateArrowFunctionExpression",
        "name" : "ArrowFunction[0,0].InstantiateArrowFunctionExpression",
        "htmlId" : "sec-runtime-semantics-instantiatearrowfunctionexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateArrowFunctionExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrowFunction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrowParameters"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "ConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    583,
    [
      "StatementList[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of |StatementListItem| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "StatementList[1,0].ContainsUndefinedBreakTarget",
        "name" : "StatementList[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2200,
    [
      "INTRINSICS.Date.prototype.getUTCDate",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return DateFromTime(_t_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getUTCDate",
        "name" : "INTRINSICS.Date.prototype.getUTCDate",
        "htmlId" : "sec-date.prototype.getutcdate",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2609,
    [
      "INTRINSICS.Set.prototype.forEach",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _entries_ be _S_.[[SetData]].\n          1. Let _numEntries_ be the number of elements in _entries_.\n          1. Let _index_ be 0.\n          1. Repeat, while _index_ < _numEntries_,\n            1. Let _e_ be _entries_[_index_].\n            1. Set _index_ to _index_ + 1.\n            1. If _e_ is not ~empty~, then\n              1. Perform ? Call(_callbackfn_, _thisArg_, « _e_, _e_, _S_ »).\n              1. NOTE: The number of elements in _entries_ may have increased during execution of _callbackfn_.\n              1. Set _numEntries_ to the number of elements in _entries_.\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Set.prototype.forEach",
        "name" : "INTRINSICS.Set.prototype.forEach",
        "htmlId" : "sec-set.prototype.foreach",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    522,
    [
      "IfStatement[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasDuplicate_ be ContainsDuplicateLabels of the first |Statement| with argument _labelSet_.\n        1. If _hasDuplicate_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of the second |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "IfStatement[0,0].ContainsDuplicateLabels",
        "name" : "IfStatement[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "else"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    830,
    [
      "FunctionExpression[0,1].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,1].Contains",
        "name" : "FunctionExpression[0,1].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    889,
    [
      "InitializeBoundName",
      0,
      [
        [
          "name",
          false,
          "String"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n          1. If _environment_ is not *undefined*, then\n            1. Perform ! _environment_.InitializeBinding(_name_, _value_).\n            1. Return ~unused~.\n          1. Else,\n            1. Let _lhs_ be ? ResolveBinding(_name_).\n            1. Return ? PutValue(_lhs_, _value_).\n        ",
      {
        "normalizedName" : "InitializeBoundName",
        "name" : "InitializeBoundName",
        "htmlId" : "sec-initializeboundname",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2179,
    [
      "LocalTime",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().\n          1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then\n            1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).\n          1. Else,\n            1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_t_) × 10<sup>6</sup>)).\n          1. Let _offsetMs_ be truncate(_offsetNs_ / 10<sup>6</sup>).\n          1. Return _t_ + 𝔽(_offsetMs_).\n        ",
      {
        "normalizedName" : "LocalTime",
        "name" : "LocalTime",
        "htmlId" : "sec-localtime",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1159,
    [
      "MakeArgSetter:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n            1. Let _setterClosure_ be a new Abstract Closure with parameters (_value_) that captures _name_ and _env_ and performs the following steps when called:\n              1. Return ! _env_.SetMutableBinding(_name_, _value_, *false*).\n            1. Let _setter_ be CreateBuiltinFunction(_setterClosure_, 1, *\"\"*, « »).\n            1. NOTE: _setter_ is never directly accessible to ECMAScript code.\n            1. Return _setter_.\n          ",
      {
        "normalizedName" : "MakeArgSetter",
        "name" : "MakeArgSetter",
        "htmlId" : "sec-makeargsetter",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    461,
    [
      "ForInOfStatement[4,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[4]]"
        ]
      ],
      "\n        1. Let _declarations1_ be « |ForBinding| ».\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[4,0].VarScopedDeclarations",
        "name" : "ForInOfStatement[4,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1836,
    [
      "EqualityExpression[4,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[4]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "EqualityExpression[4,0].HasCallInTailPosition",
        "name" : "EqualityExpression[4,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "!=="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1787,
    [
      "ForStatement[0,1].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[0,1].HasCallInTailPosition",
        "name" : "ForStatement[0,1].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2181,
    [
      "MakeTime",
      0,
      [
        [
          "hour",
          false,
          "Number"
        ],
        [
          "min",
          false,
          "Number"
        ],
        [
          "sec",
          false,
          "Number"
        ],
        [
          "ms",
          false,
          "Number"
        ]
      ],
      "\n          1. If _hour_ is not finite, _min_ is not finite, _sec_ is not finite, or _ms_ is not finite, return *NaN*.\n          1. Let _h_ be 𝔽(! ToIntegerOrInfinity(_hour_)).\n          1. Let _m_ be 𝔽(! ToIntegerOrInfinity(_min_)).\n          1. Let _s_ be 𝔽(! ToIntegerOrInfinity(_sec_)).\n          1. Let _milli_ be 𝔽(! ToIntegerOrInfinity(_ms_)).\n          1. Return ((_h_ × msPerHour + _m_ × msPerMinute) + _s_ × msPerSecond) + _milli_.\n        ",
      {
        "normalizedName" : "MakeTime",
        "name" : "MakeTime",
        "htmlId" : "sec-maketime",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    493,
    [
      "StatementList[1,0].TopLevelLexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be TopLevelLexicallyDeclaredNames of |StatementList|.\n        1. Let _names2_ be TopLevelLexicallyDeclaredNames of |StatementListItem|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "StatementList[1,0].TopLevelLexicallyDeclaredNames",
        "name" : "StatementList[1,0].TopLevelLexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-toplevellexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelLexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1210,
    [
      "ParseText",
      0,
      [
        [
          "sourceText",
          false,
          "Unknown[\"SequenceOfUnicodeCodePoint\"]"
        ],
        [
          "goalSymbol",
          false,
          "Unknown[\"NonterminalInOneOfTheECMAScriptGrammar\"]"
        ]
      ],
      "\n        1. Attempt to parse _sourceText_ using _goalSymbol_ as the goal symbol, and analyse the parse result for any early error conditions. Parsing and early error detection may be interleaved in an implementation-defined manner.\n        1. If the parse succeeded and no early errors were found, return the Parse Node (an instance of _goalSymbol_) at the root of the parse tree resulting from the parse.\n        1. Otherwise, return a List of one or more *SyntaxError* objects representing the parsing errors and/or early errors. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-defined, but at least one must be present.\n      ",
      {
        "normalizedName" : "ParseText",
        "name" : "ParseText",
        "htmlId" : "sec-parsetext",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1656,
    [
      "AsyncGeneratorBody[0,0].EvaluateAsyncGeneratorBody",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).\n        1. Let _generator_ be ? OrdinaryCreateFromConstructor(_functionObject_, *\"%AsyncGeneratorFunction.prototype.prototype%\"*, « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] »).\n        1. Set _generator_.[[GeneratorBrand]] to ~empty~.\n        1. Set _generator_.[[AsyncGeneratorState]] to *undefined*.\n        1. Perform AsyncGeneratorStart(_generator_, |FunctionBody|).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _generator_, [[Target]]: ~empty~ }.\n      ",
      {
        "normalizedName" : "AsyncGeneratorBody[0,0].EvaluateAsyncGeneratorBody",
        "name" : "AsyncGeneratorBody[0,0].EvaluateAsyncGeneratorBody",
        "htmlId" : "sec-runtime-semantics-evaluateasyncgeneratorbody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateAsyncGeneratorBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1079,
    [
      "AddToKeptObjects",
      0,
      [
        [
          "value",
          false,
          "Record[Object | Symbol]"
        ]
      ],
      "\n      1. Let _agentRecord_ be the surrounding agent's Agent Record.\n      1. Append _value_ to _agentRecord_.[[KeptAlive]].\n      1. Return ~unused~.\n    ",
      {
        "normalizedName" : "AddToKeptObjects",
        "name" : "AddToKeptObjects",
        "htmlId" : "sec-addtokeptobjects",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1027,
    [
      "Record[FunctionEnvironmentRecord].BindThisValue",
      3,
      [
        [
          "envRec",
          false,
          "Record[FunctionEnvironmentRecord]"
        ],
        [
          "V",
          false,
          "ESValue"
        ]
      ],
      "\n            1. Assert: _envRec_.[[ThisBindingStatus]] is not ~lexical~.\n            1. If _envRec_.[[ThisBindingStatus]] is ~initialized~, throw a *ReferenceError* exception.\n            1. Set _envRec_.[[ThisValue]] to _V_.\n            1. Set _envRec_.[[ThisBindingStatus]] to ~initialized~.\n            1. Return _V_.\n          ",
      {
        "normalizedName" : "Record[FunctionEnvironmentRecord].BindThisValue",
        "name" : "Record[FunctionEnvironmentRecord].BindThisValue",
        "htmlId" : "sec-bindthisvalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "FunctionEnvironmentRecord",
          "BindThisValue"
        ]
      }
    ]
  ],
  [
    2327,
    [
      "ClassSubtraction[1,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSubtraction[1]]"
        ]
      ],
      "\n          1. Return MayContainStrings of the |ClassSubtraction|.\n        ",
      {
        "normalizedName" : "ClassSubtraction[1,0].MayContainStrings",
        "name" : "ClassSubtraction[1,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassSubtraction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSubtraction"
              },
              {
                "type" : "terminal",
                "value" : "--"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2213,
    [
      "INTRINSICS.Date.prototype.setMonth",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _m_ be ? ToNumber(_month_).\n          1. If _date_ is present, let _dt_ be ? ToNumber(_date_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Set _t_ to LocalTime(_t_).\n          1. If _date_ is not present, let _dt_ be DateFromTime(_t_).\n          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).\n          1. Let _u_ be TimeClip(UTC(_newDate_)).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setMonth",
        "name" : "INTRINSICS.Date.prototype.setMonth",
        "htmlId" : "sec-date.prototype.setmonth",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    757,
    [
      "RelationalExpression[3,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[3]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[3,0].IsFunctionDefinition",
        "name" : "RelationalExpression[3,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "<="
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2345,
    [
      "Disjunction[1,0].CompileSubpattern",
      2,
      [
        [
          "this",
          false,
          "Ast[Disjunction[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Let _m1_ be CompileSubpattern of |Alternative| with arguments _rer_ and _direction_.\n          1. Let _m2_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.\n          1. Return MatchTwoAlternatives(_m1_, _m2_).\n        ",
      {
        "normalizedName" : "Disjunction[1,0].CompileSubpattern",
        "name" : "Disjunction[1,0].CompileSubpattern",
        "htmlId" : "sec-compilesubpattern",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileSubpattern",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Disjunction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Alternative"
              },
              {
                "type" : "terminal",
                "value" : "|"
              },
              {
                "type" : "nonterminal",
                "value" : "Disjunction"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    682,
    [
      "SwitchStatement[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[SwitchStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |CaseBlock| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "SwitchStatement[0,0].ContainsUndefinedContinueTarget",
        "name" : "SwitchStatement[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SwitchStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "switch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1195,
    [
      "Record[ProxyExoticObject].GetOwnProperty",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"getOwnPropertyDescriptor\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. Let _trapResultObj_ be ? Call(_trap_, _handler_, « _target_, _P_ »).\n        1. If _trapResultObj_ is not an Object and _trapResultObj_ is not *undefined*, throw a *TypeError* exception.\n        1. Let _targetDesc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. If _trapResultObj_ is *undefined*, then\n          1. If _targetDesc_ is *undefined*, return *undefined*.\n          1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.\n          1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n          1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.\n          1. Return *undefined*.\n        1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n        1. Let _resultDesc_ be ? ToPropertyDescriptor(_trapResultObj_).\n        1. Perform CompletePropertyDescriptor(_resultDesc_).\n        1. Let _valid_ be IsCompatiblePropertyDescriptor(_extensibleTarget_, _resultDesc_, _targetDesc_).\n        1. If _valid_ is *false*, throw a *TypeError* exception.\n        1. If _resultDesc_.[[Configurable]] is *false*, then\n          1. If _targetDesc_ is *undefined* or _targetDesc_.[[Configurable]] is *true*, then\n            1. Throw a *TypeError* exception.\n          1. If _resultDesc_ has a [[Writable]] field and _resultDesc_.[[Writable]] is *false*, then\n            1. Assert: _targetDesc_ has a [[Writable]] field.\n            1. If _targetDesc_.[[Writable]] is *true*, throw a *TypeError* exception.\n        1. Return _resultDesc_.\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].GetOwnProperty",
        "name" : "Record[ProxyExoticObject].GetOwnProperty",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[GetOwnProperty]]"
        ]
      }
    ]
  ],
  [
    2211,
    [
      "INTRINSICS.Date.prototype.setMilliseconds",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Set _ms_ to ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Set _t_ to LocalTime(_t_).\n          1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_).\n          1. Let _u_ be TimeClip(UTC(MakeDate(Day(_t_), _time_))).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setMilliseconds",
        "name" : "INTRINSICS.Date.prototype.setMilliseconds",
        "htmlId" : "sec-date.prototype.setmilliseconds",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1407,
    [
      "AssignmentProperty[0,1].PropertyDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentProperty[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _P_ be StringValue of |IdentifierReference|.\n          1. Let _lref_ be ? ResolveBinding(_P_).\n          1. Let _v_ be ? GetV(_value_, _P_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n              1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _P_.\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Set _v_ to ? GetValue(_defaultValue_).\n          1. Perform ? PutValue(_lref_, _v_).\n          1. Return « _P_ ».\n        ",
      {
        "normalizedName" : "AssignmentProperty[0,1].PropertyDestructuringAssignmentEvaluation",
        "name" : "AssignmentProperty[0,1].PropertyDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-propertydestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AssignmentProperty",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierReference"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2313,
    [
      "CharacterClassEscape[7,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[7]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "CharacterClassEscape[7,0].MayContainStrings",
        "name" : "CharacterClassEscape[7,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "P{"
              },
              {
                "type" : "nonterminal",
                "value" : "UnicodePropertyValueExpression"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2492,
    [
      "INTRINSICS.Array.prototype.findLast",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Value]].\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.findLast",
        "name" : "INTRINSICS.Array.prototype.findLast",
        "htmlId" : "sec-array.prototype.findlast",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2547,
    [
      "INTRINSICS.TypedArray.prototype.forEach",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Perform ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n            1. Set _k_ to _k_ + 1.\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.forEach",
        "name" : "INTRINSICS.TypedArray.prototype.forEach",
        "htmlId" : "sec-%typedarray%.prototype.foreach",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2344,
    [
      "Pattern[0,0].CompilePattern",
      2,
      [
        [
          "this",
          false,
          "Ast[Pattern[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.\n          1. Return a new Abstract Closure with parameters (_Input_, _index_) that captures _rer_ and _m_ and performs the following steps when called:\n            1. Assert: _Input_ is a List of characters.\n            1. Assert: 0 ≤ _index_ ≤ the number of elements in _Input_.\n            1. Let _c_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Return _y_.\n            1. Let _cap_ be a List of _rer_.[[CapturingGroupsCount]] *undefined* values, indexed 1 through _rer_.[[CapturingGroupsCount]].\n            1. Let _x_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _index_, [[Captures]]: _cap_ }.\n            1. Return _m_(_x_, _c_).\n        ",
      {
        "normalizedName" : "Pattern[0,0].CompilePattern",
        "name" : "Pattern[0,0].CompilePattern",
        "htmlId" : "sec-compilepattern",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompilePattern",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Pattern",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Disjunction"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    551,
    [
      "WithStatement[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[WithStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "WithStatement[0,0].ContainsDuplicateLabels",
        "name" : "WithStatement[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WithStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "with"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1128,
    [
      "MakeClassConstructor",
      0,
      [
        [
          "F",
          false,
          "Record[ECMAScriptFunctionObject]"
        ]
      ],
      "\n        1. Assert: _F_.[[IsClassConstructor]] is *false*.\n        1. Set _F_.[[IsClassConstructor]] to *true*.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "MakeClassConstructor",
        "name" : "MakeClassConstructor",
        "htmlId" : "sec-makeclassconstructor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1281,
    [
      "SubstitutionTemplate[0,0].TemplateStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[SubstitutionTemplate[0]]"
        ],
        [
          "raw",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Let _head_ be « TemplateString(|TemplateHead|, _raw_) ».\n          1. Let _tail_ be TemplateStrings of |TemplateSpans| with argument _raw_.\n          1. Return the list-concatenation of _head_ and _tail_.\n        ",
      {
        "normalizedName" : "SubstitutionTemplate[0,0].TemplateStrings",
        "name" : "SubstitutionTemplate[0,0].TemplateStrings",
        "htmlId" : "sec-static-semantics-templatestrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TemplateStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SubstitutionTemplate",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateHead"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateSpans"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2741,
    [
      "INTRINSICS.AsyncIteratorPrototype[@@asyncIterator]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return the *this* value.\n        ",
      {
        "normalizedName" : "INTRINSICS.AsyncIteratorPrototype[@@asyncIterator]",
        "name" : "INTRINSICS.AsyncIteratorPrototype[@@asyncIterator]",
        "htmlId" : "sec-asynciteratorprototype-asynciterator",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1634,
    [
      "MethodDefinition[1,0].SpecialMethod",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[1]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "MethodDefinition[1,0].SpecialMethod",
        "name" : "MethodDefinition[1,0].SpecialMethod",
        "htmlId" : "sec-static-semantics-specialmethod",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "SpecialMethod",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "GeneratorMethod"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1392,
    [
      "ObjectAssignmentPattern[2,0].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectAssignmentPattern[2]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Perform ? RequireObjectCoercible(_value_).\n          1. Perform ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "ObjectAssignmentPattern[2,0].DestructuringAssignmentEvaluation",
        "name" : "ObjectAssignmentPattern[2,0].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ObjectAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentPropertyList"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2228,
    [
      "DateString",
      0,
      [
        [
          "tv",
          false,
          "Unknown[\"Number,ButNot*NaN*\"]"
        ]
      ],
      "\n            1. Let _weekday_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-day-names\"></emu-xref> with the Number WeekDay(_tv_).\n            1. Let _month_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-month-names\"></emu-xref> with the Number MonthFromTime(_tv_).\n            1. Let _day_ be ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2).\n            1. Let _yv_ be YearFromTime(_tv_).\n            1. If _yv_ is *+0*<sub>𝔽</sub> or _yv_ > *+0*<sub>𝔽</sub>, let _yearSign_ be the empty String; otherwise, let _yearSign_ be *\"-\"*.\n            1. Let _paddedYear_ be ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4).\n            1. Return the string-concatenation of _weekday_, the code unit 0x0020 (SPACE), _month_, the code unit 0x0020 (SPACE), _day_, the code unit 0x0020 (SPACE), _yearSign_, and _paddedYear_.\n          ",
      {
        "normalizedName" : "DateString",
        "name" : "DateString",
        "htmlId" : "sec-datestring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2112,
    [
      "INTRINSICS.Number.prototype.toExponential",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _x_ be ? ThisNumberValue(*this* value).\n          1. Let _f_ be ? ToIntegerOrInfinity(_fractionDigits_).\n          1. Assert: If _fractionDigits_ is *undefined*, then _f_ is 0.\n          1. If _x_ is not finite, return Number::toString(_x_, 10).\n          1. If _f_ < 0 or _f_ > 100, throw a *RangeError* exception.\n          1. Set _x_ to ℝ(_x_).\n          1. Let _s_ be the empty String.\n          1. If _x_ < 0, then\n            1. Set _s_ to *\"-\"*.\n            1. Set _x_ to -_x_.\n          1. If _x_ = 0, then\n            1. Let _m_ be the String value consisting of _f_ + 1 occurrences of the code unit 0x0030 (DIGIT ZERO).\n            1. Let _e_ be 0.\n          1. Else,\n            1. If _fractionDigits_ is not *undefined*, then\n              1. Let _e_ and _n_ be integers such that 10<sup>_f_</sup> ≤ _n_ < 10<sup>_f_ + 1</sup> and for which _n_ × 10<sup>_e_ - _f_</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ × 10<sup>_e_ - _f_</sup> is larger.\n            1. Else,\n              1. [id=\"step-number-proto-toexponential-intermediate-values\"] Let _e_, _n_, and _ff_ be integers such that _ff_ ≥ 0, 10<sup>_ff_</sup> ≤ _n_ < 10<sup>_ff_ + 1</sup>, 𝔽(_n_ × 10<sup>_e_ - _ff_</sup>) is 𝔽(_x_), and _ff_ is as small as possible. Note that the decimal representation of _n_ has _ff_ + 1 digits, _n_ is not divisible by 10, and the least significant digit of _n_ is not necessarily uniquely determined by these criteria.\n              1. Set _f_ to _ff_.\n            1. Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).\n          1. If _f_ ≠ 0, then\n            1. Let _a_ be the first code unit of _m_.\n            1. Let _b_ be the other _f_ code units of _m_.\n            1. Set _m_ to the string-concatenation of _a_, *\".\"*, and _b_.\n          1. If _e_ = 0, then\n            1. Let _c_ be *\"+\"*.\n            1. Let _d_ be *\"0\"*.\n          1. Else,\n            1. If _e_ > 0, then\n              1. Let _c_ be *\"+\"*.\n            1. Else,\n              1. Assert: _e_ < 0.\n              1. Let _c_ be *\"-\"*.\n              1. Set _e_ to -_e_.\n            1. Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).\n          1. Set _m_ to the string-concatenation of _m_, *\"e\"*, _c_, and _d_.\n          1. Return the string-concatenation of _s_ and _m_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Number.prototype.toExponential",
        "name" : "INTRINSICS.Number.prototype.toExponential",
        "htmlId" : "sec-number.prototype.toexponential",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1291,
    [
      "TemplateMiddleList[1,0].SubstitutionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateMiddleList[1]]"
        ]
      ],
      "\n          1. Let _preceding_ be ? SubstitutionEvaluation of |TemplateMiddleList|.\n          1. Let _nextRef_ be ? Evaluation of |Expression|.\n          1. Let _next_ be ? GetValue(_nextRef_).\n          1. Return the list-concatenation of _preceding_ and « _next_ ».\n        ",
      {
        "normalizedName" : "TemplateMiddleList[1,0].SubstitutionEvaluation",
        "name" : "TemplateMiddleList[1,0].SubstitutionEvaluation",
        "htmlId" : "sec-runtime-semantics-substitutionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "SubstitutionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TemplateMiddleList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateMiddleList"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateMiddle"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    710,
    [
      "AsyncArrowFunction[0,0].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowFunction[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncArrowFunction[0,0].HasName",
        "name" : "AsyncArrowFunction[0,0].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncArrowFunction",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncArrowBindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    456,
    [
      "ForInOfStatement[3,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[3]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForInOfStatement[3,0].VarScopedDeclarations",
        "name" : "ForInOfStatement[3,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1740,
    [
      "ClassTail[0,2].ClassDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassTail[0]]"
        ],
        [
          "classBinding",
          false,
          "String | Undefined"
        ],
        [
          "className",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.\n        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n        1. If |ClassBody| is present, then\n          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do\n            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then\n              1. Assert: This is only possible for getter/setter pairs.\n            1. Else,\n              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.\n              1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n        1. If |ClassHeritage| is not present, then\n          1. Let _protoParent_ be %Object.prototype%.\n          1. Let _constructorParent_ be %Function.prototype%.\n        1. Else,\n          1. Set the running execution context's LexicalEnvironment to _classEnv_.\n          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).\n          1. Set the running execution context's LexicalEnvironment to _env_.\n          1. Let _superclass_ be ? GetValue(? _superclassRef_).\n          1. If _superclass_ is *null*, then\n            1. Let _protoParent_ be *null*.\n            1. Let _constructorParent_ be %Function.prototype%.\n          1. Else if IsConstructor(_superclass_) is *false*, then\n            1. Throw a *TypeError* exception.\n          1. Else,\n            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.\n            1. Let _constructorParent_ be _superclass_.\n        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n        1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n        1. Set the running execution context's LexicalEnvironment to _classEnv_.\n        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.\n        1. If _constructor_ is ~empty~, then\n          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n            1. If NewTarget is *undefined*, throw a *TypeError* exception.\n            1. Let _F_ be the active function object.\n            1. If _F_.[[ConstructorKind]] is ~derived~, then\n              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n            1. Else,\n              1. NOTE: This branch behaves similarly to `constructor() {}`.\n              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n            1. Perform ? InitializeInstanceElements(_result_, _F_).\n            1. Return _result_.\n          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n        1. Else,\n          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n          1. Let _F_ be _constructorInfo_.[[Closure]].\n          1. Perform MakeClassConstructor(_F_).\n          1. Perform SetFunctionName(_F_, _className_).\n        1. Perform MakeConstructor(_F_, *false*, _proto_).\n        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n        1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n        1. If |ClassBody| is not present, let _elements_ be a new empty List.\n        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n        1. Let _instancePrivateMethods_ be a new empty List.\n        1. Let _staticPrivateMethods_ be a new empty List.\n        1. Let _instanceFields_ be a new empty List.\n        1. Let _staticElements_ be a new empty List.\n        1. For each |ClassElement| _e_ of _elements_, do\n          1. If IsStatic of _e_ is *false*, then\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n          1. Else,\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n          1. If _element_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _env_.\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _element_.\n          1. Set _element_ to ! _element_.\n          1. If _element_ is a PrivateElement, then\n            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n            1. Else, let _container_ be _staticPrivateMethods_.\n            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.\n              1. If _element_.[[Get]] is *undefined*, then\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n              1. Else,\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n              1. Replace _pe_ in _container_ with _combined_.\n            1. Else,\n              1. Append _element_ to _container_.\n          1. Else if _element_ is a ClassFieldDefinition Record, then\n            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n            1. Else, append _element_ to _staticElements_.\n          1. Else if _element_ is a ClassStaticBlockDefinition Record, then\n            1. Append _element_ to _staticElements_.\n        1. Set the running execution context's LexicalEnvironment to _env_.\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n        1. Set _F_.[[Fields]] to _instanceFields_.\n        1. For each PrivateElement _method_ of _staticPrivateMethods_, do\n          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n        1. For each element _elementRecord_ of _staticElements_, do\n          1. If _elementRecord_ is a ClassFieldDefinition Record, then\n            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n          1. Else,\n            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.\n            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n          1. If _result_ is an abrupt completion, then\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _result_.\n        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "ClassTail[0,2].ClassDefinitionEvaluation",
        "name" : "ClassTail[0,2].ClassDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-classdefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 2,
            "astName" : "ClassTail",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassHeritage"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1910,
    [
      "Script[0,0].IsStrict",
      2,
      [
        [
          "this",
          false,
          "Ast[Script[0]]"
        ]
      ],
      "\n        1. If |ScriptBody| is present and the Directive Prologue of |ScriptBody| contains a Use Strict Directive, return *true*; otherwise, return *false*.\n      ",
      {
        "normalizedName" : "Script[0,0].IsStrict",
        "name" : "Script[0,0].IsStrict",
        "htmlId" : "sec-static-semantics-isstrict",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsStrict",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Script",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    842,
    [
      "AsyncFunctionExpression[0,1].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,1].Contains",
        "name" : "AsyncFunctionExpression[0,1].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    324,
    [
      "CaseBlock[1,1].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _declarations1_ be the LexicallyScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the LexicallyScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,1].LexicallyScopedDeclarations",
        "name" : "CaseBlock[1,1].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1573,
    [
      "SingleNameBinding[0,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[SingleNameBinding[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "SingleNameBinding[0,0].ContainsExpression",
        "name" : "SingleNameBinding[0,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SingleNameBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    974,
    [
      "BitwiseANDExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[BitwiseANDExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "BitwiseANDExpression[1,0].AssignmentTargetType",
        "name" : "BitwiseANDExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BitwiseANDExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BitwiseANDExpression"
              },
              {
                "type" : "terminal",
                "value" : "&"
              },
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2769,
    [
      "INTRINSICS.yet:`Promise.allSettled`RejectElementFunction",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _F_ be the active function object.\n            1. Let _alreadyCalled_ be _F_.[[AlreadyCalled]].\n            1. If _alreadyCalled_.[[Value]] is *true*, return *undefined*.\n            1. Set _alreadyCalled_.[[Value]] to *true*.\n            1. Let _index_ be _F_.[[Index]].\n            1. Let _values_ be _F_.[[Values]].\n            1. Let _promiseCapability_ be _F_.[[Capability]].\n            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].\n            1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"status\"*, *\"rejected\"*).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"reason\"*, _x_).\n            1. Set _values_[_index_] to _obj_.\n            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n            1. If _remainingElementsCount_.[[Value]] = 0, then\n              1. Let _valuesArray_ be CreateArrayFromList(_values_).\n              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n            1. Return *undefined*.\n          ",
      {
        "normalizedName" : "INTRINSICS.yet:Promise.allSettledRejectElementFunction",
        "name" : "INTRINSICS.yet:`Promise.allSettled`RejectElementFunction",
        "htmlId" : "sec-promise.allsettled-reject-element-functions",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1012,
    [
      "Record[DeclarativeEnvironmentRecord].SetMutableBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "S",
          false,
          "Boolean"
        ]
      ],
      "\n            1. [id=\"step-setmutablebinding-missing-binding\"] If _envRec_ does not have a binding for _N_, then\n              1. If _S_ is *true*, throw a *ReferenceError* exception.\n              1. Perform ! _envRec_.CreateMutableBinding(_N_, *true*).\n              1. Perform ! _envRec_.InitializeBinding(_N_, _V_).\n              1. Return ~unused~.\n            1. If the binding for _N_ in _envRec_ is a strict binding, set _S_ to *true*.\n            1. If the binding for _N_ in _envRec_ has not yet been initialized, then\n              1. Throw a *ReferenceError* exception.\n            1. Else if the binding for _N_ in _envRec_ is a mutable binding, then\n              1. Change its bound value to _V_.\n            1. Else,\n              1. Assert: This is an attempt to change the value of an immutable binding.\n              1. If _S_ is *true*, throw a *TypeError* exception.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[DeclarativeEnvironmentRecord].SetMutableBinding",
        "name" : "Record[DeclarativeEnvironmentRecord].SetMutableBinding",
        "htmlId" : "sec-declarative-environment-records-setmutablebinding-n-v-s",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "DeclarativeEnvironmentRecord",
          "SetMutableBinding"
        ]
      }
    ]
  ],
  [
    2653,
    [
      "INTRINSICS.ArrayBuffer.prototype.transferToFixedLength",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Return ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~fixed-length~).\n        ",
      {
        "normalizedName" : "INTRINSICS.ArrayBuffer.prototype.transferToFixedLength",
        "name" : "INTRINSICS.ArrayBuffer.prototype.transferToFixedLength",
        "htmlId" : "sec-arraybuffer.prototype.transfertofixedlength",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    285,
    [
      "ClassDeclaration[0,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassDeclaration[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassDeclaration[0,0].IsConstantDeclaration",
        "name" : "ClassDeclaration[0,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    224,
    [
      "ArrayBindingPattern[0,3].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingRestElement|.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[0,3].BoundNames",
        "name" : "ArrayBindingPattern[0,3].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1106,
    [
      "OrdinaryOwnPropertyKeys",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Let _keys_ be a new empty List.\n          1. For each own property key _P_ of _O_ such that _P_ is an array index, in ascending numeric index order, do\n            1. Append _P_ to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is a String and _P_ is not an array index, in ascending chronological order of property creation, do\n            1. Append _P_ to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is a Symbol, in ascending chronological order of property creation, do\n            1. Append _P_ to _keys_.\n          1. Return _keys_.\n        ",
      {
        "normalizedName" : "OrdinaryOwnPropertyKeys",
        "name" : "OrdinaryOwnPropertyKeys",
        "htmlId" : "sec-ordinaryownpropertykeys",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1402,
    [
      "ArrayAssignmentPattern[2,1].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayAssignmentPattern[2]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n          1. If _status_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n            1. Return ? _status_.\n          1. If |Elision| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n            1. If _status_ is an abrupt completion, then\n              1. Assert: _iteratorRecord_.[[Done]] is *true*.\n              1. Return ? _status_.\n          1. If |AssignmentRestElement| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n          1. Return ? _status_.\n        ",
      {
        "normalizedName" : "ArrayAssignmentPattern[2,1].DestructuringAssignmentEvaluation",
        "name" : "ArrayAssignmentPattern[2,1].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ArrayAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1983,
    [
      "ModuleItemList[1,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ]
      ],
      "\n          1. Let _names1_ be ExportedNames of |ModuleItemList|.\n          1. Let _names2_ be ExportedNames of |ModuleItem|.\n          1. Return the list-concatenation of _names1_ and _names2_.\n        ",
      {
        "normalizedName" : "ModuleItemList[1,0].ExportedNames",
        "name" : "ModuleItemList[1,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    169,
    [
      "GetMethod",
      0,
      [
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n        1. Let _func_ be ? GetV(_V_, _P_).\n        1. If _func_ is either *undefined* or *null*, return *undefined*.\n        1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.\n        1. Return _func_.\n      ",
      {
        "normalizedName" : "GetMethod",
        "name" : "GetMethod",
        "htmlId" : "sec-getmethod",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    593,
    [
      "ForStatement[0,5].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,5].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[0,5].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 5,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    989,
    [
      "Expression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[Expression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "Expression[1,0].AssignmentTargetType",
        "name" : "Expression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Expression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1360,
    [
      "AdditiveExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AdditiveExpression[1]]"
        ]
      ],
      "\n          1. Return ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `+`, |MultiplicativeExpression|).\n        ",
      {
        "normalizedName" : "AdditiveExpression[1,0].Evaluation",
        "name" : "AdditiveExpression[1,0].Evaluation",
        "htmlId" : "sec-addition-operator-plus-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AdditiveExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              },
              {
                "type" : "terminal",
                "value" : "+"
              },
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2245,
    [
      "INTRINSICS.String.prototype.includes",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _isRegExp_ be ? IsRegExp(_searchString_).\n          1. If _isRegExp_ is *true*, throw a *TypeError* exception.\n          1. Let _searchStr_ be ? ToString(_searchString_).\n          1. Let _pos_ be ? ToIntegerOrInfinity(_position_).\n          1. Assert: If _position_ is *undefined*, then _pos_ is 0.\n          1. Let _len_ be the length of _S_.\n          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.\n          1. Let _index_ be StringIndexOf(_S_, _searchStr_, _start_).\n          1. If _index_ ≠ -1, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.includes",
        "name" : "INTRINSICS.String.prototype.includes",
        "htmlId" : "sec-string.prototype.includes",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1350,
    [
      "UpdateExpression[4,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[4]]"
        ]
      ],
      "\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).\n          1. If _oldValue_ is a Number, then\n            1. Let _newValue_ be Number::subtract(_oldValue_, *1*<sub>𝔽</sub>).\n          1. Else,\n            1. Assert: _oldValue_ is a BigInt.\n            1. Let _newValue_ be BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>).\n          1. Perform ? PutValue(_expr_, _newValue_).\n          1. Return _newValue_.\n        ",
      {
        "normalizedName" : "UpdateExpression[4,0].Evaluation",
        "name" : "UpdateExpression[4,0].Evaluation",
        "htmlId" : "sec-prefix-decrement-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "--"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1936,
    [
      "InnerModuleEvaluation",
      0,
      [
        [
          "module",
          false,
          "Record[ModuleRecord]"
        ],
        [
          "stack",
          false,
          "List[Record[CyclicModuleRecord]]"
        ],
        [
          "index",
          false,
          "Int[0+]"
        ]
      ],
      "\n              1. If _module_ is not a Cyclic Module Record, then\n                1. Let _promise_ be ! _module_.Evaluate().\n                1. Assert: _promise_.[[PromiseState]] is not ~pending~.\n                1. If _promise_.[[PromiseState]] is ~rejected~, then\n                  1. Return ThrowCompletion(_promise_.[[PromiseResult]]).\n                1. Return _index_.\n              1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, then\n                1. If _module_.[[EvaluationError]] is ~empty~, return _index_.\n                1. Otherwise, return ? _module_.[[EvaluationError]].\n              1. If _module_.[[Status]] is ~evaluating~, return _index_.\n              1. Assert: _module_.[[Status]] is ~linked~.\n              1. Set _module_.[[Status]] to ~evaluating~.\n              1. Set _module_.[[DFSIndex]] to _index_.\n              1. Set _module_.[[DFSAncestorIndex]] to _index_.\n              1. Set _module_.[[PendingAsyncDependencies]] to 0.\n              1. Set _index_ to _index_ + 1.\n              1. Append _module_ to _stack_.\n              1. For each String _required_ of _module_.[[RequestedModules]], do\n                1. Let _requiredModule_ be GetImportedModule(_module_, _required_).\n                1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).\n                1. If _requiredModule_ is a Cyclic Module Record, then\n                  1. Assert: _requiredModule_.[[Status]] is one of ~evaluating~, ~evaluating-async~, or ~evaluated~.\n                  1. Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _stack_ contains _requiredModule_.\n                  1. If _requiredModule_.[[Status]] is ~evaluating~, then\n                    1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).\n                  1. Else,\n                    1. Set _requiredModule_ to _requiredModule_.[[CycleRoot]].\n                    1. Assert: _requiredModule_.[[Status]] is either ~evaluating-async~ or ~evaluated~.\n                    1. If _requiredModule_.[[EvaluationError]] is not ~empty~, return ? _requiredModule_.[[EvaluationError]].\n                  1. If _requiredModule_.[[AsyncEvaluation]] is *true*, then\n                    1. Set _module_.[[PendingAsyncDependencies]] to _module_.[[PendingAsyncDependencies]] + 1.\n                    1. Append _module_ to _requiredModule_.[[AsyncParentModules]].\n              1. If _module_.[[PendingAsyncDependencies]] > 0 or _module_.[[HasTLA]] is *true*, then\n                1. Assert: _module_.[[AsyncEvaluation]] is *false* and was never previously set to *true*.\n                1. Set _module_.[[AsyncEvaluation]] to *true*.\n                1. NOTE: The order in which module records have their [[AsyncEvaluation]] fields transition to *true* is significant. (See <emu-xref href=\"#sec-async-module-execution-fulfilled\"></emu-xref>.)\n                1. If _module_.[[PendingAsyncDependencies]] = 0, perform ExecuteAsyncModule(_module_).\n              1. Else,\n                1. Perform ? <emu-meta effects=\"user-code\">_module_.ExecuteModule()</emu-meta>.\n              1. Assert: _module_ occurs exactly once in _stack_.\n              1. Assert: _module_.[[DFSAncestorIndex]] ≤ _module_.[[DFSIndex]].\n              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then\n                1. Let _done_ be *false*.\n                1. Repeat, while _done_ is *false*,\n                  1. Let _requiredModule_ be the last element of _stack_.\n                  1. Remove the last element of _stack_.\n                  1. Assert: _requiredModule_ is a Cyclic Module Record.\n                  1. If _requiredModule_.[[AsyncEvaluation]] is *false*, set _requiredModule_.[[Status]] to ~evaluated~.\n                  1. Otherwise, set _requiredModule_.[[Status]] to ~evaluating-async~.\n                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.\n                  1. Set _requiredModule_.[[CycleRoot]] to _module_.\n              1. Return _index_.\n            ",
      {
        "normalizedName" : "InnerModuleEvaluation",
        "name" : "InnerModuleEvaluation",
        "htmlId" : "sec-innermoduleevaluation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    519,
    [
      "Block[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[Block[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Block[0,0].ContainsDuplicateLabels",
        "name" : "Block[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Block",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1592,
    [
      "ArrowParameters[0,0].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowParameters[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "ArrowParameters[0,0].IsSimpleParameterList",
        "name" : "ArrowParameters[0,0].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrowParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    742,
    [
      "UnaryExpression[3,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[3]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[3,0].IsFunctionDefinition",
        "name" : "UnaryExpression[3,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "typeof"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2300,
    [
      "HexLeadSurrogate[0,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[HexLeadSurrogate[0]]"
        ]
      ],
      "\n          1. Return the MV of |Hex4Digits|.\n        ",
      {
        "normalizedName" : "HexLeadSurrogate[0,0].CharacterValue",
        "name" : "HexLeadSurrogate[0,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "HexLeadSurrogate",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Hex4Digits"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    578,
    [
      "Statement[8,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[8]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[8,0].ContainsUndefinedBreakTarget",
        "name" : "Statement[8,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ReturnStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    697,
    [
      "TryStatement[2,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[2]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If ContainsUndefinedContinueTarget of |Catch| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of |Finally| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "TryStatement[2,0].ContainsUndefinedContinueTarget",
        "name" : "TryStatement[2,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1234,
    [
      "LabelIdentifier[2,0].StringValue",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelIdentifier[2]]"
        ]
      ],
      "\n        1. Return *\"await\"*.\n      ",
      {
        "normalizedName" : "LabelIdentifier[2,0].StringValue",
        "name" : "LabelIdentifier[2,0].StringValue",
        "htmlId" : "sec-static-semantics-stringvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringValue",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "LabelIdentifier",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "await"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1541,
    [
      "Statement[4,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[4]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |Statement|.\n      ",
      {
        "normalizedName" : "Statement[4,0].LabelledEvaluation",
        "name" : "Statement[4,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IfStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1089,
    [
      "OrdinaryPreventExtensions",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Set _O_.[[Extensible]] to *false*.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "OrdinaryPreventExtensions",
        "name" : "OrdinaryPreventExtensions",
        "htmlId" : "sec-ordinarypreventextensions",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2498,
    [
      "INTRINSICS.Array.prototype.forEach",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Perform ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n            1. Set _k_ to _k_ + 1.\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.forEach",
        "name" : "INTRINSICS.Array.prototype.forEach",
        "htmlId" : "sec-array.prototype.foreach",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    874,
    [
      "GeneratorDeclaration[1,0].InstantiateFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorDeclaration[1]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Return InstantiateGeneratorFunctionObject of |GeneratorDeclaration| with arguments _env_ and _privateEnv_.\n      ",
      {
        "normalizedName" : "GeneratorDeclaration[1,0].InstantiateFunctionObject",
        "name" : "GeneratorDeclaration[1,0].InstantiateFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiatefunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "GeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2157,
    [
      "INTRINSICS.Math.tanh",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *+∞*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n          1. If _n_ is *-∞*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of the hyperbolic tangent of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.tanh",
        "name" : "INTRINSICS.Math.tanh",
        "htmlId" : "sec-math.tanh",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2840,
    [
      "INTRINSICS.Reflect.deleteProperty",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[Delete]]</emu-meta>(_key_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.deleteProperty",
        "name" : "INTRINSICS.Reflect.deleteProperty",
        "htmlId" : "sec-reflect.deleteproperty",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1143,
    [
      "ArraySpeciesCreate",
      0,
      [
        [
          "originalArray",
          false,
          "Record[Object]"
        ],
        [
          "length",
          false,
          "Int[0+]"
        ]
      ],
      "\n          1. Let _isArray_ be ? IsArray(_originalArray_).\n          1. If _isArray_ is *false*, return ? ArrayCreate(_length_).\n          1. Let _C_ be ? Get(_originalArray_, *\"constructor\"*).\n          1. If IsConstructor(_C_) is *true*, then\n            1. Let _thisRealm_ be the current Realm Record.\n            1. Let _realmC_ be ? GetFunctionRealm(_C_).\n            1. If _thisRealm_ and _realmC_ are not the same Realm Record, then\n              1. If SameValue(_C_, _realmC_.[[Intrinsics]].[[%Array%]]) is *true*, set _C_ to *undefined*.\n          1. If _C_ is an Object, then\n            1. Set _C_ to ? Get(_C_, @@species).\n            1. If _C_ is *null*, set _C_ to *undefined*.\n          1. If _C_ is *undefined*, return ? ArrayCreate(_length_).\n          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n          1. Return ? Construct(_C_, « 𝔽(_length_) »).\n        ",
      {
        "normalizedName" : "ArraySpeciesCreate",
        "name" : "ArraySpeciesCreate",
        "htmlId" : "sec-arrayspeciescreate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2115,
    [
      "INTRINSICS.Number.prototype.toString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _x_ be ? ThisNumberValue(*this* value).\n          1. If _radix_ is *undefined*, let _radixMV_ be 10.\n          1. Else, let _radixMV_ be ? ToIntegerOrInfinity(_radix_).\n          1. If _radixMV_ is not in the inclusive interval from 2 to 36, throw a *RangeError* exception.\n          1. Return Number::toString(_x_, _radixMV_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Number.prototype.toString",
        "name" : "INTRINSICS.Number.prototype.toString",
        "htmlId" : "sec-number.prototype.tostring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1762,
    [
      "AsyncArrowFunction[1,0].InstantiateAsyncArrowFunctionExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowFunction[1]]"
        ],
        [
          "name",
          true,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncArrowFunction|.\n        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n        1. Let _parameters_ be the |ArrowFormalParameters| of _head_.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Return _closure_.\n      ",
      {
        "normalizedName" : "AsyncArrowFunction[1,0].InstantiateAsyncArrowFunctionExpression",
        "name" : "AsyncArrowFunction[1,0].InstantiateAsyncArrowFunctionExpression",
        "htmlId" : "sec-runtime-semantics-instantiateasyncarrowfunctionexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateAsyncArrowFunctionExpression",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncArrowFunction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverCallExpressionAndAsyncArrowHead"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2515,
    [
      "SortIndexedProperties",
      0,
      [
        [
          "obj",
          false,
          "Record[Object]"
        ],
        [
          "len",
          false,
          "Int[0+]"
        ],
        [
          "SortCompare",
          false,
          "Unknown[\"AbstractClosureWithTwoParameter\"]"
        ],
        [
          "holes",
          false,
          "Enum[~read-through-holes~, ~skip-holes~]"
        ]
      ],
      "\n            1. Let _items_ be a new empty List.\n            1. Let _k_ be 0.\n            1. Repeat, while _k_ < _len_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. If _holes_ is ~skip-holes~, then\n                1. Let _kRead_ be ? HasProperty(_obj_, _Pk_).\n              1. Else,\n                1. Assert: _holes_ is ~read-through-holes~.\n                1. Let _kRead_ be *true*.\n              1. If _kRead_ is *true*, then\n                1. Let _kValue_ be ? Get(_obj_, _Pk_).\n                1. Append _kValue_ to _items_.\n              1. Set _k_ to _k_ + 1.\n            1. [id=\"step-array-sort\"] Sort _items_ using an implementation-defined sequence of <emu-meta effects=\"user-code\">calls to _SortCompare_</emu-meta>. If any such call returns an abrupt completion, stop before performing any further calls to _SortCompare_ and return that Completion Record.\n            1. Return _items_.\n          ",
      {
        "normalizedName" : "SortIndexedProperties",
        "name" : "SortIndexedProperties",
        "htmlId" : "sec-sortindexedproperties",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2100,
    [
      "INTRINSICS.Symbol.prototype[@@toPrimitive]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return ? ThisSymbolValue(*this* value).\n        ",
      {
        "normalizedName" : "INTRINSICS.Symbol.prototype[@@toPrimitive]",
        "name" : "INTRINSICS.Symbol.prototype[@@toPrimitive]",
        "htmlId" : "sec-symbol.prototype-@@toprimitive",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1270,
    [
      "LiteralPropertyName[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[LiteralPropertyName[1]]"
        ]
      ],
      "\n          1. Return the SV of |StringLiteral|.\n        ",
      {
        "normalizedName" : "LiteralPropertyName[1,0].Evaluation",
        "name" : "LiteralPropertyName[1,0].Evaluation",
        "htmlId" : "sec-object-initializer-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LiteralPropertyName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StringLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1851,
    [
      "UpdateExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UpdateExpression[1,0].HasCallInTailPosition",
        "name" : "UpdateExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "++"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1772,
    [
      "Statement[7,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[7]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[7,0].HasCallInTailPosition",
        "name" : "Statement[7,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BreakStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1259,
    [
      "ArrayLiteral[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayLiteral[1]]"
        ]
      ],
      "\n          1. Let _array_ be ! ArrayCreate(0).\n          1. Perform ? ArrayAccumulation of |ElementList| with arguments _array_ and 0.\n          1. Return _array_.\n        ",
      {
        "normalizedName" : "ArrayLiteral[1,0].Evaluation",
        "name" : "ArrayLiteral[1,0].Evaluation",
        "htmlId" : "sec-array-initializer-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ArrayLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "ElementList"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    317,
    [
      "ModuleItem[1,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[1]]"
        ]
      ],
      "\n        1. If |ExportDeclaration| is `export` |VariableStatement|, return a new empty List.\n        1. Return the BoundNames of |ExportDeclaration|.\n      ",
      {
        "normalizedName" : "ModuleItem[1,0].LexicallyDeclaredNames",
        "name" : "ModuleItem[1,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2377,
    [
      "Atom[5,0].CompileAtom",
      2,
      [
        [
          "this",
          false,
          "Ast[Atom[5]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Return CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.\n        ",
      {
        "normalizedName" : "Atom[5,0].CompileAtom",
        "name" : "Atom[5,0].CompileAtom",
        "htmlId" : "sec-compileatom",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAtom",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "Atom",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "(?:"
              },
              {
                "type" : "nonterminal",
                "value" : "Disjunction"
              },
              {
                "type" : "terminal",
                "value" : ")"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2801,
    [
      "GetGeneratorKind",
      0,
      [
      ],
      "\n          1. Let _genContext_ be the running execution context.\n          1. If _genContext_ does not have a Generator component, return ~non-generator~.\n          1. Let _generator_ be the Generator component of _genContext_.\n          1. If _generator_ has an [[AsyncGeneratorState]] internal slot, return ~async~.\n          1. Else, return ~sync~.\n        ",
      {
        "normalizedName" : "GetGeneratorKind",
        "name" : "GetGeneratorKind",
        "htmlId" : "sec-getgeneratorkind",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    650,
    [
      "IfStatement[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of the first |Statement| with arguments _iterationSet_ and « ».\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of the second |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "IfStatement[0,0].ContainsUndefinedContinueTarget",
        "name" : "IfStatement[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "else"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    948,
    [
      "UnaryExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "UnaryExpression[1,0].AssignmentTargetType",
        "name" : "UnaryExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "delete"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1534,
    [
      "BreakableStatement[1,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BreakableStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _stmtResult_ be Completion(Evaluation of |SwitchStatement|).\n        1. If _stmtResult_ is a break completion, then\n          1. If _stmtResult_.[[Target]] is ~empty~, then\n            1. If _stmtResult_.[[Value]] is ~empty~, set _stmtResult_ to NormalCompletion(*undefined*).\n            1. Else, set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).\n        1. Return ? _stmtResult_.\n      ",
      {
        "normalizedName" : "BreakableStatement[1,0].LabelledEvaluation",
        "name" : "BreakableStatement[1,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BreakableStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SwitchStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1794,
    [
      "ForStatement[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[1,0].HasCallInTailPosition",
        "name" : "ForStatement[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1017,
    [
      "Record[DeclarativeEnvironmentRecord].WithBaseObject",
      3,
      [
        [
          "envRec",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ]
      ],
      "\n            1. Return *undefined*.\n          ",
      {
        "normalizedName" : "Record[DeclarativeEnvironmentRecord].WithBaseObject",
        "name" : "Record[DeclarativeEnvironmentRecord].WithBaseObject",
        "htmlId" : "sec-declarative-environment-records-withbaseobject",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "DeclarativeEnvironmentRecord",
          "WithBaseObject"
        ]
      }
    ]
  ],
  [
    1953,
    [
      "ModuleItemList[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ]
      ],
      "\n          1. Let _sl_ be ? Evaluation of |ModuleItemList|.\n          1. Let _s_ be Completion(Evaluation of |ModuleItem|).\n          1. Return ? UpdateEmpty(_s_, _sl_).\n        ",
      {
        "normalizedName" : "ModuleItemList[1,0].Evaluation",
        "name" : "ModuleItemList[1,0].Evaluation",
        "htmlId" : "sec-module-semantics-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2685,
    [
      "INTRINSICS.DataView.prototype.setFloat64",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~float64~, _value_).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.setFloat64",
        "name" : "INTRINSICS.DataView.prototype.setFloat64",
        "htmlId" : "sec-dataview.prototype.setfloat64",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    615,
    [
      "WithStatement[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[WithStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "WithStatement[0,0].ContainsUndefinedBreakTarget",
        "name" : "WithStatement[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WithStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "with"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1804,
    [
      "ForInOfStatement[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[2,0].HasCallInTailPosition",
        "name" : "ForInOfStatement[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    156,
    [
      "SameValueNonNumber",
      0,
      [
        [
          "x",
          false,
          "Unknown[\"ECMAScriptLanguageValue,ButNotANumber\"]"
        ],
        [
          "y",
          false,
          "Unknown[\"ECMAScriptLanguageValue,ButNotANumber\"]"
        ]
      ],
      "\n        1. Assert: Type(_x_) is Type(_y_).\n        1. If _x_ is either *null* or *undefined*, return *true*.\n        1. If _x_ is a BigInt, then\n          1. Return BigInt::equal(_x_, _y_).\n        1. If _x_ is a String, then\n          1. If _x_ and _y_ have the same length and the same code units in the same positions, return *true*; otherwise, return *false*.\n        1. If _x_ is a Boolean, then\n          1. If _x_ and _y_ are both *true* or both *false*, return *true*; otherwise, return *false*.\n        1. NOTE: All other ECMAScript language values are compared by identity.\n        1. If _x_ is _y_, return *true*; otherwise, return *false*.\n      ",
      {
        "normalizedName" : "SameValueNonNumber",
        "name" : "SameValueNonNumber",
        "htmlId" : "sec-samevaluenonnumber",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2841,
    [
      "INTRINSICS.Reflect.get",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n        1. If _receiver_ is not present, then\n          1. Set _receiver_ to _target_.\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[Get]]</emu-meta>(_key_, _receiver_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.get",
        "name" : "INTRINSICS.Reflect.get",
        "htmlId" : "sec-reflect.get",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1328,
    [
      "OptionalExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalExpression[1]]"
        ]
      ],
      "\n          1. Let _baseReference_ be ? Evaluation of |CallExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If _baseValue_ is either *undefined* or *null*, then\n            1. Return *undefined*.\n          1. Return ? ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_.\n        ",
      {
        "normalizedName" : "OptionalExpression[1,0].Evaluation",
        "name" : "OptionalExpression[1,0].Evaluation",
        "htmlId" : "sec-optional-chaining-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "OptionalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1121,
    [
      "ClassStaticBlockBody[0,0].EvaluateBody",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Assert: _argumentsList_ is empty.\n          1. Return ? EvaluateClassStaticBlockBody of |ClassStaticBlockBody| with argument _functionObject_.\n        ",
      {
        "normalizedName" : "ClassStaticBlockBody[0,0].EvaluateBody",
        "name" : "ClassStaticBlockBody[0,0].EvaluateBody",
        "htmlId" : "sec-runtime-semantics-evaluatebody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStaticBlockBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassStaticBlockStatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2359,
    [
      "Assertion[4,0].CompileAssertion",
      2,
      [
        [
          "this",
          false,
          "Ast[Assertion[4]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Return _y_.\n            1. Let _r_ be _m_(_x_, _d_).\n            1. If _r_ is ~failure~, return ~failure~.\n            1. Assert: _r_ is a MatchState.\n            1. Let _cap_ be _r_.[[Captures]].\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _xe_ be _x_.[[EndIndex]].\n            1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }.\n            1. Return _c_(_z_).\n        ",
      {
        "normalizedName" : "Assertion[4,0].CompileAssertion",
        "name" : "Assertion[4,0].CompileAssertion",
        "htmlId" : "sec-compileassertion",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAssertion",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "Assertion",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "(?="
              },
              {
                "type" : "nonterminal",
                "value" : "Disjunction"
              },
              {
                "type" : "terminal",
                "value" : ")"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1375,
    [
      "EqualityExpression[3,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[3]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |EqualityExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Return IsStrictlyEqual(_rval_, _lval_).\n      ",
      {
        "normalizedName" : "EqualityExpression[3,0].Evaluation",
        "name" : "EqualityExpression[3,0].Evaluation",
        "htmlId" : "sec-equality-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "==="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2577,
    [
      "TypedArrayElementType",
      0,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ]
      ],
      "\n          1. Return the Element Type value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _O_.[[TypedArrayName]].\n        ",
      {
        "normalizedName" : "TypedArrayElementType",
        "name" : "TypedArrayElementType",
        "htmlId" : "sec-typedarrayelementtype",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1064,
    [
      "SetRealmGlobalObject",
      0,
      [
        [
          "realmRec",
          false,
          "Record[RealmRecord]"
        ],
        [
          "globalObj",
          false,
          "Record[Object] | Undefined"
        ],
        [
          "thisValue",
          false,
          "Record[Object] | Undefined"
        ]
      ],
      "\n        1. If _globalObj_ is *undefined*, then\n          1. Let _intrinsics_ be _realmRec_.[[Intrinsics]].\n          1. Set _globalObj_ to OrdinaryObjectCreate(_intrinsics_.[[%Object.prototype%]]).\n        1. Assert: _globalObj_ is an Object.\n        1. If _thisValue_ is *undefined*, set _thisValue_ to _globalObj_.\n        1. Set _realmRec_.[[GlobalObject]] to _globalObj_.\n        1. Let _newGlobalEnv_ be NewGlobalEnvironment(_globalObj_, _thisValue_).\n        1. Set _realmRec_.[[GlobalEnv]] to _newGlobalEnv_.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "SetRealmGlobalObject",
        "name" : "SetRealmGlobalObject",
        "htmlId" : "sec-setrealmglobalobject",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1970,
    [
      "ModuleItem[0,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ModuleItem[0,0].ExportedBindings",
        "name" : "ModuleItem[0,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1227,
    [
      "IdentifierName[0,0].StringValue",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierName[0]]"
        ]
      ],
      "\n        1. Let _idTextUnescaped_ be IdentifierCodePoints of |IdentifierName|.\n        1. Return CodePointsToString(_idTextUnescaped_).\n      ",
      {
        "normalizedName" : "IdentifierName[0,0].StringValue",
        "name" : "IdentifierName[0,0].StringValue",
        "htmlId" : "sec-static-semantics-stringvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IdentifierName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierStart"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1111,
    [
      "Record[ECMAScriptFunctionObject].Call",
      4,
      [
        [
          "F",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "thisArgument",
          false,
          "ESValue"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Let _callerContext_ be the running execution context.\n        1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, *undefined*).\n        1. Assert: _calleeContext_ is now the running execution context.\n        1. If _F_.[[IsClassConstructor]] is *true*, then\n          1. Let _error_ be a newly created *TypeError* object.\n          1. NOTE: _error_ is created in _calleeContext_ with _F_'s associated Realm Record.\n          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n          1. Return ThrowCompletion(_error_).\n        1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).\n        1. Let _result_ be Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_)).\n        1. [id=\"step-call-pop-context-stack\"] Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n        1. If _result_ is a return completion, return _result_.[[Value]].\n        1. ReturnIfAbrupt(_result_).\n        1. Return *undefined*.\n      ",
      {
        "normalizedName" : "Record[ECMAScriptFunctionObject].Call",
        "name" : "Record[ECMAScriptFunctionObject].Call",
        "htmlId" : "sec-ecmascript-function-objects-call-thisargument-argumentslist",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ECMAScriptFunctionObject",
          "[[Call]]"
        ]
      }
    ]
  ],
  [
    2709,
    [
      "AtomicCompareExchangeInSharedBlock",
      0,
      [
        [
          "block",
          false,
          "Record[SharedDataBlock]"
        ],
        [
          "byteIndexInBuffer",
          false,
          "Int"
        ],
        [
          "elementSize",
          false,
          "Int[0+]"
        ],
        [
          "expectedBytes",
          false,
          "Unknown[\"ListOfByteValue\"]"
        ],
        [
          "replacementBytes",
          false,
          "Unknown[\"ListOfByteValue\"]"
        ]
      ],
      "\n          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.\n          1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.\n          1. NOTE: The comparison of the expected value and the read value is performed outside of the read-modify-write modification function to avoid needlessly strong synchronization when the expected value is not equal to the read value.\n          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then\n            1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:\n              1. Return _newBytes_.\n            1. Let _event_ be ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_, [[Payload]]: _replacementBytes_, [[ModifyOp]]: _second_ }.\n          1. Else,\n            1. Let _event_ be ReadSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_ }.\n          1. Append _event_ to _eventsRecord_.[[EventList]].\n          1. Append Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].\n          1. Return _rawBytesRead_.\n        ",
      {
        "normalizedName" : "AtomicCompareExchangeInSharedBlock",
        "name" : "AtomicCompareExchangeInSharedBlock",
        "htmlId" : "sec-atomiccompareexchangeinsharedblock",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1856,
    [
      "UnaryExpression[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[2,0].HasCallInTailPosition",
        "name" : "UnaryExpression[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "void"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    725,
    [
      "PrimaryExpression[11,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[11]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[11,0].IsFunctionDefinition",
        "name" : "PrimaryExpression[11,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 11,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    980,
    [
      "ConditionalExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[ConditionalExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "ConditionalExpression[1,0].AssignmentTargetType",
        "name" : "ConditionalExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ConditionalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShortCircuitExpression"
              },
              {
                "type" : "terminal",
                "value" : "?"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    403,
    [
      "DefaultClause[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the VarDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "DefaultClause[0,0].VarDeclaredNames",
        "name" : "DefaultClause[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2692,
    [
      "ValidateIntegerTypedArray",
      0,
      [
        [
          "typedArray",
          false,
          "ESValue"
        ],
        [
          "waitable",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Let _taRecord_ be ? ValidateTypedArray(_typedArray_, ~unordered~).\n          1. NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.\n          1. If _waitable_ is *true*, then\n            1. If _typedArray_.[[TypedArrayName]] is neither *\"Int32Array\"* nor *\"BigInt64Array\"*, throw a *TypeError* exception.\n          1. Else,\n            1. Let _type_ be TypedArrayElementType(_typedArray_).\n            1. If IsUnclampedIntegerElementType(_type_) is *false* and IsBigIntElementType(_type_) is *false*, throw a *TypeError* exception.\n          1. Return _taRecord_.\n        ",
      {
        "normalizedName" : "ValidateIntegerTypedArray",
        "name" : "ValidateIntegerTypedArray",
        "htmlId" : "sec-validateintegertypedarray",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1498,
    [
      "ForInOfStatement[3,0].ForInOfLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[3]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~).\n          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_).\n        ",
      {
        "normalizedName" : "ForInOfStatement[3,0].ForInOfLoopEvaluation",
        "name" : "ForInOfStatement[3,0].ForInOfLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forinofloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForInOfLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    9,
    [
      "INTRINSICS.Function.prototype",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Object] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1587,
    [
      "FormalParameters[0,0].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameters[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "FormalParameters[0,0].IsSimpleParameterList",
        "name" : "FormalParameters[0,0].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FormalParameters",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2694,
    [
      "ValidateAtomicAccessOnIntegerTypedArray",
      0,
      [
        [
          "typedArray",
          false,
          "ESValue"
        ],
        [
          "requestIndex",
          false,
          "ESValue"
        ],
        [
          "waitable",
          true,
          "Boolean"
        ]
      ],
      "\n          1. If _waitable_ is not present, set _waitable_ to *false*.\n          1. Let _taRecord_ be ? ValidateIntegerTypedArray(_typedArray_, _waitable_).\n          1. Return ? ValidateAtomicAccess(_taRecord_, _requestIndex_).\n        ",
      {
        "normalizedName" : "ValidateAtomicAccessOnIntegerTypedArray",
        "name" : "ValidateAtomicAccessOnIntegerTypedArray",
        "htmlId" : "sec-validateatomicaccessonintegertypedarray",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1425,
    [
      "HoistableDeclaration[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[HoistableDeclaration[0]]"
        ]
      ],
      "\n        1. Return ? Evaluation of |FunctionDeclaration|.\n      ",
      {
        "normalizedName" : "HoistableDeclaration[0,0].Evaluation",
        "name" : "HoistableDeclaration[0,0].Evaluation",
        "htmlId" : "sec-statement-semantics-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "HoistableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1096,
    [
      "Record[OrdinaryObject].HasProperty",
      4,
      [
        [
          "O",
          false,
          "Record[OrdinaryObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n        1. Return ? OrdinaryHasProperty(_O_, _P_).\n      ",
      {
        "normalizedName" : "Record[OrdinaryObject].HasProperty",
        "name" : "Record[OrdinaryObject].HasProperty",
        "htmlId" : "sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "OrdinaryObject",
          "[[HasProperty]]"
        ]
      }
    ]
  ],
  [
    188,
    [
      "PrivateGet",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[PrivateName]"
        ]
      ],
      "\n        1. Let _entry_ be PrivateElementFind(_O_, _P_).\n        1. If _entry_ is ~empty~, throw a *TypeError* exception.\n        1. If _entry_.[[Kind]] is either ~field~ or ~method~, then\n          1. Return _entry_.[[Value]].\n        1. Assert: _entry_.[[Kind]] is ~accessor~.\n        1. If _entry_.[[Get]] is *undefined*, throw a *TypeError* exception.\n        1. Let _getter_ be _entry_.[[Get]].\n        1. Return ? Call(_getter_, _O_).\n      ",
      {
        "normalizedName" : "PrivateGet",
        "name" : "PrivateGet",
        "htmlId" : "sec-privateget",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2509,
    [
      "INTRINSICS.Array.prototype.reverse",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _middle_ be floor(_len_ / 2).\n          1. Let _lower_ be 0.\n          1. Repeat, while _lower_ ≠ _middle_,\n            1. Let _upper_ be _len_ - _lower_ - 1.\n            1. Let _upperP_ be ! ToString(𝔽(_upper_)).\n            1. Let _lowerP_ be ! ToString(𝔽(_lower_)).\n            1. Let _lowerExists_ be ? HasProperty(_O_, _lowerP_).\n            1. If _lowerExists_ is *true*, then\n              1. Let _lowerValue_ be ? Get(_O_, _lowerP_).\n            1. Let _upperExists_ be ? HasProperty(_O_, _upperP_).\n            1. If _upperExists_ is *true*, then\n              1. Let _upperValue_ be ? Get(_O_, _upperP_).\n            1. If _lowerExists_ is *true* and _upperExists_ is *true*, then\n              1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).\n              1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).\n            1. Else if _lowerExists_ is *false* and _upperExists_ is *true*, then\n              1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).\n              1. Perform ? DeletePropertyOrThrow(_O_, _upperP_).\n            1. Else if _lowerExists_ is *true* and _upperExists_ is *false*, then\n              1. Perform ? DeletePropertyOrThrow(_O_, _lowerP_).\n              1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).\n            1. Else,\n              1. Assert: _lowerExists_ and _upperExists_ are both *false*.\n              1. NOTE: No action is required.\n            1. Set _lower_ to _lower_ + 1.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.reverse",
        "name" : "INTRINSICS.Array.prototype.reverse",
        "htmlId" : "sec-array.prototype.reverse",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1672,
    [
      "ClassElement[1,0].IsStatic",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[1]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "ClassElement[1,0].IsStatic",
        "name" : "ClassElement[1,0].IsStatic",
        "htmlId" : "sec-static-semantics-isstatic",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsStatic",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "static"
              },
              {
                "type" : "nonterminal",
                "value" : "MethodDefinition"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1540,
    [
      "Statement[3,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[3]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |Statement|.\n      ",
      {
        "normalizedName" : "Statement[3,0].LabelledEvaluation",
        "name" : "Statement[3,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1006,
    [
      "FieldDefinition[0,1].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[FieldDefinition[0]]"
        ]
      ],
      "\n        1. Return PropName of |ClassElementName|.\n      ",
      {
        "normalizedName" : "FieldDefinition[0,1].PropName",
        "name" : "FieldDefinition[0,1].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FieldDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    388,
    [
      "ForInOfStatement[6,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[6]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForInOfStatement[6,0].VarDeclaredNames",
        "name" : "ForInOfStatement[6,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1878,
    [
      "PrimaryExpression[3,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[3]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[3,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[3,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrayLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2726,
    [
      "INTRINSICS.JSON.parse",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _jsonString_ be ? ToString(_text_).\n        1. [id=\"step-json-parse-validate\"] Parse StringToCodePoints(_jsonString_) as a JSON text as specified in ECMA-404. Throw a *SyntaxError* exception if it is not a valid JSON text as defined in that specification.\n        1. Let _scriptString_ be the string-concatenation of *\"(\"*, _jsonString_, and *\");\"*.\n        1. [id=\"step-json-parse-parse\"] Let _script_ be ParseText(StringToCodePoints(_scriptString_), |Script|).\n        1. NOTE: The early error rules defined in <emu-xref href=\"#sec-object-initializer-static-semantics-early-errors\"></emu-xref> have special handling for the above invocation of ParseText.\n        1. Assert: _script_ is a Parse Node.\n        1. [id=\"step-json-parse-eval\"] Let _completion_ be Completion(<emu-meta suppress-effects=\"user-code\">Evaluation of _script_</emu-meta>).\n        1. NOTE: The PropertyDefinitionEvaluation semantics defined in <emu-xref href=\"#sec-runtime-semantics-propertydefinitionevaluation\"></emu-xref> have special handling for the above evaluation.\n        1. Let _unfiltered_ be _completion_.[[Value]].\n        1. [id=\"step-json-parse-assert-type\"] Assert: _unfiltered_ is either a String, a Number, a Boolean, an Object that is defined by either an |ArrayLiteral| or an |ObjectLiteral|, or *null*.\n        1. If IsCallable(_reviver_) is *true*, then\n          1. Let _root_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Let _rootName_ be the empty String.\n          1. Perform ! CreateDataPropertyOrThrow(_root_, _rootName_, _unfiltered_).\n          1. Return ? InternalizeJSONProperty(_root_, _rootName_, _reviver_).\n        1. Else,\n          1. Return _unfiltered_.\n      ",
      {
        "normalizedName" : "INTRINSICS.JSON.parse",
        "name" : "INTRINSICS.JSON.parse",
        "htmlId" : "sec-json.parse",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2631,
    [
      "GetArrayBufferMaxByteLengthOption",
      0,
      [
        [
          "options",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If _options_ is not an Object, return ~empty~.\n          1. Let _maxByteLength_ be ? Get(_options_, *\"maxByteLength\"*).\n          1. If _maxByteLength_ is *undefined*, return ~empty~.\n          1. Return ? ToIndex(_maxByteLength_).\n        ",
      {
        "normalizedName" : "GetArrayBufferMaxByteLengthOption",
        "name" : "GetArrayBufferMaxByteLengthOption",
        "htmlId" : "sec-getarraybuffermaxbytelengthoption",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    53,
    [
      "Number::exponentiate",
      1,
      [
        [
          "base",
          false,
          "Number"
        ],
        [
          "exponent",
          false,
          "Number"
        ]
      ],
      "\n            1. If _exponent_ is *NaN*, return *NaN*.\n            1. If _exponent_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n            1. If _base_ is *NaN*, return *NaN*.\n            1. If _base_ is *+∞*<sub>𝔽</sub>, then\n              1. If _exponent_ > *+0*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.\n            1. If _base_ is *-∞*<sub>𝔽</sub>, then\n              1. If _exponent_ > *+0*<sub>𝔽</sub>, then\n                1. If _exponent_ is an odd integral Number, return *-∞*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.\n              1. Else,\n                1. If _exponent_ is an odd integral Number, return *-0*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.\n            1. If _base_ is *+0*<sub>𝔽</sub>, then\n              1. If _exponent_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.\n            1. If _base_ is *-0*<sub>𝔽</sub>, then\n              1. If _exponent_ > *+0*<sub>𝔽</sub>, then\n                1. If _exponent_ is an odd integral Number, return *-0*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.\n              1. Else,\n                1. If _exponent_ is an odd integral Number, return *-∞*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.\n            1. Assert: _base_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.\n            1. If _exponent_ is *+∞*<sub>𝔽</sub>, then\n              1. If abs(ℝ(_base_)) > 1, return *+∞*<sub>𝔽</sub>.\n              1. If abs(ℝ(_base_)) = 1, return *NaN*.\n              1. If abs(ℝ(_base_)) < 1, return *+0*<sub>𝔽</sub>.\n            1. If _exponent_ is *-∞*<sub>𝔽</sub>, then\n              1. If abs(ℝ(_base_)) > 1, return *+0*<sub>𝔽</sub>.\n              1. If abs(ℝ(_base_)) = 1, return *NaN*.\n              1. If abs(ℝ(_base_)) < 1, return *+∞*<sub>𝔽</sub>.\n            1. Assert: _exponent_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.\n            1. If _base_ < *-0*<sub>𝔽</sub> and _exponent_ is not an integral Number, return *NaN*.\n            1. Return an implementation-approximated Number value representing the result of raising ℝ(_base_) to the ℝ(_exponent_) power.\n          ",
      {
        "normalizedName" : "Number::exponentiate",
        "name" : "Number::exponentiate",
        "htmlId" : "sec-numeric-types-number-exponentiate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1138,
    [
      "Record[BoundFunctionExoticObject].Call",
      4,
      [
        [
          "F",
          false,
          "Record[BoundFunctionExoticObject]"
        ],
        [
          "thisArgument",
          false,
          "ESValue"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Let _target_ be _F_.[[BoundTargetFunction]].\n          1. Let _boundThis_ be _F_.[[BoundThis]].\n          1. Let _boundArgs_ be _F_.[[BoundArguments]].\n          1. Let _args_ be the list-concatenation of _boundArgs_ and _argumentsList_.\n          1. Return ? Call(_target_, _boundThis_, _args_).\n        ",
      {
        "normalizedName" : "Record[BoundFunctionExoticObject].Call",
        "name" : "Record[BoundFunctionExoticObject].Call",
        "htmlId" : "sec-bound-function-exotic-objects-call-thisargument-argumentslist",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "BoundFunctionExoticObject",
          "[[Call]]"
        ]
      }
    ]
  ],
  [
    2724,
    [
      "INTRINSICS.Atomics.notify",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_, *true*).\n        1. If _count_ is *undefined*, then\n          1. Let _c_ be +∞.\n        1. Else,\n          1. Let _intCount_ be ? ToIntegerOrInfinity(_count_).\n          1. Let _c_ be max(_intCount_, 0).\n        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n        1. Let _block_ be _buffer_.[[ArrayBufferData]].\n        1. If IsSharedArrayBuffer(_buffer_) is *false*, return *+0*<sub>𝔽</sub>.\n        1. Let _WL_ be GetWaiterList(_block_, _byteIndexInBuffer_).\n        1. Perform EnterCriticalSection(_WL_).\n        1. Let _S_ be RemoveWaiters(_WL_, _c_).\n        1. For each element _W_ of _S_, do\n          1. Perform NotifyWaiter(_WL_, _W_).\n        1. Perform LeaveCriticalSection(_WL_).\n        1. Let _n_ be the number of elements in _S_.\n        1. Return 𝔽(_n_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.notify",
        "name" : "INTRINSICS.Atomics.notify",
        "htmlId" : "sec-atomics.notify",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1719,
    [
      "MethodDefinition[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[0]]"
        ]
      ],
      "\n        1. Return ContainsArguments of |ClassElementName|.\n      ",
      {
        "normalizedName" : "MethodDefinition[0,0].ContainsArguments",
        "name" : "MethodDefinition[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    356,
    [
      "Statement[7,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[7]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[7,0].VarDeclaredNames",
        "name" : "Statement[7,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BreakStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2537,
    [
      "INTRINSICS.get TypedArray.prototype.byteOffset",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *+0*<sub>𝔽</sub>.\n          1. Let _offset_ be _O_.[[ByteOffset]].\n          1. Return 𝔽(_offset_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get TypedArray.prototype.byteOffset",
        "name" : "INTRINSICS.get TypedArray.prototype.byteOffset",
        "htmlId" : "sec-get-%typedarray%.prototype.byteoffset",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    141,
    [
      "ToString",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If _argument_ is a String, return _argument_.\n        1. If _argument_ is a Symbol, throw a *TypeError* exception.\n        1. If _argument_ is *undefined*, return *\"undefined\"*.\n        1. If _argument_ is *null*, return *\"null\"*.\n        1. If _argument_ is *true*, return *\"true\"*.\n        1. If _argument_ is *false*, return *\"false\"*.\n        1. If _argument_ is a Number, return Number::toString(_argument_, 10).\n        1. If _argument_ is a BigInt, return BigInt::toString(_argument_, 10).\n        1. Assert: _argument_ is an Object.\n        1. Let _primValue_ be ? ToPrimitive(_argument_, ~string~).\n        1. Assert: _primValue_ is not an Object.\n        1. Return ? ToString(_primValue_).\n      ",
      {
        "normalizedName" : "ToString",
        "name" : "ToString",
        "htmlId" : "sec-tostring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    869,
    [
      "FieldDefinition[0,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[FieldDefinition[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      ",
      {
        "normalizedName" : "FieldDefinition[0,0].ComputedPropertyContains",
        "name" : "FieldDefinition[0,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FieldDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    610,
    [
      "ForInOfStatement[6,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[6]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[6,0].ContainsUndefinedBreakTarget",
        "name" : "ForInOfStatement[6,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1755,
    [
      "AsyncFunctionExpression[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ]
      ],
      "\n        1. Return InstantiateAsyncFunctionExpression of |AsyncFunctionExpression|.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,0].Evaluation",
        "name" : "AsyncFunctionExpression[0,0].Evaluation",
        "htmlId" : "sec-async-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    783,
    [
      "FunctionExpression[0,1].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,1].IsFunctionDefinition",
        "name" : "FunctionExpression[0,1].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2638,
    [
      "GetRawBytesFromSharedBlock",
      0,
      [
        [
          "block",
          false,
          "Record[SharedDataBlock]"
        ],
        [
          "byteIndex",
          false,
          "Int[0+]"
        ],
        [
          "type",
          false,
          "Unknown[\"TypedArrayElementType\"]"
        ],
        [
          "isTypedArray",
          false,
          "Boolean"
        ],
        [
          "order",
          false,
          "Enum[~seq-cst~, ~unordered~]"
        ]
      ],
      "\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n          1. If _isTypedArray_ is *true* and IsNoTearConfiguration(_type_, _order_) is *true*, let _noTear_ be *true*; otherwise let _noTear_ be *false*.\n          1. Let _rawValue_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.\n          1. NOTE: In implementations, _rawValue_ is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.\n          1. Let _readEvent_ be ReadSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_ }.\n          1. Append _readEvent_ to _eventsRecord_.[[EventList]].\n          1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _rawValue_ } to _execution_.[[ChosenValues]].\n          1. Return _rawValue_.\n        ",
      {
        "normalizedName" : "GetRawBytesFromSharedBlock",
        "name" : "GetRawBytesFromSharedBlock",
        "htmlId" : "sec-getrawbytesfromsharedblock",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    420,
    [
      "ModuleItem[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ModuleItem[0,0].VarDeclaredNames",
        "name" : "ModuleItem[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1118,
    [
      "AsyncFunctionBody[0,0].EvaluateBody",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Return ? EvaluateAsyncFunctionBody of |AsyncFunctionBody| with arguments _functionObject_ and _argumentsList_.\n        ",
      {
        "normalizedName" : "AsyncFunctionBody[0,0].EvaluateBody",
        "name" : "AsyncFunctionBody[0,0].EvaluateBody",
        "htmlId" : "sec-runtime-semantics-evaluatebody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2268,
    [
      "INTRINSICS.String.prototype.toString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return ? ThisStringValue(*this* value).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.toString",
        "name" : "INTRINSICS.String.prototype.toString",
        "htmlId" : "sec-string.prototype.tostring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    499,
    [
      "StatementList[1,0].TopLevelVarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be TopLevelVarDeclaredNames of |StatementList|.\n        1. Let _names2_ be TopLevelVarDeclaredNames of |StatementListItem|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "StatementList[1,0].TopLevelVarDeclaredNames",
        "name" : "StatementList[1,0].TopLevelVarDeclaredNames",
        "htmlId" : "sec-static-semantics-toplevelvardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelVarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    857,
    [
      "ClassElementName[1,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementName[1]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassElementName[1,0].ComputedPropertyContains",
        "name" : "ClassElementName[1,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassElementName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1397,
    [
      "ArrayAssignmentPattern[0,2].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayAssignmentPattern[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "ArrayAssignmentPattern[0,2].DestructuringAssignmentEvaluation",
        "name" : "ArrayAssignmentPattern[0,2].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 2,
            "astName" : "ArrayAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1160,
    [
      "MakeArgSetter",
      0,
      [
        [
          "name",
          false,
          "String"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ]
      ],
      "\n            1. Let _setterClosure_ be a new Abstract Closure with parameters (_value_) that captures _name_ and _env_ and performs the following steps when called:\n              1. Return ! _env_.SetMutableBinding(_name_, _value_, *false*).\n            1. Let _setter_ be CreateBuiltinFunction(_setterClosure_, 1, *\"\"*, « »).\n            1. NOTE: _setter_ is never directly accessible to ECMAScript code.\n            1. Return _setter_.\n          ",
      {
        "normalizedName" : "MakeArgSetter",
        "name" : "MakeArgSetter",
        "htmlId" : "sec-makeargsetter",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    488,
    [
      "ScriptBody[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ScriptBody[0]]"
        ]
      ],
      "\n        1. Return TopLevelVarScopedDeclarations of |StatementList|.\n      ",
      {
        "normalizedName" : "ScriptBody[0,0].VarScopedDeclarations",
        "name" : "ScriptBody[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ScriptBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1361,
    [
      "AdditiveExpression[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AdditiveExpression[2]]"
        ]
      ],
      "\n          1. Return ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `-`, |MultiplicativeExpression|).\n        ",
      {
        "normalizedName" : "AdditiveExpression[2,0].Evaluation",
        "name" : "AdditiveExpression[2,0].Evaluation",
        "htmlId" : "sec-subtraction-operator-minus-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "AdditiveExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              },
              {
                "type" : "terminal",
                "value" : "-"
              },
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2323,
    [
      "ClassUnion[1,1].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassUnion[1]]"
        ]
      ],
      "\n          1. If MayContainStrings of the |ClassSetOperand| is *true*, return *true*.\n          1. If |ClassUnion| is present, return MayContainStrings of the |ClassUnion|.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ClassUnion[1,1].MayContainStrings",
        "name" : "ClassUnion[1,1].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "ClassUnion",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassUnion"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    339,
    [
      "ConciseBody[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ConciseBody[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ConciseBody[0,0].LexicallyScopedDeclarations",
        "name" : "ConciseBody[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    669,
    [
      "ForStatement[2,3].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[2,3].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[2,3].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2666,
    [
      "GetViewValue",
      0,
      [
        [
          "view",
          false,
          "ESValue"
        ],
        [
          "requestIndex",
          false,
          "ESValue"
        ],
        [
          "isLittleEndian",
          false,
          "ESValue"
        ],
        [
          "type",
          false,
          "Unknown[\"TypedArrayElementType\"]"
        ]
      ],
      "\n          1. Perform ? RequireInternalSlot(_view_, [[DataView]]).\n          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _getIndex_ be ? ToIndex(_requestIndex_).\n          1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).\n          1. Let _viewOffset_ be _view_.[[ByteOffset]].\n          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~).\n          1. NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.\n          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.\n          1. Let _viewSize_ be GetViewByteLength(_viewRecord_).\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. If _getIndex_ + _elementSize_ > _viewSize_, throw a *RangeError* exception.\n          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.\n          1. Return GetValueFromBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, *false*, ~unordered~, _isLittleEndian_).\n        ",
      {
        "normalizedName" : "GetViewValue",
        "name" : "GetViewValue",
        "htmlId" : "sec-getviewvalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1567,
    [
      "BindingPropertyList[1,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingPropertyList[1]]"
        ]
      ],
      "\n        1. Let _has_ be ContainsExpression of |BindingPropertyList|.\n        1. If _has_ is *true*, return *true*.\n        1. Return ContainsExpression of |BindingProperty|.\n      ",
      {
        "normalizedName" : "BindingPropertyList[1,0].ContainsExpression",
        "name" : "BindingPropertyList[1,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingPropertyList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPropertyList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "BindingProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    471,
    [
      "CaseClause[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the VarScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "CaseClause[0,0].VarScopedDeclarations",
        "name" : "CaseClause[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    256,
    [
      "ImportClause[3,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportClause[3]]"
        ]
      ],
      "\n        1. Let _names1_ be the BoundNames of |ImportedDefaultBinding|.\n        1. Let _names2_ be the BoundNames of |NameSpaceImport|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ImportClause[3,0].BoundNames",
        "name" : "ImportClause[3,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ImportClause",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportedDefaultBinding"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "NameSpaceImport"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    109,
    [
      "ToPrimitive",
      0,
      [
        [
          "input",
          false,
          "ESValue"
        ],
        [
          "preferredType",
          true,
          "Enum[~number~, ~string~]"
        ]
      ],
      "\n        1. If _input_ is an Object, then\n          1. Let _exoticToPrim_ be ? GetMethod(_input_, @@toPrimitive).\n          1. If _exoticToPrim_ is not *undefined*, then\n            1. If _preferredType_ is not present, then\n              1. Let _hint_ be *\"default\"*.\n            1. Else if _preferredType_ is ~string~, then\n              1. Let _hint_ be *\"string\"*.\n            1. Else,\n              1. Assert: _preferredType_ is ~number~.\n              1. Let _hint_ be *\"number\"*.\n            1. Let _result_ be ? Call(_exoticToPrim_, _input_, « _hint_ »).\n            1. If _result_ is not an Object, return _result_.\n            1. Throw a *TypeError* exception.\n          1. If _preferredType_ is not present, let _preferredType_ be ~number~.\n          1. Return ? OrdinaryToPrimitive(_input_, _preferredType_).\n        1. Return _input_.\n      ",
      {
        "normalizedName" : "ToPrimitive",
        "name" : "ToPrimitive",
        "htmlId" : "sec-toprimitive",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    328,
    [
      "CaseClause[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the LexicallyScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "CaseClause[0,0].LexicallyScopedDeclarations",
        "name" : "CaseClause[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2460,
    [
      "EscapeRegExpPattern",
      0,
      [
        [
          "P",
          false,
          "String"
        ],
        [
          "F",
          false,
          "String"
        ]
      ],
      "\n            1. If _F_ contains *\"v\"*, then\n              1. Let _patternSymbol_ be |Pattern[+UnicodeMode, +UnicodeSetsMode]|.\n            1. Else if _F_ contains *\"u\"*, then\n              1. Let _patternSymbol_ be |Pattern[+UnicodeMode, ~UnicodeSetsMode]|.\n            1. Else,\n              1. Let _patternSymbol_ be |Pattern[~UnicodeMode, ~UnicodeSetsMode]|.\n            1. Let _S_ be a String in the form of a _patternSymbol_ equivalent to _P_ interpreted as UTF-16 encoded Unicode code points (<emu-xref href=\"#sec-ecmascript-language-types-string-type\"></emu-xref>), in which certain code points are escaped as described below. _S_ may or may not differ from _P_; however, the Abstract Closure that would result from evaluating _S_ as a _patternSymbol_ must behave identically to the Abstract Closure given by the constructed object's [[RegExpMatcher]] internal slot. Multiple calls to this abstract operation using the same values for _P_ and _F_ must produce identical results.\n            1. The code points `/` or any |LineTerminator| occurring in the pattern shall be escaped in _S_ as necessary to ensure that the string-concatenation of *\"/\"*, _S_, *\"/\"*, and _F_ can be parsed (in an appropriate lexical context) as a |RegularExpressionLiteral| that behaves identically to the constructed regular expression. For example, if _P_ is *\"/\"*, then _S_ could be *\"\\\\/\"* or *\"\\\\u002F\"*, among other possibilities, but not *\"/\"*, because `///` followed by _F_ would be parsed as a |SingleLineComment| rather than a |RegularExpressionLiteral|. If _P_ is the empty String, this specification can be met by letting _S_ be *\"(?:)\"*.\n            1. Return _S_.\n          ",
      {
        "normalizedName" : "EscapeRegExpPattern",
        "name" : "EscapeRegExpPattern",
        "htmlId" : "sec-escaperegexppattern",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1493,
    [
      "ForDeclaration[0,0].ForDeclarationBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ForDeclaration[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n          1. Return ? BindingInitialization of |ForBinding| with arguments _value_ and _environment_.\n        ",
      {
        "normalizedName" : "ForDeclaration[0,0].ForDeclarationBindingInitialization",
        "name" : "ForDeclaration[0,0].ForDeclarationBindingInitialization",
        "htmlId" : "sec-runtime-semantics-fordeclarationbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForDeclarationBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LetOrConst"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2798,
    [
      "GeneratorResume",
      0,
      [
        [
          "generator",
          false,
          "ESValue"
        ],
        [
          "value",
          false,
          "ESValue | Enum[~empty~]"
        ],
        [
          "generatorBrand",
          false,
          "Enum[~empty~] | String"
        ]
      ],
      "\n          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).\n          1. If _state_ is ~completed~, return CreateIterResultObject(*undefined*, *true*).\n          1. Assert: _state_ is either ~suspended-start~ or ~suspended-yield~.\n          1. Let _genContext_ be _generator_.[[GeneratorContext]].\n          1. Let _methodContext_ be the running execution context.\n          1. Suspend _methodContext_.\n          1. Set _generator_.[[GeneratorState]] to ~executing~.\n          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _genContext_</emu-meta> using NormalCompletion(_value_) as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.\n          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.\n          1. Return ? _result_.\n        ",
      {
        "normalizedName" : "GeneratorResume",
        "name" : "GeneratorResume",
        "htmlId" : "sec-generatorresume",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1683,
    [
      "CallExpression[7,0].AllPrivateIdentifiersValid",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[7]]"
        ],
        [
          "names",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If _names_ contains the StringValue of |PrivateIdentifier|, then\n          1. Return AllPrivateIdentifiersValid of |CallExpression| with argument _names_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CallExpression[7,0].AllPrivateIdentifiersValid",
        "name" : "CallExpression[7,0].AllPrivateIdentifiersValid",
        "htmlId" : "sec-static-semantics-allprivateidentifiersvalid",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AllPrivateIdentifiersValid",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    884,
    [
      "ObjectBindingPattern[0,0].BindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectBindingPattern[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "ObjectBindingPattern[0,0].BindingInitialization",
        "name" : "ObjectBindingPattern[0,0].BindingInitialization",
        "htmlId" : "sec-runtime-semantics-bindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ObjectBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1329,
    [
      "OptionalExpression[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalExpression[2]]"
        ]
      ],
      "\n          1. Let _baseReference_ be ? Evaluation of |OptionalExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If _baseValue_ is either *undefined* or *null*, then\n            1. Return *undefined*.\n          1. Return ? ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_.\n        ",
      {
        "normalizedName" : "OptionalExpression[2,0].Evaluation",
        "name" : "OptionalExpression[2,0].Evaluation",
        "htmlId" : "sec-optional-chaining-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "OptionalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1028,
    [
      "Record[FunctionEnvironmentRecord].HasThisBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[FunctionEnvironmentRecord]"
        ]
      ],
      "\n            1. If _envRec_.[[ThisBindingStatus]] is ~lexical~, return *false*; otherwise, return *true*.\n          ",
      {
        "normalizedName" : "Record[FunctionEnvironmentRecord].HasThisBinding",
        "name" : "Record[FunctionEnvironmentRecord].HasThisBinding",
        "htmlId" : "sec-function-environment-records-hasthisbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "FunctionEnvironmentRecord",
          "HasThisBinding"
        ]
      }
    ]
  ],
  [
    1082,
    [
      "Record[OrdinaryObject].GetPrototypeOf",
      4,
      [
        [
          "O",
          false,
          "Record[OrdinaryObject]"
        ]
      ],
      "\n        1. Return OrdinaryGetPrototypeOf(_O_).\n      ",
      {
        "normalizedName" : "Record[OrdinaryObject].GetPrototypeOf",
        "name" : "Record[OrdinaryObject].GetPrototypeOf",
        "htmlId" : "sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "OrdinaryObject",
          "[[GetPrototypeOf]]"
        ]
      }
    ]
  ],
  [
    2023,
    [
      "ExportDeclaration[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[1]]"
        ]
      ],
      "\n          1. Return ~empty~.\n        ",
      {
        "normalizedName" : "ExportDeclaration[1,0].Evaluation",
        "name" : "ExportDeclaration[1,0].Evaluation",
        "htmlId" : "sec-exports-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "NamedExports"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1942,
    [
      "AsyncModuleExecutionRejected",
      0,
      [
        [
          "module",
          false,
          "Record[CyclicModuleRecord]"
        ],
        [
          "error",
          false,
          "ESValue"
        ]
      ],
      "\n              1. If _module_.[[Status]] is ~evaluated~, then\n                1. Assert: _module_.[[EvaluationError]] is not ~empty~.\n                1. Return ~unused~.\n              1. Assert: _module_.[[Status]] is ~evaluating-async~.\n              1. Assert: _module_.[[AsyncEvaluation]] is *true*.\n              1. Assert: _module_.[[EvaluationError]] is ~empty~.\n              1. Set _module_.[[EvaluationError]] to ThrowCompletion(_error_).\n              1. Set _module_.[[Status]] to ~evaluated~.\n              1. For each Cyclic Module Record _m_ of _module_.[[AsyncParentModules]], do\n                1. Perform AsyncModuleExecutionRejected(_m_, _error_).\n              1. If _module_.[[TopLevelCapability]] is not ~empty~, then\n                1. Assert: _module_.[[CycleRoot]] is _module_.\n                1. Perform ! Call(_module_.[[TopLevelCapability]].[[Reject]], *undefined*, « _error_ »).\n              1. Return ~unused~.\n            ",
      {
        "normalizedName" : "AsyncModuleExecutionRejected",
        "name" : "AsyncModuleExecutionRejected",
        "htmlId" : "sec-async-module-execution-rejected",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    225,
    [
      "ArrayBindingPattern[2,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[2]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingElementList|.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[2,0].BoundNames",
        "name" : "ArrayBindingPattern[2,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1659,
    [
      "AsyncGeneratorExpression[0,0].InstantiateAsyncGeneratorFunctionExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ],
        [
          "name",
          true,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return _closure_.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,0].InstantiateAsyncGeneratorFunctionExpression",
        "name" : "AsyncGeneratorExpression[0,0].InstantiateAsyncGeneratorFunctionExpression",
        "htmlId" : "sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateAsyncGeneratorFunctionExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    124,
    [
      "StrUnsignedDecimalLiteral[1,2].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StrUnsignedDecimalLiteral[1]]"
        ]
      ],
      "\n            1. Let _a_ be MV of the first |DecimalDigits|.\n            1. If the second |DecimalDigits| is present, then\n              1. Let _b_ be MV of the second |DecimalDigits|.\n              1. Let _n_ be the number of code points in the second |DecimalDigits|.\n            1. Else,\n              1. Let _b_ be 0.\n              1. Let _n_ be 0.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Return RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>).\n          ",
      {
        "normalizedName" : "StrUnsignedDecimalLiteral[1,2].StringNumericValue",
        "name" : "StrUnsignedDecimalLiteral[1,2].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "StrUnsignedDecimalLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1964,
    [
      "NameSpaceImport[0,0].ImportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[NameSpaceImport[0]]"
        ],
        [
          "module",
          false,
          "String"
        ]
      ],
      "\n          1. Let _localName_ be the StringValue of |ImportedBinding|.\n          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~namespace-object~, [[LocalName]]: _localName_ }.\n          1. Return « _entry_ ».\n        ",
      {
        "normalizedName" : "NameSpaceImport[0,0].ImportEntriesForModule",
        "name" : "NameSpaceImport[0,0].ImportEntriesForModule",
        "htmlId" : "sec-static-semantics-importentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NameSpaceImport",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "as"
              },
              {
                "type" : "nonterminal",
                "value" : "ImportedBinding"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1292,
    [
      "TemplateLiteral[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateLiteral[0]]"
        ]
      ],
      "\n          1. Return the TV of |NoSubstitutionTemplate| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.\n        ",
      {
        "normalizedName" : "TemplateLiteral[0,0].Evaluation",
        "name" : "TemplateLiteral[0,0].Evaluation",
        "htmlId" : "sec-template-literals-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TemplateLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NoSubstitutionTemplate"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    933,
    [
      "CallExpression[0,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[0]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "CallExpression[0,0].AssignmentTargetType",
        "name" : "CallExpression[0,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverCallExpressionAndAsyncArrowHead"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    77,
    [
      "BigInt::signedRightShift",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. Return BigInt::leftShift(_x_, -_y_).\n          ",
      {
        "normalizedName" : "BigInt::signedRightShift",
        "name" : "BigInt::signedRightShift",
        "htmlId" : "sec-numeric-types-bigint-signedRightShift",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    554,
    [
      "CaseBlock[1,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,0].ContainsDuplicateLabels",
        "name" : "CaseBlock[1,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    753,
    [
      "ShiftExpression[2,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[ShiftExpression[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ShiftExpression[2,0].IsFunctionDefinition",
        "name" : "ShiftExpression[2,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ShiftExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              },
              {
                "type" : "terminal",
                "value" : ">>"
              },
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2561,
    [
      "INTRINSICS.TypedArray.prototype.slice",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _srcArrayLength_ be TypedArrayLength(_taRecord_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _startIndex_ be 0.\n          1. Else if _relativeStart_ < 0, let _startIndex_ be max(_srcArrayLength_ + _relativeStart_, 0).\n          1. Else, let _startIndex_ be min(_relativeStart_, _srcArrayLength_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _srcArrayLength_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _endIndex_ be 0.\n          1. Else if _relativeEnd_ < 0, let _endIndex_ be max(_srcArrayLength_ + _relativeEnd_, 0).\n          1. Else, let _endIndex_ be min(_relativeEnd_, _srcArrayLength_).\n          1. Let _countBytes_ be max(_endIndex_ - _startIndex_, 0).\n          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_countBytes_) »).\n          1. If _countBytes_ > 0, then\n            1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n            1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n            1. Set _endIndex_ to min(_endIndex_, TypedArrayLength(_taRecord_)).\n            1. Set _countBytes_ to max(_endIndex_ - _startIndex_, 0).\n            1. Let _srcType_ be TypedArrayElementType(_O_).\n            1. Let _targetType_ be TypedArrayElementType(_A_).\n            1. If _srcType_ is _targetType_, then\n              1. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n              1. Let _srcBuffer_ be _O_.[[ViewedArrayBuffer]].\n              1. Let _targetBuffer_ be _A_.[[ViewedArrayBuffer]].\n              1. Let _elementSize_ be TypedArrayElementSize(_O_).\n              1. Let _srcByteOffset_ be _O_.[[ByteOffset]].\n              1. Let _srcByteIndex_ be (_startIndex_ × _elementSize_) + _srcByteOffset_.\n              1. Let _targetByteIndex_ be _A_.[[ByteOffset]].\n              1. Let _endByteIndex_ be _targetByteIndex_ + (_countBytes_ × _elementSize_).\n              1. Repeat, while _targetByteIndex_ < _endByteIndex_,\n                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~).\n                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~).\n                1. Set _srcByteIndex_ to _srcByteIndex_ + 1.\n                1. Set _targetByteIndex_ to _targetByteIndex_ + 1.\n            1. Else,\n              1. Let _n_ be 0.\n              1. Let _k_ be _startIndex_.\n              1. Repeat, while _k_ < _endIndex_,\n                1. Let _Pk_ be ! ToString(𝔽(_k_)).\n                1. Let _kValue_ be ! Get(_O_, _Pk_).\n                1. Perform ! Set(_A_, ! ToString(𝔽(_n_)), _kValue_, *true*).\n                1. Set _k_ to _k_ + 1.\n                1. Set _n_ to _n_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.slice",
        "name" : "INTRINSICS.TypedArray.prototype.slice",
        "htmlId" : "sec-%typedarray%.prototype.slice",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2830,
    [
      "AsyncBlockStart",
      0,
      [
        [
          "promiseCapability",
          false,
          "Record[PromiseCapabilityRecord]"
        ],
        [
          "asyncBody",
          false,
          "Ast"
        ],
        [
          "asyncContext",
          false,
          "Record[ExecutionContext]"
        ]
      ],
      "\n          1. Assert: _promiseCapability_ is a PromiseCapability Record.\n          1. Let _runningContext_ be the running execution context.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _promiseCapability_ and _asyncBody_ and performs the following steps when called:\n            1. Let _acAsyncContext_ be the running execution context.\n            1. Let _result_ be Completion(Evaluation of _asyncBody_).\n            1. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.\n            1. Remove _acAsyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. If _result_ is a normal completion, then\n              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).\n            1. Else if _result_ is a return completion, then\n              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] »).\n            1. Else,\n              1. Assert: _result_ is a throw completion.\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] »).\n            1. [id=\"step-asyncblockstart-return-undefined\"] Return ~unused~.\n          1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta>. Let _result_ be the value returned by the resumed computation.\n          1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.\n          1. Assert: _result_ is a normal completion with a value of ~unused~. The possible sources of this value are Await or, if the async function doesn't await anything, step <emu-xref href=\"#step-asyncblockstart-return-undefined\"></emu-xref> above.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncBlockStart",
        "name" : "AsyncBlockStart",
        "htmlId" : "sec-asyncblockstart",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1182,
    [
      "Record[ModuleNamespaceExoticObject].DefineOwnProperty",
      4,
      [
        [
          "O",
          false,
          "Record[ModuleNamespaceExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Desc",
          false,
          "Record[PropertyDescriptor]"
        ]
      ],
      "\n          1. If _P_ is a Symbol, return ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).\n          1. Let _current_ be ? _O_.[[GetOwnProperty]](_P_).\n          1. If _current_ is *undefined*, return *false*.\n          1. If _Desc_ has a [[Configurable]] field and _Desc_.[[Configurable]] is *true*, return *false*.\n          1. If _Desc_ has an [[Enumerable]] field and _Desc_.[[Enumerable]] is *false*, return *false*.\n          1. If IsAccessorDescriptor(_Desc_) is *true*, return *false*.\n          1. If _Desc_ has a [[Writable]] field and _Desc_.[[Writable]] is *false*, return *false*.\n          1. If _Desc_ has a [[Value]] field, return SameValue(_Desc_.[[Value]], _current_.[[Value]]).\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "Record[ModuleNamespaceExoticObject].DefineOwnProperty",
        "name" : "Record[ModuleNamespaceExoticObject].DefineOwnProperty",
        "htmlId" : "sec-module-namespace-exotic-objects-defineownproperty-p-desc",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleNamespaceExoticObject",
          "[[DefineOwnProperty]]"
        ]
      }
    ]
  ],
  [
    1739,
    [
      "ClassTail[0,2].ClassDefinitionEvaluation:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.\n        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n        1. If |ClassBody| is present, then\n          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do\n            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then\n              1. Assert: This is only possible for getter/setter pairs.\n            1. Else,\n              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.\n              1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n        1. If |ClassHeritage| is not present, then\n          1. Let _protoParent_ be %Object.prototype%.\n          1. Let _constructorParent_ be %Function.prototype%.\n        1. Else,\n          1. Set the running execution context's LexicalEnvironment to _classEnv_.\n          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).\n          1. Set the running execution context's LexicalEnvironment to _env_.\n          1. Let _superclass_ be ? GetValue(? _superclassRef_).\n          1. If _superclass_ is *null*, then\n            1. Let _protoParent_ be *null*.\n            1. Let _constructorParent_ be %Function.prototype%.\n          1. Else if IsConstructor(_superclass_) is *false*, then\n            1. Throw a *TypeError* exception.\n          1. Else,\n            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.\n            1. Let _constructorParent_ be _superclass_.\n        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n        1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n        1. Set the running execution context's LexicalEnvironment to _classEnv_.\n        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.\n        1. If _constructor_ is ~empty~, then\n          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n            1. If NewTarget is *undefined*, throw a *TypeError* exception.\n            1. Let _F_ be the active function object.\n            1. If _F_.[[ConstructorKind]] is ~derived~, then\n              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n            1. Else,\n              1. NOTE: This branch behaves similarly to `constructor() {}`.\n              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n            1. Perform ? InitializeInstanceElements(_result_, _F_).\n            1. Return _result_.\n          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n        1. Else,\n          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n          1. Let _F_ be _constructorInfo_.[[Closure]].\n          1. Perform MakeClassConstructor(_F_).\n          1. Perform SetFunctionName(_F_, _className_).\n        1. Perform MakeConstructor(_F_, *false*, _proto_).\n        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n        1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n        1. If |ClassBody| is not present, let _elements_ be a new empty List.\n        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n        1. Let _instancePrivateMethods_ be a new empty List.\n        1. Let _staticPrivateMethods_ be a new empty List.\n        1. Let _instanceFields_ be a new empty List.\n        1. Let _staticElements_ be a new empty List.\n        1. For each |ClassElement| _e_ of _elements_, do\n          1. If IsStatic of _e_ is *false*, then\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n          1. Else,\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n          1. If _element_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _env_.\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _element_.\n          1. Set _element_ to ! _element_.\n          1. If _element_ is a PrivateElement, then\n            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n            1. Else, let _container_ be _staticPrivateMethods_.\n            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.\n              1. If _element_.[[Get]] is *undefined*, then\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n              1. Else,\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n              1. Replace _pe_ in _container_ with _combined_.\n            1. Else,\n              1. Append _element_ to _container_.\n          1. Else if _element_ is a ClassFieldDefinition Record, then\n            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n            1. Else, append _element_ to _staticElements_.\n          1. Else if _element_ is a ClassStaticBlockDefinition Record, then\n            1. Append _element_ to _staticElements_.\n        1. Set the running execution context's LexicalEnvironment to _env_.\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n        1. Set _F_.[[Fields]] to _instanceFields_.\n        1. For each PrivateElement _method_ of _staticPrivateMethods_, do\n          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n        1. For each element _elementRecord_ of _staticElements_, do\n          1. If _elementRecord_ is a ClassFieldDefinition Record, then\n            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n          1. Else,\n            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.\n            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n          1. If _result_ is an abrupt completion, then\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _result_.\n        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "ClassTail[0,2].ClassDefinitionEvaluation",
        "name" : "ClassTail[0,2].ClassDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-classdefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    193,
    [
      "GroupBy",
      0,
      [
        [
          "items",
          false,
          "ESValue"
        ],
        [
          "callbackfn",
          false,
          "ESValue"
        ],
        [
          "keyCoercion",
          false,
          "Enum[~property~, ~zero~]"
        ]
      ],
      "\n        1. Perform ? RequireObjectCoercible(_items_).\n        1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n        1. Let _groups_ be a new empty List.\n        1. Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~).\n        1. Let _k_ be 0.\n        1. Repeat,\n          1. If _k_ ≥ 2<sup>53</sup> - 1, then\n            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).\n            1. Return ? IteratorClose(_iteratorRecord_, _error_).\n          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is ~done~, then\n            1. Return _groups_.\n          1. Let _value_ be _next_.\n          1. Let _key_ be Completion(Call(_callbackfn_, *undefined*, « _value_, 𝔽(_k_) »)).\n          1. IfAbruptCloseIterator(_key_, _iteratorRecord_).\n          1. If _keyCoercion_ is ~property~, then\n            1. Set _key_ to Completion(ToPropertyKey(_key_)).\n            1. IfAbruptCloseIterator(_key_, _iteratorRecord_).\n          1. Else,\n            1. Assert: _keyCoercion_ is ~zero~.\n            1. If _key_ is *-0*<sub>𝔽</sub>, set _key_ to *+0*<sub>𝔽</sub>.\n          1. Perform AddValueToKeyedGroup(_groups_, _key_, _value_).\n          1. Set _k_ to _k_ + 1.\n      ",
      {
        "normalizedName" : "GroupBy",
        "name" : "GroupBy",
        "htmlId" : "sec-groupby",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1461,
    [
      "ForStatement[0,0].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        ",
      {
        "normalizedName" : "ForStatement[0,0].ForLoopEvaluation",
        "name" : "ForStatement[0,0].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    537,
    [
      "ForStatement[1,3].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[1,3].ContainsDuplicateLabels",
        "name" : "ForStatement[1,3].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    901,
    [
      "BindingElement[1,0].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElement[1]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _v_ be *undefined*.\n        1. If _iteratorRecord_.[[Done]] is *false*, then\n          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is not ~done~, then\n            1. Set _v_ to _next_.\n        1. If |Initializer| is present and _v_ is *undefined*, then\n          1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n          1. Set _v_ to ? GetValue(_defaultValue_).\n        1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.\n      ",
      {
        "normalizedName" : "BindingElement[1,0].IteratorBindingInitialization",
        "name" : "BindingElement[1,0].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    686,
    [
      "CaseBlock[1,2].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "CaseBlock[1,2].ContainsUndefinedContinueTarget",
        "name" : "CaseBlock[1,2].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2419,
    [
      "NestedClass[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[NestedClass[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return CompileToCharSet of |ClassContents| with argument _rer_.\n        ",
      {
        "normalizedName" : "NestedClass[0,0].CompileToCharSet",
        "name" : "NestedClass[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NestedClass",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "ClassContents"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1075,
    [
      "AgentSignifier",
      0,
      [
      ],
      "\n        1. Let _AR_ be the Agent Record of the surrounding agent.\n        1. Return _AR_.[[Signifier]].\n      ",
      {
        "normalizedName" : "AgentSignifier",
        "name" : "AgentSignifier",
        "htmlId" : "sec-agentsignifier",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    476,
    [
      "LabelledItem[1,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[1]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "LabelledItem[1,0].VarScopedDeclarations",
        "name" : "LabelledItem[1,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1424,
    [
      "HoistableDeclaration[3,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[HoistableDeclaration[3]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "HoistableDeclaration[3,0].Evaluation",
        "name" : "HoistableDeclaration[3,0].Evaluation",
        "htmlId" : "sec-statement-semantics-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "HoistableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2312,
    [
      "CharacterClassEscape[5,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[5]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "CharacterClassEscape[5,0].MayContainStrings",
        "name" : "CharacterClassEscape[5,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "W"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2455,
    [
      "INTRINSICS.RegExp.prototype[@@matchAll]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. If _R_ is not an Object, throw a *TypeError* exception.\n          1. Let _S_ be ? ToString(_string_).\n          1. Let _C_ be ? SpeciesConstructor(_R_, %RegExp%).\n          1. Let _flags_ be ? ToString(? Get(_R_, *\"flags\"*)).\n          1. Let _matcher_ be ? Construct(_C_, « _R_, _flags_ »).\n          1. Let _lastIndex_ be ? ToLength(? Get(_R_, *\"lastIndex\"*)).\n          1. Perform ? Set(_matcher_, *\"lastIndex\"*, _lastIndex_, *true*).\n          1. If _flags_ contains *\"g\"*, let _global_ be *true*.\n          1. Else, let _global_ be *false*.\n          1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _fullUnicode_ be *true*.\n          1. Else, let _fullUnicode_ be *false*.\n          1. Return CreateRegExpStringIterator(_matcher_, _S_, _global_, _fullUnicode_).\n        ",
      {
        "normalizedName" : "INTRINSICS.RegExp.prototype[@@matchAll]",
        "name" : "INTRINSICS.RegExp.prototype[@@matchAll]",
        "htmlId" : "sec-regexp-prototype-matchall",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2080,
    [
      "INTRINSICS.Object.prototype.__lookupGetter__",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _O_ be ? ToObject(*this* value).\n            1. Let _key_ be ? ToPropertyKey(_P_).\n            1. Repeat,\n              1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_key_).\n              1. If _desc_ is not *undefined*, then\n                1. If IsAccessorDescriptor(_desc_) is *true*, return _desc_.[[Get]].\n                1. Return *undefined*.\n              1. Set _O_ to ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]()</emu-meta>.\n              1. If _O_ is *null*, return *undefined*.\n          ",
      {
        "normalizedName" : "INTRINSICS.Object.prototype.__lookupGetter__",
        "name" : "INTRINSICS.Object.prototype.__lookupGetter__",
        "htmlId" : "sec-object.prototype.__lookupGetter__",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    642,
    [
      "Statement[8,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[8]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[8,0].ContainsUndefinedContinueTarget",
        "name" : "Statement[8,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ReturnStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1414,
    [
      "Elision[0,0].IteratorDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Elision[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n          1. If _iteratorRecord_.[[Done]] is *false*, then\n            1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).\n            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.\n            1. ReturnIfAbrupt(_next_).\n            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "Elision[0,0].IteratorDestructuringAssignmentEvaluation",
        "name" : "Elision[0,0].IteratorDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Elision",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : ","
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2053,
    [
      "INTRINSICS.Object.getOwnPropertyDescriptor",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Let _key_ be ? ToPropertyKey(_P_).\n          1. Let _desc_ be ? <emu-meta effects=\"user-code\">_obj_.[[GetOwnProperty]]</emu-meta>(_key_).\n          1. Return FromPropertyDescriptor(_desc_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.getOwnPropertyDescriptor",
        "name" : "INTRINSICS.Object.getOwnPropertyDescriptor",
        "htmlId" : "sec-object.getownpropertydescriptor",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2196,
    [
      "INTRINSICS.Date.prototype.getMonth",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return MonthFromTime(LocalTime(_t_)).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getMonth",
        "name" : "INTRINSICS.Date.prototype.getMonth",
        "htmlId" : "sec-date.prototype.getmonth",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2240,
    [
      "INTRINSICS.String.prototype.charAt",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).\n          1. Let _size_ be the length of _S_.\n          1. If _position_ < 0 or _position_ ≥ _size_, return the empty String.\n          1. Return the substring of _S_ from _position_ to _position_ + 1.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.charAt",
        "name" : "INTRINSICS.String.prototype.charAt",
        "htmlId" : "sec-string.prototype.charat",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    526,
    [
      "ForStatement[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,0].ContainsDuplicateLabels",
        "name" : "ForStatement[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1842,
    [
      "RelationalExpression[6,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[6]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[6,0].HasCallInTailPosition",
        "name" : "RelationalExpression[6,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    637,
    [
      "ModuleItem[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ModuleItem[1,0].ContainsUndefinedBreakTarget",
        "name" : "ModuleItem[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1584,
    [
      "BindingElement[1,1].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElement[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "BindingElement[1,1].IsSimpleParameterList",
        "name" : "BindingElement[1,1].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "BindingElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1700,
    [
      "AsyncGeneratorMethod[0,0].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorMethod[0]]"
        ]
      ],
      "\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      ",
      {
        "normalizedName" : "AsyncGeneratorMethod[0,0].PrivateBoundIdentifiers",
        "name" : "AsyncGeneratorMethod[0,0].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    489,
    [
      "Module[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Module[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Module[0,0].VarScopedDeclarations",
        "name" : "Module[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Module",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2613,
    [
      "CreateSetIterator:clo0",
      6,
      [
      ],
      "\n          1. Perform ? RequireInternalSlot(_set_, [[SetData]]).\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _set_ and _kind_ and performs the following steps when called:\n            1. Let _index_ be 0.\n            1. Let _entries_ be _set_.[[SetData]].\n            1. Let _numEntries_ be the number of elements in _entries_.\n            1. Repeat, while _index_ < _numEntries_,\n              1. Let _e_ be _entries_[_index_].\n              1. Set _index_ to _index_ + 1.\n              1. If _e_ is not ~empty~, then\n                1. If _kind_ is ~key+value~, then\n                  1. Let _result_ be CreateArrayFromList(« _e_, _e_ »).\n                  1. Perform ? GeneratorYield(CreateIterResultObject(_result_, *false*)).\n                1. Else,\n                  1. Assert: _kind_ is ~value~.\n                  1. Perform ? GeneratorYield(CreateIterResultObject(_e_, *false*)).\n                1. NOTE: The number of elements in _entries_ may have increased while execution of this abstract operation was paused by Yield.\n                1. Set _numEntries_ to the number of elements in _entries_.\n            1. Return NormalCompletion(*undefined*).\n          1. Return CreateIteratorFromClosure(_closure_, *\"%SetIteratorPrototype%\"*, %SetIteratorPrototype%).\n        ",
      {
        "normalizedName" : "CreateSetIterator",
        "name" : "CreateSetIterator",
        "htmlId" : "sec-createsetiterator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1937,
    [
      "ExecuteAsyncModule:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n              1. Assert: _module_.[[Status]] is either ~evaluating~ or ~evaluating-async~.\n              1. Assert: _module_.[[HasTLA]] is *true*.\n              1. Let _capability_ be ! NewPromiseCapability(%Promise%).\n              1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and performs the following steps when called:\n                1. Perform AsyncModuleExecutionFulfilled(_module_).\n                1. Return *undefined*.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *\"\"*, « »).\n              1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_error_) that captures _module_ and performs the following steps when called:\n                1. Perform AsyncModuleExecutionRejected(_module_, _error_).\n                1. Return *undefined*.\n              1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 0, *\"\"*, « »).\n              1. Perform PerformPromiseThen(_capability_.[[Promise]], _onFulfilled_, _onRejected_).\n              1. Perform ! <emu-meta effects=\"user-code\">_module_.ExecuteModule</emu-meta>(_capability_).\n              1. Return ~unused~.\n            ",
      {
        "normalizedName" : "ExecuteAsyncModule",
        "name" : "ExecuteAsyncModule",
        "htmlId" : "sec-execute-async-module",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2172,
    [
      "SecFromTime",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. Return 𝔽(floor(ℝ(_t_ / msPerSecond)) modulo SecondsPerMinute).\n        ",
      {
        "normalizedName" : "SecFromTime",
        "name" : "SecFromTime",
        "htmlId" : "sec-secfromtime",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1810,
    [
      "CaseBlock[1,1].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Let _has_ be *false*.\n        1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.\n        1. Return _has_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,1].HasCallInTailPosition",
        "name" : "CaseBlock[1,1].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1791,
    [
      "ForStatement[0,5].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[0,5].HasCallInTailPosition",
        "name" : "ForStatement[0,5].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 5,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1214,
    [
      "IdentifierPart[0,0].IdentifierCodePoint",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierPart[0]]"
        ]
      ],
      "\n          1. Return the code point matched by |IdentifierPartChar|.\n        ",
      {
        "normalizedName" : "IdentifierPart[0,0].IdentifierCodePoint",
        "name" : "IdentifierPart[0,0].IdentifierCodePoint",
        "htmlId" : "sec-identifiercodepoint",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IdentifierCodePoint",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IdentifierPart",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierPartChar"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2349,
    [
      "Term[1,0].CompileSubpattern",
      2,
      [
        [
          "this",
          false,
          "Ast[Term[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Return CompileAtom of |Atom| with arguments _rer_ and _direction_.\n        ",
      {
        "normalizedName" : "Term[1,0].CompileSubpattern",
        "name" : "Term[1,0].CompileSubpattern",
        "htmlId" : "sec-compilesubpattern",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileSubpattern",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Term",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Atom"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2108,
    [
      "INTRINSICS.Number.isFinite",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _number_ is not a Number, return *false*.\n          1. If _number_ is not finite, return *false*.\n          1. Otherwise, return *true*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Number.isFinite",
        "name" : "INTRINSICS.Number.isFinite",
        "htmlId" : "sec-number.isfinite",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2038,
    [
      "INTRINSICS.encodeURI",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _uriString_ be ? ToString(_uri_).\n          1. Let _extraUnescaped_ be *\";/?:@&=+$,#\"*.\n          1. Return ? Encode(_uriString_, _extraUnescaped_).\n        ",
      {
        "normalizedName" : "INTRINSICS.encodeURI",
        "name" : "INTRINSICS.encodeURI",
        "htmlId" : "sec-encodeuri-uri",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1446,
    [
      "BindingElement[1,0].KeyedBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElement[1]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ],
        [
          "propertyName",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. Let _v_ be ? GetV(_value_, _propertyName_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n            1. Set _v_ to ? GetValue(_defaultValue_).\n          1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.\n        ",
      {
        "normalizedName" : "BindingElement[1,0].KeyedBindingInitialization",
        "name" : "BindingElement[1,0].KeyedBindingInitialization",
        "htmlId" : "sec-runtime-semantics-keyedbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "KeyedBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2551,
    [
      "INTRINSICS.TypedArray.prototype.keys",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Return CreateArrayIterator(_O_, ~key~).\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.keys",
        "name" : "INTRINSICS.TypedArray.prototype.keys",
        "htmlId" : "sec-%typedarray%.prototype.keys",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1016,
    [
      "Record[DeclarativeEnvironmentRecord].HasSuperBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ]
      ],
      "\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "Record[DeclarativeEnvironmentRecord].HasSuperBinding",
        "name" : "Record[DeclarativeEnvironmentRecord].HasSuperBinding",
        "htmlId" : "sec-declarative-environment-records-hassuperbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "DeclarativeEnvironmentRecord",
          "HasSuperBinding"
        ]
      }
    ]
  ],
  [
    2085,
    [
      "INTRINSICS.Function.prototype.bind",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _Target_ be the *this* value.\n          1. If IsCallable(_Target_) is *false*, throw a *TypeError* exception.\n          1. Let _F_ be ? BoundFunctionCreate(_Target_, _thisArg_, _args_).\n          1. Let _L_ be 0.\n          1. Let _targetHasLength_ be ? HasOwnProperty(_Target_, *\"length\"*).\n          1. If _targetHasLength_ is *true*, then\n            1. Let _targetLen_ be ? Get(_Target_, *\"length\"*).\n            1. If _targetLen_ is a Number, then\n              1. If _targetLen_ is *+∞*<sub>𝔽</sub>, then\n                1. Set _L_ to +∞.\n              1. Else if _targetLen_ is *-∞*<sub>𝔽</sub>, then\n                1. Set _L_ to 0.\n              1. Else,\n                1. Let _targetLenAsInt_ be ! ToIntegerOrInfinity(_targetLen_).\n                1. Assert: _targetLenAsInt_ is finite.\n                1. Let _argCount_ be the number of elements in _args_.\n                1. Set _L_ to max(_targetLenAsInt_ - _argCount_, 0).\n          1. Perform SetFunctionLength(_F_, _L_).\n          1. Let _targetName_ be ? Get(_Target_, *\"name\"*).\n          1. If _targetName_ is not a String, set _targetName_ to the empty String.\n          1. Perform SetFunctionName(_F_, _targetName_, *\"bound\"*).\n          1. Return _F_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Function.prototype.bind",
        "name" : "INTRINSICS.Function.prototype.bind",
        "htmlId" : "sec-function.prototype.bind",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1207,
    [
      "CodePointsToString",
      0,
      [
        [
          "text",
          false,
          "Unknown[\"SequenceOfUnicodeCodePoint\"]"
        ]
      ],
      "\n        1. Let _result_ be the empty String.\n        1. For each code point _cp_ of _text_, do\n          1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(_cp_).\n        1. Return _result_.\n      ",
      {
        "normalizedName" : "CodePointsToString",
        "name" : "CodePointsToString",
        "htmlId" : "sec-codepointstostring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    590,
    [
      "ForStatement[0,2].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,2].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[0,2].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1889,
    [
      "ConditionalExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ConditionalExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Let _has_ be HasCallInTailPosition of the first |AssignmentExpression| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Return HasCallInTailPosition of the second |AssignmentExpression| with argument _call_.\n      ",
      {
        "normalizedName" : "ConditionalExpression[1,0].HasCallInTailPosition",
        "name" : "ConditionalExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ConditionalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShortCircuitExpression"
              },
              {
                "type" : "terminal",
                "value" : "?"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1644,
    [
      "AsyncGeneratorMethod[0,0].MethodDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorMethod[0]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ],
        [
          "enumerable",
          false,
          "Boolean"
        ]
      ],
      "\n        1. Let _propKey_ be ? Evaluation of |ClassElementName|.\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncGeneratorMethod|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform MakeMethod(_closure_, _object_).\n        1. Perform SetFunctionName(_closure_, _propKey_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_).\n      ",
      {
        "normalizedName" : "AsyncGeneratorMethod[0,0].MethodDefinitionEvaluation",
        "name" : "AsyncGeneratorMethod[0,0].MethodDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-methoddefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MethodDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1612,
    [
      "FunctionDeclaration[0,0].InstantiateOrdinaryFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[0]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Let _name_ be StringValue of |BindingIdentifier|.\n        1. Let _sourceText_ be the source text matched by |FunctionDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, _name_).\n        1. Perform MakeConstructor(_F_).\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[0,0].InstantiateOrdinaryFunctionObject",
        "name" : "FunctionDeclaration[0,0].InstantiateOrdinaryFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiateordinaryfunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateOrdinaryFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2472,
    [
      "GetMatchIndexPair",
      0,
      [
        [
          "S",
          false,
          "String"
        ],
        [
          "match",
          false,
          "Record[MatchRecord]"
        ]
      ],
      "\n          1. Assert: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ the length of _S_.\n          1. Return CreateArrayFromList(« 𝔽(_match_.[[StartIndex]]), 𝔽(_match_.[[EndIndex]]) »).\n        ",
      {
        "normalizedName" : "GetMatchIndexPair",
        "name" : "GetMatchIndexPair",
        "htmlId" : "sec-getmatchindexpair",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2649,
    [
      "INTRINSICS.get ArrayBuffer.prototype.resizable",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. If IsFixedLengthArrayBuffer(_O_) is *false*, return *true*; otherwise return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.get ArrayBuffer.prototype.resizable",
        "name" : "INTRINSICS.get ArrayBuffer.prototype.resizable",
        "htmlId" : "sec-get-arraybuffer.prototype.resizable",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    679,
    [
      "ContinueStatement[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ContinueStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ContinueStatement[0,0].ContainsUndefinedContinueTarget",
        "name" : "ContinueStatement[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ContinueStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "continue"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1039,
    [
      "Record[GlobalEnvironmentRecord].HasThisBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ]
      ],
      "\n            1. Return *true*.\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].HasThisBinding",
        "name" : "Record[GlobalEnvironmentRecord].HasThisBinding",
        "htmlId" : "sec-global-environment-records-hasthisbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "HasThisBinding"
        ]
      }
    ]
  ],
  [
    970,
    [
      "EqualityExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "EqualityExpression[1,0].AssignmentTargetType",
        "name" : "EqualityExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "=="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2317,
    [
      "ClassContents[1,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassContents[1]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ClassContents[1,0].MayContainStrings",
        "name" : "ClassContents[1,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassContents",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NonemptyClassRanges"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1155,
    [
      "CreateUnmappedArgumentsObject",
      0,
      [
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Let _len_ be the number of elements in _argumentsList_.\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]] »).\n          1. Set _obj_.[[ParameterMap]] to *undefined*.\n          1. Perform ! DefinePropertyOrThrow(_obj_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n          1. Let _index_ be 0.\n          1. Repeat, while _index_ < _len_,\n            1. Let _val_ be _argumentsList_[_index_].\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_).\n            1. Set _index_ to _index_ + 1.\n          1. Perform ! DefinePropertyOrThrow(_obj_, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n          1. Perform ! DefinePropertyOrThrow(_obj_, *\"callee\"*, PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "CreateUnmappedArgumentsObject",
        "name" : "CreateUnmappedArgumentsObject",
        "htmlId" : "sec-createunmappedargumentsobject",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    547,
    [
      "ForInOfStatement[5,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[5]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[5,0].ContainsDuplicateLabels",
        "name" : "ForInOfStatement[5,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1744,
    [
      "ClassDeclaration[1,0].BindingClassDeclarationEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassDeclaration[1]]"
        ]
      ],
      "\n        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and *\"default\"*.\n        1. Set _value_.[[SourceText]] to the source text matched by |ClassDeclaration|.\n        1. Return _value_.\n      ",
      {
        "normalizedName" : "ClassDeclaration[1,0].BindingClassDeclarationEvaluation",
        "name" : "ClassDeclaration[1,0].BindingClassDeclarationEvaluation",
        "htmlId" : "sec-runtime-semantics-bindingclassdeclarationevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BindingClassDeclarationEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    212,
    [
      "LexicalBinding[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[LexicalBinding[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingIdentifier|.\n      ",
      {
        "normalizedName" : "LexicalBinding[0,0].BoundNames",
        "name" : "LexicalBinding[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LexicalBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    706,
    [
      "GeneratorExpression[0,0].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,0].HasName",
        "name" : "GeneratorExpression[0,0].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2781,
    [
      "INTRINSICS.Promise.prototype.finally:clo0:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _promise_ be the *this* value.\n          1. If _promise_ is not an Object, throw a *TypeError* exception.\n          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).\n          1. Assert: IsConstructor(_C_) is *true*.\n          1. If IsCallable(_onFinally_) is *false*, then\n            1. Let _thenFinally_ be _onFinally_.\n            1. Let _catchFinally_ be _onFinally_.\n          1. Else,\n            1. Let _thenFinallyClosure_ be a new Abstract Closure with parameters (_value_) that captures _onFinally_ and _C_ and performs the following steps when called:\n              1. Let _result_ be ? Call(_onFinally_, *undefined*).\n              1. Let _p_ be ? PromiseResolve(_C_, _result_).\n              1. Let _returnValue_ be a new Abstract Closure with no parameters that captures _value_ and performs the following steps when called:\n                1. Return _value_.\n              1. Let _valueThunk_ be CreateBuiltinFunction(_returnValue_, 0, *\"\"*, « »).\n              1. Return ? Invoke(_p_, *\"then\"*, « _valueThunk_ »).\n            1. Let _thenFinally_ be CreateBuiltinFunction(_thenFinallyClosure_, 1, *\"\"*, « »).\n            1. Let _catchFinallyClosure_ be a new Abstract Closure with parameters (_reason_) that captures _onFinally_ and _C_ and performs the following steps when called:\n              1. Let _result_ be ? Call(_onFinally_, *undefined*).\n              1. Let _p_ be ? PromiseResolve(_C_, _result_).\n              1. Let _throwReason_ be a new Abstract Closure with no parameters that captures _reason_ and performs the following steps when called:\n                1. Return ThrowCompletion(_reason_).\n              1. Let _thrower_ be CreateBuiltinFunction(_throwReason_, 0, *\"\"*, « »).\n              1. Return ? Invoke(_p_, *\"then\"*, « _thrower_ »).\n            1. Let _catchFinally_ be CreateBuiltinFunction(_catchFinallyClosure_, 1, *\"\"*, « »).\n          1. Return ? Invoke(_promise_, *\"then\"*, « _thenFinally_, _catchFinally_ »).\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.prototype.finally",
        "name" : "INTRINSICS.Promise.prototype.finally",
        "htmlId" : "sec-promise.prototype.finally",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    96,
    [
      "PutValue",
      0,
      [
        [
          "V",
          false,
          "ESValue | Record[ReferenceRecord]"
        ],
        [
          "W",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If _V_ is not a Reference Record, throw a *ReferenceError* exception.\n          1. If IsUnresolvableReference(_V_) is *true*, then\n            1. If _V_.[[Strict]] is *true*, throw a *ReferenceError* exception.\n            1. Let _globalObj_ be GetGlobalObject().\n            1. Perform ? Set(_globalObj_, _V_.[[ReferencedName]], _W_, *false*).\n            1. Return ~unused~.\n          1. If IsPropertyReference(_V_) is *true*, then\n            1. [id=\"step-putvalue-toobject\"] Let _baseObj_ be ? ToObject(_V_.[[Base]]).\n            1. If IsPrivateReference(_V_) is *true*, then\n              1. Return ? PrivateSet(_baseObj_, _V_.[[ReferencedName]], _W_).\n            1. Let _succeeded_ be ? <emu-meta effects=\"user-code\">_baseObj_.[[Set]]</emu-meta>(_V_.[[ReferencedName]], _W_, GetThisValue(_V_)).\n            1. If _succeeded_ is *false* and _V_.[[Strict]] is *true*, throw a *TypeError* exception.\n            1. Return ~unused~.\n          1. Else,\n            1. Let _base_ be _V_.[[Base]].\n            1. Assert: _base_ is an Environment Record.\n            1. Return ? <emu-meta effects=\"user-code\">_base_.SetMutableBinding</emu-meta>(_V_.[[ReferencedName]], _W_, _V_.[[Strict]]) (see <emu-xref href=\"#sec-environment-records\"></emu-xref>).\n        ",
      {
        "normalizedName" : "PutValue",
        "name" : "PutValue",
        "htmlId" : "sec-putvalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1419,
    [
      "AssignmentElement[0,0].KeyedDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentElement[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "propertyName",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.\n          1. Let _v_ be ? GetV(_value_, _propertyName_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) and IsIdentifierRef of |DestructuringAssignmentTarget| are both *true*, then\n              1. Let _rhsValue_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Let _rhsValue_ be ? GetValue(_defaultValue_).\n          1. Else,\n            1. Let _rhsValue_ be _v_.\n          1. If |DestructuringAssignmentTarget| is either an |ObjectLiteral| or an |ArrayLiteral|, then\n            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n            1. Return ? DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _rhsValue_.\n          1. Return ? PutValue(_lref_, _rhsValue_).\n        ",
      {
        "normalizedName" : "AssignmentElement[0,0].KeyedDestructuringAssignmentEvaluation",
        "name" : "AssignmentElement[0,0].KeyedDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-keyeddestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "KeyedDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AssignmentElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DestructuringAssignmentTarget"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    701,
    [
      "ModuleItemList[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |ModuleItemList| with arguments _iterationSet_ and « ».\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of |ModuleItem| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ModuleItemList[1,0].ContainsUndefinedContinueTarget",
        "name" : "ModuleItemList[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1984,
    [
      "ModuleItem[1,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[1]]"
        ]
      ],
      "\n          1. Return the ExportedNames of |ExportDeclaration|.\n        ",
      {
        "normalizedName" : "ModuleItem[1,0].ExportedNames",
        "name" : "ModuleItem[1,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1874,
    [
      "MemberExpression[7,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[7]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[7,0].HasCallInTailPosition",
        "name" : "MemberExpression[7,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1715,
    [
      "AsyncFunctionDeclaration[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionDeclaration[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncFunctionDeclaration[0,0].ContainsArguments",
        "name" : "AsyncFunctionDeclaration[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1720,
    [
      "MethodDefinition[4,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[4]]"
        ]
      ],
      "\n        1. Return ContainsArguments of |ClassElementName|.\n      ",
      {
        "normalizedName" : "MethodDefinition[4,0].ContainsArguments",
        "name" : "MethodDefinition[4,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "get"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2272,
    [
      "INTRINSICS.String.prototype.trimEnd",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Return ? TrimString(_S_, ~end~).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.trimEnd",
        "name" : "INTRINSICS.String.prototype.trimEnd",
        "htmlId" : "sec-string.prototype.trimend",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    622,
    [
      "CaseClauses[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClauses[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |CaseClauses| with argument _labelSet_.\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of |CaseClause| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "CaseClauses[1,0].ContainsUndefinedBreakTarget",
        "name" : "CaseClauses[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseClauses",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClause"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    837,
    [
      "AsyncGeneratorExpression[0,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,0].Contains",
        "name" : "AsyncGeneratorExpression[0,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1825,
    [
      "AssignmentExpression[4,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[4]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[4,0].HasCallInTailPosition",
        "name" : "AssignmentExpression[4,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    393,
    [
      "WithStatement[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[WithStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "WithStatement[0,0].VarDeclaredNames",
        "name" : "WithStatement[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WithStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "with"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1114,
    [
      "FunctionBody[0,0].EvaluateBody",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Return ? EvaluateFunctionBody of |FunctionBody| with arguments _functionObject_ and _argumentsList_.\n        ",
      {
        "normalizedName" : "FunctionBody[0,0].EvaluateBody",
        "name" : "FunctionBody[0,0].EvaluateBody",
        "htmlId" : "sec-runtime-semantics-evaluatebody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionStatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1324,
    [
      "TemplateLiteral[0,0].ArgumentListEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateLiteral[0]]"
        ]
      ],
      "\n          1. Let _templateLiteral_ be this |TemplateLiteral|.\n          1. Let _siteObj_ be GetTemplateObject(_templateLiteral_).\n          1. Return « _siteObj_ ».\n        ",
      {
        "normalizedName" : "TemplateLiteral[0,0].ArgumentListEvaluation",
        "name" : "TemplateLiteral[0,0].ArgumentListEvaluation",
        "htmlId" : "sec-runtime-semantics-argumentlistevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArgumentListEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TemplateLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NoSubstitutionTemplate"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2285,
    [
      "ClassEscape[0,0].IsCharacterClass",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassEscape[0]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ClassEscape[0,0].IsCharacterClass",
        "name" : "ClassEscape[0,0].IsCharacterClass",
        "htmlId" : "sec-patterns-static-semantics-is-character-class",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsCharacterClass",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "b"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2504,
    [
      "INTRINSICS.Array.prototype.map",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, _len_).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Let _mappedValue_ be ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n              1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.map",
        "name" : "INTRINSICS.Array.prototype.map",
        "htmlId" : "sec-array.prototype.map",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    647,
    [
      "Statement[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |BlockStatement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "Statement[0,0].ContainsUndefinedContinueTarget",
        "name" : "Statement[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BlockStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1776,
    [
      "ReturnStatement[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ReturnStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ReturnStatement[0,0].HasCallInTailPosition",
        "name" : "ReturnStatement[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ReturnStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "return"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1263,
    [
      "PropertyName[1,0].IsComputedPropertyKey",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyName[1]]"
        ]
      ],
      "\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "PropertyName[1,0].IsComputedPropertyKey",
        "name" : "PropertyName[1,0].IsComputedPropertyKey",
        "htmlId" : "sec-static-semantics-iscomputedpropertykey",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsComputedPropertyKey",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "PropertyName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ComputedPropertyName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    997,
    [
      "MethodDefinition[0,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[0]]"
        ]
      ],
      "\n        1. Return PropName of |ClassElementName|.\n      ",
      {
        "normalizedName" : "MethodDefinition[0,0].PropName",
        "name" : "MethodDefinition[0,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2450,
    [
      "RegExpHasFlag",
      0,
      [
        [
          "R",
          false,
          "ESValue"
        ],
        [
          "codeUnit",
          false,
          "Unknown[\"CodeUnit\"]"
        ]
      ],
      "\n            1. If _R_ is not an Object, throw a *TypeError* exception.\n            1. If _R_ does not have an [[OriginalFlags]] internal slot, then\n              1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *undefined*.\n              1. Otherwise, throw a *TypeError* exception.\n            1. Let _flags_ be _R_.[[OriginalFlags]].\n            1. If _flags_ contains _codeUnit_, return *true*.\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "RegExpHasFlag",
        "name" : "RegExpHasFlag",
        "htmlId" : "sec-regexphasflag",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2125,
    [
      "INTRINSICS.Math.abs",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is *NaN*, return *NaN*.\n          1. If _n_ is *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ is *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n          1. If _n_ < *-0*<sub>𝔽</sub>, return -_n_.\n          1. Return _n_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.abs",
        "name" : "INTRINSICS.Math.abs",
        "htmlId" : "sec-math.abs",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1588,
    [
      "FormalParameters[1,0].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameters[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FormalParameters[1,0].IsSimpleParameterList",
        "name" : "FormalParameters[1,0].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FormalParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionRestParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1099,
    [
      "OrdinaryGet",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. If _desc_ is *undefined*, then\n            1. Let _parent_ be ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]</emu-meta>().\n            1. If _parent_ is *null*, return *undefined*.\n            1. Return ? <emu-meta effects=\"user-code\">_parent_.[[Get]]</emu-meta>(_P_, _Receiver_).\n          1. If IsDataDescriptor(_desc_) is *true*, return _desc_.[[Value]].\n          1. Assert: IsAccessorDescriptor(_desc_) is *true*.\n          1. Let _getter_ be _desc_.[[Get]].\n          1. If _getter_ is *undefined*, return *undefined*.\n          1. Return ? Call(_getter_, _Receiver_).\n        ",
      {
        "normalizedName" : "OrdinaryGet",
        "name" : "OrdinaryGet",
        "htmlId" : "sec-ordinaryget",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    985,
    [
      "AssignmentExpression[5,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[5]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "AssignmentExpression[5,0].AssignmentTargetType",
        "name" : "AssignmentExpression[5,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentOperator"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    515,
    [
      "Statement[7,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[7]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[7,0].ContainsDuplicateLabels",
        "name" : "Statement[7,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BreakStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1150,
    [
      "Record[ArgumentsExoticObject].GetOwnProperty",
      4,
      [
        [
          "args",
          false,
          "Record[ArgumentsExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. Let _desc_ be OrdinaryGetOwnProperty(_args_, _P_).\n          1. If _desc_ is *undefined*, return *undefined*.\n          1. Let _map_ be _args_.[[ParameterMap]].\n          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n          1. If _isMapped_ is *true*, then\n            1. Set _desc_.[[Value]] to ! Get(_map_, _P_).\n          1. Return _desc_.\n        ",
      {
        "normalizedName" : "Record[ArgumentsExoticObject].GetOwnProperty",
        "name" : "Record[ArgumentsExoticObject].GetOwnProperty",
        "htmlId" : "sec-arguments-exotic-objects-getownproperty-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ArgumentsExoticObject",
          "[[GetOwnProperty]]"
        ]
      }
    ]
  ],
  [
    1478,
    [
      "CreatePerIterationEnvironment",
      0,
      [
        [
          "perIterationBindings",
          false,
          "List[String]"
        ]
      ],
      "\n          1. If _perIterationBindings_ has any elements, then\n            1. Let _lastIterationEnv_ be the running execution context's LexicalEnvironment.\n            1. Let _outer_ be _lastIterationEnv_.[[OuterEnv]].\n            1. Assert: _outer_ is not *null*.\n            1. Let _thisIterationEnv_ be NewDeclarativeEnvironment(_outer_).\n            1. For each element _bn_ of _perIterationBindings_, do\n              1. Perform ! _thisIterationEnv_.CreateMutableBinding(_bn_, *false*).\n              1. Let _lastValue_ be ? _lastIterationEnv_.GetBindingValue(_bn_, *true*).\n              1. Perform ! _thisIterationEnv_.InitializeBinding(_bn_, _lastValue_).\n            1. Set the running execution context's LexicalEnvironment to _thisIterationEnv_.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "CreatePerIterationEnvironment",
        "name" : "CreatePerIterationEnvironment",
        "htmlId" : "sec-createperiterationenvironment",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1249,
    [
      "ElementList[0,1].ArrayAccumulation",
      2,
      [
        [
          "this",
          false,
          "Ast[ElementList[0]]"
        ],
        [
          "array",
          false,
          "Record[Array]"
        ],
        [
          "nextIndex",
          false,
          "Int"
        ]
      ],
      "\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Let _initResult_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _initValue_ be ? GetValue(_initResult_).\n          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).\n          1. Return _nextIndex_ + 1.\n        ",
      {
        "normalizedName" : "ElementList[0,1].ArrayAccumulation",
        "name" : "ElementList[0,1].ArrayAccumulation",
        "htmlId" : "sec-runtime-semantics-arrayaccumulation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArrayAccumulation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2519,
    [
      "INTRINSICS.Array.prototype.toReversed",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _A_ be ? ArrayCreate(_len_).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _from_ be ! ToString(𝔽(_len_ - _k_ - 1)).\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _fromValue_ be ? Get(_O_, _from_).\n            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.toReversed",
        "name" : "INTRINSICS.Array.prototype.toReversed",
        "htmlId" : "sec-array.prototype.toreversed",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2536,
    [
      "INTRINSICS.get TypedArray.prototype.byteLength",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. Let _size_ be TypedArrayByteLength(_taRecord_).\n          1. Return 𝔽(_size_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get TypedArray.prototype.byteLength",
        "name" : "INTRINSICS.get TypedArray.prototype.byteLength",
        "htmlId" : "sec-get-%typedarray%.prototype.bytelength",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1297,
    [
      "TemplateMiddleList[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateMiddleList[1]]"
        ]
      ],
      "\n          1. Let _rest_ be ? Evaluation of |TemplateMiddleList|.\n          1. Let _middle_ be the TV of |TemplateMiddle| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.\n          1. Let _subRef_ be ? Evaluation of |Expression|.\n          1. Let _sub_ be ? GetValue(_subRef_).\n          1. Let _last_ be ? ToString(_sub_).\n          1. Return the string-concatenation of _rest_, _middle_, and _last_.\n        ",
      {
        "normalizedName" : "TemplateMiddleList[1,0].Evaluation",
        "name" : "TemplateMiddleList[1,0].Evaluation",
        "htmlId" : "sec-template-literals-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TemplateMiddleList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateMiddleList"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateMiddle"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2681,
    [
      "INTRINSICS.DataView.prototype.getUint32",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~uint32~).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.getUint32",
        "name" : "INTRINSICS.DataView.prototype.getUint32",
        "htmlId" : "sec-dataview.prototype.getuint32",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1451,
    [
      "ExpressionStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ExpressionStatement[0]]"
        ]
      ],
      "\n        1. Let _exprRef_ be ? Evaluation of |Expression|.\n        1. Return ? GetValue(_exprRef_).\n      ",
      {
        "normalizedName" : "ExpressionStatement[0,0].Evaluation",
        "name" : "ExpressionStatement[0,0].Evaluation",
        "htmlId" : "sec-expression-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExpressionStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    738,
    [
      "UpdateExpression[3,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[3]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UpdateExpression[3,0].IsFunctionDefinition",
        "name" : "UpdateExpression[3,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "++"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2304,
    [
      "ClassSetCharacter[0,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSetCharacter[0]]"
        ]
      ],
      "\n          1. Let _ch_ be the code point matched by |SourceCharacter|.\n          1. Return the numeric value of _ch_.\n        ",
      {
        "normalizedName" : "ClassSetCharacter[0,0].CharacterValue",
        "name" : "ClassSetCharacter[0,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassSetCharacter",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SourceCharacter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1530,
    [
      "DefaultClause[0,1].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ]
      ],
      "\n        1. Return ? Evaluation of |StatementList|.\n      ",
      {
        "normalizedName" : "DefaultClause[0,1].Evaluation",
        "name" : "DefaultClause[0,1].Evaluation",
        "htmlId" : "sec-switch-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1539,
    [
      "Statement[2,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |Statement|.\n      ",
      {
        "normalizedName" : "Statement[2,0].LabelledEvaluation",
        "name" : "Statement[2,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EmptyStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2836,
    [
      "Await",
      0,
      [
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _asyncContext_ be the running execution context.\n          1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).\n          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_v_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using NormalCompletion(_v_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using ThrowCompletion(_reason_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n          1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n          1. Let _callerContext_ be the running execution context.\n          1. Resume _callerContext_ passing ~empty~. If _asyncContext_ is ever resumed again, let _completion_ be the Completion Record with which it is resumed.\n          1. Assert: If control reaches here, then _asyncContext_ is the running execution context again.\n          1. Return _completion_.\n        ",
      {
        "normalizedName" : "Await",
        "name" : "Await",
        "htmlId" : "await",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1456,
    [
      "IterationStatement[1,0].LoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[IterationStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Return ? WhileLoopEvaluation of |WhileStatement| with argument _labelSet_.\n        ",
      {
        "normalizedName" : "IterationStatement[1,0].LoopEvaluation",
        "name" : "IterationStatement[1,0].LoopEvaluation",
        "htmlId" : "sec-runtime-semantics-loopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IterationStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "WhileStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1382,
    [
      "CoalesceExpression[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CoalesceExpression[0]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |CoalesceExpressionHead|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. If _lval_ is either *undefined* or *null*, then\n          1. Let _rref_ be ? Evaluation of |BitwiseORExpression|.\n          1. Return ? GetValue(_rref_).\n        1. Else,\n          1. Return _lval_.\n      ",
      {
        "normalizedName" : "CoalesceExpression[0,0].Evaluation",
        "name" : "CoalesceExpression[0,0].Evaluation",
        "htmlId" : "sec-binary-logical-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CoalesceExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoalesceExpressionHead"
              },
              {
                "type" : "terminal",
                "value" : "??"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseORExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2487,
    [
      "INTRINSICS.Array.prototype.every",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n              1. If _testResult_ is *false*, return *false*.\n            1. Set _k_ to _k_ + 1.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.every",
        "name" : "INTRINSICS.Array.prototype.every",
        "htmlId" : "sec-array.prototype.every",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2845,
    [
      "INTRINSICS.Reflect.isExtensible",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[IsExtensible]]()</emu-meta>.\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.isExtensible",
        "name" : "INTRINSICS.Reflect.isExtensible",
        "htmlId" : "sec-reflect.isextensible",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2598,
    [
      "INTRINSICS.get Map.prototype.size",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. Let _count_ be 0.\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do\n            1. If _p_.[[Key]] is not ~empty~, set _count_ to _count_ + 1.\n          1. Return 𝔽(_count_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get Map.prototype.size",
        "name" : "INTRINSICS.get Map.prototype.size",
        "htmlId" : "sec-get-map.prototype.size",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1266,
    [
      "ObjectLiteral[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectLiteral[0]]"
        ]
      ],
      "\n          1. Return OrdinaryObjectCreate(%Object.prototype%).\n        ",
      {
        "normalizedName" : "ObjectLiteral[0,0].Evaluation",
        "name" : "ObjectLiteral[0,0].Evaluation",
        "htmlId" : "sec-object-initializer-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ObjectLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2153,
    [
      "INTRINSICS.Math.sin",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the sine of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.sin",
        "name" : "INTRINSICS.Math.sin",
        "htmlId" : "sec-math.sin",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2387,
    [
      "ClassContents[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassContents[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return the empty CharSet.\n        ",
      {
        "normalizedName" : "ClassContents[0,0].CompileToCharSet",
        "name" : "ClassContents[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassContents",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1831,
    [
      "BitwiseXORExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[BitwiseXORExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "BitwiseXORExpression[1,0].HasCallInTailPosition",
        "name" : "BitwiseXORExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BitwiseXORExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BitwiseXORExpression"
              },
              {
                "type" : "terminal",
                "value" : "^"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseANDExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1231,
    [
      "LabelIdentifier[1,0].StringValue",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelIdentifier[1]]"
        ]
      ],
      "\n        1. Return *\"yield\"*.\n      ",
      {
        "normalizedName" : "LabelIdentifier[1,0].StringValue",
        "name" : "LabelIdentifier[1,0].StringValue",
        "htmlId" : "sec-static-semantics-stringvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LabelIdentifier",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "yield"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1131,
    [
      "SetFunctionName",
      0,
      [
        [
          "F",
          false,
          "Record[FunctionObject]"
        ],
        [
          "name",
          false,
          "Record[PrivateName | Symbol] | String"
        ],
        [
          "prefix",
          true,
          "String"
        ]
      ],
      "\n        1. Assert: _F_ is an extensible object that does not have a *\"name\"* own property.\n        1. If _name_ is a Symbol, then\n          1. Let _description_ be _name_'s [[Description]] value.\n          1. If _description_ is *undefined*, set _name_ to the empty String.\n          1. Else, set _name_ to the string-concatenation of *\"[\"*, _description_, and *\"]\"*.\n        1. Else if _name_ is a Private Name, then\n          1. Set _name_ to _name_.[[Description]].\n        1. If _F_ has an [[InitialName]] internal slot, then\n          1. Set _F_.[[InitialName]] to _name_.\n        1. If _prefix_ is present, then\n          1. Set _name_ to the string-concatenation of _prefix_, the code unit 0x0020 (SPACE), and _name_.\n          1. If _F_ has an [[InitialName]] internal slot, then\n            1. Optionally, set _F_.[[InitialName]] to _name_.\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"name\"*, PropertyDescriptor { [[Value]]: _name_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "SetFunctionName",
        "name" : "SetFunctionName",
        "htmlId" : "sec-setfunctionname",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    654,
    [
      "ForStatement[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[0,0].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1668,
    [
      "ClassElement[5,0].ClassElementKind",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[5]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "ClassElement[5,0].ClassElementKind",
        "name" : "ClassElement[5,0].ClassElementKind",
        "htmlId" : "sec-static-semantics-classelementkind",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassElementKind",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1974,
    [
      "ExportDeclaration[2,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[2]]"
        ]
      ],
      "\n          1. Return the BoundNames of |VariableStatement|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[2,0].ExportedBindings",
        "name" : "ExportDeclaration[2,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1552,
    [
      "TryStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[0]]"
        ]
      ],
      "\n        1. Let _B_ be Completion(Evaluation of |Block|).\n        1. If _B_ is a throw completion, let _C_ be Completion(CatchClauseEvaluation of |Catch| with argument _B_.[[Value]]).\n        1. Else, let _C_ be _B_.\n        1. Return ? UpdateEmpty(_C_, *undefined*).\n      ",
      {
        "normalizedName" : "TryStatement[0,0].Evaluation",
        "name" : "TryStatement[0,0].Evaluation",
        "htmlId" : "sec-try-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2851,
    [
      "INTRINSICS.Proxy.revocable:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _proxy_ be ? ProxyCreate(_target_, _handler_).\n          1. Let _revokerClosure_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _F_ be the active function object.\n            1. Let _p_ be _F_.[[RevocableProxy]].\n            1. If _p_ is *null*, return *undefined*.\n            1. Set _F_.[[RevocableProxy]] to *null*.\n            1. Assert: _p_ is a Proxy exotic object.\n            1. Set _p_.[[ProxyTarget]] to *null*.\n            1. Set _p_.[[ProxyHandler]] to *null*.\n            1. Return *undefined*.\n          1. Let _revoker_ be CreateBuiltinFunction(_revokerClosure_, 0, *\"\"*, « [[RevocableProxy]] »).\n          1. Set _revoker_.[[RevocableProxy]] to _proxy_.\n          1. Let _result_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ! CreateDataPropertyOrThrow(_result_, *\"proxy\"*, _proxy_).\n          1. Perform ! CreateDataPropertyOrThrow(_result_, *\"revoke\"*, _revoker_).\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Proxy.revocable",
        "name" : "INTRINSICS.Proxy.revocable",
        "htmlId" : "sec-proxy.revocable",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2243,
    [
      "INTRINSICS.String.prototype.concat",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _R_ be _S_.\n          1. For each element _next_ of _args_, do\n            1. Let _nextString_ be ? ToString(_next_).\n            1. Set _R_ to the string-concatenation of _R_ and _nextString_.\n          1. Return _R_.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.concat",
        "name" : "INTRINSICS.String.prototype.concat",
        "htmlId" : "sec-string.prototype.concat",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2355,
    [
      "Assertion[0,0].CompileAssertion",
      2,
      [
        [
          "this",
          false,
          "Ast[Assertion[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _e_ be _x_.[[EndIndex]].\n            1. If _e_ = 0, or if _rer_.[[Multiline]] is *true* and the character _Input_[_e_ - 1] is matched by |LineTerminator|, then\n              1. Return _c_(_x_).\n            1. Return ~failure~.\n        ",
      {
        "normalizedName" : "Assertion[0,0].CompileAssertion",
        "name" : "Assertion[0,0].CompileAssertion",
        "htmlId" : "sec-compileassertion",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAssertion",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Assertion",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "^"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1192,
    [
      "Record[ProxyExoticObject].SetPrototypeOf",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ],
        [
          "V",
          false,
          "Record[Object] | Null"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"setPrototypeOf\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[SetPrototypeOf]]</emu-meta>(_V_).\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _V_ »)).\n        1. If _booleanTrapResult_ is *false*, return *false*.\n        1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n        1. If _extensibleTarget_ is *true*, return *true*.\n        1. Let _targetProto_ be ? <emu-meta effects=\"user-code\">_target_.[[GetPrototypeOf]]</emu-meta>().\n        1. If SameValue(_V_, _targetProto_) is *false*, throw a *TypeError* exception.\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].SetPrototypeOf",
        "name" : "Record[ProxyExoticObject].SetPrototypeOf",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[SetPrototypeOf]]"
        ]
      }
    ]
  ],
  [
    1932,
    [
      "ContinueModuleLoading",
      0,
      [
        [
          "state",
          false,
          "Record[GraphLoadingStateRecord]"
        ],
        [
          "moduleCompletion",
          false,
          "Normal[Record[ModuleRecord]] | Throw"
        ]
      ],
      "\n              1. If _state_.[[IsLoading]] is *false*, return ~unused~.\n              1. If _moduleCompletion_ is a normal completion, then\n                1. Perform InnerModuleLoading(_state_, _moduleCompletion_.[[Value]]).\n              1. Else,\n                1. Set _state_.[[IsLoading]] to *false*.\n                1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).\n              1. Return ~unused~.\n            ",
      {
        "normalizedName" : "ContinueModuleLoading",
        "name" : "ContinueModuleLoading",
        "htmlId" : "sec-ContinueModuleLoading",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1060,
    [
      "NewPrivateEnvironment",
      0,
      [
        [
          "outerPrivEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n          1. Let _names_ be a new empty List.\n          1. Return the PrivateEnvironment Record { [[OuterPrivateEnvironment]]: _outerPrivEnv_, [[Names]]: _names_ }.\n        ",
      {
        "normalizedName" : "NewPrivateEnvironment",
        "name" : "NewPrivateEnvironment",
        "htmlId" : "sec-newprivateenvironment",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1050,
    [
      "Record[ModuleEnvironmentRecord].GetBindingValue",
      3,
      [
        [
          "envRec",
          false,
          "Record[ModuleEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "S",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Assert: _S_ is *true*.\n            1. Assert: _envRec_ has a binding for _N_.\n            1. If the binding for _N_ is an indirect binding, then\n              1. Let _M_ and _N2_ be the indirection values provided when this binding for _N_ was created.\n              1. Let _targetEnv_ be _M_.[[Environment]].\n              1. If _targetEnv_ is ~empty~, throw a *ReferenceError* exception.\n              1. Return ? <emu-meta effects=\"user-code\">_targetEnv_.GetBindingValue</emu-meta>(_N2_, *true*).\n            1. If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.\n            1. Return the value currently bound to _N_ in _envRec_.\n          ",
      {
        "normalizedName" : "Record[ModuleEnvironmentRecord].GetBindingValue",
        "name" : "Record[ModuleEnvironmentRecord].GetBindingValue",
        "htmlId" : "sec-module-environment-records-getbindingvalue-n-s",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleEnvironmentRecord",
          "GetBindingValue"
        ]
      }
    ]
  ],
  [
    457,
    [
      "ForInOfStatement[5,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[5]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForInOfStatement[5,0].VarScopedDeclarations",
        "name" : "ForInOfStatement[5,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2581,
    [
      "InitializeTypedArrayFromTypedArray",
      0,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "srcArray",
          false,
          "Record[TypedArray]"
        ]
      ],
      "\n            1. Let _srcData_ be _srcArray_.[[ViewedArrayBuffer]].\n            1. Let _elementType_ be TypedArrayElementType(_O_).\n            1. Let _elementSize_ be TypedArrayElementSize(_O_).\n            1. Let _srcType_ be TypedArrayElementType(_srcArray_).\n            1. Let _srcElementSize_ be TypedArrayElementSize(_srcArray_).\n            1. Let _srcByteOffset_ be _srcArray_.[[ByteOffset]].\n            1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_srcArray_, ~seq-cst~).\n            1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, throw a *TypeError* exception.\n            1. Let _elementLength_ be TypedArrayLength(_srcRecord_).\n            1. Let _byteLength_ be _elementSize_ × _elementLength_.\n            1. If _elementType_ is _srcType_, then\n              1. Let _data_ be ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_).\n            1. Else,\n              1. Let _data_ be ? <emu-meta suppress-effects=\"user-code\">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>.\n              1. If _srcArray_.[[ContentType]] is not _O_.[[ContentType]], throw a *TypeError* exception.\n              1. Let _srcByteIndex_ be _srcByteOffset_.\n              1. Let _targetByteIndex_ be 0.\n              1. Let _count_ be _elementLength_.\n              1. Repeat, while _count_ > 0,\n                1. Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~unordered~).\n                1. Perform SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~unordered~).\n                1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.\n                1. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.\n                1. Set _count_ to _count_ - 1.\n            1. Set _O_.[[ViewedArrayBuffer]] to _data_.\n            1. Set _O_.[[ByteLength]] to _byteLength_.\n            1. Set _O_.[[ByteOffset]] to 0.\n            1. Set _O_.[[ArrayLength]] to _elementLength_.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "InitializeTypedArrayFromTypedArray",
        "name" : "InitializeTypedArrayFromTypedArray",
        "htmlId" : "sec-initializetypedarrayfromtypedarray",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2465,
    [
      "INTRINSICS.get RegExp.prototype.unicode",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0075 (LATIN SMALL LETTER U).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get RegExp.prototype.unicode",
        "name" : "INTRINSICS.get RegExp.prototype.unicode",
        "htmlId" : "sec-get-regexp.prototype.unicode",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    984,
    [
      "AssignmentExpression[4,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[4]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "AssignmentExpression[4,0].AssignmentTargetType",
        "name" : "AssignmentExpression[4,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    173,
    [
      "Construct",
      0,
      [
        [
          "F",
          false,
          "Record[Constructor]"
        ],
        [
          "argumentsList",
          true,
          "List[ESValue]"
        ],
        [
          "newTarget",
          true,
          "Record[Constructor]"
        ]
      ],
      "\n        1. If _newTarget_ is not present, set _newTarget_ to _F_.\n        1. If _argumentsList_ is not present, set _argumentsList_ to a new empty List.\n        1. Return ? <emu-meta effects=\"user-code\">_F_.[[Construct]]</emu-meta>(_argumentsList_, _newTarget_).\n      ",
      {
        "normalizedName" : "Construct",
        "name" : "Construct",
        "htmlId" : "sec-construct",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    911,
    [
      "IdentifierReference[0,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierReference[0]]"
        ]
      ],
      "\n        1. If this |IdentifierReference| is contained in strict mode code and StringValue of |Identifier| is either *\"eval\"* or *\"arguments\"*, return ~invalid~.\n        1. Return ~simple~.\n      ",
      {
        "normalizedName" : "IdentifierReference[0,0].AssignmentTargetType",
        "name" : "IdentifierReference[0,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IdentifierReference",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Identifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2505,
    [
      "INTRINSICS.Array.prototype.pop",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If _len_ = 0, then\n            1. Perform ? Set(_O_, *\"length\"*, *+0*<sub>𝔽</sub>, *true*).\n            1. Return *undefined*.\n          1. Else,\n            1. Assert: _len_ > 0.\n            1. Let _newLen_ be 𝔽(_len_ - 1).\n            1. Let _index_ be ! ToString(_newLen_).\n            1. Let _element_ be ? Get(_O_, _index_).\n            1. Perform ? DeletePropertyOrThrow(_O_, _index_).\n            1. Perform ? Set(_O_, *\"length\"*, _newLen_, *true*).\n            1. Return _element_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.pop",
        "name" : "INTRINSICS.Array.prototype.pop",
        "htmlId" : "sec-array.prototype.pop",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2006,
    [
      "ExportDeclaration[2,0].ExportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[2]]"
        ]
      ],
      "\n          1. Let _entries_ be a new empty List.\n          1. Let _names_ be the BoundNames of |VariableStatement|.\n          1. For each element _name_ of _names_, do\n            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.\n          1. Return _entries_.\n        ",
      {
        "normalizedName" : "ExportDeclaration[2,0].ExportEntries",
        "name" : "ExportDeclaration[2,0].ExportEntries",
        "htmlId" : "sec-static-semantics-exportentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntries",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2497,
    [
      "INTRINSICS.Array.prototype.flatMap",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _sourceLen_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_mapperFunction_) is *false*, throw a *TypeError* exception.\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).\n          1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, 1, _mapperFunction_, _thisArg_).\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.flatMap",
        "name" : "INTRINSICS.Array.prototype.flatMap",
        "htmlId" : "sec-array.prototype.flatmap",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    721,
    [
      "PrimaryExpression[2,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[2,0].IsFunctionDefinition",
        "name" : "PrimaryExpression[2,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Literal"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2566,
    [
      "INTRINSICS.TypedArray.prototype.toReversed",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _length_ be TypedArrayLength(_taRecord_).\n          1. Let _A_ be ? TypedArrayCreateSameType(_O_, « 𝔽(_length_) »).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _length_,\n            1. Let _from_ be ! ToString(𝔽(_length_ - _k_ - 1)).\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _fromValue_ be ! Get(_O_, _from_).\n            1. Perform ! Set(_A_, _Pk_, _fromValue_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.toReversed",
        "name" : "INTRINSICS.TypedArray.prototype.toReversed",
        "htmlId" : "sec-%typedarray%.prototype.toreversed",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1799,
    [
      "ForStatement[2,1].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[2,1].HasCallInTailPosition",
        "name" : "ForStatement[2,1].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    13,
    [
      "INTRINSICS.RangeError",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1947,
    [
      "Record[SourceTextModuleRecord].ExecuteModule",
      3,
      [
        [
          "module",
          false,
          "Record[SourceTextModuleRecord]"
        ],
        [
          "capability",
          true,
          "Record[PromiseCapabilityRecord]"
        ]
      ],
      "\n            1. Let _moduleContext_ be a new ECMAScript code execution context.\n            1. Set the Function of _moduleContext_ to *null*.\n            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].\n            1. Set the ScriptOrModule of _moduleContext_ to _module_.\n            1. Assert: _module_ has been linked and declarations in its module environment have been instantiated.\n            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].\n            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].\n            1. Suspend the running execution context.\n            1. If _module_.[[HasTLA]] is *false*, then\n              1. Assert: _capability_ is not present.\n              1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.\n              1. Let _result_ be Completion(Evaluation of _module_.[[ECMAScriptCode]]).\n              1. Suspend _moduleContext_ and remove it from the execution context stack.\n              1. Resume the context that is now on the top of the execution context stack as the running execution context.\n              1. If _result_ is an abrupt completion, then\n                1. Return ? _result_.\n            1. Else,\n              1. Assert: _capability_ is a PromiseCapability Record.\n              1. Perform AsyncBlockStart(_capability_, _module_.[[ECMAScriptCode]], _moduleContext_).\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[SourceTextModuleRecord].ExecuteModule",
        "name" : "Record[SourceTextModuleRecord].ExecuteModule",
        "htmlId" : "sec-source-text-module-record-execute-module",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "SourceTextModuleRecord",
          "ExecuteModule"
        ]
      }
    ]
  ],
  [
    129,
    [
      "StrUnsignedDecimalLiteral[3,1].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StrUnsignedDecimalLiteral[3]]"
        ]
      ],
      "\n            1. Let _a_ be MV of |DecimalDigits|.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Return RoundMVResult(_a_ × 10<sup>_e_</sup>).\n          ",
      {
        "normalizedName" : "StrUnsignedDecimalLiteral[3,1].StringNumericValue",
        "name" : "StrUnsignedDecimalLiteral[3,1].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 1,
            "astName" : "StrUnsignedDecimalLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "nonterminal",
                "value" : "ExponentPart"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1002,
    [
      "ClassElement[4,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[4]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "ClassElement[4,0].PropName",
        "name" : "ClassElement[4,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassStaticBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1852,
    [
      "UpdateExpression[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UpdateExpression[2,0].HasCallInTailPosition",
        "name" : "UpdateExpression[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "--"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2813,
    [
      "AsyncGeneratorEnqueue",
      0,
      [
        [
          "generator",
          false,
          "Record[AsyncGenerator]"
        ],
        [
          "completion",
          false,
          "Completion"
        ],
        [
          "promiseCapability",
          false,
          "Record[PromiseCapabilityRecord]"
        ]
      ],
      "\n          1. Let _request_ be AsyncGeneratorRequest { [[Completion]]: _completion_, [[Capability]]: _promiseCapability_ }.\n          1. Append _request_ to _generator_.[[AsyncGeneratorQueue]].\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncGeneratorEnqueue",
        "name" : "AsyncGeneratorEnqueue",
        "htmlId" : "sec-asyncgeneratorenqueue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    569,
    [
      "FunctionStatementList[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,0].ContainsDuplicateLabels",
        "name" : "FunctionStatementList[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1429,
    [
      "Block[0,1].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Block[0]]"
        ]
      ],
      "\n        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n        1. Perform BlockDeclarationInstantiation(|StatementList|, _blockEnv_).\n        1. Set the running execution context's LexicalEnvironment to _blockEnv_.\n        1. Let _blockValue_ be Completion(Evaluation of |StatementList|).\n        1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n        1. Return ? _blockValue_.\n      ",
      {
        "normalizedName" : "Block[0,1].Evaluation",
        "name" : "Block[0,1].Evaluation",
        "htmlId" : "sec-block-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "Block",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2766,
    [
      "INTRINSICS.Promise.allSettled",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the *this* value.\n          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).\n          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).\n          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).\n          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).\n          1. Let _result_ be Completion(PerformPromiseAllSettled(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).\n          1. If _result_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Return ? _result_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.allSettled",
        "name" : "INTRINSICS.Promise.allSettled",
        "htmlId" : "sec-promise.allsettled",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2052,
    [
      "INTRINSICS.Object.fromEntries",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Perform ? RequireObjectCoercible(_iterable_).\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Assert: _obj_ is an extensible ordinary object with no own properties.\n          1. Let _closure_ be a new Abstract Closure with parameters (_key_, _value_) that captures _obj_ and performs the following steps when called:\n            1. Let _propertyKey_ be ? ToPropertyKey(_key_).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, _propertyKey_, _value_).\n            1. Return *undefined*.\n          1. Let _adder_ be CreateBuiltinFunction(_closure_, 2, *\"\"*, « »).\n          1. Return ? AddEntriesFromIterable(_obj_, _iterable_, _adder_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.fromEntries",
        "name" : "INTRINSICS.Object.fromEntries",
        "htmlId" : "sec-object.fromentries",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2482,
    [
      "INTRINSICS.Array.prototype.at",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n          1. If _relativeIndex_ ≥ 0, then\n            1. Let _k_ be _relativeIndex_.\n          1. Else,\n            1. Let _k_ be _len_ + _relativeIndex_.\n          1. If _k_ < 0 or _k_ ≥ _len_, return *undefined*.\n          1. Return ? Get(_O_, ! ToString(𝔽(_k_))).\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.at",
        "name" : "INTRINSICS.Array.prototype.at",
        "htmlId" : "sec-array.prototype.at",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1599,
    [
      "SingleNameBinding[0,1].HasInitializer",
      2,
      [
        [
          "this",
          false,
          "Ast[SingleNameBinding[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "SingleNameBinding[0,1].HasInitializer",
        "name" : "SingleNameBinding[0,1].HasInitializer",
        "htmlId" : "sec-static-semantics-hasinitializer",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasInitializer",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "SingleNameBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2697,
    [
      "EnterCriticalSection",
      0,
      [
        [
          "WL",
          false,
          "Record[WaiterListRecord]"
        ]
      ],
      "\n          1. Assert: The surrounding agent is not in the critical section for any WaiterList Record.\n          1. Wait until no agent is in the critical section for _WL_, then enter the critical section for _WL_ (without allowing any other agent to enter).\n          1. If _WL_.[[MostRecentLeaveEvent]] is not ~empty~, then\n            1. NOTE: A _WL_ whose critical section has been entered at least once has a Synchronize event set by LeaveCriticalSection.\n            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n            1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n            1. Let _enterEvent_ be a new Synchronize event.\n            1. Append _enterEvent_ to _eventsRecord_.[[EventList]].\n            1. Append (_WL_.[[MostRecentLeaveEvent]], _enterEvent_) to _eventsRecord_.[[AgentSynchronizesWith]].\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "EnterCriticalSection",
        "name" : "EnterCriticalSection",
        "htmlId" : "sec-entercriticalsection",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1246,
    [
      "Elision[0,0].ArrayAccumulation",
      2,
      [
        [
          "this",
          false,
          "Ast[Elision[0]]"
        ],
        [
          "array",
          false,
          "Record[Array]"
        ],
        [
          "nextIndex",
          false,
          "Int"
        ]
      ],
      "\n          1. Let _len_ be _nextIndex_ + 1.\n          1. Perform ? Set(_array_, *\"length\"*, 𝔽(_len_), *true*).\n          1. NOTE: The above step throws if _len_ exceeds 2<sup>32</sup> - 1.\n          1. Return _len_.\n        ",
      {
        "normalizedName" : "Elision[0,0].ArrayAccumulation",
        "name" : "Elision[0,0].ArrayAccumulation",
        "htmlId" : "sec-runtime-semantics-arrayaccumulation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArrayAccumulation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Elision",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : ","
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1979,
    [
      "NamedExports[0,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[NamedExports[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "NamedExports[0,0].ExportedBindings",
        "name" : "NamedExports[0,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NamedExports",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    779,
    [
      "Expression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[Expression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Expression[1,0].IsFunctionDefinition",
        "name" : "Expression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Expression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2140,
    [
      "INTRINSICS.Math.floor",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ < *1*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ is an integral Number, return _n_.\n          1. Return the greatest (closest to +∞) integral Number value that is not greater than _n_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.floor",
        "name" : "INTRINSICS.Math.floor",
        "htmlId" : "sec-math.floor",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    371,
    [
      "ForStatement[0,3].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,3].VarDeclaredNames",
        "name" : "ForStatement[0,3].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2756,
    [
      "TriggerPromiseReactions",
      0,
      [
        [
          "reactions",
          false,
          "List[Record[PromiseReactionRecord]]"
        ],
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n          1. For each element _reaction_ of _reactions_, do\n            1. Let _job_ be NewPromiseReactionJob(_reaction_, _argument_).\n            1. Perform HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "TriggerPromiseReactions",
        "name" : "TriggerPromiseReactions",
        "htmlId" : "sec-triggerpromisereactions",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1759,
    [
      "AsyncConciseBody[1,0].AsyncConciseBodyContainsUseStrict",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncConciseBody[1]]"
        ]
      ],
      "\n        1. Return FunctionBodyContainsUseStrict of |AsyncFunctionBody|.\n      ",
      {
        "normalizedName" : "AsyncConciseBody[1,0].AsyncConciseBodyContainsUseStrict",
        "name" : "AsyncConciseBody[1,0].AsyncConciseBodyContainsUseStrict",
        "htmlId" : "sec-static-semantics-asyncconcisebodycontainsusestrict",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AsyncConciseBodyContainsUseStrict",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncConciseBody",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1393,
    [
      "ObjectAssignmentPattern[3,0].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectAssignmentPattern[3]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Perform ? RequireObjectCoercible(_value_).\n          1. Perform ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "ObjectAssignmentPattern[3,0].DestructuringAssignmentEvaluation",
        "name" : "ObjectAssignmentPattern[3,0].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ObjectAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentPropertyList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    503,
    [
      "LabelledItem[0,0].TopLevelVarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[0]]"
        ]
      ],
      "\n        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return TopLevelVarDeclaredNames of |Statement|.\n        1. Return VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "LabelledItem[0,0].TopLevelVarDeclaredNames",
        "name" : "LabelledItem[0,0].TopLevelVarDeclaredNames",
        "htmlId" : "sec-static-semantics-toplevelvardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelVarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    605,
    [
      "ForInOfStatement[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[1,0].ContainsUndefinedBreakTarget",
        "name" : "ForInOfStatement[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1627,
    [
      "MethodDefinition[0,0].HasDirectSuper",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[0]]"
        ]
      ],
      "\n        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.\n        1. Return |FunctionBody| Contains |SuperCall|.\n      ",
      {
        "normalizedName" : "MethodDefinition[0,0].HasDirectSuper",
        "name" : "MethodDefinition[0,0].HasDirectSuper",
        "htmlId" : "sec-static-semantics-hasdirectsuper",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasDirectSuper",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2370,
    [
      "QuantifierPrefix[4,0].CompileQuantifierPrefix",
      2,
      [
        [
          "this",
          false,
          "Ast[QuantifierPrefix[4]]"
        ]
      ],
      "\n          1. Let _i_ be the MV of |DecimalDigits|.\n          1. Return the Record { [[Min]]: _i_, [[Max]]: +∞ }.\n        ",
      {
        "normalizedName" : "QuantifierPrefix[4,0].CompileQuantifierPrefix",
        "name" : "QuantifierPrefix[4,0].CompileQuantifierPrefix",
        "htmlId" : "sec-compilequantifierprefix",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileQuantifierPrefix",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "QuantifierPrefix",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "terminal",
                "value" : ",}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1525,
    [
      "CaseClauseIsSelected",
      0,
      [
        [
          "C",
          false,
          "Ast[CaseClause]"
        ],
        [
          "input",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Assert: _C_ is an instance of the production <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>.\n        1. Let _exprRef_ be ? Evaluation of the |Expression| of _C_.\n        1. Let _clauseSelector_ be ? GetValue(_exprRef_).\n        1. Return IsStrictlyEqual(_input_, _clauseSelector_).\n      ",
      {
        "normalizedName" : "CaseClauseIsSelected",
        "name" : "CaseClauseIsSelected",
        "htmlId" : "sec-runtime-semantics-caseclauseisselected",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    921,
    [
      "PrimaryExpression[12,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[12]]"
        ]
      ],
      "\n        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return AssignmentTargetType of _expr_.\n      ",
      {
        "normalizedName" : "PrimaryExpression[12,0].AssignmentTargetType",
        "name" : "PrimaryExpression[12,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 12,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    541,
    [
      "ForStatement[2,3].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[2,3].ContainsDuplicateLabels",
        "name" : "ForStatement[2,3].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1732,
    [
      "ClassElement[1,0].ClassElementEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[1]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Return ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and *false*.\n      ",
      {
        "normalizedName" : "ClassElement[1,0].ClassElementEvaluation",
        "name" : "ClassElement[1,0].ClassElementEvaluation",
        "htmlId" : "sec-static-semantics-classelementevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassElementEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "static"
              },
              {
                "type" : "nonterminal",
                "value" : "MethodDefinition"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    926,
    [
      "PrimaryExpression[5,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[5]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "PrimaryExpression[5,0].AssignmentTargetType",
        "name" : "PrimaryExpression[5,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    134,
    [
      "ToInt16",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n        1. Let _int_ be truncate(ℝ(_number_)).\n        1. Let _int16bit_ be _int_ modulo 2<sup>16</sup>.\n        1. If _int16bit_ ≥ 2<sup>15</sup>, return 𝔽(_int16bit_ - 2<sup>16</sup>); otherwise return 𝔽(_int16bit_).\n      ",
      {
        "normalizedName" : "ToInt16",
        "name" : "ToInt16",
        "htmlId" : "sec-toint16",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1333,
    [
      "OptionalChain[4,0].ChainEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[4]]"
        ],
        [
          "baseValue",
          false,
          "ESValue"
        ],
        [
          "baseReference",
          false,
          "ESValue | Record[ReferenceRecord]"
        ]
      ],
      "\n          1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.\n          1. Return MakePrivateReference(_baseValue_, _fieldNameString_).\n        ",
      {
        "normalizedName" : "OptionalChain[4,0].ChainEvaluation",
        "name" : "OptionalChain[4,0].ChainEvaluation",
        "htmlId" : "sec-optional-chaining-chain-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ChainEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "?."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2634,
    [
      "IsUnclampedIntegerElementType",
      0,
      [
        [
          "type",
          false,
          "Unknown[\"TypedArrayElementType\"]"
        ]
      ],
      "\n          1. If _type_ is one of ~int8~, ~uint8~, ~int16~, ~uint16~, ~int32~, or ~uint32~, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "IsUnclampedIntegerElementType",
        "name" : "IsUnclampedIntegerElementType",
        "htmlId" : "sec-isunclampedintegerelementtype",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2749,
    [
      "INTRINSICS.yet:PromiseRejectFunction",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _F_ be the active function object.\n            1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.\n            1. Let _promise_ be _F_.[[Promise]].\n            1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].\n            1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.\n            1. Set _alreadyResolved_.[[Value]] to *true*.\n            1. Perform RejectPromise(_promise_, _reason_).\n            1. Return *undefined*.\n          ",
      {
        "normalizedName" : "INTRINSICS.yet:PromiseRejectFunction",
        "name" : "INTRINSICS.yet:PromiseRejectFunction",
        "htmlId" : "sec-promise-reject-functions",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1434,
    [
      "LexicalBinding[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[LexicalBinding[0]]"
        ]
      ],
      "\n          1. Let _lhs_ be ! ResolveBinding(StringValue of |BindingIdentifier|).\n          1. Perform ! InitializeReferencedBinding(_lhs_, *undefined*).\n          1. Return ~empty~.\n        ",
      {
        "normalizedName" : "LexicalBinding[0,0].Evaluation",
        "name" : "LexicalBinding[0,0].Evaluation",
        "htmlId" : "sec-let-and-const-declarations-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LexicalBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    73,
    [
      "BigInt::divide",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. If _y_ is *0*<sub>ℤ</sub>, throw a *RangeError* exception.\n            1. Let _quotient_ be ℝ(_x_) / ℝ(_y_).\n            1. Return ℤ(truncate(_quotient_)).\n          ",
      {
        "normalizedName" : "BigInt::divide",
        "name" : "BigInt::divide",
        "htmlId" : "sec-numeric-types-bigint-divide",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1857,
    [
      "UnaryExpression[3,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[3]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[3,0].HasCallInTailPosition",
        "name" : "UnaryExpression[3,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "typeof"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    128,
    [
      "StrUnsignedDecimalLiteral[3,0].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StrUnsignedDecimalLiteral[3]]"
        ]
      ],
      "\n            1. Let _a_ be MV of |DecimalDigits|.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Return RoundMVResult(_a_ × 10<sup>_e_</sup>).\n          ",
      {
        "normalizedName" : "StrUnsignedDecimalLiteral[3,0].StringNumericValue",
        "name" : "StrUnsignedDecimalLiteral[3,0].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "StrUnsignedDecimalLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    343,
    [
      "Module[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Module[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Module[0,0].LexicallyScopedDeclarations",
        "name" : "Module[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Module",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    237,
    [
      "BindingElement[1,1].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElement[1]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingPattern|.\n      ",
      {
        "normalizedName" : "BindingElement[1,1].BoundNames",
        "name" : "BindingElement[1,1].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "BindingElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1991,
    [
      "ExportDeclaration[2,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[2]]"
        ]
      ],
      "\n          1. Return the BoundNames of |VariableStatement|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[2,0].ExportedNames",
        "name" : "ExportDeclaration[2,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2788,
    [
      "INTRINSICS.GeneratorFunction",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the active function object.\n          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.\n          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~generator~, _parameterArgs_, _bodyArg_).\n        ",
      {
        "normalizedName" : "INTRINSICS.GeneratorFunction",
        "name" : "INTRINSICS.GeneratorFunction",
        "htmlId" : "sec-generatorfunction",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1318,
    [
      "MakeSuperPropertyReference",
      0,
      [
        [
          "actualThis",
          false,
          "ESValue"
        ],
        [
          "propertyKey",
          false,
          "Record[Symbol] | String"
        ],
        [
          "strict",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Let _env_ be GetThisEnvironment().\n          1. Assert: _env_.HasSuperBinding() is *true*.\n          1. Let _baseValue_ be ? _env_.GetSuperBase().\n          1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: _actualThis_ }.\n        ",
      {
        "normalizedName" : "MakeSuperPropertyReference",
        "name" : "MakeSuperPropertyReference",
        "htmlId" : "sec-makesuperpropertyreference",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    105,
    [
      "CompletePropertyDescriptor",
      0,
      [
        [
          "Desc",
          false,
          "Record[PropertyDescriptor]"
        ]
      ],
      "\n          1. Let _like_ be the Record { [[Value]]: *undefined*, [[Writable]]: *false*, [[Get]]: *undefined*, [[Set]]: *undefined*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.\n          1. If IsGenericDescriptor(_Desc_) is *true* or IsDataDescriptor(_Desc_) is *true*, then\n            1. If _Desc_ does not have a [[Value]] field, set _Desc_.[[Value]] to _like_.[[Value]].\n            1. If _Desc_ does not have a [[Writable]] field, set _Desc_.[[Writable]] to _like_.[[Writable]].\n          1. Else,\n            1. If _Desc_ does not have a [[Get]] field, set _Desc_.[[Get]] to _like_.[[Get]].\n            1. If _Desc_ does not have a [[Set]] field, set _Desc_.[[Set]] to _like_.[[Set]].\n          1. If _Desc_ does not have an [[Enumerable]] field, set _Desc_.[[Enumerable]] to _like_.[[Enumerable]].\n          1. If _Desc_ does not have a [[Configurable]] field, set _Desc_.[[Configurable]] to _like_.[[Configurable]].\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "CompletePropertyDescriptor",
        "name" : "CompletePropertyDescriptor",
        "htmlId" : "sec-completepropertydescriptor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    244,
    [
      "ArrowParameters[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowParameters[1]]"
        ]
      ],
      "\n        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return the BoundNames of _formals_.\n      ",
      {
        "normalizedName" : "ArrowParameters[1,0].BoundNames",
        "name" : "ArrowParameters[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ArrowParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1202,
    [
      "Record[ProxyExoticObject].Call",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ],
        [
          "thisArgument",
          false,
          "ESValue"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"apply\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? Call(_target_, _thisArgument_, _argumentsList_).\n        1. Let _argArray_ be CreateArrayFromList(_argumentsList_).\n        1. Return ? Call(_trap_, _handler_, « _target_, _thisArgument_, _argArray_ »).\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].Call",
        "name" : "Record[ProxyExoticObject].Call",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[Call]]"
        ]
      }
    ]
  ],
  [
    792,
    [
      "IsAnonymousFunctionDefinition",
      0,
      [
        [
          "expr",
          false,
          "Ast[AssignmentExpression | Expression | Initializer]"
        ]
      ],
      "\n        1. If IsFunctionDefinition of _expr_ is *false*, return *false*.\n        1. Let _hasName_ be HasName of _expr_.\n        1. If _hasName_ is *true*, return *false*.\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "IsAnonymousFunctionDefinition",
        "name" : "IsAnonymousFunctionDefinition",
        "htmlId" : "sec-isanonymousfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2,
    [
      "BigInt::toString",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "radix",
          true,
          "Math"
        ]
      ],
      "\n            1. If _x_ < *0*<sub>ℤ</sub>, return the string-concatenation of *\"-\"* and BigInt::toString(-_x_, _radix_).\n            1. Return the String value consisting of the representation of _x_ using radix _radix_.\n          ",
      {
        "normalizedName" : "BigInt::toString",
        "name" : "BigInt::toString",
        "htmlId" : "sec-numeric-types-bigint-tostring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2203,
    [
      "INTRINSICS.Date.prototype.getUTCHours",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return HourFromTime(_t_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getUTCHours",
        "name" : "INTRINSICS.Date.prototype.getUTCHours",
        "htmlId" : "sec-date.prototype.getutchours",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1814,
    [
      "CaseClause[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CaseClause[0,0].HasCallInTailPosition",
        "name" : "CaseClause[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1086,
    [
      "Record[OrdinaryObject].IsExtensible",
      4,
      [
        [
          "O",
          false,
          "Record[OrdinaryObject]"
        ]
      ],
      "\n        1. Return OrdinaryIsExtensible(_O_).\n      ",
      {
        "normalizedName" : "Record[OrdinaryObject].IsExtensible",
        "name" : "Record[OrdinaryObject].IsExtensible",
        "htmlId" : "sec-ordinary-object-internal-methods-and-internal-slots-isextensible",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "OrdinaryObject",
          "[[IsExtensible]]"
        ]
      }
    ]
  ],
  [
    938,
    [
      "NewExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[NewExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "NewExpression[1,0].AssignmentTargetType",
        "name" : "NewExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "NewExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "nonterminal",
                "value" : "NewExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1241,
    [
      "PrimaryExpression[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[0]]"
        ]
      ],
      "\n          1. Return ? ResolveThisBinding().\n        ",
      {
        "normalizedName" : "PrimaryExpression[0,0].Evaluation",
        "name" : "PrimaryExpression[0,0].Evaluation",
        "htmlId" : "sec-this-keyword-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "this"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    266,
    [
      "ExportDeclaration[5,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[5]]"
        ]
      ],
      "\n        1. Let _declarationNames_ be the BoundNames of |ClassDeclaration|.\n        1. If _declarationNames_ does not include the element *\"\\*default\\*\"*, append *\"\\*default\\*\"* to _declarationNames_.\n        1. Return _declarationNames_.\n      ",
      {
        "normalizedName" : "ExportDeclaration[5,0].BoundNames",
        "name" : "ExportDeclaration[5,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2702,
    [
      "SuspendThisAgent",
      0,
      [
        [
          "WL",
          false,
          "Record[WaiterListRecord]"
        ],
        [
          "waiterRecord",
          false,
          "Record[WaiterRecord]"
        ]
      ],
      "\n          1. Assert: The surrounding agent is in the critical section for _WL_.\n          1. Assert: _WL_.[[Waiters]] contains _waiterRecord_.\n          1. Let _thisAgent_ be AgentSignifier().\n          1. Assert: _waiterRecord_.[[AgentSignifier]] is _thisAgent_.\n          1. Assert: _waiterRecord_.[[PromiseCapability]] is ~blocking~.\n          1. Assert: AgentCanSuspend() is *true*.\n          1. Perform LeaveCriticalSection(_WL_) and suspend the surrounding agent until the time is _waiterRecord_.[[TimeoutTime]], performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost. The surrounding agent can only wake from suspension due to a timeout or due to another agent calling NotifyWaiter with arguments _WL_ and _thisAgent_ (i.e. via a call to `Atomics.notify`).\n          1. Perform EnterCriticalSection(_WL_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "SuspendThisAgent",
        "name" : "SuspendThisAgent",
        "htmlId" : "sec-suspendthisagent",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2546,
    [
      "INTRINSICS.TypedArray.prototype.findLastIndex",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Index]].\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.findLastIndex",
        "name" : "INTRINSICS.TypedArray.prototype.findLastIndex",
        "htmlId" : "sec-%typedarray%.prototype.findlastindex",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2761,
    [
      "INTRINSICS.Promise",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. If IsCallable(_executor_) is *false*, throw a *TypeError* exception.\n          1. Let _promise_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Promise.prototype%\"*, « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »).\n          1. Set _promise_.[[PromiseState]] to ~pending~.\n          1. Set _promise_.[[PromiseFulfillReactions]] to a new empty List.\n          1. Set _promise_.[[PromiseRejectReactions]] to a new empty List.\n          1. Set _promise_.[[PromiseIsHandled]] to *false*.\n          1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promise_).\n          1. Let _completion_ be Completion(Call(_executor_, *undefined*, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)).\n          1. If _completion_ is an abrupt completion, then\n            1. Perform ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _completion_.[[Value]] »).\n          1. Return _promise_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise",
        "name" : "INTRINSICS.Promise",
        "htmlId" : "sec-promise-executor",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    633,
    [
      "FunctionStatementList[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,0].ContainsUndefinedBreakTarget",
        "name" : "FunctionStatementList[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1779,
    [
      "ForInOfStatement[4,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[4]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ForInOfStatement[4,0].HasCallInTailPosition",
        "name" : "ForInOfStatement[4,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    360,
    [
      "Block[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[Block[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Block[0,0].VarDeclaredNames",
        "name" : "Block[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Block",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2208,
    [
      "INTRINSICS.Date.prototype.setDate",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _dt_ be ? ToNumber(_date_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Set _t_ to LocalTime(_t_).\n          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).\n          1. Let _u_ be TimeClip(UTC(_newDate_)).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setDate",
        "name" : "INTRINSICS.Date.prototype.setDate",
        "htmlId" : "sec-date.prototype.setdate",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    805,
    [
      "PrimaryExpression[12,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[12]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[12,0].IsIdentifierRef",
        "name" : "PrimaryExpression[12,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 12,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    205,
    [
      "CreateListIteratorRecord",
      0,
      [
        [
          "list",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Let _closure_ be a new Abstract Closure with no parameters that captures _list_ and performs the following steps when called:\n          1. For each element _E_ of _list_, do\n            1. Perform ? GeneratorYield(CreateIterResultObject(_E_, *false*)).\n          1. Return NormalCompletion(*undefined*).\n        1. Let _iterator_ be CreateIteratorFromClosure(_closure_, ~empty~, %IteratorPrototype%).\n        1. Return the Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: %GeneratorFunction.prototype.prototype.next%, [[Done]]: *false* }.\n      ",
      {
        "normalizedName" : "CreateListIteratorRecord",
        "name" : "CreateListIteratorRecord",
        "htmlId" : "sec-createlistiteratorRecord",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2043,
    [
      "INTRINSICS.Object",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is neither *undefined* nor the active function object, then\n            1. Return ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n          1. If _value_ is either *undefined* or *null*, return OrdinaryObjectCreate(%Object.prototype%).\n          1. Return ! ToObject(_value_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object",
        "name" : "INTRINSICS.Object",
        "htmlId" : "sec-object-value",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    508,
    [
      "LabelledStatement[0,0].TopLevelVarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledStatement[0]]"
        ]
      ],
      "\n        1. Return the TopLevelVarScopedDeclarations of |LabelledItem|.\n      ",
      {
        "normalizedName" : "LabelledStatement[0,0].TopLevelVarScopedDeclarations",
        "name" : "LabelledStatement[0,0].TopLevelVarScopedDeclarations",
        "htmlId" : "sec-static-semantics-toplevelvarscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelVarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelledItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    311,
    [
      "ConciseBody[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ConciseBody[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ConciseBody[0,0].LexicallyDeclaredNames",
        "name" : "ConciseBody[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1695,
    [
      "MethodDefinition[0,0].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[0]]"
        ]
      ],
      "\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      ",
      {
        "normalizedName" : "MethodDefinition[0,0].PrivateBoundIdentifiers",
        "name" : "MethodDefinition[0,0].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1563,
    [
      "ArrayBindingPattern[2,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[2]]"
        ]
      ],
      "\n        1. Return ContainsExpression of |BindingElementList|.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[2,0].ContainsExpression",
        "name" : "ArrayBindingPattern[2,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    657,
    [
      "ForStatement[0,3].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[0,3].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[0,3].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1712,
    [
      "AsyncGeneratorDeclaration[1,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorDeclaration[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorDeclaration[1,0].ContainsArguments",
        "name" : "AsyncGeneratorDeclaration[1,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncGeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1846,
    [
      "ShiftExpression[3,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ShiftExpression[3]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ShiftExpression[3,0].HasCallInTailPosition",
        "name" : "ShiftExpression[3,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ShiftExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              },
              {
                "type" : "terminal",
                "value" : ">>>"
              },
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1054,
    [
      "GetIdentifierReference",
      0,
      [
        [
          "env",
          false,
          "Record[EnvironmentRecord] | Null"
        ],
        [
          "name",
          false,
          "String"
        ],
        [
          "strict",
          false,
          "Boolean"
        ]
      ],
      "\n          1. If _env_ is *null*, then\n            1. Return the Reference Record { [[Base]]: ~unresolvable~, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.\n          1. Let _exists_ be ? <emu-meta effects=\"user-code\">_env_.HasBinding</emu-meta>(_name_).\n          1. If _exists_ is *true*, then\n            1. Return the Reference Record { [[Base]]: _env_, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.\n          1. Else,\n            1. Let _outer_ be _env_.[[OuterEnv]].\n            1. Return ? GetIdentifierReference(_outer_, _name_, _strict_).\n        ",
      {
        "normalizedName" : "GetIdentifierReference",
        "name" : "GetIdentifierReference",
        "htmlId" : "sec-getidentifierreference",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2057,
    [
      "GetOwnPropertyKeys",
      0,
      [
        [
          "O",
          false,
          "ESValue"
        ],
        [
          "type",
          false,
          "Enum[~string~, ~symbol~]"
        ]
      ],
      "\n            1. Let _obj_ be ? ToObject(_O_).\n            1. Let _keys_ be ? <emu-meta effects=\"user-code\">_obj_.[[OwnPropertyKeys]]()</emu-meta>.\n            1. Let _nameList_ be a new empty List.\n            1. For each element _nextKey_ of _keys_, do\n              1. If _nextKey_ is a Symbol and _type_ is ~symbol~, or if _nextKey_ is a String and _type_ is ~string~, then\n                1. Append _nextKey_ to _nameList_.\n            1. Return _nameList_.\n          ",
      {
        "normalizedName" : "GetOwnPropertyKeys",
        "name" : "GetOwnPropertyKeys",
        "htmlId" : "sec-getownpropertykeys",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    765,
    [
      "EqualityExpression[4,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[4]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "EqualityExpression[4,0].IsFunctionDefinition",
        "name" : "EqualityExpression[4,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "!=="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2076,
    [
      "INTRINSICS.get Object.prototype.__proto__",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _O_ be ? ToObject(*this* value).\n            1. Return ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]()</emu-meta>.\n          ",
      {
        "normalizedName" : "INTRINSICS.get Object.prototype.__proto__",
        "name" : "INTRINSICS.get Object.prototype.__proto__",
        "htmlId" : "sec-get-object.prototype.__proto__",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2748,
    [
      "CreateResolvingFunctions",
      0,
      [
        [
          "promise",
          false,
          "Record[Promise]"
        ]
      ],
      "\n          1. Let _alreadyResolved_ be the Record { [[Value]]: *false* }.\n          1. Let _stepsResolve_ be the algorithm steps defined in <emu-xref href=\"#sec-promise-resolve-functions\" title></emu-xref>.\n          1. Let _lengthResolve_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise-resolve-functions\" title></emu-xref>.\n          1. Let _resolve_ be CreateBuiltinFunction(_stepsResolve_, _lengthResolve_, *\"\"*, « [[Promise]], [[AlreadyResolved]] »).\n          1. Set _resolve_.[[Promise]] to _promise_.\n          1. Set _resolve_.[[AlreadyResolved]] to _alreadyResolved_.\n          1. Let _stepsReject_ be the algorithm steps defined in <emu-xref href=\"#sec-promise-reject-functions\" title></emu-xref>.\n          1. Let _lengthReject_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise-reject-functions\" title></emu-xref>.\n          1. Let _reject_ be CreateBuiltinFunction(_stepsReject_, _lengthReject_, *\"\"*, « [[Promise]], [[AlreadyResolved]] »).\n          1. Set _reject_.[[Promise]] to _promise_.\n          1. Set _reject_.[[AlreadyResolved]] to _alreadyResolved_.\n          1. Return the Record { [[Resolve]]: _resolve_, [[Reject]]: _reject_ }.\n        ",
      {
        "normalizedName" : "CreateResolvingFunctions",
        "name" : "CreateResolvingFunctions",
        "htmlId" : "sec-createresolvingfunctions",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1170,
    [
      "TypedArrayByteLength",
      0,
      [
        [
          "taRecord",
          false,
          "Record[TypedArrayWithBufferWitnessRecord]"
        ]
      ],
      "\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return 0.\n          1. Let _length_ be TypedArrayLength(_taRecord_).\n          1. If _length_ = 0, return 0.\n          1. Let _O_ be _taRecord_.[[Object]].\n          1. If _O_.[[ByteLength]] is not ~auto~, return _O_.[[ByteLength]].\n          1. Let _elementSize_ be TypedArrayElementSize(_O_).\n          1. Return _length_ × _elementSize_.\n        ",
      {
        "normalizedName" : "TypedArrayByteLength",
        "name" : "TypedArrayByteLength",
        "htmlId" : "sec-typedarraybytelength",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1286,
    [
      "TemplateString",
      0,
      [
        [
          "templateToken",
          false,
          "Ast[NoSubstitutionTemplate | TemplateHead | TemplateMiddle | TemplateTail]"
        ],
        [
          "raw",
          false,
          "Boolean"
        ]
      ],
      "\n          1. If _raw_ is *true*, then\n            1. Let _string_ be the TRV of _templateToken_.\n          1. Else,\n            1. Let _string_ be the TV of _templateToken_.\n          1. Return _string_.\n        ",
      {
        "normalizedName" : "TemplateString",
        "name" : "TemplateString",
        "htmlId" : "sec-templatestring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    398,
    [
      "CaseBlock[1,2].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _names1_ be the VarDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be VarDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the VarDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,2].VarDeclaredNames",
        "name" : "CaseBlock[1,2].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1035,
    [
      "Record[GlobalEnvironmentRecord].InitializeBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "V",
          false,
          "ESValue"
        ]
      ],
      "\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, then\n              1. Return ! _DclRec_.InitializeBinding(_N_, _V_).\n            1. Assert: If the binding exists, it must be in the Object Environment Record.\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Return ? <emu-meta effects=\"user-code\">_ObjRec_.InitializeBinding</emu-meta>(_N_, _V_).\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].InitializeBinding",
        "name" : "Record[GlobalEnvironmentRecord].InitializeBinding",
        "htmlId" : "sec-global-environment-records-initializebinding-n-v",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "InitializeBinding"
        ]
      }
    ]
  ],
  [
    2368,
    [
      "QuantifierPrefix[2,0].CompileQuantifierPrefix",
      2,
      [
        [
          "this",
          false,
          "Ast[QuantifierPrefix[2]]"
        ]
      ],
      "\n          1. Return the Record { [[Min]]: 0, [[Max]]: 1 }.\n        ",
      {
        "normalizedName" : "QuantifierPrefix[2,0].CompileQuantifierPrefix",
        "name" : "QuantifierPrefix[2,0].CompileQuantifierPrefix",
        "htmlId" : "sec-compilequantifierprefix",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileQuantifierPrefix",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "QuantifierPrefix",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "?"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1466,
    [
      "ForStatement[0,5].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        ",
      {
        "normalizedName" : "ForStatement[0,5].ForLoopEvaluation",
        "name" : "ForStatement[0,5].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 5,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    558,
    [
      "CaseClauses[1,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClauses[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |CaseClauses| with argument _labelSet_.\n        1. If _hasDuplicates_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of |CaseClause| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "CaseClauses[1,0].ContainsDuplicateLabels",
        "name" : "CaseClauses[1,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseClauses",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClause"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1071,
    [
      "GetGlobalObject",
      0,
      [
      ],
      "\n        1. Let _currentRealm_ be the current Realm Record.\n        1. Return _currentRealm_.[[GlobalObject]].\n      ",
      {
        "normalizedName" : "GetGlobalObject",
        "name" : "GetGlobalObject",
        "htmlId" : "sec-getglobalobject",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2402,
    [
      "CharacterClassEscape[5,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[5]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `w`</emu-grammar>.\n          1. Return CharacterComplement(_rer_, _S_).\n        ",
      {
        "normalizedName" : "CharacterClassEscape[5,0].CompileToCharSet",
        "name" : "CharacterClassEscape[5,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "W"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1187,
    [
      "Record[ModuleNamespaceExoticObject].OwnPropertyKeys",
      4,
      [
        [
          "O",
          false,
          "Record[ModuleNamespaceExoticObject]"
        ]
      ],
      "\n          1. Let _exports_ be _O_.[[Exports]].\n          1. Let _symbolKeys_ be OrdinaryOwnPropertyKeys(_O_).\n          1. Return the list-concatenation of _exports_ and _symbolKeys_.\n        ",
      {
        "normalizedName" : "Record[ModuleNamespaceExoticObject].OwnPropertyKeys",
        "name" : "Record[ModuleNamespaceExoticObject].OwnPropertyKeys",
        "htmlId" : "sec-module-namespace-exotic-objects-ownpropertykeys",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleNamespaceExoticObject",
          "[[OwnPropertyKeys]]"
        ]
      }
    ]
  ],
  [
    674,
    [
      "ForInOfStatement[4,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[4]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForInOfStatement[4,0].ContainsUndefinedContinueTarget",
        "name" : "ForInOfStatement[4,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2440,
    [
      "NonEmptyClassString[0,1].CompileClassSetString",
      2,
      [
        [
          "this",
          false,
          "Ast[NonEmptyClassString[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _cs_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.\n          1. Let _s1_ be the sequence of characters that is the single CharSetElement of _cs_.\n          1. If |NonEmptyClassString| is present, then\n            1. Let _s2_ be CompileClassSetString of |NonEmptyClassString| with argument _rer_.\n            1. Return the concatenation of _s1_ and _s2_.\n          1. Return _s1_.\n        ",
      {
        "normalizedName" : "NonEmptyClassString[0,1].CompileClassSetString",
        "name" : "NonEmptyClassString[0,1].CompileClassSetString",
        "htmlId" : "sec-compileclasssetstring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileClassSetString",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "NonEmptyClassString",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetCharacter"
              },
              {
                "type" : "nonterminal",
                "value" : "NonEmptyClassString"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2408,
    [
      "ClassUnion[0,1].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassUnion[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of |ClassSetRange| with argument _rer_.\n          1. If |ClassUnion| is present, then\n            1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.\n            1. Return the union of CharSets _A_ and _B_.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "ClassUnion[0,1].CompileToCharSet",
        "name" : "ClassUnion[0,1].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ClassUnion",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetRange"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassUnion"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2793,
    [
      "GeneratorStart:clo0",
      6,
      [
      ],
      "\n          1. Assert: The value of _generator_.[[GeneratorState]] is *undefined*.\n          1. Let _genContext_ be the running execution context.\n          1. Set the Generator component of _genContext_ to _generator_.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:\n            1. Let _acGenContext_ be the running execution context.\n            1. Let _acGenerator_ be the Generator component of _acGenContext_.\n            1. If _generatorBody_ is a Parse Node, then\n              1. Let _result_ be Completion(Evaluation of _generatorBody_).\n            1. Else,\n              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.\n              1. Let _result_ be _generatorBody_().\n            1. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.\n            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. Set _acGenerator_.[[GeneratorState]] to ~completed~.\n            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _acGenerator_ can be discarded at this point.\n            1. If _result_ is a normal completion, then\n              1. Let _resultValue_ be *undefined*.\n            1. Else if _result_ is a return completion, then\n              1. Let _resultValue_ be _result_.[[Value]].\n            1. Else,\n              1. Assert: _result_ is a throw completion.\n              1. Return ? _result_.\n            1. Return CreateIterResultObject(_resultValue_, *true*).\n          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Set _generator_.[[GeneratorContext]] to _genContext_.\n          1. Set _generator_.[[GeneratorState]] to ~suspended-start~.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "GeneratorStart",
        "name" : "GeneratorStart",
        "htmlId" : "sec-generatorstart",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1663,
    [
      "ClassElement[0,0].ClassElementKind",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[0]]"
        ]
      ],
      "\n        1. If PropName of |MethodDefinition| is *\"constructor\"*, return ~constructor-method~.\n        1. Return ~non-constructor-method~.\n      ",
      {
        "normalizedName" : "ClassElement[0,0].ClassElementKind",
        "name" : "ClassElement[0,0].ClassElementKind",
        "htmlId" : "sec-static-semantics-classelementkind",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassElementKind",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MethodDefinition"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2089,
    [
      "INTRINSICS.Boolean.prototype.toString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _b_ be ? ThisBooleanValue(*this* value).\n          1. If _b_ is *true*, return *\"true\"*; else return *\"false\"*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Boolean.prototype.toString",
        "name" : "INTRINSICS.Boolean.prototype.toString",
        "htmlId" : "sec-boolean.prototype.tostring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1515,
    [
      "BreakStatement[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BreakStatement[1]]"
        ]
      ],
      "\n        1. Let _label_ be the StringValue of |LabelIdentifier|.\n        1. Return Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: _label_ }.\n      ",
      {
        "normalizedName" : "BreakStatement[1,0].Evaluation",
        "name" : "BreakStatement[1,0].Evaluation",
        "htmlId" : "sec-break-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BreakStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "break"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2221,
    [
      "INTRINSICS.Date.prototype.setUTCMonth",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _m_ be ? ToNumber(_month_).\n          1. If _date_ is present, let _dt_ be ? ToNumber(_date_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. If _date_ is not present, let _dt_ be DateFromTime(_t_).\n          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).\n          1. Let _v_ be TimeClip(_newDate_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setUTCMonth",
        "name" : "INTRINSICS.Date.prototype.setUTCMonth",
        "htmlId" : "sec-date.prototype.setutcmonth",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1026,
    [
      "Record[ObjectEnvironmentRecord].WithBaseObject",
      3,
      [
        [
          "envRec",
          false,
          "Record[ObjectEnvironmentRecord]"
        ]
      ],
      "\n            1. If _envRec_.[[IsWithEnvironment]] is *true*, return _envRec_.[[BindingObject]].\n            1. Otherwise, return *undefined*.\n          ",
      {
        "normalizedName" : "Record[ObjectEnvironmentRecord].WithBaseObject",
        "name" : "Record[ObjectEnvironmentRecord].WithBaseObject",
        "htmlId" : "sec-object-environment-records-withbaseobject",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ObjectEnvironmentRecord",
          "WithBaseObject"
        ]
      }
    ]
  ],
  [
    1895,
    [
      "CallExpression[6,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[6]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. If this |CallExpression| is _call_, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CallExpression[6,0].HasCallInTailPosition",
        "name" : "CallExpression[6,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1167,
    [
      "Record[TypedArray].OwnPropertyKeys",
      4,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ]
      ],
      "\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. Let _keys_ be a new empty List.\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *false*, then\n            1. Let _length_ be TypedArrayLength(_taRecord_).\n            1. For each integer _i_ such that 0 ≤ _i_ < _length_, in ascending order, do\n              1. Append ! ToString(𝔽(_i_)) to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is a String and _P_ is not an integer index, in ascending chronological order of property creation, do\n            1. Append _P_ to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is a Symbol, in ascending chronological order of property creation, do\n            1. Append _P_ to _keys_.\n          1. Return _keys_.\n        ",
      {
        "normalizedName" : "Record[TypedArray].OwnPropertyKeys",
        "name" : "Record[TypedArray].OwnPropertyKeys",
        "htmlId" : "sec-typedarray-ownpropertykeys",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "TypedArray",
          "[[OwnPropertyKeys]]"
        ]
      }
    ]
  ],
  [
    2645,
    [
      "INTRINSICS.get ArrayBuffer[@@species]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return the *this* value.\n        ",
      {
        "normalizedName" : "INTRINSICS.get ArrayBuffer[@@species]",
        "name" : "INTRINSICS.get ArrayBuffer[@@species]",
        "htmlId" : "sec-get-arraybuffer-@@species",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2189,
    [
      "INTRINSICS.Date.UTC",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _y_ be ? ToNumber(_year_).\n          1. If _month_ is present, let _m_ be ? ToNumber(_month_); else let _m_ be *+0*<sub>𝔽</sub>.\n          1. If _date_ is present, let _dt_ be ? ToNumber(_date_); else let _dt_ be *1*<sub>𝔽</sub>.\n          1. If _hours_ is present, let _h_ be ? ToNumber(_hours_); else let _h_ be *+0*<sub>𝔽</sub>.\n          1. If _minutes_ is present, let _min_ be ? ToNumber(_minutes_); else let _min_ be *+0*<sub>𝔽</sub>.\n          1. If _seconds_ is present, let _s_ be ? ToNumber(_seconds_); else let _s_ be *+0*<sub>𝔽</sub>.\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_); else let _milli_ be *+0*<sub>𝔽</sub>.\n          1. Let _yr_ be MakeFullYear(_y_).\n          1. Return TimeClip(MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_))).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.UTC",
        "name" : "INTRINSICS.Date.UTC",
        "htmlId" : "sec-date.utc",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1616,
    [
      "FunctionDeclaration[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[0]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[0,0].Evaluation",
        "name" : "FunctionDeclaration[0,0].Evaluation",
        "htmlId" : "sec-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    530,
    [
      "ForStatement[0,4].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,4].ContainsDuplicateLabels",
        "name" : "ForStatement[0,4].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 4,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2617,
    [
      "INTRINSICS.WeakMap.prototype.delete",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).\n          1. If CanBeHeldWeakly(_key_) is *false*, return *false*.\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then\n              1. Set _p_.[[Key]] to ~empty~.\n              1. Set _p_.[[Value]] to ~empty~.\n              1. Return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.WeakMap.prototype.delete",
        "name" : "INTRINSICS.WeakMap.prototype.delete",
        "htmlId" : "sec-weakmap.prototype.delete",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    953,
    [
      "UnaryExpression[6,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[6]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "UnaryExpression[6,0].AssignmentTargetType",
        "name" : "UnaryExpression[6,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "~"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2662,
    [
      "INTRINSICS.SharedArrayBuffer.prototype.slice",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n          1. Let _len_ be ArrayBufferByteLength(_O_, ~seq-cst~).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _first_ be 0.\n          1. Else if _relativeStart_ < 0, let _first_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _first_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _final_ be 0.\n          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _final_ be min(_relativeEnd_, _len_).\n          1. Let _newLen_ be max(_final_ - _first_, 0).\n          1. Let _ctor_ be ? SpeciesConstructor(_O_, %SharedArrayBuffer%).\n          1. Let _new_ be ? Construct(_ctor_, « 𝔽(_newLen_) »).\n          1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_new_) is *false*, throw a *TypeError* exception.\n          1. If _new_.[[ArrayBufferData]] is _O_.[[ArrayBufferData]], throw a *TypeError* exception.\n          1. If ArrayBufferByteLength(_new_, ~seq-cst~) < _newLen_, throw a *TypeError* exception.\n          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].\n          1. Let _toBuf_ be _new_.[[ArrayBufferData]].\n          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).\n          1. Return _new_.\n        ",
      {
        "normalizedName" : "INTRINSICS.SharedArrayBuffer.prototype.slice",
        "name" : "INTRINSICS.SharedArrayBuffer.prototype.slice",
        "htmlId" : "sec-sharedarraybuffer.prototype.slice",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1185,
    [
      "Record[ModuleNamespaceExoticObject].Set",
      4,
      [
        [
          "this",
          false,
          "Record[ModuleNamespaceExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "Record[ModuleNamespaceExoticObject].Set",
        "name" : "Record[ModuleNamespaceExoticObject].Set",
        "htmlId" : "sec-module-namespace-exotic-objects-set-p-v-receiver",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleNamespaceExoticObject",
          "[[Set]]"
        ]
      }
    ]
  ],
  [
    773,
    [
      "AssignmentExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[1,0].IsFunctionDefinition",
        "name" : "AssignmentExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "YieldExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    794,
    [
      "PrimaryExpression[0,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[0,0].IsIdentifierRef",
        "name" : "PrimaryExpression[0,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "this"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    586,
    [
      "DoWhileStatement[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[DoWhileStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "DoWhileStatement[0,0].ContainsUndefinedBreakTarget",
        "name" : "DoWhileStatement[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DoWhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "do"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2338,
    [
      "RegExpIdentifierPart[0,0].RegExpIdentifierCodePoint",
      2,
      [
        [
          "this",
          false,
          "Ast[RegExpIdentifierPart[0]]"
        ]
      ],
      "\n          1. Return the code point matched by |IdentifierPartChar|.\n        ",
      {
        "normalizedName" : "RegExpIdentifierPart[0,0].RegExpIdentifierCodePoint",
        "name" : "RegExpIdentifierPart[0,0].RegExpIdentifierCodePoint",
        "htmlId" : "sec-regexpidentifiercodepoint",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "RegExpIdentifierCodePoint",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "RegExpIdentifierPart",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierPartChar"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1996,
    [
      "NamedExports[0,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[NamedExports[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "NamedExports[0,0].ExportedNames",
        "name" : "NamedExports[0,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NamedExports",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    662,
    [
      "ForStatement[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[1,0].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    718,
    [
      "PrimaryExpression[12,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[12]]"
        ]
      ],
      "\n        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return IsFunctionDefinition of _expr_.\n      ",
      {
        "normalizedName" : "PrimaryExpression[12,0].IsFunctionDefinition",
        "name" : "PrimaryExpression[12,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 12,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    888,
    [
      "ObjectBindingPattern[3,1].BindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectBindingPattern[3]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _excludedNames_ be ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.\n        1. Return ? RestBindingInitialization of |BindingRestProperty| with arguments _value_, _environment_, and _excludedNames_.\n      ",
      {
        "normalizedName" : "ObjectBindingPattern[3,1].BindingInitialization",
        "name" : "ObjectBindingPattern[3,1].BindingInitialization",
        "htmlId" : "sec-runtime-semantics-bindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 1,
            "astName" : "ObjectBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingPropertyList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestProperty"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2423,
    [
      "ClassStringDisjunctionContents[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStringDisjunctionContents[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _s_ be CompileClassSetString of |ClassString| with argument _rer_.\n          1. Return the CharSet containing the one string _s_.\n        ",
      {
        "normalizedName" : "ClassStringDisjunctionContents[0,0].CompileToCharSet",
        "name" : "ClassStringDisjunctionContents[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStringDisjunctionContents",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassString"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2529,
    [
      "INTRINSICS.ArrayIteratorPrototype.next",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Return ? GeneratorResume(*this* value, ~empty~, *\"%ArrayIteratorPrototype%\"*).\n          ",
      {
        "normalizedName" : "INTRINSICS.ArrayIteratorPrototype.next",
        "name" : "INTRINSICS.ArrayIteratorPrototype.next",
        "htmlId" : "sec-%arrayiteratorprototype%.next",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2001,
    [
      "ModuleItemList[1,0].ExportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ]
      ],
      "\n          1. Let _entries1_ be ExportEntries of |ModuleItemList|.\n          1. Let _entries2_ be ExportEntries of |ModuleItem|.\n          1. Return the list-concatenation of _entries1_ and _entries2_.\n        ",
      {
        "normalizedName" : "ModuleItemList[1,0].ExportEntries",
        "name" : "ModuleItemList[1,0].ExportEntries",
        "htmlId" : "sec-static-semantics-exportentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntries",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2585,
    [
      "AllocateTypedArrayBuffer",
      0,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "length",
          false,
          "Int[0+]"
        ]
      ],
      "\n            1. Assert: _O_.[[ViewedArrayBuffer]] is *undefined*.\n            1. Let _elementSize_ be TypedArrayElementSize(_O_).\n            1. Let _byteLength_ be _elementSize_ × _length_.\n            1. Let _data_ be ? <emu-meta suppress-effects=\"user-code\">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>.\n            1. Set _O_.[[ViewedArrayBuffer]] to _data_.\n            1. Set _O_.[[ByteLength]] to _byteLength_.\n            1. Set _O_.[[ByteOffset]] to 0.\n            1. Set _O_.[[ArrayLength]] to _length_.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "AllocateTypedArrayBuffer",
        "name" : "AllocateTypedArrayBuffer",
        "htmlId" : "sec-allocatetypedarraybuffer",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    166,
    [
      "CreateNonEnumerableDataPropertyOrThrow",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "V",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Assert: _O_ is an ordinary, extensible object with no non-configurable properties.\n        1. Let _newDesc_ be the PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.\n        1. Perform ! DefinePropertyOrThrow(_O_, _P_, _newDesc_).\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "CreateNonEnumerableDataPropertyOrThrow",
        "name" : "CreateNonEnumerableDataPropertyOrThrow",
        "htmlId" : "sec-createnonenumerabledatapropertyorthrow",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    856,
    [
      "OptionalChain[7,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[7]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. If |OptionalChain| Contains _symbol_ is *true*, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "OptionalChain[7,0].Contains",
        "name" : "OptionalChain[7,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    573,
    [
      "ModuleItem[1,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ModuleItem[1,0].ContainsDuplicateLabels",
        "name" : "ModuleItem[1,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    17,
    [
      "INTRINSICS.String.prototype.toUpperCase",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Object] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    444,
    [
      "ForStatement[0,6].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,6].VarScopedDeclarations",
        "name" : "ForStatement[0,6].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 6,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1374,
    [
      "EqualityExpression[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[2]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |EqualityExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _r_ be ? IsLooselyEqual(_rval_, _lval_).\n        1. If _r_ is *true*, return *false*. Otherwise, return *true*.\n      ",
      {
        "normalizedName" : "EqualityExpression[2,0].Evaluation",
        "name" : "EqualityExpression[2,0].Evaluation",
        "htmlId" : "sec-equality-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "!="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2121,
    [
      "INTRINSICS.BigInt.asUintN",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Set _bits_ to ? ToIndex(_bits_).\n          1. Set _bigint_ to ? ToBigInt(_bigint_).\n          1. Return ℤ(ℝ(_bigint_) modulo 2<sup>_bits_</sup>).\n        ",
      {
        "normalizedName" : "INTRINSICS.BigInt.asUintN",
        "name" : "INTRINSICS.BigInt.asUintN",
        "htmlId" : "sec-bigint.asuintn",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2235,
    [
      "INTRINSICS.String",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _value_ is not present, then\n            1. Let _s_ be the empty String.\n          1. Else,\n            1. If NewTarget is *undefined* and _value_ is a Symbol, return SymbolDescriptiveString(_value_).\n            1. Let _s_ be ? ToString(_value_).\n          1. If NewTarget is *undefined*, return _s_.\n          1. Return StringCreate(_s_, ? GetPrototypeFromConstructor(NewTarget, *\"%String.prototype%\"*)).\n        ",
      {
        "normalizedName" : "INTRINSICS.String",
        "name" : "INTRINSICS.String",
        "htmlId" : "sec-string-constructor-string-value",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2144,
    [
      "INTRINSICS.Math.log",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n          1. If _n_ < *-0*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the natural logarithm of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.log",
        "name" : "INTRINSICS.Math.log",
        "htmlId" : "sec-math.log",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    906,
    [
      "FormalParameters[4,0].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameters[4]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Perform ? IteratorBindingInitialization of |FormalParameterList| with arguments _iteratorRecord_ and _environment_.\n        1. Return ? IteratorBindingInitialization of |FunctionRestParameter| with arguments _iteratorRecord_ and _environment_.\n      ",
      {
        "normalizedName" : "FormalParameters[4,0].IteratorBindingInitialization",
        "name" : "FormalParameters[4,0].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "FormalParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameterList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionRestParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1278,
    [
      "IsValidRegularExpressionLiteral",
      0,
      [
        [
          "literal",
          false,
          "Ast[RegularExpressionLiteral]"
        ]
      ],
      "\n          1. Let _flags_ be FlagText of _literal_.\n          1. If _flags_ contains any code points other than `d`, `g`, `i`, `m`, `s`, `u`, `v`, or `y`, or if _flags_ contains any code point more than once, return *false*.\n          1. If _flags_ contains `u`, let _u_ be *true*; else let _u_ be *false*.\n          1. If _flags_ contains `v`, let _v_ be *true*; else let _v_ be *false*.\n          1. Let _patternText_ be BodyText of _literal_.\n          1. If _u_ is *false* and _v_ is *false*, then\n            1. Let _stringValue_ be CodePointsToString(_patternText_).\n            1. Set _patternText_ to the sequence of code points resulting from interpreting each of the 16-bit elements of _stringValue_ as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.\n          1. Let _parseResult_ be ParsePattern(_patternText_, _u_, _v_).\n          1. If _parseResult_ is a Parse Node, return *true*; else return *false*.\n        ",
      {
        "normalizedName" : "IsValidRegularExpressionLiteral",
        "name" : "IsValidRegularExpressionLiteral",
        "htmlId" : "sec-isvalidregularexpressionliteral",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1906,
    [
      "OptionalChain[5,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[5]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. If this |OptionalChain| is _call_, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "OptionalChain[5,0].HasCallInTailPosition",
        "name" : "OptionalChain[5,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    298,
    [
      "CaseBlock[1,3].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _names1_ be the LexicallyDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be LexicallyDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the LexicallyDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,3].LexicallyDeclaredNames",
        "name" : "CaseBlock[1,3].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1135,
    [
      "Record[BuiltinFunctionObject].Construct",
      4,
      [
        [
          "F",
          false,
          "Record[BuiltinFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "newTarget",
          false,
          "Record[Constructor]"
        ]
      ],
      "\n        1. Return ? BuiltinCallOrConstruct(_F_, ~uninitialized~, _argumentsList_, _newTarget_).\n      ",
      {
        "normalizedName" : "Record[BuiltinFunctionObject].Construct",
        "name" : "Record[BuiltinFunctionObject].Construct",
        "htmlId" : "sec-built-in-function-objects-construct-argumentslist-newtarget",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "BuiltinFunctionObject",
          "[[Construct]]"
        ]
      }
    ]
  ],
  [
    2729,
    [
      "SerializeJSONProperty",
      0,
      [
        [
          "state",
          false,
          "Record[JSONSerializationRecord]"
        ],
        [
          "key",
          false,
          "String"
        ],
        [
          "holder",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Let _value_ be ? Get(_holder_, _key_).\n          1. If _value_ is an Object or _value_ is a BigInt, then\n            1. Let _toJSON_ be ? GetV(_value_, *\"toJSON\"*).\n            1. If IsCallable(_toJSON_) is *true*, then\n              1. Set _value_ to ? Call(_toJSON_, _value_, « _key_ »).\n          1. If _state_.[[ReplacerFunction]] is not *undefined*, then\n            1. Set _value_ to ? Call(_state_.[[ReplacerFunction]], _holder_, « _key_, _value_ »).\n          1. If _value_ is an Object, then\n            1. If _value_ has a [[NumberData]] internal slot, then\n              1. Set _value_ to ? ToNumber(_value_).\n            1. Else if _value_ has a [[StringData]] internal slot, then\n              1. Set _value_ to ? ToString(_value_).\n            1. Else if _value_ has a [[BooleanData]] internal slot, then\n              1. Set _value_ to _value_.[[BooleanData]].\n            1. Else if _value_ has a [[BigIntData]] internal slot, then\n              1. Set _value_ to _value_.[[BigIntData]].\n          1. If _value_ is *null*, return *\"null\"*.\n          1. If _value_ is *true*, return *\"true\"*.\n          1. If _value_ is *false*, return *\"false\"*.\n          1. If _value_ is a String, return QuoteJSONString(_value_).\n          1. If _value_ is a Number, then\n            1. If _value_ is finite, return ! ToString(_value_).\n            1. Return *\"null\"*.\n          1. If _value_ is a BigInt, throw a *TypeError* exception.\n          1. If _value_ is an Object and IsCallable(_value_) is *false*, then\n            1. Let _isArray_ be ? IsArray(_value_).\n            1. If _isArray_ is *true*, return ? SerializeJSONArray(_state_, _value_).\n            1. Return ? SerializeJSONObject(_state_, _value_).\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "SerializeJSONProperty",
        "name" : "SerializeJSONProperty",
        "htmlId" : "sec-serializejsonproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1648,
    [
      "GeneratorDeclaration[1,0].InstantiateGeneratorFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorDeclaration[1]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Let _sourceText_ be the source text matched by |GeneratorDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, *\"default\"*).\n        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "GeneratorDeclaration[1,0].InstantiateGeneratorFunctionObject",
        "name" : "GeneratorDeclaration[1,0].InstantiateGeneratorFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiategeneratorfunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateGeneratorFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "GeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    412,
    [
      "FunctionStatementList[0,1].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ]
      ],
      "\n        1. Return TopLevelVarDeclaredNames of |StatementList|.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,1].VarDeclaredNames",
        "name" : "FunctionStatementList[0,1].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    965,
    [
      "RelationalExpression[3,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[3]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "RelationalExpression[3,0].AssignmentTargetType",
        "name" : "RelationalExpression[3,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "<="
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    750,
    [
      "AdditiveExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AdditiveExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AdditiveExpression[1,0].IsFunctionDefinition",
        "name" : "AdditiveExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AdditiveExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              },
              {
                "type" : "terminal",
                "value" : "+"
              },
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1727,
    [
      "ClassStaticBlock[0,0].ClassStaticBlockDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlock[0]]"
        ],
        [
          "homeObject",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Let _lex_ be the running execution context's LexicalEnvironment.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the empty sequence of Unicode code points.\n        1. Let _formalParameters_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.\n        1. [id=\"step-synthetic-class-static-block-fn\"] Let _bodyFunction_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameters_, |ClassStaticBlockBody|, ~non-lexical-this~, _lex_, _privateEnv_).\n        1. Perform MakeMethod(_bodyFunction_, _homeObject_).\n        1. Return the ClassStaticBlockDefinition Record { [[BodyFunction]]: _bodyFunction_ }.\n      ",
      {
        "normalizedName" : "ClassStaticBlock[0,0].ClassStaticBlockDefinitionEvaluation",
        "name" : "ClassStaticBlock[0,0].ClassStaticBlockDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-classstaticblockdefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassStaticBlockDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStaticBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "static"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassStaticBlockBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1510,
    [
      "CreateForInIterator",
      0,
      [
        [
          "object",
          false,
          "Record[Object]"
        ]
      ],
      "\n            1. Let _iterator_ be OrdinaryObjectCreate(%ForInIteratorPrototype%, « [[Object]], [[ObjectWasVisited]], [[VisitedKeys]], [[RemainingKeys]] »).\n            1. Set _iterator_.[[Object]] to _object_.\n            1. Set _iterator_.[[ObjectWasVisited]] to *false*.\n            1. Set _iterator_.[[VisitedKeys]] to a new empty List.\n            1. Set _iterator_.[[RemainingKeys]] to a new empty List.\n            1. Return _iterator_.\n          ",
      {
        "normalizedName" : "CreateForInIterator",
        "name" : "CreateForInIterator",
        "htmlId" : "sec-createforiniterator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1251,
    [
      "ElementList[1,1].ArrayAccumulation",
      2,
      [
        [
          "this",
          false,
          "Ast[ElementList[1]]"
        ],
        [
          "array",
          false,
          "Record[Array]"
        ],
        [
          "nextIndex",
          false,
          "Int"
        ]
      ],
      "\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.\n        ",
      {
        "normalizedName" : "ElementList[1,1].ArrayAccumulation",
        "name" : "ElementList[1,1].ArrayAccumulation",
        "htmlId" : "sec-runtime-semantics-arrayaccumulation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArrayAccumulation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "ElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "SpreadElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    618,
    [
      "CaseBlock[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,0].ContainsUndefinedBreakTarget",
        "name" : "CaseBlock[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1764,
    [
      "AsyncArrowFunction[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowFunction[1]]"
        ]
      ],
      "\n        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction|.\n      ",
      {
        "normalizedName" : "AsyncArrowFunction[1,0].Evaluation",
        "name" : "AsyncArrowFunction[1,0].Evaluation",
        "htmlId" : "sec-async-arrow-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncArrowFunction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverCallExpressionAndAsyncArrowHead"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2413,
    [
      "ClassSubtraction[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSubtraction[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of the first |ClassSetOperand| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of the second |ClassSetOperand| with argument _rer_.\n          1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _B_.\n        ",
      {
        "normalizedName" : "ClassSubtraction[0,0].CompileToCharSet",
        "name" : "ClassSubtraction[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassSubtraction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              },
              {
                "type" : "terminal",
                "value" : "--"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    425,
    [
      "Statement[7,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[7]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[7,0].VarScopedDeclarations",
        "name" : "Statement[7,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BreakStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2677,
    [
      "INTRINSICS.DataView.prototype.getInt16",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~int16~).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.getInt16",
        "name" : "INTRINSICS.DataView.prototype.getInt16",
        "htmlId" : "sec-dataview.prototype.getint16",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2176,
    [
      "GetNamedTimeZoneOffsetNanoseconds",
      0,
      [
        [
          "timeZoneIdentifier",
          false,
          "String"
        ],
        [
          "epochNanoseconds",
          false,
          "BigInt"
        ]
      ],
      "\n          1. Assert: _timeZoneIdentifier_ is *\"UTC\"*.\n          1. Return 0.\n        ",
      {
        "normalizedName" : "GetNamedTimeZoneOffsetNanoseconds",
        "name" : "GetNamedTimeZoneOffsetNanoseconds",
        "htmlId" : "sec-getnamedtimezoneoffsetnanoseconds",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    513,
    [
      "Statement[3,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[3]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[3,0].ContainsDuplicateLabels",
        "name" : "Statement[3,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1146,
    [
      "Record[StringExoticObject].DefineOwnProperty",
      4,
      [
        [
          "S",
          false,
          "Record[StringExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Desc",
          false,
          "Record[PropertyDescriptor]"
        ]
      ],
      "\n          1. Let _stringDesc_ be StringGetOwnProperty(_S_, _P_).\n          1. If _stringDesc_ is not *undefined*, then\n            1. Let _extensible_ be _S_.[[Extensible]].\n            1. Return IsCompatiblePropertyDescriptor(_extensible_, _Desc_, _stringDesc_).\n          1. Return ! OrdinaryDefineOwnProperty(_S_, _P_, _Desc_).\n        ",
      {
        "normalizedName" : "Record[StringExoticObject].DefineOwnProperty",
        "name" : "Record[StringExoticObject].DefineOwnProperty",
        "htmlId" : "sec-string-exotic-objects-defineownproperty-p-desc",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "StringExoticObject",
          "[[DefineOwnProperty]]"
        ]
      }
    ]
  ],
  [
    1754,
    [
      "AsyncFunctionBody[0,0].EvaluateAsyncFunctionBody",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n        1. Let _declResult_ be Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)).\n        1. If _declResult_ is an abrupt completion, then\n          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _declResult_.[[Value]] »).\n        1. Else,\n          1. Perform AsyncFunctionStart(_promiseCapability_, |FunctionBody|).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _promiseCapability_.[[Promise]], [[Target]]: ~empty~ }.\n      ",
      {
        "normalizedName" : "AsyncFunctionBody[0,0].EvaluateAsyncFunctionBody",
        "name" : "AsyncFunctionBody[0,0].EvaluateAsyncFunctionBody",
        "htmlId" : "sec-runtime-semantics-evaluateasyncfunctionbody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateAsyncFunctionBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2292,
    [
      "ClassEscape[1,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassEscape[1]]"
        ]
      ],
      "\n          1. Return the numeric value of U+002D (HYPHEN-MINUS).\n        ",
      {
        "normalizedName" : "ClassEscape[1,0].CharacterValue",
        "name" : "ClassEscape[1,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "-"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    430,
    [
      "StatementList[1,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be VarScopedDeclarations of |StatementList|.\n        1. Let _declarations2_ be VarScopedDeclarations of |StatementListItem|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "StatementList[1,0].VarScopedDeclarations",
        "name" : "StatementList[1,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2391,
    [
      "NonemptyClassRangesNoDash[2,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[NonemptyClassRangesNoDash[2]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of |ClassAtomNoDash| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of |ClassAtom| with argument _rer_.\n          1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.\n          1. Let _D_ be CharacterRange(_A_, _B_).\n          1. Return the union of _D_ and _C_.\n        ",
      {
        "normalizedName" : "NonemptyClassRangesNoDash[2,0].CompileToCharSet",
        "name" : "NonemptyClassRangesNoDash[2,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "NonemptyClassRangesNoDash",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassAtomNoDash"
              },
              {
                "type" : "terminal",
                "value" : "-"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassAtom"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassContents"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1680,
    [
      "ClassElementList[1,0].PrototypePropertyNameList",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementList[1]]"
        ]
      ],
      "\n        1. Let _list_ be PrototypePropertyNameList of |ClassElementList|.\n        1. Let _propName_ be PropName of |ClassElement|.\n        1. If _propName_ is ~empty~, return _list_.\n        1. If IsStatic of |ClassElement| is *true*, return _list_.\n        1. Return the list-concatenation of _list_ and « _propName_ ».\n      ",
      {
        "normalizedName" : "ClassElementList[1,0].PrototypePropertyNameList",
        "name" : "ClassElementList[1,0].PrototypePropertyNameList",
        "htmlId" : "sec-static-semantics-prototypepropertynamelist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrototypePropertyNameList",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementList"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1698,
    [
      "GeneratorMethod[0,0].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorMethod[0]]"
        ]
      ],
      "\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      ",
      {
        "normalizedName" : "GeneratorMethod[0,0].PrivateBoundIdentifiers",
        "name" : "GeneratorMethod[0,0].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1959,
    [
      "ImportDeclaration[0,0].ImportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportDeclaration[0]]"
        ]
      ],
      "\n          1. Let _module_ be the sole element of ModuleRequests of |FromClause|.\n          1. Return ImportEntriesForModule of |ImportClause| with argument _module_.\n        ",
      {
        "normalizedName" : "ImportDeclaration[0,0].ImportEntries",
        "name" : "ImportDeclaration[0,0].ImportEntries",
        "htmlId" : "sec-static-semantics-importentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntries",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ImportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "import"
              },
              {
                "type" : "nonterminal",
                "value" : "ImportClause"
              },
              {
                "type" : "nonterminal",
                "value" : "FromClause"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2556,
    [
      "INTRINSICS.TypedArray.prototype.reduceRight",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.\n          1. Let _k_ be _len_ - 1.\n          1. Let _accumulator_ be *undefined*.\n          1. If _initialValue_ is present, then\n            1. Set _accumulator_ to _initialValue_.\n          1. Else,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Set _accumulator_ to ! Get(_O_, _Pk_).\n            1. Set _k_ to _k_ - 1.\n          1. Repeat, while _k_ ≥ 0,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).\n            1. Set _k_ to _k_ - 1.\n          1. Return _accumulator_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.reduceRight",
        "name" : "INTRINSICS.TypedArray.prototype.reduceRight",
        "htmlId" : "sec-%typedarray%.prototype.reduceright",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1103,
    [
      "Record[OrdinaryObject].Delete",
      4,
      [
        [
          "O",
          false,
          "Record[OrdinaryObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n        1. Return ? OrdinaryDelete(_O_, _P_).\n      ",
      {
        "normalizedName" : "Record[OrdinaryObject].Delete",
        "name" : "Record[OrdinaryObject].Delete",
        "htmlId" : "sec-ordinary-object-internal-methods-and-internal-slots-delete-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "OrdinaryObject",
          "[[Delete]]"
        ]
      }
    ]
  ],
  [
    2253,
    [
      "INTRINSICS.String.prototype.padEnd",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Return ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~end~).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.padEnd",
        "name" : "INTRINSICS.String.prototype.padEnd",
        "htmlId" : "sec-string.prototype.padend",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2275,
    [
      "ThisStringValue",
      0,
      [
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n            1. If _value_ is a String, return _value_.\n            1. If _value_ is an Object and _value_ has a [[StringData]] internal slot, then\n              1. Let _s_ be _value_.[[StringData]].\n              1. Assert: _s_ is a String.\n              1. Return _s_.\n            1. Throw a *TypeError* exception.\n          ",
      {
        "normalizedName" : "ThisStringValue",
        "name" : "ThisStringValue",
        "htmlId" : "sec-thisstringvalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2033,
    [
      "INTRINSICS.isNaN",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _num_ be ? ToNumber(_number_).\n        1. If _num_ is *NaN*, return *true*.\n        1. Otherwise, return *false*.\n      ",
      {
        "normalizedName" : "INTRINSICS.isNaN",
        "name" : "INTRINSICS.isNaN",
        "htmlId" : "sec-isnan-number",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2149,
    [
      "INTRINSICS.Math.min",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _coerced_ be a new empty List.\n          1. For each element _arg_ of _args_, do\n            1. Let _n_ be ? ToNumber(_arg_).\n            1. Append _n_ to _coerced_.\n          1. Let _lowest_ be *+∞*<sub>𝔽</sub>.\n          1. For each element _number_ of _coerced_, do\n            1. If _number_ is *NaN*, return *NaN*.\n            1. If _number_ is *-0*<sub>𝔽</sub> and _lowest_ is *+0*<sub>𝔽</sub>, set _lowest_ to *-0*<sub>𝔽</sub>.\n            1. If _number_ < _lowest_, set _lowest_ to _number_.\n          1. Return _lowest_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.min",
        "name" : "INTRINSICS.Math.min",
        "htmlId" : "sec-math.min",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2717,
    [
      "INTRINSICS.Atomics.isLockFree",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _n_ be ? ToIntegerOrInfinity(_size_).\n        1. Let _AR_ be the Agent Record of the surrounding agent.\n        1. If _n_ = 1, return _AR_.[[IsLockFree1]].\n        1. If _n_ = 2, return _AR_.[[IsLockFree2]].\n        1. If _n_ = 4, return *true*.\n        1. If _n_ = 8, return _AR_.[[IsLockFree8]].\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.isLockFree",
        "name" : "INTRINSICS.Atomics.isLockFree",
        "htmlId" : "sec-atomics.islockfree",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1219,
    [
      "NumericLiteral[4,0].NumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[NumericLiteral[4]]"
        ]
      ],
      "\n          1. Return 𝔽(MV of |LegacyOctalIntegerLiteral|).\n        ",
      {
        "normalizedName" : "NumericLiteral[4,0].NumericValue",
        "name" : "NumericLiteral[4,0].NumericValue",
        "htmlId" : "sec-numericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NumericValue",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "NumericLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LegacyOctalIntegerLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    824,
    [
      "AsyncArrowFunction[1,0].NamedEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowFunction[1]]"
        ],
        [
          "name",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction| with argument _name_.\n      ",
      {
        "normalizedName" : "AsyncArrowFunction[1,0].NamedEvaluation",
        "name" : "AsyncArrowFunction[1,0].NamedEvaluation",
        "htmlId" : "sec-runtime-semantics-namedevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NamedEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncArrowFunction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverCallExpressionAndAsyncArrowHead"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    34,
    [
      "__FLAT_LIST__",
      8,
      [
        [
          "lists",
          false,
          "List[List]"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1483,
    [
      "MemberExpression[4,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[4]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "MemberExpression[4,0].IsDestructuring",
        "name" : "MemberExpression[4,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SuperProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    32,
    [
      "__APPEND_LIST__",
      8,
      [
        [
          "to",
          false,
          "List"
        ],
        [
          "from",
          false,
          "List"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1273,
    [
      "PropertyDefinitionList[1,0].PropertyDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyDefinitionList[1]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with argument _object_.\n          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinition| with argument _object_.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "PropertyDefinitionList[1,0].PropertyDefinitionEvaluation",
        "name" : "PropertyDefinitionList[1,0].PropertyDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-propertydefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "PropertyDefinitionList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PropertyDefinitionList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "PropertyDefinition"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    148,
    [
      "IsConstructor",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If _argument_ is not an Object, return *false*.\n        1. If _argument_ has a [[Construct]] internal method, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "IsConstructor",
        "name" : "IsConstructor",
        "htmlId" : "sec-isconstructor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2570,
    [
      "INTRINSICS.TypedArray.prototype.with",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n          1. If _relativeIndex_ ≥ 0, let _actualIndex_ be _relativeIndex_.\n          1. Else, let _actualIndex_ be _len_ + _relativeIndex_.\n          1. If _O_.[[ContentType]] is ~bigint~, let _numericValue_ be ? ToBigInt(_value_).\n          1. Else, let _numericValue_ be ? ToNumber(_value_).\n          1. If IsValidIntegerIndex(_O_, 𝔽(_actualIndex_)) is *false*, throw a *RangeError* exception.\n          1. Let _A_ be ? TypedArrayCreateSameType(_O_, « 𝔽(_len_) »).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. If _k_ is _actualIndex_, let _fromValue_ be _numericValue_.\n            1. Else, let _fromValue_ be ! Get(_O_, _Pk_).\n            1. Perform ! Set(_A_, _Pk_, _fromValue_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.with",
        "name" : "INTRINSICS.TypedArray.prototype.with",
        "htmlId" : "sec-%typedarray%.prototype.with",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1747,
    [
      "ClassExpression[0,1].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassExpression[0]]"
        ]
      ],
      "\n        1. Let _className_ be StringValue of |BindingIdentifier|.\n        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments _className_ and _className_.\n        1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.\n        1. Return _value_.\n      ",
      {
        "normalizedName" : "ClassExpression[0,1].Evaluation",
        "name" : "ClassExpression[0,1].Evaluation",
        "htmlId" : "sec-class-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ClassExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    264,
    [
      "ExportDeclaration[3,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[3]]"
        ]
      ],
      "\n        1. Return the BoundNames of |Declaration|.\n      ",
      {
        "normalizedName" : "ExportDeclaration[3,0].BoundNames",
        "name" : "ExportDeclaration[3,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1548,
    [
      "Statement[13,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[13]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |Statement|.\n      ",
      {
        "normalizedName" : "Statement[13,0].LabelledEvaluation",
        "name" : "Statement[13,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 13,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DebuggerStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1927,
    [
      "ExportDeclaration[4,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[4]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ExportDeclaration[4,0].ModuleRequests",
        "name" : "ExportDeclaration[4,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "HoistableDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    161,
    [
      "Get",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n        1. Return ? <emu-meta effects=\"user-code\">_O_.[[Get]]</emu-meta>(_P_, _O_).\n      ",
      {
        "normalizedName" : "Get",
        "name" : "Get",
        "htmlId" : "sec-get-o-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    745,
    [
      "UnaryExpression[6,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[6]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[6,0].IsFunctionDefinition",
        "name" : "UnaryExpression[6,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "~"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    279,
    [
      "GeneratorDeclaration[0,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorDeclaration[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "GeneratorDeclaration[0,0].IsConstantDeclaration",
        "name" : "GeneratorDeclaration[0,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    64,
    [
      "Number::sameValue",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. If _x_ is *NaN* and _y_ is *NaN*, return *true*.\n            1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *false*.\n            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *false*.\n            1. If _x_ is _y_, return *true*.\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "Number::sameValue",
        "name" : "Number::sameValue",
        "htmlId" : "sec-numeric-types-number-sameValue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2602,
    [
      "INTRINSICS.MapIteratorPrototype.next",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Return ? <emu-meta suppress-effects=\"user-code\">GeneratorResume(*this* value, ~empty~, *\"%MapIteratorPrototype%\"*)</emu-meta>.\n          ",
      {
        "normalizedName" : "INTRINSICS.MapIteratorPrototype.next",
        "name" : "INTRINSICS.MapIteratorPrototype.next",
        "htmlId" : "sec-%mapiteratorprototype%.next",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2028,
    [
      "ExportDeclaration[6,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[6]]"
        ]
      ],
      "\n          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then\n            1. Let _value_ be ? NamedEvaluation of |AssignmentExpression| with argument *\"default\"*.\n          1. Else,\n            1. Let _rhs_ be ? Evaluation of |AssignmentExpression|.\n            1. Let _value_ be ? GetValue(_rhs_).\n          1. Let _env_ be the running execution context's LexicalEnvironment.\n          1. Perform ? InitializeBoundName(*\"\\*default\\*\"*, _value_, _env_).\n          1. Return ~empty~.\n        ",
      {
        "normalizedName" : "ExportDeclaration[6,0].Evaluation",
        "name" : "ExportDeclaration[6,0].Evaluation",
        "htmlId" : "sec-exports-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1301,
    [
      "MemberExpression[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[2]]"
        ]
      ],
      "\n          1. Let _baseReference_ be ? Evaluation of |MemberExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If the source text matched by this |MemberExpression| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_).\n        ",
      {
        "normalizedName" : "MemberExpression[2,0].Evaluation",
        "name" : "MemberExpression[2,0].Evaluation",
        "htmlId" : "sec-property-accessors-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1595,
    [
      "CoverCallExpressionAndAsyncArrowHead[0,0].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[CoverCallExpressionAndAsyncArrowHead[0]]"
        ]
      ],
      "\n        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n        1. Return IsSimpleParameterList of _head_.\n      ",
      {
        "normalizedName" : "CoverCallExpressionAndAsyncArrowHead[0,0].IsSimpleParameterList",
        "name" : "CoverCallExpressionAndAsyncArrowHead[0,0].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CoverCallExpressionAndAsyncArrowHead",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2734,
    [
      "INTRINSICS.WeakRef",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. If CanBeHeldWeakly(_target_) is *false*, throw a *TypeError* exception.\n          1. Let _weakRef_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%WeakRef.prototype%\"*, « [[WeakRefTarget]] »).\n          1. Perform AddToKeptObjects(_target_).\n          1. Set _weakRef_.[[WeakRefTarget]] to _target_.\n          1. Return _weakRef_.\n        ",
      {
        "normalizedName" : "INTRINSICS.WeakRef",
        "name" : "INTRINSICS.WeakRef",
        "htmlId" : "sec-weak-ref-target",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    180,
    [
      "OrdinaryHasInstance",
      0,
      [
        [
          "C",
          false,
          "ESValue"
        ],
        [
          "O",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If IsCallable(_C_) is *false*, return *false*.\n        1. If _C_ has a [[BoundTargetFunction]] internal slot, then\n          1. Let _BC_ be _C_.[[BoundTargetFunction]].\n          1. Return ? InstanceofOperator(_O_, _BC_).\n        1. If _O_ is not an Object, return *false*.\n        1. Let _P_ be ? Get(_C_, *\"prototype\"*).\n        1. If _P_ is not an Object, throw a *TypeError* exception.\n        1. Repeat,\n          1. Set _O_ to ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]</emu-meta>().\n          1. If _O_ is *null*, return *false*.\n          1. If SameValue(_P_, _O_) is *true*, return *true*.\n      ",
      {
        "normalizedName" : "OrdinaryHasInstance",
        "name" : "OrdinaryHasInstance",
        "htmlId" : "sec-ordinaryhasinstance",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    689,
    [
      "CaseClause[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CaseClause[0,0].ContainsUndefinedContinueTarget",
        "name" : "CaseClause[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    296,
    [
      "CaseBlock[1,1].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _names1_ be the LexicallyDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be LexicallyDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the LexicallyDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,1].LexicallyDeclaredNames",
        "name" : "CaseBlock[1,1].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2524,
    [
      "INTRINSICS.Array.prototype.unshift",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _argCount_ be the number of elements in _items_.\n          1. If _argCount_ > 0, then\n            1. If _len_ + _argCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n            1. Let _k_ be _len_.\n            1. Repeat, while _k_ > 0,\n              1. Let _from_ be ! ToString(𝔽(_k_ - 1)).\n              1. Let _to_ be ! ToString(𝔽(_k_ + _argCount_ - 1)).\n              1. Let _fromPresent_ be ? HasProperty(_O_, _from_).\n              1. If _fromPresent_ is *true*, then\n                1. Let _fromValue_ be ? Get(_O_, _from_).\n                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).\n              1. Else,\n                1. Assert: _fromPresent_ is *false*.\n                1. Perform ? DeletePropertyOrThrow(_O_, _to_).\n              1. Set _k_ to _k_ - 1.\n            1. Let _j_ be *+0*<sub>𝔽</sub>.\n            1. For each element _E_ of _items_, do\n              1. Perform ? Set(_O_, ! ToString(_j_), _E_, *true*).\n              1. Set _j_ to _j_ + *1*<sub>𝔽</sub>.\n          1. Perform ? Set(_O_, *\"length\"*, 𝔽(_len_ + _argCount_), *true*).\n          1. Return 𝔽(_len_ + _argCount_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.unshift",
        "name" : "INTRINSICS.Array.prototype.unshift",
        "htmlId" : "sec-array.prototype.unshift",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    149,
    [
      "IsExtensible",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Return ? <emu-meta effects=\"user-code\">_O_.[[IsExtensible]]</emu-meta>().\n      ",
      {
        "normalizedName" : "IsExtensible",
        "name" : "IsExtensible",
        "htmlId" : "sec-isextensible-o",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2376,
    [
      "Atom[4,1].CompileAtom",
      2,
      [
        [
          "this",
          false,
          "Ast[Atom[4]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.\n          1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Atom|).\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _direction_, _m_, and _parenIndex_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _x_, _c_, _direction_, and _parenIndex_ and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Let _cap_ be a copy of _y_.[[Captures]].\n              1. Let _Input_ be _x_.[[Input]].\n              1. Let _xe_ be _x_.[[EndIndex]].\n              1. Let _ye_ be _y_.[[EndIndex]].\n              1. If _direction_ is ~forward~, then\n                1. Assert: _xe_ ≤ _ye_.\n                1. Let _r_ be the CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ }.\n              1. Else,\n                1. Assert: _direction_ is ~backward~.\n                1. Assert: _ye_ ≤ _xe_.\n                1. Let _r_ be the CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ }.\n              1. Set _cap_[_parenIndex_ + 1] to _r_.\n              1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ }.\n              1. Return _c_(_z_).\n            1. Return _m_(_x_, _d_).\n        ",
      {
        "normalizedName" : "Atom[4,1].CompileAtom",
        "name" : "Atom[4,1].CompileAtom",
        "htmlId" : "sec-compileatom",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAtom",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 1,
            "astName" : "Atom",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "GroupSpecifier"
              },
              {
                "type" : "nonterminal",
                "value" : "Disjunction"
              },
              {
                "type" : "terminal",
                "value" : ")"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1631,
    [
      "AsyncGeneratorMethod[0,0].HasDirectSuper",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorMethod[0]]"
        ]
      ],
      "\n        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.\n        1. Return |AsyncGeneratorBody| Contains |SuperCall|.\n      ",
      {
        "normalizedName" : "AsyncGeneratorMethod[0,0].HasDirectSuper",
        "name" : "AsyncGeneratorMethod[0,0].HasDirectSuper",
        "htmlId" : "sec-static-semantics-hasdirectsuper",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasDirectSuper",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    375,
    [
      "ForStatement[0,7].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,7].VarDeclaredNames",
        "name" : "ForStatement[0,7].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 7,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    733,
    [
      "NewExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[NewExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "NewExpression[1,0].IsFunctionDefinition",
        "name" : "NewExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "NewExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "nonterminal",
                "value" : "NewExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2260,
    [
      "GetSubstitution",
      0,
      [
        [
          "matched",
          false,
          "String"
        ],
        [
          "str",
          false,
          "String"
        ],
        [
          "position",
          false,
          "Int[0+]"
        ],
        [
          "captures",
          false,
          "List[String | Undefined]"
        ],
        [
          "namedCaptures",
          false,
          "Record[Object] | Undefined"
        ],
        [
          "replacementTemplate",
          false,
          "String"
        ]
      ],
      "\n            1. Let _stringLength_ be the length of _str_.\n            1. Assert: _position_ ≤ _stringLength_.\n            1. Let _result_ be the empty String.\n            1. Let _templateRemainder_ be _replacementTemplate_.\n            1. Repeat, while _templateRemainder_ is not the empty String,\n              1. [declared=\"ref,refReplacement\"] NOTE: The following steps isolate _ref_ (a prefix of _templateRemainder_), determine _refReplacement_ (its replacement), and then append that replacement to _result_.\n              1. If _templateRemainder_ starts with *\"$$\"*, then\n                1. Let _ref_ be *\"$$\"*.\n                1. Let _refReplacement_ be *\"$\"*.\n              1. Else if _templateRemainder_ starts with *\"$`\"*, then\n                1. Let _ref_ be *\"$`\"*.\n                1. Let _refReplacement_ be the substring of _str_ from 0 to _position_.\n              1. Else if _templateRemainder_ starts with *\"$&\"*, then\n                1. Let _ref_ be *\"$&\"*.\n                1. Let _refReplacement_ be _matched_.\n              1. Else if _templateRemainder_ starts with *\"$'\"* (0x0024 (DOLLAR SIGN) followed by 0x0027 (APOSTROPHE)), then\n                1. Let _ref_ be *\"$'\"*.\n                1. Let _matchLength_ be the length of _matched_.\n                1. Let _tailPos_ be _position_ + _matchLength_.\n                1. Let _refReplacement_ be the substring of _str_ from min(_tailPos_, _stringLength_).\n                1. NOTE: _tailPos_ can exceed _stringLength_ only if this abstract operation was invoked by a call to the intrinsic @@replace method of %RegExp.prototype% on an object whose *\"exec\"* property is not the intrinsic %RegExp.prototype.exec%.\n              1. Else if _templateRemainder_ starts with *\"$\"* followed by 1 or more decimal digits, then\n                1. If _templateRemainder_ starts with *\"$\"* followed by 2 or more decimal digits, let _digitCount_ be 2. Otherwise, let _digitCount_ be 1.\n                1. Let _digits_ be the substring of _templateRemainder_ from 1 to 1 + _digitCount_.\n                1. Let _index_ be ℝ(StringToNumber(_digits_)).\n                1. Assert: 0 ≤ _index_ ≤ 99.\n                1. Let _captureLen_ be the number of elements in _captures_.\n                1. If _index_ > _captureLen_ and _digitCount_ = 2, then\n                  1. NOTE: When a two-digit replacement pattern specifies an index exceeding the count of capturing groups, it is treated as a one-digit replacement pattern followed by a literal digit.\n                  1. Set _digitCount_ to 1.\n                  1. Set _digits_ to the substring of _digits_ from 0 to 1.\n                  1. Set _index_ to ℝ(StringToNumber(_digits_)).\n                1. Let _ref_ be the substring of _templateRemainder_ from 0 to 1 + _digitCount_.\n                1. If 1 ≤ _index_ ≤ _captureLen_, then\n                  1. Let _capture_ be _captures_[_index_ - 1].\n                  1. If _capture_ is *undefined*, then\n                    1. Let _refReplacement_ be the empty String.\n                  1. Else,\n                    1. Let _refReplacement_ be _capture_.\n                1. Else,\n                  1. Let _refReplacement_ be _ref_.\n              1. Else if _templateRemainder_ starts with *\"$<\"*, then\n                1. Let _gtPos_ be StringIndexOf(_templateRemainder_, *\">\"*, 0).\n                1. If _gtPos_ = -1 or _namedCaptures_ is *undefined*, then\n                  1. Let _ref_ be *\"$<\"*.\n                  1. Let _refReplacement_ be _ref_.\n                1. Else,\n                  1. Let _ref_ be the substring of _templateRemainder_ from 0 to _gtPos_ + 1.\n                  1. Let _groupName_ be the substring of _templateRemainder_ from 2 to _gtPos_.\n                  1. Assert: _namedCaptures_ is an Object.\n                  1. Let _capture_ be ? Get(_namedCaptures_, _groupName_).\n                  1. If _capture_ is *undefined*, then\n                    1. Let _refReplacement_ be the empty String.\n                  1. Else,\n                    1. Let _refReplacement_ be ? ToString(_capture_).\n              1. Else,\n                1. Let _ref_ be the substring of _templateRemainder_ from 0 to 1.\n                1. Let _refReplacement_ be _ref_.\n              1. Let _refLength_ be the length of _ref_.\n              1. Set _templateRemainder_ to the substring of _templateRemainder_ from _refLength_.\n              1. Set _result_ to the string-concatenation of _result_ and _refReplacement_.\n            1. Return _result_.\n          ",
      {
        "normalizedName" : "GetSubstitution",
        "name" : "GetSubstitution",
        "htmlId" : "sec-getsubstitution",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    601,
    [
      "ForStatement[2,1].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[2,1].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[2,1].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    819,
    [
      "GeneratorExpression[0,0].NamedEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ],
        [
          "name",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Return InstantiateGeneratorFunctionExpression of |GeneratorExpression| with argument _name_.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,0].NamedEvaluation",
        "name" : "GeneratorExpression[0,0].NamedEvaluation",
        "htmlId" : "sec-runtime-semantics-namedevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NamedEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2048,
    [
      "INTRINSICS.Object.defineProperty",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _O_ is not an Object, throw a *TypeError* exception.\n          1. Let _key_ be ? ToPropertyKey(_P_).\n          1. Let _desc_ be ? ToPropertyDescriptor(_Attributes_).\n          1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.defineProperty",
        "name" : "INTRINSICS.Object.defineProperty",
        "htmlId" : "sec-object.defineproperty",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2791,
    [
      "INTRINSICS.GeneratorFunction.prototype.prototype.return",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _g_ be the *this* value.\n          1. Let _C_ be Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n          1. Return ? GeneratorResumeAbrupt(_g_, _C_, ~empty~).\n        ",
      {
        "normalizedName" : "INTRINSICS.GeneratorFunction.prototype.prototype.return",
        "name" : "INTRINSICS.GeneratorFunction.prototype.prototype.return",
        "htmlId" : "sec-generator.prototype.return",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1388,
    [
      "AssignmentExpression[8,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[8]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |LeftHandSideExpression|.\n        1. [id=\"step-assignmentexpression-evaluation-lgcl-nullish-getvalue\"] Let _lval_ be ? GetValue(_lref_).\n        1. If _lval_ is neither *undefined* nor *null*, return _lval_.\n        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then\n          1. Let _rval_ be ? NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].\n        1. Else,\n          1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _rval_ be ? GetValue(_rref_).\n        1. [id=\"step-assignmentexpression-evaluation-lgcl-nullish-putvalue\"] Perform ? PutValue(_lref_, _rval_).\n        1. Return _rval_.\n      ",
      {
        "normalizedName" : "AssignmentExpression[8,0].Evaluation",
        "name" : "AssignmentExpression[8,0].Evaluation",
        "htmlId" : "sec-assignment-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "??="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    743,
    [
      "UnaryExpression[4,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[4]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[4,0].IsFunctionDefinition",
        "name" : "UnaryExpression[4,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "+"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2716,
    [
      "INTRINSICS.Atomics.exchange",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:\n          1. Return _newBytes_.\n        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _second_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.exchange",
        "name" : "INTRINSICS.Atomics.exchange",
        "htmlId" : "sec-atomics.exchange",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1965,
    [
      "NamedImports[0,0].ImportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[NamedImports[0]]"
        ],
        [
          "module",
          false,
          "String"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "NamedImports[0,0].ImportEntriesForModule",
        "name" : "NamedImports[0,0].ImportEntriesForModule",
        "htmlId" : "sec-static-semantics-importentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NamedImports",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    413,
    [
      "ClassStaticBlockStatementList[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockStatementList[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ClassStaticBlockStatementList[0,0].VarDeclaredNames",
        "name" : "ClassStaticBlockStatementList[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStaticBlockStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    584,
    [
      "IfStatement[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of the first |Statement| with argument _labelSet_.\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of the second |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "IfStatement[0,0].ContainsUndefinedBreakTarget",
        "name" : "IfStatement[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "else"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1154,
    [
      "Record[ArgumentsExoticObject].Delete",
      4,
      [
        [
          "args",
          false,
          "Record[ArgumentsExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. Let _map_ be _args_.[[ParameterMap]].\n          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n          1. Let _result_ be ? OrdinaryDelete(_args_, _P_).\n          1. If _result_ is *true* and _isMapped_ is *true*, then\n            1. Perform ! _map_.[[Delete]](_P_).\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "Record[ArgumentsExoticObject].Delete",
        "name" : "Record[ArgumentsExoticObject].Delete",
        "htmlId" : "sec-arguments-exotic-objects-delete-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ArgumentsExoticObject",
          "[[Delete]]"
        ]
      }
    ]
  ],
  [
    562,
    [
      "DefaultClause[0,1].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "DefaultClause[0,1].ContainsDuplicateLabels",
        "name" : "DefaultClause[0,1].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    904,
    [
      "BindingRestElement[1,0].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingRestElement[1]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _A_ be ! ArrayCreate(0).\n        1. Let _n_ be 0.\n        1. Repeat,\n          1. Let _next_ be ~done~.\n          1. If _iteratorRecord_.[[Done]] is *false*, then\n            1. Set _next_ to ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is ~done~, then\n            1. Return ? BindingInitialization of |BindingPattern| with arguments _A_ and _environment_.\n          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_).\n          1. Set _n_ to _n_ + 1.\n      ",
      {
        "normalizedName" : "BindingRestElement[1,0].IteratorBindingInitialization",
        "name" : "BindingRestElement[1,0].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingRestElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "..."
              },
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    975,
    [
      "BitwiseXORExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[BitwiseXORExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "BitwiseXORExpression[1,0].AssignmentTargetType",
        "name" : "BitwiseXORExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BitwiseXORExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BitwiseXORExpression"
              },
              {
                "type" : "terminal",
                "value" : "^"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseANDExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    176,
    [
      "CreateArrayFromList",
      0,
      [
        [
          "elements",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Let _array_ be ! ArrayCreate(0).\n        1. Let _n_ be 0.\n        1. For each element _e_ of _elements_, do\n          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_n_)), _e_).\n          1. Set _n_ to _n_ + 1.\n        1. Return _array_.\n      ",
      {
        "normalizedName" : "CreateArrayFromList",
        "name" : "CreateArrayFromList",
        "htmlId" : "sec-createarrayfromlist",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1833,
    [
      "EqualityExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "EqualityExpression[1,0].HasCallInTailPosition",
        "name" : "EqualityExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "=="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2727,
    [
      "InternalizeJSONProperty",
      0,
      [
        [
          "holder",
          false,
          "Record[Object]"
        ],
        [
          "name",
          false,
          "String"
        ],
        [
          "reviver",
          false,
          "Record[FunctionObject]"
        ]
      ],
      "\n          1. Let _val_ be ? Get(_holder_, _name_).\n          1. If _val_ is an Object, then\n            1. Let _isArray_ be ? IsArray(_val_).\n            1. If _isArray_ is *true*, then\n              1. Let _len_ be ? LengthOfArrayLike(_val_).\n              1. Let _I_ be 0.\n              1. Repeat, while _I_ < _len_,\n                1. Let _prop_ be ! ToString(𝔽(_I_)).\n                1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _prop_, _reviver_).\n                1. If _newElement_ is *undefined*, then\n                  1. Perform ? <emu-meta effects=\"user-code\">_val_.[[Delete]]</emu-meta>(_prop_).\n                1. Else,\n                  1. Perform ? CreateDataProperty(_val_, _prop_, _newElement_).\n                1. Set _I_ to _I_ + 1.\n            1. Else,\n              1. Let _keys_ be ? EnumerableOwnProperties(_val_, ~key~).\n              1. For each String _P_ of _keys_, do\n                1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _P_, _reviver_).\n                1. If _newElement_ is *undefined*, then\n                  1. Perform ? <emu-meta effects=\"user-code\">_val_.[[Delete]]</emu-meta>(_P_).\n                1. Else,\n                  1. Perform ? CreateDataProperty(_val_, _P_, _newElement_).\n          1. Return ? Call(_reviver_, _holder_, « _name_, _val_ »).\n        ",
      {
        "normalizedName" : "InternalizeJSONProperty",
        "name" : "InternalizeJSONProperty",
        "htmlId" : "sec-internalizejsonproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    423,
    [
      "Statement[3,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[3]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[3,0].VarScopedDeclarations",
        "name" : "Statement[3,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1007,
    [
      "ClassElementName[1,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementName[1]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "ClassElementName[1,0].PropName",
        "name" : "ClassElementName[1,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassElementName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    694,
    [
      "LabelledItem[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "LabelledItem[1,0].ContainsUndefinedContinueTarget",
        "name" : "LabelledItem[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    191,
    [
      "InitializeInstanceElements",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "constructor",
          false,
          "Record[ECMAScriptFunctionObject]"
        ]
      ],
      "\n        1. Let _methods_ be the value of _constructor_.[[PrivateMethods]].\n        1. For each PrivateElement _method_ of _methods_, do\n          1. Perform ? PrivateMethodOrAccessorAdd(_O_, _method_).\n        1. Let _fields_ be the value of _constructor_.[[Fields]].\n        1. For each element _fieldRecord_ of _fields_, do\n          1. Perform ? DefineField(_O_, _fieldRecord_).\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "InitializeInstanceElements",
        "name" : "InitializeInstanceElements",
        "htmlId" : "sec-initializeinstanceelements",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1916,
    [
      "ImportedLocalNames",
      0,
      [
        [
          "importEntries",
          false,
          "List[Record[ImportEntryRecord]]"
        ]
      ],
      "\n          1. Let _localNames_ be a new empty List.\n          1. For each ImportEntry Record _i_ of _importEntries_, do\n            1. Append _i_.[[LocalName]] to _localNames_.\n          1. Return _localNames_.\n        ",
      {
        "normalizedName" : "ImportedLocalNames",
        "name" : "ImportedLocalNames",
        "htmlId" : "sec-importedlocalnames",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    402,
    [
      "CaseClause[0,1].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the VarDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "CaseClause[0,1].VarDeclaredNames",
        "name" : "CaseClause[0,1].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2225,
    [
      "INTRINSICS.Date.prototype.toJSON",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _tv_ be ? ToPrimitive(_O_, ~number~).\n          1. If _tv_ is a Number and _tv_ is not finite, return *null*.\n          1. Return ? Invoke(_O_, *\"toISOString\"*).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.toJSON",
        "name" : "INTRINSICS.Date.prototype.toJSON",
        "htmlId" : "sec-date.prototype.tojson",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    732,
    [
      "MemberExpression[7,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[7]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[7,0].IsFunctionDefinition",
        "name" : "MemberExpression[7,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1884,
    [
      "PrimaryExpression[9,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[9]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[9,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[9,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 9,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    22,
    [
      "IsInTailPosition",
      0,
      [
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. If the source text matched by _call_ is non-strict code, return *false*.\n        1. If _call_ is not contained within a |FunctionBody|, a |ConciseBody|, or an |AsyncConciseBody|, return *false*.\n        1. Let _body_ be the |FunctionBody|, |ConciseBody|, or |AsyncConciseBody| that most closely contains _call_.\n        1. If _body_ is the |FunctionBody| of a |GeneratorBody|, return *false*.\n        1. If _body_ is the |FunctionBody| of an |AsyncFunctionBody|, return *false*.\n        1. If _body_ is the |FunctionBody| of an |AsyncGeneratorBody|, return *false*.\n        1. If _body_ is an |AsyncConciseBody|, return *false*.\n        1. Return the result of HasCallInTailPosition of _body_ with argument _call_.\n      ",
      {
        "normalizedName" : "IsInTailPosition",
        "name" : "IsInTailPosition",
        "htmlId" : "sec-isintailposition",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1615,
    [
      "FunctionExpression[0,1].InstantiateOrdinaryFunctionExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ],
        [
          "name",
          true,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Assert: _name_ is not present.\n        1. Set _name_ to StringValue of |BindingIdentifier|.\n        1. Let _outerEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).\n        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |FunctionExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Perform MakeConstructor(_closure_).\n        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).\n        1. Return _closure_.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,1].InstantiateOrdinaryFunctionExpression",
        "name" : "FunctionExpression[0,1].InstantiateOrdinaryFunctionExpression",
        "htmlId" : "sec-runtime-semantics-instantiateordinaryfunctionexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateOrdinaryFunctionExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1784,
    [
      "DoWhileStatement[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[DoWhileStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "DoWhileStatement[0,0].HasCallInTailPosition",
        "name" : "DoWhileStatement[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DoWhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "do"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1389,
    [
      "ApplyStringOrNumericBinaryOperator",
      0,
      [
        [
          "lval",
          false,
          "ESValue"
        ],
        [
          "opText",
          false,
          "Unknown[\"`**`,`*`,`/`,`%`,`+`,``,`<<`,`>>`,`>>>`,`&`,`^`,Or``\"]"
        ],
        [
          "rval",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If _opText_ is `+`, then\n          1. [id=\"step-binary-op-toprimitive-lval\"] Let _lprim_ be ? ToPrimitive(_lval_).\n          1. [id=\"step-binary-op-toprimitive-rval\"] Let _rprim_ be ? ToPrimitive(_rval_).\n          1. [id=\"step-binary-op-string-check\"] If _lprim_ is a String or _rprim_ is a String, then\n            1. Let _lstr_ be ? ToString(_lprim_).\n            1. Let _rstr_ be ? ToString(_rprim_).\n            1. Return the string-concatenation of _lstr_ and _rstr_.\n          1. Set _lval_ to _lprim_.\n          1. Set _rval_ to _rprim_.\n        1. NOTE: At this point, it must be a numeric operation.\n        1. Let _lnum_ be ? ToNumeric(_lval_).\n        1. Let _rnum_ be ? ToNumeric(_rval_).\n        1. If Type(_lnum_) is not Type(_rnum_), throw a *TypeError* exception.\n        1. If _lnum_ is a BigInt, then\n          1. If _opText_ is `**`, return ? BigInt::exponentiate(_lnum_, _rnum_).\n          1. If _opText_ is `/`, return ? BigInt::divide(_lnum_, _rnum_).\n          1. If _opText_ is `%`, return ? BigInt::remainder(_lnum_, _rnum_).\n          1. If _opText_ is `>>>`, return ? BigInt::unsignedRightShift(_lnum_, _rnum_).\n        1. Let _operation_ be the abstract operation associated with _opText_ and Type(_lnum_) in the following table:\n          <figure>\n            <!-- emu-format ignore -->\n            <table class=\"lightweight-table\">\n              <tbody><tr><th> _opText_       </th><th> Type(_lnum_) </th><th> _operation_                </th></tr>\n              <tr><td> `**`           </td><td> Number       </td><td> Number::exponentiate       </td></tr>\n              <tr><td> `*`            </td><td> Number       </td><td> Number::multiply           </td></tr>\n              <tr><td> `*`            </td><td> BigInt       </td><td> BigInt::multiply           </td></tr>\n              <tr><td> `/`            </td><td> Number       </td><td> Number::divide             </td></tr>\n              <tr><td> `%`            </td><td> Number       </td><td> Number::remainder          </td></tr>\n              <tr><td> `+`            </td><td> Number       </td><td> Number::add                </td></tr>\n              <tr><td> `+`            </td><td> BigInt       </td><td> BigInt::add                </td></tr>\n              <tr><td> `-`            </td><td> Number       </td><td> Number::subtract           </td></tr>\n              <tr><td> `-`            </td><td> BigInt       </td><td> BigInt::subtract           </td></tr>\n              <tr><td> `<<`     </td><td> Number       </td><td> Number::leftShift          </td></tr>\n              <tr><td> `<<`     </td><td> BigInt       </td><td> BigInt::leftShift          </td></tr>\n              <tr><td> `>>`     </td><td> Number       </td><td> Number::signedRightShift   </td></tr>\n              <tr><td> `>>`     </td><td> BigInt       </td><td> BigInt::signedRightShift   </td></tr>\n              <tr><td> `>>>` </td><td> Number       </td><td> Number::unsignedRightShift </td></tr>\n              <tr><td> `&`        </td><td> Number       </td><td> Number::bitwiseAND         </td></tr>\n              <tr><td> `&`        </td><td> BigInt       </td><td> BigInt::bitwiseAND         </td></tr>\n              <tr><td> `^`            </td><td> Number       </td><td> Number::bitwiseXOR         </td></tr>\n              <tr><td> `^`            </td><td> BigInt       </td><td> BigInt::bitwiseXOR         </td></tr>\n              <tr><td> `|`            </td><td> Number       </td><td> Number::bitwiseOR          </td></tr>\n              <tr><td> `|`            </td><td> BigInt       </td><td> BigInt::bitwiseOR          </td></tr>\n            </tbody></table>\n          </figure>\n        1. Return _operation_(_lnum_, _rnum_).\n      ",
      {
        "normalizedName" : "ApplyStringOrNumericBinaryOperator",
        "name" : "ApplyStringOrNumericBinaryOperator",
        "htmlId" : "sec-applystringornumericbinaryoperator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2789,
    [
      "INTRINSICS.AsyncGeneratorFunction",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the active function object.\n          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.\n          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~async-generator~, _parameterArgs_, _bodyArg_).\n        ",
      {
        "normalizedName" : "INTRINSICS.AsyncGeneratorFunction",
        "name" : "INTRINSICS.AsyncGeneratorFunction",
        "htmlId" : "sec-asyncgeneratorfunction",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    843,
    [
      "ClassTail[0,1].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassTail[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. If _symbol_ is |ClassBody|, return *true*.\n        1. If _symbol_ is |ClassHeritage|, then\n          1. If |ClassHeritage| is present, return *true*; otherwise return *false*.\n        1. If |ClassHeritage| is present, then\n          1. If |ClassHeritage| Contains _symbol_ is *true*, return *true*.\n        1. Return the result of ComputedPropertyContains of |ClassBody| with argument _symbol_.\n      ",
      {
        "normalizedName" : "ClassTail[0,1].Contains",
        "name" : "ClassTail[0,1].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ClassTail",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1125,
    [
      "AddRestrictedFunctionProperties",
      0,
      [
        [
          "F",
          false,
          "Record[FunctionObject]"
        ],
        [
          "realm",
          false,
          "Record[RealmRecord]"
        ]
      ],
      "\n        1. Assert: _realm_.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.\n        1. Let _thrower_ be _realm_.[[Intrinsics]].[[%ThrowTypeError%]].\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"caller\"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"arguments\"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "AddRestrictedFunctionProperties",
        "name" : "AddRestrictedFunctionProperties",
        "htmlId" : "sec-addrestrictedfunctionproperties",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2525,
    [
      "INTRINSICS.Array.prototype.values",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Return CreateArrayIterator(_O_, ~value~).\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.values",
        "name" : "INTRINSICS.Array.prototype.values",
        "htmlId" : "sec-array.prototype.values",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2657,
    [
      "INTRINSICS.get SharedArrayBuffer[@@species]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return the *this* value.\n        ",
      {
        "normalizedName" : "INTRINSICS.get SharedArrayBuffer[@@species]",
        "name" : "INTRINSICS.get SharedArrayBuffer[@@species]",
        "htmlId" : "sec-sharedarraybuffer-@@species",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2849,
    [
      "INTRINSICS.Reflect.setPrototypeOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. If _proto_ is not an Object and _proto_ is not *null*, throw a *TypeError* exception.\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[SetPrototypeOf]]</emu-meta>(_proto_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.setPrototypeOf",
        "name" : "INTRINSICS.Reflect.setPrototypeOf",
        "htmlId" : "sec-reflect.setprototypeof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2188,
    [
      "INTRINSICS.Date",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, then\n            1. Let _now_ be the time value (UTC) identifying the current time.\n            1. Return ToDateString(_now_).\n          1. Let _numberOfArgs_ be the number of elements in _values_.\n          1. If _numberOfArgs_ = 0, then\n            1. Let _dv_ be the time value (UTC) identifying the current time.\n          1. Else if _numberOfArgs_ = 1, then\n            1. Let _value_ be _values_[0].\n            1. If _value_ is an Object and _value_ has a [[DateValue]] internal slot, then\n              1. Let _tv_ be _value_.[[DateValue]].\n            1. Else,\n              1. Let _v_ be ? ToPrimitive(_value_).\n              1. If _v_ is a String, then\n                1. Assert: The next step never returns an abrupt completion because _v_ is a String.\n                1. Let _tv_ be the result of parsing _v_ as a date, in exactly the same manner as for the `parse` method (<emu-xref href=\"#sec-date.parse\"></emu-xref>).\n              1. Else,\n                1. Let _tv_ be ? ToNumber(_v_).\n            1. Let _dv_ be TimeClip(_tv_).\n          1. Else,\n            1. Assert: _numberOfArgs_ ≥ 2.\n            1. Let _y_ be ? ToNumber(_values_[0]).\n            1. Let _m_ be ? ToNumber(_values_[1]).\n            1. If _numberOfArgs_ > 2, let _dt_ be ? ToNumber(_values_[2]); else let _dt_ be *1*<sub>𝔽</sub>.\n            1. If _numberOfArgs_ > 3, let _h_ be ? ToNumber(_values_[3]); else let _h_ be *+0*<sub>𝔽</sub>.\n            1. If _numberOfArgs_ > 4, let _min_ be ? ToNumber(_values_[4]); else let _min_ be *+0*<sub>𝔽</sub>.\n            1. If _numberOfArgs_ > 5, let _s_ be ? ToNumber(_values_[5]); else let _s_ be *+0*<sub>𝔽</sub>.\n            1. If _numberOfArgs_ > 6, let _milli_ be ? ToNumber(_values_[6]); else let _milli_ be *+0*<sub>𝔽</sub>.\n            1. Let _yr_ be MakeFullYear(_y_).\n            1. Let _finalDate_ be MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_)).\n            1. Let _dv_ be TimeClip(UTC(_finalDate_)).\n          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Date.prototype%\"*, « [[DateValue]] »).\n          1. Set _O_.[[DateValue]] to _dv_.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date",
        "name" : "INTRINSICS.Date",
        "htmlId" : "sec-date",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    772,
    [
      "ConditionalExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[ConditionalExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ConditionalExpression[1,0].IsFunctionDefinition",
        "name" : "ConditionalExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ConditionalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShortCircuitExpression"
              },
              {
                "type" : "terminal",
                "value" : "?"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1620,
    [
      "FunctionStatementList[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ]
      ],
      "\n        1. Return *undefined*.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,0].Evaluation",
        "name" : "FunctionStatementList[0,0].Evaluation",
        "htmlId" : "sec-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2489,
    [
      "INTRINSICS.Array.prototype.filter",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).\n          1. Let _k_ be 0.\n          1. Let _to_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Let _selected_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n              1. If _selected_ is *true*, then\n                1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_to_)), _kValue_).\n                1. Set _to_ to _to_ + 1.\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.filter",
        "name" : "INTRINSICS.Array.prototype.filter",
        "htmlId" : "sec-array.prototype.filter",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2393,
    [
      "ClassAtomNoDash[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassAtomNoDash[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return the CharSet containing the character matched by |SourceCharacter|.\n        ",
      {
        "normalizedName" : "ClassAtomNoDash[0,0].CompileToCharSet",
        "name" : "ClassAtomNoDash[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassAtomNoDash",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SourceCharacter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    286,
    [
      "ClassDeclaration[1,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassDeclaration[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassDeclaration[1,0].IsConstantDeclaration",
        "name" : "ClassDeclaration[1,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1752,
    [
      "AsyncFunctionExpression[0,0].InstantiateAsyncFunctionExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ],
        [
          "name",
          true,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Return _closure_.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,0].InstantiateAsyncFunctionExpression",
        "name" : "AsyncFunctionExpression[0,0].InstantiateAsyncFunctionExpression",
        "htmlId" : "sec-runtime-semantics-instantiateasyncfunctionexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateAsyncFunctionExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1652,
    [
      "GeneratorExpression[0,1].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return InstantiateGeneratorFunctionExpression of |GeneratorExpression|.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,1].Evaluation",
        "name" : "GeneratorExpression[0,1].Evaluation",
        "htmlId" : "sec-generator-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1929,
    [
      "ExportDeclaration[6,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[6]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ExportDeclaration[6,0].ModuleRequests",
        "name" : "ExportDeclaration[6,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2674,
    [
      "INTRINSICS.DataView.prototype.getFloat32",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~float32~).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.getFloat32",
        "name" : "INTRINSICS.DataView.prototype.getFloat32",
        "htmlId" : "sec-dataview.prototype.getfloat32",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2016,
    [
      "ExportSpecifier[1,0].ExportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportSpecifier[1]]"
        ],
        [
          "module",
          false,
          "String | Null"
        ]
      ],
      "\n          1. Let _sourceName_ be the StringValue of the first |ModuleExportName|.\n          1. Let _exportName_ be the StringValue of the second |ModuleExportName|.\n          1. If _module_ is *null*, then\n            1. Let _localName_ be _sourceName_.\n            1. Let _importName_ be *null*.\n          1. Else,\n            1. Let _localName_ be *null*.\n            1. Let _importName_ be _sourceName_.\n          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _exportName_ }.\n        ",
      {
        "normalizedName" : "ExportSpecifier[1,0].ExportEntriesForModule",
        "name" : "ExportSpecifier[1,0].ExportEntriesForModule",
        "htmlId" : "sec-static-semantics-exportentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportSpecifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              },
              {
                "type" : "terminal",
                "value" : "as"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2514,
    [
      "INTRINSICS.Array.prototype.sort",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. [id=\"step-array-sort-comparefn\"] If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n          1. Let _obj_ be ? ToObject(*this* value).\n          1. [id=\"step-array-sort-len\"] Let _len_ be ? LengthOfArrayLike(_obj_).\n          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n            1. Return ? CompareArrayElements(_x_, _y_, _comparefn_).\n          1. [id=\"step-array-sortindexedproperties\"] Let _sortedList_ be ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~skip-holes~).\n          1. Let _itemCount_ be the number of elements in _sortedList_.\n          1. Let _j_ be 0.\n          1. Repeat, while _j_ < _itemCount_,\n            1. Perform ? Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).\n            1. Set _j_ to _j_ + 1.\n          1. NOTE: The call to SortIndexedProperties in step <emu-xref href=\"#step-array-sortindexedproperties\"></emu-xref> uses ~skip-holes~. The remaining indices are deleted to preserve the number of holes that were detected and excluded from the sort.\n          1. Repeat, while _j_ < _len_,\n            1. Perform ? DeletePropertyOrThrow(_obj_, ! ToString(𝔽(_j_))).\n            1. Set _j_ to _j_ + 1.\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.sort",
        "name" : "INTRINSICS.Array.prototype.sort",
        "htmlId" : "sec-array.prototype.sort",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2568,
    [
      "INTRINSICS.TypedArray.prototype.toSorted",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _A_ be ? TypedArrayCreateSameType(_O_, « 𝔽(_len_) »).\n          1. NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href=\"#sec-array.prototype.tosorted\"></emu-xref>.\n          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n            1. Return ? CompareTypedArrayElements(_x_, _y_, _comparefn_).\n          1. Let _sortedList_ be ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).\n          1. Let _j_ be 0.\n          1. Repeat, while _j_ < _len_,\n            1. Perform ! Set(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).\n            1. Set _j_ to _j_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.toSorted",
        "name" : "INTRINSICS.TypedArray.prototype.toSorted",
        "htmlId" : "sec-%typedarray%.prototype.tosorted",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    875,
    [
      "AsyncGeneratorDeclaration[0,0].InstantiateFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorDeclaration[0]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Return InstantiateAsyncGeneratorFunctionObject of |AsyncGeneratorDeclaration| with arguments _env_ and _privateEnv_.\n      ",
      {
        "normalizedName" : "AsyncGeneratorDeclaration[0,0].InstantiateFunctionObject",
        "name" : "AsyncGeneratorDeclaration[0,0].InstantiateFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiatefunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    826,
    [
      "<DEFAULT>.Contains",
      2,
      [
        [
          "this",
          false,
          "Ast"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. For each child node _child_ of this Parse Node, do\n          1. If _child_ is an instance of _symbol_, return *true*.\n          1. If _child_ is an instance of a nonterminal, then\n            1. Let _contained_ be the result of _child_ Contains _symbol_.\n            1. If _contained_ is *true*, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "<DEFAULT>.Contains",
        "name" : "<DEFAULT>.Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "default",
          "prod" : null
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    577,
    [
      "Statement[6,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[6]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[6,0].ContainsUndefinedBreakTarget",
        "name" : "Statement[6,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ContinueStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    711,
    [
      "AsyncArrowFunction[1,0].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowFunction[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncArrowFunction[1,0].HasName",
        "name" : "AsyncArrowFunction[1,0].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncArrowFunction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverCallExpressionAndAsyncArrowHead"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    579,
    [
      "Statement[11,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[11]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[11,0].ContainsUndefinedBreakTarget",
        "name" : "Statement[11,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 11,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ThrowStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    291,
    [
      "StatementList[1,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be LexicallyDeclaredNames of |StatementList|.\n        1. Let _names2_ be LexicallyDeclaredNames of |StatementListItem|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "StatementList[1,0].LexicallyDeclaredNames",
        "name" : "StatementList[1,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1535,
    [
      "LabelledStatement[0,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _label_ be the StringValue of |LabelIdentifier|.\n        1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».\n        1. Let _stmtResult_ be Completion(LabelledEvaluation of |LabelledItem| with argument _newLabelSet_).\n        1. If _stmtResult_ is a break completion and _stmtResult_.[[Target]] is _label_, then\n          1. Set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).\n        1. Return ? _stmtResult_.\n      ",
      {
        "normalizedName" : "LabelledStatement[0,0].LabelledEvaluation",
        "name" : "LabelledStatement[0,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelledItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2806,
    [
      "INTRINSICS.AsyncGeneratorFunction.prototype.prototype.next",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _generator_ be the *this* value.\n          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n          1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).\n          1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Let _state_ be _generator_.[[AsyncGeneratorState]].\n          1. If _state_ is ~completed~, then\n            1. Let _iteratorResult_ be CreateIterResultObject(*undefined*, *true*).\n            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).\n            1. Return _promiseCapability_.[[Promise]].\n          1. Let _completion_ be NormalCompletion(_value_).\n          1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).\n          1. If _state_ is either ~suspended-start~ or ~suspended-yield~, then\n            1. Perform AsyncGeneratorResume(_generator_, _completion_).\n          1. Else,\n            1. Assert: _state_ is either ~executing~ or ~awaiting-return~.\n          1. Return _promiseCapability_.[[Promise]].\n        ",
      {
        "normalizedName" : "INTRINSICS.AsyncGeneratorFunction.prototype.prototype.next",
        "name" : "INTRINSICS.AsyncGeneratorFunction.prototype.prototype.next",
        "htmlId" : "sec-asyncgenerator-prototype-next",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    958,
    [
      "AdditiveExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[AdditiveExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "AdditiveExpression[1,0].AssignmentTargetType",
        "name" : "AdditiveExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AdditiveExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              },
              {
                "type" : "terminal",
                "value" : "+"
              },
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    118,
    [
      "StringNumericLiteral[1,3].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StringNumericLiteral[1]]"
        ]
      ],
      "\n            1. Return StringNumericValue of |StrNumericLiteral|.\n          ",
      {
        "normalizedName" : "StringNumericLiteral[1,3].StringNumericValue",
        "name" : "StringNumericLiteral[1,3].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "StringNumericLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StrWhiteSpace"
              },
              {
                "type" : "nonterminal",
                "value" : "StrNumericLiteral"
              },
              {
                "type" : "nonterminal",
                "value" : "StrWhiteSpace"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1403,
    [
      "ArrayAssignmentPattern[2,2].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayAssignmentPattern[2]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n          1. If _status_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n            1. Return ? _status_.\n          1. If |Elision| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n            1. If _status_ is an abrupt completion, then\n              1. Assert: _iteratorRecord_.[[Done]] is *true*.\n              1. Return ? _status_.\n          1. If |AssignmentRestElement| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n          1. Return ? _status_.\n        ",
      {
        "normalizedName" : "ArrayAssignmentPattern[2,2].DestructuringAssignmentEvaluation",
        "name" : "ArrayAssignmentPattern[2,2].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 2,
            "astName" : "ArrayAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    59,
    [
      "Number::leftShift",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. Let _lnum_ be ! ToInt32(_x_).\n            1. Let _rnum_ be ! ToUint32(_y_).\n            1. Let _shiftCount_ be ℝ(_rnum_) modulo 32.\n            1. Return the result of left shifting _lnum_ by _shiftCount_ bits. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.\n          ",
      {
        "normalizedName" : "Number::leftShift",
        "name" : "Number::leftShift",
        "htmlId" : "sec-numeric-types-number-leftShift",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1795,
    [
      "ForStatement[1,1].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[1,1].HasCallInTailPosition",
        "name" : "ForStatement[1,1].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1701,
    [
      "<DEFAULT>.ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast"
        ]
      ],
      "\n        1. For each child node _child_ of this Parse Node, do\n          1. If _child_ is an instance of a nonterminal, then\n            1. If ContainsArguments of _child_ is *true*, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "<DEFAULT>.ContainsArguments",
        "name" : "<DEFAULT>.ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "default",
          "prod" : null
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2398,
    [
      "CharacterClassEscape[1,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `d`</emu-grammar>.\n          1. Return CharacterComplement(_rer_, _S_).\n        ",
      {
        "normalizedName" : "CharacterClassEscape[1,0].CompileToCharSet",
        "name" : "CharacterClassEscape[1,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "D"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1520,
    [
      "CaseBlock[0,1].CaseBlockEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[0]]"
        ],
        [
          "input",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _V_ be *undefined*.\n        1. Let _A_ be the List of |CaseClause| items in |CaseClauses|, in source text order.\n        1. Let _found_ be *false*.\n        1. For each |CaseClause| _C_ of _A_, do\n          1. If _found_ is *false*, then\n            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n          1. If _found_ is *true*, then\n            1. Let _R_ be Completion(Evaluation of _C_).\n            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n            1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Return _V_.\n      ",
      {
        "normalizedName" : "CaseBlock[0,1].CaseBlockEvaluation",
        "name" : "CaseBlock[0,1].CaseBlockEvaluation",
        "htmlId" : "sec-runtime-semantics-caseblockevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CaseBlockEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2817,
    [
      "AsyncGeneratorUnwrapYieldResumption",
      0,
      [
        [
          "resumptionValue",
          false,
          "Completion"
        ]
      ],
      "\n          1. If _resumptionValue_ is not a return completion, return ? _resumptionValue_.\n          1. Let _awaited_ be Completion(Await(_resumptionValue_.[[Value]])).\n          1. If _awaited_ is a throw completion, return ? _awaited_.\n          1. Assert: _awaited_ is a normal completion.\n          1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _awaited_.[[Value]], [[Target]]: ~empty~ }.\n        ",
      {
        "normalizedName" : "AsyncGeneratorUnwrapYieldResumption",
        "name" : "AsyncGeneratorUnwrapYieldResumption",
        "htmlId" : "sec-asyncgeneratorunwrapyieldresumption",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1124,
    [
      "OrdinaryFunctionCreate",
      0,
      [
        [
          "functionPrototype",
          false,
          "Record[Object]"
        ],
        [
          "sourceText",
          false,
          "Unknown[\"SequenceOfUnicodeCodePoint\"]"
        ],
        [
          "ParameterList",
          false,
          "Ast"
        ],
        [
          "Body",
          false,
          "Ast"
        ],
        [
          "thisMode",
          false,
          "Enum[~lexical-this~, ~non-lexical-this~]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href=\"#table-internal-slots-of-ecmascript-function-objects\"></emu-xref>.\n        1. Let _F_ be OrdinaryObjectCreate(_functionPrototype_, _internalSlotsList_).\n        1. Set _F_.[[Call]] to the definition specified in <emu-xref href=\"#sec-ecmascript-function-objects-call-thisargument-argumentslist\"></emu-xref>.\n        1. Set _F_.[[SourceText]] to _sourceText_.\n        1. Set _F_.[[FormalParameters]] to _ParameterList_.\n        1. Set _F_.[[ECMAScriptCode]] to _Body_.\n        1. If the source text matched by _Body_ is strict mode code, let _Strict_ be *true*; else let _Strict_ be *false*.\n        1. Set _F_.[[Strict]] to _Strict_.\n        1. If _thisMode_ is ~lexical-this~, set _F_.[[ThisMode]] to ~lexical~.\n        1. Else if _Strict_ is *true*, set _F_.[[ThisMode]] to ~strict~.\n        1. Else, set _F_.[[ThisMode]] to ~global~.\n        1. Set _F_.[[IsClassConstructor]] to *false*.\n        1. Set _F_.[[Environment]] to _env_.\n        1. Set _F_.[[PrivateEnvironment]] to _privateEnv_.\n        1. Set _F_.[[ScriptOrModule]] to GetActiveScriptOrModule().\n        1. Set _F_.[[Realm]] to the current Realm Record.\n        1. Set _F_.[[HomeObject]] to *undefined*.\n        1. Set _F_.[[Fields]] to a new empty List.\n        1. Set _F_.[[PrivateMethods]] to a new empty List.\n        1. Set _F_.[[ClassFieldInitializerName]] to ~empty~.\n        1. Let _len_ be the ExpectedArgumentCount of _ParameterList_.\n        1. Perform SetFunctionLength(_F_, _len_).\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "OrdinaryFunctionCreate",
        "name" : "OrdinaryFunctionCreate",
        "htmlId" : "sec-ordinaryfunctioncreate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    281,
    [
      "AsyncGeneratorDeclaration[0,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorDeclaration[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorDeclaration[0,0].IsConstantDeclaration",
        "name" : "AsyncGeneratorDeclaration[0,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    204,
    [
      "CreateListIteratorRecord:clo0",
      6,
      [
      ],
      "\n        1. Let _closure_ be a new Abstract Closure with no parameters that captures _list_ and performs the following steps when called:\n          1. For each element _E_ of _list_, do\n            1. Perform ? GeneratorYield(CreateIterResultObject(_E_, *false*)).\n          1. Return NormalCompletion(*undefined*).\n        1. Let _iterator_ be CreateIteratorFromClosure(_closure_, ~empty~, %IteratorPrototype%).\n        1. Return the Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: %GeneratorFunction.prototype.prototype.next%, [[Done]]: *false* }.\n      ",
      {
        "normalizedName" : "CreateListIteratorRecord",
        "name" : "CreateListIteratorRecord",
        "htmlId" : "sec-createlistiteratorRecord",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1226,
    [
      "RegularExpressionLiteral[0,0].FlagText",
      2,
      [
        [
          "this",
          false,
          "Ast[RegularExpressionLiteral[0]]"
        ]
      ],
      "\n          1. Return the source text that was recognized as |RegularExpressionFlags|.\n        ",
      {
        "normalizedName" : "RegularExpressionLiteral[0,0].FlagText",
        "name" : "RegularExpressionLiteral[0,0].FlagText",
        "htmlId" : "sec-static-semantics-flagtext",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "FlagText",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "RegularExpressionLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "/"
              },
              {
                "type" : "nonterminal",
                "value" : "RegularExpressionBody"
              },
              {
                "type" : "terminal",
                "value" : "/"
              },
              {
                "type" : "nonterminal",
                "value" : "RegularExpressionFlags"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    545,
    [
      "ForInOfStatement[3,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[3]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[3,0].ContainsDuplicateLabels",
        "name" : "ForInOfStatement[3,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1488,
    [
      "LeftHandSideExpression[1,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[LeftHandSideExpression[1]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "LeftHandSideExpression[1,0].IsDestructuring",
        "name" : "LeftHandSideExpression[1,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LeftHandSideExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2695,
    [
      "RevalidateAtomicAccess",
      0,
      [
        [
          "typedArray",
          false,
          "Record[TypedArray]"
        ],
        [
          "byteIndexInBuffer",
          false,
          "Int"
        ]
      ],
      "\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_typedArray_, ~unordered~).\n          1. NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n          1. Assert: _byteIndexInBuffer_ ≥ _typedArray_.[[ByteOffset]].\n          1. If _byteIndexInBuffer_ ≥ _taRecord_.[[CachedBufferByteLength]], throw a *RangeError* exception.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "RevalidateAtomicAccess",
        "name" : "RevalidateAtomicAccess",
        "htmlId" : "sec-revalidateatomicaccess",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1256,
    [
      "SpreadElement[0,0].ArrayAccumulation",
      2,
      [
        [
          "this",
          false,
          "Ast[SpreadElement[0]]"
        ],
        [
          "array",
          false,
          "Record[Array]"
        ],
        [
          "nextIndex",
          false,
          "Int"
        ]
      ],
      "\n          1. Let _spreadRef_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _spreadObj_ be ? GetValue(_spreadRef_).\n          1. Let _iteratorRecord_ be ? GetIterator(_spreadObj_, ~sync~).\n          1. Repeat,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is ~done~, return _nextIndex_.\n            1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _next_).\n            1. Set _nextIndex_ to _nextIndex_ + 1.\n        ",
      {
        "normalizedName" : "SpreadElement[0,0].ArrayAccumulation",
        "name" : "SpreadElement[0,0].ArrayAccumulation",
        "htmlId" : "sec-runtime-semantics-arrayaccumulation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArrayAccumulation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SpreadElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "..."
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2827,
    [
      "AsyncBlockStart:clo0",
      6,
      [
      ],
      "\n          1. Assert: _promiseCapability_ is a PromiseCapability Record.\n          1. Let _runningContext_ be the running execution context.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _promiseCapability_ and _asyncBody_ and performs the following steps when called:\n            1. Let _acAsyncContext_ be the running execution context.\n            1. Let _result_ be Completion(Evaluation of _asyncBody_).\n            1. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.\n            1. Remove _acAsyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. If _result_ is a normal completion, then\n              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).\n            1. Else if _result_ is a return completion, then\n              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] »).\n            1. Else,\n              1. Assert: _result_ is a throw completion.\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] »).\n            1. [id=\"step-asyncblockstart-return-undefined\"] Return ~unused~.\n          1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta>. Let _result_ be the value returned by the resumed computation.\n          1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.\n          1. Assert: _result_ is a normal completion with a value of ~unused~. The possible sources of this value are Await or, if the async function doesn't await anything, step <emu-xref href=\"#step-asyncblockstart-return-undefined\"></emu-xref> above.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncBlockStart",
        "name" : "AsyncBlockStart",
        "htmlId" : "sec-asyncblockstart",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    259,
    [
      "ImportsList[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportsList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be the BoundNames of |ImportsList|.\n        1. Let _names2_ be the BoundNames of |ImportSpecifier|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ImportsList[1,0].BoundNames",
        "name" : "ImportsList[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ImportsList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportsList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "ImportSpecifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2134,
    [
      "INTRINSICS.Math.ceil",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ < *-0*<sub>𝔽</sub> and _n_ > *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n          1. If _n_ is an integral Number, return _n_.\n          1. Return the smallest (closest to -∞) integral Number value that is not less than _n_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.ceil",
        "name" : "INTRINSICS.Math.ceil",
        "htmlId" : "sec-math.ceil",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    27,
    [
      "StringToCodePoints",
      0,
      [
        [
          "string",
          false,
          "String"
        ]
      ],
      "\n        1. Let _codePoints_ be a new empty List.\n        1. Let _size_ be the length of _string_.\n        1. Let _position_ be 0.\n        1. Repeat, while _position_ < _size_,\n          1. Let _cp_ be CodePointAt(_string_, _position_).\n          1. Append _cp_.[[CodePoint]] to _codePoints_.\n          1. Set _position_ to _position_ + _cp_.[[CodeUnitCount]].\n        1. Return _codePoints_.\n      ",
      {
        "normalizedName" : "StringToCodePoints",
        "name" : "StringToCodePoints",
        "htmlId" : "sec-stringtocodepoints",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    12,
    [
      "INTRINSICS.Number.prototype.toLocaleString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Object] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1312,
    [
      "CallExpression[3,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[3]]"
        ]
      ],
      "\n          1. Let _ref_ be ? Evaluation of |CallExpression|.\n          1. Let _func_ be ? GetValue(_ref_).\n          1. Let _thisCall_ be this |CallExpression|.\n          1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n          1. Return ? EvaluateCall(_func_, _ref_, |Arguments|, _tailCall_).\n        ",
      {
        "normalizedName" : "CallExpression[3,0].Evaluation",
        "name" : "CallExpression[3,0].Evaluation",
        "htmlId" : "sec-function-calls-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1332,
    [
      "OptionalChain[2,0].ChainEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[2]]"
        ],
        [
          "baseValue",
          false,
          "ESValue"
        ],
        [
          "baseReference",
          false,
          "ESValue | Record[ReferenceRecord]"
        ]
      ],
      "\n          1. If the source text matched by this |OptionalChain| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_).\n        ",
      {
        "normalizedName" : "OptionalChain[2,0].ChainEvaluation",
        "name" : "OptionalChain[2,0].ChainEvaluation",
        "htmlId" : "sec-optional-chaining-chain-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ChainEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "?."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    350,
    [
      "ExportDeclaration[4,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[4]]"
        ]
      ],
      "\n        1. Return a List whose sole element is DeclarationPart of |HoistableDeclaration|.\n      ",
      {
        "normalizedName" : "ExportDeclaration[4,0].LexicallyScopedDeclarations",
        "name" : "ExportDeclaration[4,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "HoistableDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    641,
    [
      "Statement[7,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[7]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[7,0].ContainsUndefinedContinueTarget",
        "name" : "Statement[7,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BreakStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1428,
    [
      "Block[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Block[0]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "Block[0,0].Evaluation",
        "name" : "Block[0,0].Evaluation",
        "htmlId" : "sec-block-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Block",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2161,
    [
      "DaysInYear",
      0,
      [
        [
          "y",
          false,
          "NumberInt"
        ]
      ],
      "\n          1. Let _ry_ be ℝ(_y_).\n          1. If (_ry_ modulo 400) = 0, return *366*<sub>𝔽</sub>.\n          1. If (_ry_ modulo 100) = 0, return *365*<sub>𝔽</sub>.\n          1. If (_ry_ modulo 4) = 0, return *366*<sub>𝔽</sub>.\n          1. Return *365*<sub>𝔽</sub>.\n        ",
      {
        "normalizedName" : "DaysInYear",
        "name" : "DaysInYear",
        "htmlId" : "sec-daysinyear",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    71,
    [
      "BigInt::bitwiseNOT",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ]
      ],
      "\n            1. Return -_x_ - *1*<sub>ℤ</sub>.\n          ",
      {
        "normalizedName" : "BigInt::bitwiseNOT",
        "name" : "BigInt::bitwiseNOT",
        "htmlId" : "sec-numeric-types-bigint-bitwiseNOT",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    391,
    [
      "ForInOfStatement[4,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[4]]"
        ]
      ],
      "\n        1. Let _names1_ be the BoundNames of |ForBinding|.\n        1. Let _names2_ be the VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[4,0].VarDeclaredNames",
        "name" : "ForInOfStatement[4,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1139,
    [
      "Record[BoundFunctionExoticObject].Construct",
      4,
      [
        [
          "F",
          false,
          "Record[BoundFunctionExoticObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "newTarget",
          false,
          "Record[Constructor]"
        ]
      ],
      "\n          1. Let _target_ be _F_.[[BoundTargetFunction]].\n          1. Assert: IsConstructor(_target_) is *true*.\n          1. Let _boundArgs_ be _F_.[[BoundArguments]].\n          1. Let _args_ be the list-concatenation of _boundArgs_ and _argumentsList_.\n          1. If SameValue(_F_, _newTarget_) is *true*, set _newTarget_ to _target_.\n          1. Return ? Construct(_target_, _args_, _newTarget_).\n        ",
      {
        "normalizedName" : "Record[BoundFunctionExoticObject].Construct",
        "name" : "Record[BoundFunctionExoticObject].Construct",
        "htmlId" : "sec-bound-function-exotic-objects-construct-argumentslist-newtarget",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "BoundFunctionExoticObject",
          "[[Construct]]"
        ]
      }
    ]
  ],
  [
    1503,
    [
      "ForInOfStatement[8,0].ForInOfLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[8]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~async-iterate~).\n          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_, ~async~).\n        ",
      {
        "normalizedName" : "ForInOfStatement[8,0].ForInOfLoopEvaluation",
        "name" : "ForInOfStatement[8,0].ForInOfLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forinofloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForInOfLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1669,
    [
      "ClassElementList[0,0].ConstructorMethod",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementList[0]]"
        ]
      ],
      "\n        1. If ClassElementKind of |ClassElement| is ~constructor-method~, return |ClassElement|.\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "ClassElementList[0,0].ConstructorMethod",
        "name" : "ClassElementList[0,0].ConstructorMethod",
        "htmlId" : "sec-static-semantics-constructormethod",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ConstructorMethod",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2193,
    [
      "INTRINSICS.Date.prototype.getHours",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return HourFromTime(LocalTime(_t_)).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getHours",
        "name" : "INTRINSICS.Date.prototype.getHours",
        "htmlId" : "sec-date.prototype.gethours",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1786,
    [
      "ForStatement[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[0,0].HasCallInTailPosition",
        "name" : "ForStatement[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    445,
    [
      "ForStatement[0,7].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,7].VarScopedDeclarations",
        "name" : "ForStatement[0,7].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 7,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    936,
    [
      "CallExpression[3,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[3]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "CallExpression[3,0].AssignmentTargetType",
        "name" : "CallExpression[3,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2220,
    [
      "INTRINSICS.Date.prototype.setUTCMinutes",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _m_ be ? ToNumber(_min_).\n          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).\n          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).\n          1. Let _v_ be TimeClip(_date_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setUTCMinutes",
        "name" : "INTRINSICS.Date.prototype.setUTCMinutes",
        "htmlId" : "sec-date.prototype.setutcminutes",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    382,
    [
      "ForStatement[2,2].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[2,2].VarDeclaredNames",
        "name" : "ForStatement[2,2].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    54,
    [
      "Number::multiply",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. If _x_ is *NaN* or _y_ is *NaN*, return *NaN*.\n            1. If _x_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, then\n              1. If _y_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *NaN*.\n              1. If _y_ > *+0*<sub>𝔽</sub>, return _x_.\n              1. Return -_x_.\n            1. If _y_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, then\n              1. If _x_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *NaN*.\n              1. If _x_ > *+0*<sub>𝔽</sub>, return _y_.\n              1. Return -_y_.\n            1. If _x_ is *-0*<sub>𝔽</sub>, then\n              1. If _y_ is *-0*<sub>𝔽</sub> or _y_ < *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n              1. Else, return *-0*<sub>𝔽</sub>.\n            1. If _y_ is *-0*<sub>𝔽</sub>, then\n              1. If _x_ < *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n              1. Else, return *-0*<sub>𝔽</sub>.\n            1. Return 𝔽(ℝ(_x_) × ℝ(_y_)).\n          ",
      {
        "normalizedName" : "Number::multiply",
        "name" : "Number::multiply",
        "htmlId" : "sec-numeric-types-number-multiply",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    572,
    [
      "ModuleItem[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ModuleItem[0,0].ContainsDuplicateLabels",
        "name" : "ModuleItem[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2029,
    [
      "INTRINSICS.eval",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Return ? PerformEval(_x_, *false*, *false*).\n      ",
      {
        "normalizedName" : "INTRINSICS.eval",
        "name" : "INTRINSICS.eval",
        "htmlId" : "sec-eval-x",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2326,
    [
      "ClassSubtraction[0,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSubtraction[0]]"
        ]
      ],
      "\n          1. Return MayContainStrings of the first |ClassSetOperand|.\n        ",
      {
        "normalizedName" : "ClassSubtraction[0,0].MayContainStrings",
        "name" : "ClassSubtraction[0,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassSubtraction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              },
              {
                "type" : "terminal",
                "value" : "--"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2293,
    [
      "CharacterEscape[0,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterEscape[0]]"
        ]
      ],
      "\n          1. Return the numeric value according to <emu-xref href=\"#table-controlescape-code-point-values\"></emu-xref>.\n        ",
      {
        "normalizedName" : "CharacterEscape[0,0].CharacterValue",
        "name" : "CharacterEscape[0,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CharacterEscape",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ControlEscape"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1707,
    [
      "GeneratorDeclaration[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorDeclaration[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "GeneratorDeclaration[0,0].ContainsArguments",
        "name" : "GeneratorDeclaration[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    313,
    [
      "Script[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[Script[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Script[0,0].LexicallyDeclaredNames",
        "name" : "Script[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Script",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1271,
    [
      "LiteralPropertyName[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[LiteralPropertyName[2]]"
        ]
      ],
      "\n          1. Let _nbr_ be the NumericValue of |NumericLiteral|.\n          1. Return ! ToString(_nbr_).\n        ",
      {
        "normalizedName" : "LiteralPropertyName[2,0].Evaluation",
        "name" : "LiteralPropertyName[2,0].Evaluation",
        "htmlId" : "sec-object-initializer-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "LiteralPropertyName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NumericLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2308,
    [
      "CharacterClassEscape[1,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[1]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "CharacterClassEscape[1,0].MayContainStrings",
        "name" : "CharacterClassEscape[1,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "D"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1371,
    [
      "RelationalExpression[7,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[7]]"
        ]
      ],
      "\n        1. Let _privateIdentifier_ be the StringValue of |PrivateIdentifier|.\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. If _rval_ is not an Object, throw a *TypeError* exception.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _privateName_ be ResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_).\n        1. If PrivateElementFind(_rval_, _privateName_) is not ~empty~, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[7,0].Evaluation",
        "name" : "RelationalExpression[7,0].Evaluation",
        "htmlId" : "sec-relational-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    611,
    [
      "ForInOfStatement[7,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[7]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[7,0].ContainsUndefinedBreakTarget",
        "name" : "ForInOfStatement[7,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    787,
    [
      "AsyncGeneratorExpression[0,1].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,1].IsFunctionDefinition",
        "name" : "AsyncGeneratorExpression[0,1].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    144,
    [
      "CanonicalNumericIndexString",
      0,
      [
        [
          "argument",
          false,
          "String"
        ]
      ],
      "\n        1. If _argument_ is *\"-0\"*, return *-0*<sub>𝔽</sub>.\n        1. Let _n_ be ! ToNumber(_argument_).\n        1. If ! ToString(_n_) is _argument_, return _n_.\n        1. Return *undefined*.\n      ",
      {
        "normalizedName" : "CanonicalNumericIndexString",
        "name" : "CanonicalNumericIndexString",
        "htmlId" : "sec-canonicalnumericindexstring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2738,
    [
      "INTRINSICS.FinalizationRegistry.prototype.register",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _finalizationRegistry_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).\n          1. If CanBeHeldWeakly(_target_) is *false*, throw a *TypeError* exception.\n          1. If SameValue(_target_, _heldValue_) is *true*, throw a *TypeError* exception.\n          1. If CanBeHeldWeakly(_unregisterToken_) is *false*, then\n            1. If _unregisterToken_ is not *undefined*, throw a *TypeError* exception.\n            1. Set _unregisterToken_ to ~empty~.\n          1. Let _cell_ be the Record { [[WeakRefTarget]]: _target_, [[HeldValue]]: _heldValue_, [[UnregisterToken]]: _unregisterToken_ }.\n          1. Append _cell_ to _finalizationRegistry_.[[Cells]].\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "INTRINSICS.FinalizationRegistry.prototype.register",
        "name" : "INTRINSICS.FinalizationRegistry.prototype.register",
        "htmlId" : "sec-finalization-registry.prototype.register",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    713,
    [
      "FunctionExpression[0,1].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,1].HasName",
        "name" : "FunctionExpression[0,1].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1865,
    [
      "CallExpression[4,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[4]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CallExpression[4,0].HasCallInTailPosition",
        "name" : "CallExpression[4,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    498,
    [
      "StatementListItem[1,0].TopLevelLexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[1]]"
        ]
      ],
      "\n        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>, then\n          1. Return a new empty List.\n        1. Return « |Declaration| ».\n      ",
      {
        "normalizedName" : "StatementListItem[1,0].TopLevelLexicallyScopedDeclarations",
        "name" : "StatementListItem[1,0].TopLevelLexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-toplevellexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelLexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1635,
    [
      "MethodDefinition[2,0].SpecialMethod",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[2]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "MethodDefinition[2,0].SpecialMethod",
        "name" : "MethodDefinition[2,0].SpecialMethod",
        "htmlId" : "sec-static-semantics-specialmethod",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "SpecialMethod",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncMethod"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1733,
    [
      "ClassElement[4,0].ClassElementEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[4]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Return ClassStaticBlockDefinitionEvaluation of |ClassStaticBlock| with argument _object_.\n      ",
      {
        "normalizedName" : "ClassElement[4,0].ClassElementEvaluation",
        "name" : "ClassElement[4,0].ClassElementEvaluation",
        "htmlId" : "sec-static-semantics-classelementevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassElementEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassStaticBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1058,
    [
      "NewGlobalEnvironment",
      0,
      [
        [
          "G",
          false,
          "Record[Object]"
        ],
        [
          "thisValue",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Let _objRec_ be NewObjectEnvironment(_G_, *false*, *null*).\n          1. Let _dclRec_ be NewDeclarativeEnvironment(*null*).\n          1. Let _env_ be a new Global Environment Record.\n          1. Set _env_.[[ObjectRecord]] to _objRec_.\n          1. Set _env_.[[GlobalThisValue]] to _thisValue_.\n          1. Set _env_.[[DeclarativeRecord]] to _dclRec_.\n          1. Set _env_.[[VarNames]] to a new empty List.\n          1. Set _env_.[[OuterEnv]] to *null*.\n          1. Return _env_.\n        ",
      {
        "normalizedName" : "NewGlobalEnvironment",
        "name" : "NewGlobalEnvironment",
        "htmlId" : "sec-newglobalenvironment",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1107,
    [
      "OrdinaryObjectCreate",
      0,
      [
        [
          "proto",
          false,
          "Record[Object] | Null"
        ],
        [
          "additionalInternalSlotsList",
          true,
          "Unknown[\"ListOfNamesOfInternalSlot\"]"
        ]
      ],
      "\n        1. Let _internalSlotsList_ be « [[Prototype]], [[Extensible]] ».\n        1. If _additionalInternalSlotsList_ is present, set _internalSlotsList_ to the list-concatenation of _internalSlotsList_ and _additionalInternalSlotsList_.\n        1. Let _O_ be MakeBasicObject(_internalSlotsList_).\n        1. Set _O_.[[Prototype]] to _proto_.\n        1. Return _O_.\n      ",
      {
        "normalizedName" : "OrdinaryObjectCreate",
        "name" : "OrdinaryObjectCreate",
        "htmlId" : "sec-ordinaryobjectcreate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1239,
    [
      "IdentifierReference[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierReference[1]]"
        ]
      ],
      "\n        1. Return ? ResolveBinding(*\"yield\"*).\n      ",
      {
        "normalizedName" : "IdentifierReference[1,0].Evaluation",
        "name" : "IdentifierReference[1,0].Evaluation",
        "htmlId" : "sec-identifiers-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IdentifierReference",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "yield"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1997,
    [
      "ExportsList[1,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportsList[1]]"
        ]
      ],
      "\n          1. Let _names1_ be the ExportedNames of |ExportsList|.\n          1. Let _names2_ be the ExportedNames of |ExportSpecifier|.\n          1. Return the list-concatenation of _names1_ and _names2_.\n        ",
      {
        "normalizedName" : "ExportsList[1,0].ExportedNames",
        "name" : "ExportsList[1,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportsList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExportsList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "ExportSpecifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    49,
    [
      "Completion",
      0,
      [
        [
          "completionRecord",
          false,
          "Completion"
        ]
      ],
      "\n          1. Assert: _completionRecord_ is a Completion Record.\n          1. Return _completionRecord_.\n        ",
      {
        "normalizedName" : "Completion",
        "name" : "Completion",
        "htmlId" : "sec-completion-ao",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2753,
    [
      "NewPromiseCapability",
      0,
      [
        [
          "C",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n          1. NOTE: _C_ is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see <emu-xref href=\"#sec-promise-executor\"></emu-xref>).\n          1. Let _resolvingFunctions_ be the Record { [[Resolve]]: *undefined*, [[Reject]]: *undefined* }.\n          1. Let _executorClosure_ be a new Abstract Closure with parameters (_resolve_, _reject_) that captures _resolvingFunctions_ and performs the following steps when called:\n            1. If _resolvingFunctions_.[[Resolve]] is not *undefined*, throw a *TypeError* exception.\n            1. If _resolvingFunctions_.[[Reject]] is not *undefined*, throw a *TypeError* exception.\n            1. Set _resolvingFunctions_.[[Resolve]] to _resolve_.\n            1. Set _resolvingFunctions_.[[Reject]] to _reject_.\n            1. Return *undefined*.\n          1. Let _executor_ be CreateBuiltinFunction(_executorClosure_, 2, *\"\"*, « »).\n          1. Let _promise_ be ? Construct(_C_, « _executor_ »).\n          1. If IsCallable(_resolvingFunctions_.[[Resolve]]) is *false*, throw a *TypeError* exception.\n          1. If IsCallable(_resolvingFunctions_.[[Reject]]) is *false*, throw a *TypeError* exception.\n          1. Return the PromiseCapability Record { [[Promise]]: _promise_, [[Resolve]]: _resolvingFunctions_.[[Resolve]], [[Reject]]: _resolvingFunctions_.[[Reject]] }.\n        ",
      {
        "normalizedName" : "NewPromiseCapability",
        "name" : "NewPromiseCapability",
        "htmlId" : "sec-newpromisecapability",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2442,
    [
      "RegExpAlloc",
      0,
      [
        [
          "newTarget",
          false,
          "Record[Constructor]"
        ]
      ],
      "\n          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%RegExp.prototype%\"*, « [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], [[RegExpMatcher]] »).\n          1. Perform ! DefinePropertyOrThrow(_obj_, *\"lastIndex\"*, PropertyDescriptor { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "RegExpAlloc",
        "name" : "RegExpAlloc",
        "htmlId" : "sec-regexpalloc",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2759,
    [
      "NewPromiseResolveThenableJob:clo0",
      6,
      [
      ],
      "\n          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _promiseToResolve_, _thenable_, and _then_ and performs the following steps when called:\n            1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promiseToResolve_).\n            1. Let _thenCallResult_ be Completion(HostCallJobCallback(_then_, _thenable_, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)).\n            1. If _thenCallResult_ is an abrupt completion, then\n              1. Return ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _thenCallResult_.[[Value]] »).\n            1. Return ? _thenCallResult_.\n          1. Let _getThenRealmResult_ be Completion(GetFunctionRealm(_then_.[[Callback]])).\n          1. If _getThenRealmResult_ is a normal completion, let _thenRealm_ be _getThenRealmResult_.[[Value]].\n          1. Else, let _thenRealm_ be the current Realm Record.\n          1. NOTE: _thenRealm_ is never *null*. When _then_.[[Callback]] is a revoked Proxy and no code runs, _thenRealm_ is used to create error objects.\n          1. Return the Record { [[Job]]: _job_, [[Realm]]: _thenRealm_ }.\n        ",
      {
        "normalizedName" : "NewPromiseResolveThenableJob",
        "name" : "NewPromiseResolveThenableJob",
        "htmlId" : "sec-newpromiseresolvethenablejob",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    466,
    [
      "CaseBlock[1,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _declarations1_ be the VarScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be VarScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the VarScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,0].VarScopedDeclarations",
        "name" : "CaseBlock[1,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2055,
    [
      "INTRINSICS.Object.getOwnPropertyNames",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~string~)).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.getOwnPropertyNames",
        "name" : "INTRINSICS.Object.getOwnPropertyNames",
        "htmlId" : "sec-object.getownpropertynames",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1092,
    [
      "Record[OrdinaryObject].DefineOwnProperty",
      4,
      [
        [
          "O",
          false,
          "Record[OrdinaryObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Desc",
          false,
          "Record[PropertyDescriptor]"
        ]
      ],
      "\n        1. Return ? OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).\n      ",
      {
        "normalizedName" : "Record[OrdinaryObject].DefineOwnProperty",
        "name" : "Record[OrdinaryObject].DefineOwnProperty",
        "htmlId" : "sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "OrdinaryObject",
          "[[DefineOwnProperty]]"
        ]
      }
    ]
  ],
  [
    335,
    [
      "FunctionStatementList[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,0].LexicallyScopedDeclarations",
        "name" : "FunctionStatementList[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2706,
    [
      "DoWait",
      0,
      [
        [
          "mode",
          false,
          "Enum[~async~, ~sync~]"
        ],
        [
          "typedArray",
          false,
          "ESValue"
        ],
        [
          "index",
          false,
          "ESValue"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "timeout",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _taRecord_ be ? ValidateIntegerTypedArray(_typedArray_, *true*).\n          1. Let _buffer_ be _taRecord_.[[Object]].[[ViewedArrayBuffer]].\n          1. If IsSharedArrayBuffer(_buffer_) is *false*, throw a *TypeError* exception.\n          1. Let _i_ be ? ValidateAtomicAccess(_taRecord_, _index_).\n          1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].\n          1. If _arrayTypeName_ is *\"BigInt64Array\"*, let _v_ be ? ToBigInt64(_value_).\n          1. Else, let _v_ be ? ToInt32(_value_).\n          1. Let _q_ be ? ToNumber(_timeout_).\n          1. If _q_ is either *NaN* or *+∞*<sub>𝔽</sub>, let _t_ be +∞; else if _q_ is *-∞*<sub>𝔽</sub>, let _t_ be 0; else let _t_ be max(ℝ(_q_), 0).\n          1. If _mode_ is ~sync~ and AgentCanSuspend() is *false*, throw a *TypeError* exception.\n          1. Let _block_ be _buffer_.[[ArrayBufferData]].\n          1. Let _offset_ be _typedArray_.[[ByteOffset]].\n          1. Let _byteIndexInBuffer_ be (_i_ × 4) + _offset_.\n          1. Let _WL_ be GetWaiterList(_block_, _byteIndexInBuffer_).\n          1. If _mode_ is ~sync~, then\n            1. Let _promiseCapability_ be ~blocking~.\n            1. Let _resultObject_ be *undefined*.\n          1. Else,\n            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n            1. Let _resultObject_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform EnterCriticalSection(_WL_).\n          1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n          1. Let _w_ be GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).\n          1. If _v_ ≠ _w_, then\n            1. Perform LeaveCriticalSection(_WL_).\n            1. If _mode_ is ~sync~, return *\"not-equal\"*.\n            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"async\"*, *false*).\n            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"value\"*, *\"not-equal\"*).\n            1. Return _resultObject_.\n          1. If _t_ is 0 and _mode_ is ~async~, then\n            1. NOTE: There is no special handling of synchronous immediate timeouts. Asynchronous immediate timeouts have special handling in order to fail fast and avoid unnecessary Promise jobs.\n            1. Perform LeaveCriticalSection(_WL_).\n            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"async\"*, *false*).\n            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"value\"*, *\"timed-out\"*).\n            1. Return _resultObject_.\n          1. Let _thisAgent_ be AgentSignifier().\n          1. Let _now_ be the time value (UTC) identifying the current time.\n          1. Let _additionalTimeout_ be an implementation-defined non-negative mathematical value.\n          1. Let _timeoutTime_ be ℝ(_now_) + _t_ + _additionalTimeout_.\n          1. NOTE: When _t_ is +∞, _timeoutTime_ is also +∞.\n          1. Let _waiterRecord_ be a new Waiter Record { [[AgentSignifier]]: _thisAgent_, [[PromiseCapability]]: _promiseCapability_, [[TimeoutTime]]: _timeoutTime_, [[Result]]: *\"ok\"* }.\n          1. Perform AddWaiter(_WL_, _waiterRecord_).\n          1. If _mode_ is ~sync~, then\n            1. Perform SuspendThisAgent(_WL_, _waiterRecord_).\n          1. Else if _timeoutTime_ is finite, then\n            1. Perform EnqueueAtomicsWaitAsyncTimeoutJob(_WL_, _waiterRecord_).\n          1. Perform LeaveCriticalSection(_WL_).\n          1. If _mode_ is ~sync~, return _waiterRecord_.[[Result]].\n          1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"async\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"value\"*, _promiseCapability_.[[Promise]]).\n          1. Return _resultObject_.\n        ",
      {
        "normalizedName" : "DoWait",
        "name" : "DoWait",
        "htmlId" : "sec-dowait",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2166,
    [
      "InLeapYear",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. If DaysInYear(YearFromTime(_t_)) is *366*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>; else return *+0*<sub>𝔽</sub>.\n        ",
      {
        "normalizedName" : "InLeapYear",
        "name" : "InLeapYear",
        "htmlId" : "sec-inleapyear",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    236,
    [
      "BindingElement[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElement[1]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingPattern|.\n      ",
      {
        "normalizedName" : "BindingElement[1,0].BoundNames",
        "name" : "BindingElement[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1765,
    [
      "StatementList[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Let _has_ be HasCallInTailPosition of |StatementList| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Return HasCallInTailPosition of |StatementListItem| with argument _call_.\n      ",
      {
        "normalizedName" : "StatementList[1,0].HasCallInTailPosition",
        "name" : "StatementList[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1090,
    [
      "Record[OrdinaryObject].GetOwnProperty",
      4,
      [
        [
          "O",
          false,
          "Record[OrdinaryObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n        1. Return OrdinaryGetOwnProperty(_O_, _P_).\n      ",
      {
        "normalizedName" : "Record[OrdinaryObject].GetOwnProperty",
        "name" : "Record[OrdinaryObject].GetOwnProperty",
        "htmlId" : "sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "OrdinaryObject",
          "[[GetOwnProperty]]"
        ]
      }
    ]
  ],
  [
    2457,
    [
      "INTRINSICS.RegExp.prototype[@@replace]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _rx_ be the *this* value.\n          1. If _rx_ is not an Object, throw a *TypeError* exception.\n          1. Let _S_ be ? ToString(_string_).\n          1. Let _lengthS_ be the length of _S_.\n          1. Let _functionalReplace_ be IsCallable(_replaceValue_).\n          1. If _functionalReplace_ is *false*, then\n            1. Set _replaceValue_ to ? ToString(_replaceValue_).\n          1. Let _flags_ be ? ToString(? Get(_rx_, *\"flags\"*)).\n          1. If _flags_ contains *\"g\"*, let _global_ be *true*. Otherwise, let _global_ be *false*.\n          1. If _global_ is *true*, then\n            1. Perform ? Set(_rx_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n          1. Let _results_ be a new empty List.\n          1. Let _done_ be *false*.\n          1. Repeat, while _done_ is *false*,\n            1. Let _result_ be ? RegExpExec(_rx_, _S_).\n            1. If _result_ is *null*, then\n              1. Set _done_ to *true*.\n            1. Else,\n              1. Append _result_ to _results_.\n              1. If _global_ is *false*, then\n                1. Set _done_ to *true*.\n              1. Else,\n                1. Let _matchStr_ be ? ToString(? Get(_result_, *\"0\"*)).\n                1. If _matchStr_ is the empty String, then\n                  1. Let _thisIndex_ be ℝ(? ToLength(? Get(_rx_, *\"lastIndex\"*))).\n                  1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _fullUnicode_ be *true*. Otherwise, let _fullUnicode_ be *false*.\n                  1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).\n                  1. Perform ? Set(_rx_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).\n          1. Let _accumulatedResult_ be the empty String.\n          1. Let _nextSourcePosition_ be 0.\n          1. For each element _result_ of _results_, do\n            1. Let _resultLength_ be ? LengthOfArrayLike(_result_).\n            1. Let _nCaptures_ be max(_resultLength_ - 1, 0).\n            1. Let _matched_ be ? ToString(? Get(_result_, *\"0\"*)).\n            1. Let _matchLength_ be the length of _matched_.\n            1. Let _position_ be ? ToIntegerOrInfinity(? Get(_result_, *\"index\"*)).\n            1. Set _position_ to the result of clamping _position_ between 0 and _lengthS_.\n            1. Let _captures_ be a new empty List.\n            1. Let _n_ be 1.\n            1. Repeat, while _n_ ≤ _nCaptures_,\n              1. Let _capN_ be ? Get(_result_, ! ToString(𝔽(_n_))).\n              1. If _capN_ is not *undefined*, then\n                1. Set _capN_ to ? ToString(_capN_).\n              1. Append _capN_ to _captures_.\n              1. NOTE: When _n_ = 1, the preceding step puts the first element into _captures_ (at index 0). More generally, the _n_<sup>th</sup> capture (the characters captured by the _n_<sup>th</sup> set of capturing parentheses) is at _captures_[_n_ - 1].\n              1. Set _n_ to _n_ + 1.\n            1. Let _namedCaptures_ be ? Get(_result_, *\"groups\"*).\n            1. If _functionalReplace_ is *true*, then\n              1. Let _replacerArgs_ be the list-concatenation of « _matched_ », _captures_, and « 𝔽(_position_), _S_ ».\n              1. If _namedCaptures_ is not *undefined*, then\n                1. Append _namedCaptures_ to _replacerArgs_.\n              1. Let _replValue_ be ? Call(_replaceValue_, *undefined*, _replacerArgs_).\n              1. Let _replacement_ be ? ToString(_replValue_).\n            1. Else,\n              1. If _namedCaptures_ is not *undefined*, then\n                1. Set _namedCaptures_ to ? ToObject(_namedCaptures_).\n              1. Let _replacement_ be ? GetSubstitution(_matched_, _S_, _position_, _captures_, _namedCaptures_, _replaceValue_).\n            1. If _position_ ≥ _nextSourcePosition_, then\n              1. NOTE: _position_ should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of _rx_. In such cases, the corresponding substitution is ignored.\n              1. Set _accumulatedResult_ to the string-concatenation of _accumulatedResult_, the substring of _S_ from _nextSourcePosition_ to _position_, and _replacement_.\n              1. Set _nextSourcePosition_ to _position_ + _matchLength_.\n          1. If _nextSourcePosition_ ≥ _lengthS_, return _accumulatedResult_.\n          1. Return the string-concatenation of _accumulatedResult_ and the substring of _S_ from _nextSourcePosition_.\n        ",
      {
        "normalizedName" : "INTRINSICS.RegExp.prototype[@@replace]",
        "name" : "INTRINSICS.RegExp.prototype[@@replace]",
        "htmlId" : "sec-regexp.prototype-@@replace",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1897,
    [
      "OptionalExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |OptionalChain| with argument _call_.\n      ",
      {
        "normalizedName" : "OptionalExpression[1,0].HasCallInTailPosition",
        "name" : "OptionalExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "OptionalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    919,
    [
      "MemberExpression[4,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[4]]"
        ]
      ],
      "\n        1. Return ~simple~.\n      ",
      {
        "normalizedName" : "MemberExpression[4,0].AssignmentTargetType",
        "name" : "MemberExpression[4,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SuperProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2557,
    [
      "INTRINSICS.TypedArray.prototype.reverse",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _middle_ be floor(_len_ / 2).\n          1. Let _lower_ be 0.\n          1. Repeat, while _lower_ ≠ _middle_,\n            1. Let _upper_ be _len_ - _lower_ - 1.\n            1. Let _upperP_ be ! ToString(𝔽(_upper_)).\n            1. Let _lowerP_ be ! ToString(𝔽(_lower_)).\n            1. Let _lowerValue_ be ! Get(_O_, _lowerP_).\n            1. Let _upperValue_ be ! Get(_O_, _upperP_).\n            1. Perform ! Set(_O_, _lowerP_, _upperValue_, *true*).\n            1. Perform ! Set(_O_, _upperP_, _lowerValue_, *true*).\n            1. Set _lower_ to _lower_ + 1.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.reverse",
        "name" : "INTRINSICS.TypedArray.prototype.reverse",
        "htmlId" : "sec-%typedarray%.prototype.reverse",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    804,
    [
      "PrimaryExpression[11,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[11]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[11,0].IsIdentifierRef",
        "name" : "PrimaryExpression[11,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 11,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    181,
    [
      "SpeciesConstructor",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "defaultConstructor",
          false,
          "Record[Constructor]"
        ]
      ],
      "\n        1. Let _C_ be ? Get(_O_, *\"constructor\"*).\n        1. If _C_ is *undefined*, return _defaultConstructor_.\n        1. If _C_ is not an Object, throw a *TypeError* exception.\n        1. Let _S_ be ? Get(_C_, @@species).\n        1. If _S_ is either *undefined* or *null*, return _defaultConstructor_.\n        1. If IsConstructor(_S_) is *true*, return _S_.\n        1. Throw a *TypeError* exception.\n      ",
      {
        "normalizedName" : "SpeciesConstructor",
        "name" : "SpeciesConstructor",
        "htmlId" : "sec-speciesconstructor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2425,
    [
      "ClassSetCharacter[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSetCharacter[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _cv_ be the CharacterValue of this |ClassSetCharacter|.\n          1. Let _c_ be the character whose character value is _cv_.\n          1. Return the CharSet containing the single character _c_.\n        ",
      {
        "normalizedName" : "ClassSetCharacter[0,0].CompileToCharSet",
        "name" : "ClassSetCharacter[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassSetCharacter",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SourceCharacter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1258,
    [
      "ArrayLiteral[0,1].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayLiteral[0]]"
        ]
      ],
      "\n          1. Let _array_ be ! ArrayCreate(0).\n          1. If |Elision| is present, then\n            1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and 0.\n          1. Return _array_.\n        ",
      {
        "normalizedName" : "ArrayLiteral[0,1].Evaluation",
        "name" : "ArrayLiteral[0,1].Evaluation",
        "htmlId" : "sec-array-initializer-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ArrayLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    704,
    [
      "PrimaryExpression[12,0].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[12]]"
        ]
      ],
      "\n        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. If IsFunctionDefinition of _expr_ is *false*, return *false*.\n        1. Return HasName of _expr_.\n      ",
      {
        "normalizedName" : "PrimaryExpression[12,0].HasName",
        "name" : "PrimaryExpression[12,0].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 12,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1464,
    [
      "ForStatement[0,3].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        ",
      {
        "normalizedName" : "ForStatement[0,3].ForLoopEvaluation",
        "name" : "ForStatement[0,3].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2474,
    [
      "CreateRegExpStringIterator:clo0",
      6,
      [
      ],
      "\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _R_, _S_, _global_, and _fullUnicode_ and performs the following steps when called:\n            1. Repeat,\n              1. Let _match_ be ? RegExpExec(_R_, _S_).\n              1. If _match_ is *null*, return *undefined*.\n              1. If _global_ is *false*, then\n                1. Perform ? GeneratorYield(CreateIterResultObject(_match_, *false*)).\n                1. Return *undefined*.\n              1. Let _matchStr_ be ? ToString(? Get(_match_, *\"0\"*)).\n              1. If _matchStr_ is the empty String, then\n                1. Let _thisIndex_ be ℝ(? ToLength(? Get(_R_, *\"lastIndex\"*))).\n                1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).\n                1. Perform ? Set(_R_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).\n              1. Perform ? GeneratorYield(CreateIterResultObject(_match_, *false*)).\n          1. Return CreateIteratorFromClosure(_closure_, *\"%RegExpStringIteratorPrototype%\"*, %RegExpStringIteratorPrototype%).\n        ",
      {
        "normalizedName" : "CreateRegExpStringIterator",
        "name" : "CreateRegExpStringIterator",
        "htmlId" : "sec-createregexpstringiterator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    947,
    [
      "UpdateExpression[4,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[4]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "UpdateExpression[4,0].AssignmentTargetType",
        "name" : "UpdateExpression[4,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "--"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1638,
    [
      "MethodDefinition[5,0].SpecialMethod",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[5]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "MethodDefinition[5,0].SpecialMethod",
        "name" : "MethodDefinition[5,0].SpecialMethod",
        "htmlId" : "sec-static-semantics-specialmethod",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "SpecialMethod",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "set"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "PropertySetParameterList"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1224,
    [
      "DecimalBigIntegerLiteral[2,0].NumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[DecimalBigIntegerLiteral[2]]"
        ]
      ],
      "\n          1. Let _n_ be the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.\n          1. Let _mv_ be (the MV of |NonZeroDigit| × 10<sup>_n_</sup>) plus the MV of |DecimalDigits|.\n          1. Return ℤ(_mv_).\n        ",
      {
        "normalizedName" : "DecimalBigIntegerLiteral[2,0].NumericValue",
        "name" : "DecimalBigIntegerLiteral[2,0].NumericValue",
        "htmlId" : "sec-numericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NumericValue",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "DecimalBigIntegerLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NonZeroDigit"
              },
              {
                "type" : "nonterminal",
                "value" : "NumericLiteralSeparator"
              },
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "nonterminal",
                "value" : "BigIntLiteralSuffix"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2358,
    [
      "Assertion[3,0].CompileAssertion",
      2,
      [
        [
          "this",
          false,
          "Ast[Assertion[3]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _e_ be _x_.[[EndIndex]].\n            1. Let _a_ be IsWordChar(_rer_, _Input_, _e_ - 1).\n            1. Let _b_ be IsWordChar(_rer_, _Input_, _e_).\n            1. If _a_ is *true* and _b_ is *true*, or if _a_ is *false* and _b_ is *false*, return _c_(_x_).\n            1. Return ~failure~.\n        ",
      {
        "normalizedName" : "Assertion[3,0].CompileAssertion",
        "name" : "Assertion[3,0].CompileAssertion",
        "htmlId" : "sec-compileassertion",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAssertion",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "Assertion",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "\\B"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2319,
    [
      "UnicodePropertyValueExpression[1,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[UnicodePropertyValueExpression[1]]"
        ]
      ],
      "\n          1. If the source text matched by |LoneUnicodePropertyNameOrValue| is a binary property of strings listed in the “Property name” column of <emu-xref href=\"#table-binary-unicode-properties-of-strings\"></emu-xref>, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "UnicodePropertyValueExpression[1,0].MayContainStrings",
        "name" : "UnicodePropertyValueExpression[1,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "UnicodePropertyValueExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LoneUnicodePropertyNameOrValue"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1356,
    [
      "UnaryExpression[6,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[6]]"
        ]
      ],
      "\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).\n          1. If _oldValue_ is a Number, then\n            1. Return Number::bitwiseNOT(_oldValue_).\n          1. Else,\n            1. Assert: _oldValue_ is a BigInt.\n            1. Return BigInt::bitwiseNOT(_oldValue_).\n        ",
      {
        "normalizedName" : "UnaryExpression[6,0].Evaluation",
        "name" : "UnaryExpression[6,0].Evaluation",
        "htmlId" : "sec-bitwise-not-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "~"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2573,
    [
      "TypedArrayCreateFromConstructor",
      0,
      [
        [
          "constructor",
          false,
          "Record[Constructor]"
        ],
        [
          "argumentList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Let _newTypedArray_ be ? Construct(_constructor_, _argumentList_).\n          1. Let _taRecord_ be ? ValidateTypedArray(_newTypedArray_, ~seq-cst~).\n          1. If the number of elements in _argumentList_ is 1 and _argumentList_[0] is a Number, then\n            1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n            1. Let _length_ be TypedArrayLength(_taRecord_).\n            1. If _length_ < ℝ(_argumentList_[0]), throw a *TypeError* exception.\n          1. Return _newTypedArray_.\n        ",
      {
        "normalizedName" : "TypedArrayCreateFromConstructor",
        "name" : "TypedArrayCreateFromConstructor",
        "htmlId" : "sec-typedarraycreatefromconstructor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2148,
    [
      "INTRINSICS.Math.max",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _coerced_ be a new empty List.\n          1. For each element _arg_ of _args_, do\n            1. Let _n_ be ? ToNumber(_arg_).\n            1. Append _n_ to _coerced_.\n          1. Let _highest_ be *-∞*<sub>𝔽</sub>.\n          1. For each element _number_ of _coerced_, do\n            1. If _number_ is *NaN*, return *NaN*.\n            1. If _number_ is *+0*<sub>𝔽</sub> and _highest_ is *-0*<sub>𝔽</sub>, set _highest_ to *+0*<sub>𝔽</sub>.\n            1. If _number_ > _highest_, set _highest_ to _number_.\n          1. Return _highest_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.max",
        "name" : "INTRINSICS.Math.max",
        "htmlId" : "sec-math.max",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1675,
    [
      "ClassElement[4,0].IsStatic",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[4]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "ClassElement[4,0].IsStatic",
        "name" : "ClassElement[4,0].IsStatic",
        "htmlId" : "sec-static-semantics-isstatic",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsStatic",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassStaticBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    540,
    [
      "ForStatement[2,2].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[2,2].ContainsDuplicateLabels",
        "name" : "ForStatement[2,2].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    86,
    [
      "BigInt::bitwiseXOR",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. Return BigIntBitwiseOp(`^`, _x_, _y_).\n          ",
      {
        "normalizedName" : "BigInt::bitwiseXOR",
        "name" : "BigInt::bitwiseXOR",
        "htmlId" : "sec-numeric-types-bigint-bitwiseXOR",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    159,
    [
      "IsStrictlyEqual",
      0,
      [
        [
          "x",
          false,
          "ESValue"
        ],
        [
          "y",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If Type(_x_) is not Type(_y_), return *false*.\n        1. If _x_ is a Number, then\n          1. Return Number::equal(_x_, _y_).\n        1. Return SameValueNonNumber(_x_, _y_).\n      ",
      {
        "normalizedName" : "IsStrictlyEqual",
        "name" : "IsStrictlyEqual",
        "htmlId" : "sec-isstrictlyequal",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    672,
    [
      "ForInOfStatement[2,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[2]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForInOfStatement[2,0].ContainsUndefinedContinueTarget",
        "name" : "ForInOfStatement[2,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2510,
    [
      "INTRINSICS.Array.prototype.shift",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If _len_ = 0, then\n            1. Perform ? Set(_O_, *\"length\"*, *+0*<sub>𝔽</sub>, *true*).\n            1. Return *undefined*.\n          1. Let _first_ be ? Get(_O_, *\"0\"*).\n          1. Let _k_ be 1.\n          1. Repeat, while _k_ < _len_,\n            1. Let _from_ be ! ToString(𝔽(_k_)).\n            1. Let _to_ be ! ToString(𝔽(_k_ - 1)).\n            1. Let _fromPresent_ be ? HasProperty(_O_, _from_).\n            1. If _fromPresent_ is *true*, then\n              1. Let _fromVal_ be ? Get(_O_, _from_).\n              1. Perform ? Set(_O_, _to_, _fromVal_, *true*).\n            1. Else,\n              1. Assert: _fromPresent_ is *false*.\n              1. Perform ? DeletePropertyOrThrow(_O_, _to_).\n            1. Set _k_ to _k_ + 1.\n          1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_len_ - 1))).\n          1. Perform ? Set(_O_, *\"length\"*, 𝔽(_len_ - 1), *true*).\n          1. Return _first_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.shift",
        "name" : "INTRINSICS.Array.prototype.shift",
        "htmlId" : "sec-array.prototype.shift",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    764,
    [
      "EqualityExpression[3,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[3]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "EqualityExpression[3,0].IsFunctionDefinition",
        "name" : "EqualityExpression[3,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "==="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    979,
    [
      "CoalesceExpression[0,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[CoalesceExpression[0]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "CoalesceExpression[0,0].AssignmentTargetType",
        "name" : "CoalesceExpression[0,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CoalesceExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoalesceExpressionHead"
              },
              {
                "type" : "terminal",
                "value" : "??"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseORExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    604,
    [
      "ForInOfStatement[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[0,0].ContainsUndefinedBreakTarget",
        "name" : "ForInOfStatement[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1194,
    [
      "Record[ProxyExoticObject].PreventExtensions",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"preventExtensions\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[PreventExtensions]]()</emu-meta>.\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_ »)).\n        1. If _booleanTrapResult_ is *true*, then\n          1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n          1. If _extensibleTarget_ is *true*, throw a *TypeError* exception.\n        1. Return _booleanTrapResult_.\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].PreventExtensions",
        "name" : "Record[ProxyExoticObject].PreventExtensions",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-preventextensions",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[PreventExtensions]]"
        ]
      }
    ]
  ],
  [
    2346,
    [
      "Alternative[0,0].CompileSubpattern",
      2,
      [
        [
          "this",
          false,
          "Ast[Alternative[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Return EmptyMatcher().\n        ",
      {
        "normalizedName" : "Alternative[0,0].CompileSubpattern",
        "name" : "Alternative[0,0].CompileSubpattern",
        "htmlId" : "sec-compilesubpattern",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileSubpattern",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Alternative",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2079,
    [
      "INTRINSICS.Object.prototype.__defineSetter__",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _O_ be ? ToObject(*this* value).\n            1. If IsCallable(_setter_) is *false*, throw a *TypeError* exception.\n            1. Let _desc_ be PropertyDescriptor { [[Set]]: _setter_, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n            1. Let _key_ be ? ToPropertyKey(_P_).\n            1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).\n            1. Return *undefined*.\n          ",
      {
        "normalizedName" : "INTRINSICS.Object.prototype.__defineSetter__",
        "name" : "INTRINSICS.Object.prototype.__defineSetter__",
        "htmlId" : "sec-object.prototype.__defineSetter__",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2361,
    [
      "Assertion[6,0].CompileAssertion",
      2,
      [
        [
          "this",
          false,
          "Ast[Assertion[6]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~backward~.\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Return _y_.\n            1. Let _r_ be _m_(_x_, _d_).\n            1. If _r_ is ~failure~, return ~failure~.\n            1. Assert: _r_ is a MatchState.\n            1. Let _cap_ be _r_.[[Captures]].\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _xe_ be _x_.[[EndIndex]].\n            1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }.\n            1. Return _c_(_z_).\n        ",
      {
        "normalizedName" : "Assertion[6,0].CompileAssertion",
        "name" : "Assertion[6,0].CompileAssertion",
        "htmlId" : "sec-compileassertion",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAssertion",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "Assertion",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "(?<="
              },
              {
                "type" : "nonterminal",
                "value" : "Disjunction"
              },
              {
                "type" : "terminal",
                "value" : ")"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2311,
    [
      "CharacterClassEscape[4,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[4]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "CharacterClassEscape[4,0].MayContainStrings",
        "name" : "CharacterClassEscape[4,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "w"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2521,
    [
      "INTRINSICS.Array.prototype.toSorted",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _A_ be ? ArrayCreate(_len_).\n          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n            1. Return ? CompareArrayElements(_x_, _y_, _comparefn_).\n          1. Let _sortedList_ be ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).\n          1. Let _j_ be 0.\n          1. Repeat, while _j_ < _len_,\n            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_]).\n            1. Set _j_ to _j_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.toSorted",
        "name" : "INTRINSICS.Array.prototype.toSorted",
        "htmlId" : "sec-array.prototype.tosorted",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    187,
    [
      "PrivateMethodOrAccessorAdd",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "method",
          false,
          "Record[PrivateElement]"
        ]
      ],
      "\n        1. Assert: _method_.[[Kind]] is either ~method~ or ~accessor~.\n        1. If the host is a web browser, then\n          1. Perform ? HostEnsureCanAddPrivateElement(_O_).\n        1. Let _entry_ be PrivateElementFind(_O_, _method_.[[Key]]).\n        1. If _entry_ is not ~empty~, throw a *TypeError* exception.\n        1. Append _method_ to _O_.[[PrivateElements]].\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "PrivateMethodOrAccessorAdd",
        "name" : "PrivateMethodOrAccessorAdd",
        "htmlId" : "sec-privatemethodoraccessoradd",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1209,
    [
      "CodePointAt",
      0,
      [
        [
          "string",
          false,
          "String"
        ],
        [
          "position",
          false,
          "Int[0+]"
        ]
      ],
      "\n        1. Let _size_ be the length of _string_.\n        1. Assert: _position_ ≥ 0 and _position_ < _size_.\n        1. Let _first_ be the code unit at index _position_ within _string_.\n        1. Let _cp_ be the code point whose numeric value is the numeric value of _first_.\n        1. If _first_ is neither a leading surrogate nor a trailing surrogate, then\n          1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *false* }.\n        1. If _first_ is a trailing surrogate or _position_ + 1 = _size_, then\n          1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }.\n        1. Let _second_ be the code unit at index _position_ + 1 within _string_.\n        1. If _second_ is not a trailing surrogate, then\n          1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }.\n        1. Set _cp_ to UTF16SurrogatePairToCodePoint(_first_, _second_).\n        1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 2, [[IsUnpairedSurrogate]]: *false* }.\n      ",
      {
        "normalizedName" : "CodePointAt",
        "name" : "CodePointAt",
        "htmlId" : "sec-codepointat",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2721,
    [
      "INTRINSICS.Atomics.sub",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _type_ be TypedArrayElementType(_typedArray_).\n        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n        1. Let _subtract_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _type_ and _isLittleEndian_ and performs the following steps atomically when called:\n          1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).\n          1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).\n          1. If _x_ is a Number, then\n            1. Let _difference_ be Number::subtract(_x_, _y_).\n          1. Else,\n            1. Assert: _x_ is a BigInt.\n            1. Let _difference_ be BigInt::subtract(_x_, _y_).\n          1. Let _differenceBytes_ be NumericToRawBytes(_type_, _difference_, _isLittleEndian_).\n          1. Assert: _differenceBytes_, _xBytes_, and _yBytes_ have the same number of elements.\n          1. Return _differenceBytes_.\n        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _subtract_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.sub",
        "name" : "INTRINSICS.Atomics.sub",
        "htmlId" : "sec-atomics.sub",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2119,
    [
      "NumberToBigInt",
      0,
      [
        [
          "number",
          false,
          "Number"
        ]
      ],
      "\n            1. If IsIntegralNumber(_number_) is *false*, throw a *RangeError* exception.\n            1. Return ℤ(ℝ(_number_)).\n          ",
      {
        "normalizedName" : "NumberToBigInt",
        "name" : "NumberToBigInt",
        "htmlId" : "sec-numbertobigint",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    900,
    [
      "SingleNameBinding[0,1].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[SingleNameBinding[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n        1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).\n        1. Let _v_ be *undefined*.\n        1. If _iteratorRecord_.[[Done]] is *false*, then\n          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is not ~done~, then\n            1. Set _v_ to _next_.\n        1. If |Initializer| is present and _v_ is *undefined*, then\n          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n            1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.\n          1. Else,\n            1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n            1. Set _v_ to ? GetValue(_defaultValue_).\n        1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).\n        1. Return ? InitializeReferencedBinding(_lhs_, _v_).\n      ",
      {
        "normalizedName" : "SingleNameBinding[0,1].IteratorBindingInitialization",
        "name" : "SingleNameBinding[0,1].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "SingleNameBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    406,
    [
      "LabelledItem[1,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[1]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "LabelledItem[1,0].VarDeclaredNames",
        "name" : "LabelledItem[1,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2679,
    [
      "INTRINSICS.DataView.prototype.getUint8",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. Return ? GetViewValue(_v_, _byteOffset_, *true*, ~uint8~).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.getUint8",
        "name" : "INTRINSICS.DataView.prototype.getUint8",
        "htmlId" : "sec-dataview.prototype.getuint8",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    172,
    [
      "Call",
      0,
      [
        [
          "F",
          false,
          "ESValue"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "argumentsList",
          true,
          "List[ESValue]"
        ]
      ],
      "\n        1. If _argumentsList_ is not present, set _argumentsList_ to a new empty List.\n        1. If IsCallable(_F_) is *false*, throw a *TypeError* exception.\n        1. Return ? <emu-meta effects=\"user-code\">_F_.[[Call]]</emu-meta>(_V_, _argumentsList_).\n      ",
      {
        "normalizedName" : "Call",
        "name" : "Call",
        "htmlId" : "sec-call",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    831,
    [
      "GeneratorDeclaration[0,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorDeclaration[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "GeneratorDeclaration[0,0].Contains",
        "name" : "GeneratorDeclaration[0,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    113,
    [
      "StringNumericLiteral[0,0].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StringNumericLiteral[0]]"
        ]
      ],
      "\n            1. Return *+0*<sub>𝔽</sub>.\n          ",
      {
        "normalizedName" : "StringNumericLiteral[0,0].StringNumericValue",
        "name" : "StringNumericLiteral[0,0].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "StringNumericLiteral",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    681,
    [
      "WithStatement[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[WithStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "WithStatement[0,0].ContainsUndefinedContinueTarget",
        "name" : "WithStatement[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WithStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "with"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2538,
    [
      "INTRINSICS.TypedArray.prototype.copyWithin",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).\n          1. If _relativeTarget_ = -∞, let _targetIndex_ be 0.\n          1. Else if _relativeTarget_ < 0, let _targetIndex_ be max(_len_ + _relativeTarget_, 0).\n          1. Else, let _targetIndex_ be min(_relativeTarget_, _len_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _startIndex_ be 0.\n          1. Else if _relativeStart_ < 0, let _startIndex_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _startIndex_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _endIndex_ be 0.\n          1. Else if _relativeEnd_ < 0, let _endIndex_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _endIndex_ be min(_relativeEnd_, _len_).\n          1. Let _count_ be min(_endIndex_ - _startIndex_, _len_ - _targetIndex_).\n          1. If _count_ > 0, then\n            1. NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source data.\n            1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].\n            1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n            1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n            1. Set _len_ to TypedArrayLength(_taRecord_).\n            1. Let _elementSize_ be TypedArrayElementSize(_O_).\n            1. Let _byteOffset_ be _O_.[[ByteOffset]].\n            1. Let _bufferByteLimit_ be (_len_ × _elementSize_) + _byteOffset_.\n            1. Let _toByteIndex_ be (_targetIndex_ × _elementSize_) + _byteOffset_.\n            1. Let _fromByteIndex_ be (_startIndex_ × _elementSize_) + _byteOffset_.\n            1. Let _countBytes_ be _count_ × _elementSize_.\n            1. If _fromByteIndex_ < _toByteIndex_ and _toByteIndex_ < _fromByteIndex_ + _countBytes_, then\n              1. Let _direction_ be -1.\n              1. Set _fromByteIndex_ to _fromByteIndex_ + _countBytes_ - 1.\n              1. Set _toByteIndex_ to _toByteIndex_ + _countBytes_ - 1.\n            1. Else,\n              1. Let _direction_ be 1.\n            1. Repeat, while _countBytes_ > 0,\n              1. If _fromByteIndex_ < _bufferByteLimit_ and _toByteIndex_ < _bufferByteLimit_, then\n                1. Let _value_ be GetValueFromBuffer(_buffer_, _fromByteIndex_, ~uint8~, *true*, ~unordered~).\n                1. Perform SetValueInBuffer(_buffer_, _toByteIndex_, ~uint8~, _value_, *true*, ~unordered~).\n                1. Set _fromByteIndex_ to _fromByteIndex_ + _direction_.\n                1. Set _toByteIndex_ to _toByteIndex_ + _direction_.\n                1. Set _countBytes_ to _countBytes_ - 1.\n              1. Else,\n                1. Set _countBytes_ to 0.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.copyWithin",
        "name" : "INTRINSICS.TypedArray.prototype.copyWithin",
        "htmlId" : "sec-%typedarray%.prototype.copywithin",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1853,
    [
      "UpdateExpression[3,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[3]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UpdateExpression[3,0].HasCallInTailPosition",
        "name" : "UpdateExpression[3,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "++"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1408,
    [
      "AssignmentProperty[1,0].PropertyDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentProperty[1]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _name_ be ? Evaluation of |PropertyName|.\n          1. Perform ? KeyedDestructuringAssignmentEvaluation of |AssignmentElement| with arguments _value_ and _name_.\n          1. Return « _name_ ».\n        ",
      {
        "normalizedName" : "AssignmentProperty[1,0].PropertyDestructuringAssignmentEvaluation",
        "name" : "AssignmentProperty[1,0].PropertyDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-propertydestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AssignmentProperty",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PropertyName"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1282,
    [
      "TemplateSpans[0,0].TemplateStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateSpans[0]]"
        ],
        [
          "raw",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Return « TemplateString(|TemplateTail|, _raw_) ».\n        ",
      {
        "normalizedName" : "TemplateSpans[0,0].TemplateStrings",
        "name" : "TemplateSpans[0,0].TemplateStrings",
        "htmlId" : "sec-static-semantics-templatestrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TemplateStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TemplateSpans",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2478,
    [
      "INTRINSICS.Array.from",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the *this* value.\n          1. If _mapfn_ is *undefined*, then\n            1. Let _mapping_ be *false*.\n          1. Else,\n            1. If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.\n            1. Let _mapping_ be *true*.\n          1. Let _usingIterator_ be ? GetMethod(_items_, @@iterator).\n          1. If _usingIterator_ is not *undefined*, then\n            1. If IsConstructor(_C_) is *true*, then\n              1. Let _A_ be ? Construct(_C_).\n            1. Else,\n              1. Let _A_ be ! ArrayCreate(0).\n            1. Let _iteratorRecord_ be ? GetIteratorFromMethod(_items_, _usingIterator_).\n            1. Let _k_ be 0.\n            1. Repeat,\n              1. If _k_ ≥ 2<sup>53</sup> - 1, then\n                1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).\n                1. Return ? IteratorClose(_iteratorRecord_, _error_).\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n              1. If _next_ is ~done~, then\n                1. Perform ? Set(_A_, *\"length\"*, 𝔽(_k_), *true*).\n                1. Return _A_.\n              1. If _mapping_ is *true*, then\n                1. Let _mappedValue_ be Completion(Call(_mapfn_, _thisArg_, « _next_, 𝔽(_k_) »)).\n                1. IfAbruptCloseIterator(_mappedValue_, _iteratorRecord_).\n              1. Else,\n                1. Let _mappedValue_ be _next_.\n              1. Let _defineStatus_ be Completion(CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_)).\n              1. IfAbruptCloseIterator(_defineStatus_, _iteratorRecord_).\n              1. Set _k_ to _k_ + 1.\n          1. NOTE: _items_ is not an Iterable so assume it is an array-like object.\n          1. Let _arrayLike_ be ! ToObject(_items_).\n          1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).\n          1. If IsConstructor(_C_) is *true*, then\n            1. Let _A_ be ? Construct(_C_, « 𝔽(_len_) »).\n          1. Else,\n            1. Let _A_ be ? ArrayCreate(_len_).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).\n            1. If _mapping_ is *true*, then\n              1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, « _kValue_, 𝔽(_k_) »).\n            1. Else,\n              1. Let _mappedValue_ be _kValue_.\n            1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).\n            1. Set _k_ to _k_ + 1.\n          1. Perform ? Set(_A_, *\"length\"*, 𝔽(_len_), *true*).\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.from",
        "name" : "INTRINSICS.Array.from",
        "htmlId" : "sec-array.from",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    219,
    [
      "ObjectBindingPattern[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectBindingPattern[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ObjectBindingPattern[0,0].BoundNames",
        "name" : "ObjectBindingPattern[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ObjectBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2151,
    [
      "INTRINSICS.Math.round",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is an integral Number, return _n_.\n          1. If _n_ < *0.5*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ < *-0*<sub>𝔽</sub> and _n_ ≥ *-0.5*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n          1. Return the integral Number closest to _n_, preferring the Number closer to +∞ in the case of a tie.\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.round",
        "name" : "INTRINSICS.Math.round",
        "htmlId" : "sec-math.round",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2642,
    [
      "GetModifySetValueInBuffer",
      0,
      [
        [
          "arrayBuffer",
          false,
          "Record[ArrayBuffer | SharedArrayBuffer]"
        ],
        [
          "byteIndex",
          false,
          "Int[0+]"
        ],
        [
          "type",
          false,
          "Unknown[\"TypedArrayElementType\"]"
        ],
        [
          "value",
          false,
          "Number | BigInt"
        ],
        [
          "op",
          false,
          "Unknown[\"ReadmodifywriteModificationFunction\"]"
        ]
      ],
      "\n          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.\n          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.\n          1. Assert: _value_ is a BigInt if IsBigIntElementType(_type_) is *true*; otherwise, _value_ is a Number.\n          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n          1. Let _rawBytes_ be NumericToRawBytes(_type_, _value_, _isLittleEndian_).\n          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then\n            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n            1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n            1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.\n            1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.\n            1. Let _rmwEvent_ be ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_, [[ModifyOp]]: _op_ }.\n            1. Append _rmwEvent_ to _eventsRecord_.[[EventList]].\n            1. Append Chosen Value Record { [[Event]]: _rmwEvent_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].\n          1. Else,\n            1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndex_].\n            1. Let _rawBytesModified_ be _op_(_rawBytesRead_, _rawBytes_).\n            1. Store the individual bytes of _rawBytesModified_ into _block_, starting at _block_[_byteIndex_].\n          1. Return RawBytesToNumeric(_type_, _rawBytesRead_, _isLittleEndian_).\n        ",
      {
        "normalizedName" : "GetModifySetValueInBuffer",
        "name" : "GetModifySetValueInBuffer",
        "htmlId" : "sec-getmodifysetvalueinbuffer",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2229,
    [
      "TimeZoneString",
      0,
      [
        [
          "tv",
          false,
          "NumberInt"
        ]
      ],
      "\n            1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().\n            1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then\n              1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).\n            1. Else,\n              1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_tv_) × 10<sup>6</sup>)).\n            1. Let _offset_ be 𝔽(truncate(_offsetNs_ / 10<sup>6</sup>)).\n            1. If _offset_ is *+0*<sub>𝔽</sub> or _offset_ > *+0*<sub>𝔽</sub>, then\n              1. Let _offsetSign_ be *\"+\"*.\n              1. Let _absOffset_ be _offset_.\n            1. Else,\n              1. Let _offsetSign_ be *\"-\"*.\n              1. Let _absOffset_ be -_offset_.\n            1. Let _offsetMin_ be ToZeroPaddedDecimalString(ℝ(MinFromTime(_absOffset_)), 2).\n            1. Let _offsetHour_ be ToZeroPaddedDecimalString(ℝ(HourFromTime(_absOffset_)), 2).\n            1. Let _tzName_ be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).\n            1. Return the string-concatenation of _offsetSign_, _offsetHour_, _offsetMin_, and _tzName_.\n          ",
      {
        "normalizedName" : "TimeZoneString",
        "name" : "TimeZoneString",
        "htmlId" : "sec-timezoneestring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2084,
    [
      "INTRINSICS.Function.prototype.apply",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _func_ be the *this* value.\n          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.\n          1. If _argArray_ is either *undefined* or *null*, then\n            1. Perform PrepareForTailCall().\n            1. Return ? Call(_func_, _thisArg_).\n          1. Let _argList_ be ? CreateListFromArrayLike(_argArray_).\n          1. Perform PrepareForTailCall().\n          1. [id=\"step-function-proto-apply-call\"] Return ? Call(_func_, _thisArg_, _argList_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Function.prototype.apply",
        "name" : "INTRINSICS.Function.prototype.apply",
        "htmlId" : "sec-function.prototype.apply",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    274,
    [
      "LexicalDeclaration[0,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[LexicalDeclaration[0]]"
        ]
      ],
      "\n        1. Return IsConstantDeclaration of |LetOrConst|.\n      ",
      {
        "normalizedName" : "LexicalDeclaration[0,0].IsConstantDeclaration",
        "name" : "LexicalDeclaration[0,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LexicalDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LetOrConst"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2214,
    [
      "INTRINSICS.Date.prototype.setSeconds",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _s_ be ? ToNumber(_sec_).\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Set _t_ to LocalTime(_t_).\n          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).\n          1. Let _u_ be TimeClip(UTC(_date_)).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setSeconds",
        "name" : "INTRINSICS.Date.prototype.setSeconds",
        "htmlId" : "sec-date.prototype.setseconds",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2383,
    [
      "BackreferenceMatcher",
      0,
      [
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "n",
          false,
          "Int[+]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n            1. Assert: _n_ ≥ 1.\n            1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_, _n_, and _direction_ and performs the following steps when called:\n              1. Assert: _x_ is a MatchState.\n              1. Assert: _c_ is a MatcherContinuation.\n              1. Let _Input_ be _x_.[[Input]].\n              1. Let _cap_ be _x_.[[Captures]].\n              1. Let _r_ be _cap_[_n_].\n              1. If _r_ is *undefined*, return _c_(_x_).\n              1. Let _e_ be _x_.[[EndIndex]].\n              1. Let _rs_ be _r_.[[StartIndex]].\n              1. Let _re_ be _r_.[[EndIndex]].\n              1. Let _len_ be _re_ - _rs_.\n              1. If _direction_ is ~forward~, let _f_ be _e_ + _len_.\n              1. Else, let _f_ be _e_ - _len_.\n              1. Let _InputLength_ be the number of elements in _Input_.\n              1. If _f_ < 0 or _f_ > _InputLength_, return ~failure~.\n              1. Let _g_ be min(_e_, _f_).\n              1. If there exists an integer _i_ in the interval from 0 (inclusive) to _len_ (exclusive) such that Canonicalize(_rer_, _Input_[_rs_ + _i_]) is not Canonicalize(_rer_, _Input_[_g_ + _i_]), return ~failure~.\n              1. Let _y_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }.\n              1. Return _c_(_y_).\n          ",
      {
        "normalizedName" : "BackreferenceMatcher",
        "name" : "BackreferenceMatcher",
        "htmlId" : "sec-backreference-matcher",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2624,
    [
      "INTRINSICS.WeakSet.prototype.has",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).\n          1. If CanBeHeldWeakly(_value_) is *false*, return *false*.\n          1. For each element _e_ of _S_.[[WeakSetData]], do\n            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.WeakSet.prototype.has",
        "name" : "INTRINSICS.WeakSet.prototype.has",
        "htmlId" : "sec-weakset.prototype.has",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2415,
    [
      "ClassSetRange[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSetRange[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of the first |ClassSetCharacter| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of the second |ClassSetCharacter| with argument _rer_.\n          1. Return MaybeSimpleCaseFolding(_rer_, CharacterRange(_A_, _B_)).\n        ",
      {
        "normalizedName" : "ClassSetRange[0,0].CompileToCharSet",
        "name" : "ClassSetRange[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassSetRange",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetCharacter"
              },
              {
                "type" : "terminal",
                "value" : "-"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassSetCharacter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1894,
    [
      "CallExpression[3,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[3]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. If this |CallExpression| is _call_, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CallExpression[3,0].HasCallInTailPosition",
        "name" : "CallExpression[3,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2493,
    [
      "INTRINSICS.Array.prototype.findLastIndex",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Index]].\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.findLastIndex",
        "name" : "INTRINSICS.Array.prototype.findLastIndex",
        "htmlId" : "sec-array.prototype.findlastindex",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    784,
    [
      "GeneratorExpression[0,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,0].IsFunctionDefinition",
        "name" : "GeneratorExpression[0,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2637,
    [
      "RawBytesToNumeric",
      0,
      [
        [
          "type",
          false,
          "Unknown[\"TypedArrayElementType\"]"
        ],
        [
          "rawBytes",
          false,
          "Unknown[\"ListOfByteValue\"]"
        ],
        [
          "isLittleEndian",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.\n          1. If _type_ is ~float32~, then\n            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary32 value.\n            1. If _value_ is an IEEE 754-2019 binary32 NaN value, return the *NaN* Number value.\n            1. Return the Number value that corresponds to _value_.\n          1. If _type_ is ~float64~, then\n            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary64 value.\n            1. If _value_ is an IEEE 754-2019 binary64 NaN value, return the *NaN* Number value.\n            1. Return the Number value that corresponds to _value_.\n          1. If IsUnsignedElementType(_type_) is *true*, then\n            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.\n          1. Else,\n            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of a binary little-endian two's complement number of bit length _elementSize_ × 8.\n          1. If IsBigIntElementType(_type_) is *true*, return the BigInt value that corresponds to _intValue_.\n          1. Otherwise, return the Number value that corresponds to _intValue_.\n        ",
      {
        "normalizedName" : "RawBytesToNumeric",
        "name" : "RawBytesToNumeric",
        "htmlId" : "sec-rawbytestonumeric",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2422,
    [
      "ClassStringDisjunction[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStringDisjunction[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return CompileToCharSet of |ClassStringDisjunctionContents| with argument _rer_.\n        ",
      {
        "normalizedName" : "ClassStringDisjunction[0,0].CompileToCharSet",
        "name" : "ClassStringDisjunction[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStringDisjunction",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "\\q{"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassStringDisjunctionContents"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1117,
    [
      "AsyncGeneratorBody[0,0].EvaluateBody",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Return ? EvaluateAsyncGeneratorBody of |AsyncGeneratorBody| with arguments _functionObject_ and _argumentsList_.\n        ",
      {
        "normalizedName" : "AsyncGeneratorBody[0,0].EvaluateBody",
        "name" : "AsyncGeneratorBody[0,0].EvaluateBody",
        "htmlId" : "sec-runtime-semantics-evaluatebody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1574,
    [
      "SingleNameBinding[0,1].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[SingleNameBinding[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "SingleNameBinding[0,1].ContainsExpression",
        "name" : "SingleNameBinding[0,1].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "SingleNameBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1806,
    [
      "LabelledStatement[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |LabelledItem| with argument _call_.\n      ",
      {
        "normalizedName" : "LabelledStatement[0,0].HasCallInTailPosition",
        "name" : "LabelledStatement[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelledItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1011,
    [
      "Record[DeclarativeEnvironmentRecord].InitializeBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "V",
          false,
          "ESValue"
        ]
      ],
      "\n            1. Assert: _envRec_ must have an uninitialized binding for _N_.\n            1. Set the bound value for _N_ in _envRec_ to _V_.\n            1. <emu-not-ref>Record</emu-not-ref> that the binding for _N_ in _envRec_ has been initialized.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[DeclarativeEnvironmentRecord].InitializeBinding",
        "name" : "Record[DeclarativeEnvironmentRecord].InitializeBinding",
        "htmlId" : "sec-declarative-environment-records-initializebinding-n-v",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "DeclarativeEnvironmentRecord",
          "InitializeBinding"
        ]
      }
    ]
  ],
  [
    419,
    [
      "ModuleItemList[1,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be VarDeclaredNames of |ModuleItemList|.\n        1. Let _names2_ be VarDeclaredNames of |ModuleItem|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ModuleItemList[1,0].VarDeclaredNames",
        "name" : "ModuleItemList[1,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2774,
    [
      "PerformPromiseRace",
      0,
      [
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "constructor",
          false,
          "Record[Constructor]"
        ],
        [
          "resultCapability",
          false,
          "Record[PromiseCapabilityRecord]"
        ],
        [
          "promiseResolve",
          false,
          "Record[FunctionObject]"
        ]
      ],
      "\n            1. Repeat,\n              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n              1. If _next_ is ~done~, then\n                1. Return _resultCapability_.[[Promise]].\n              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).\n              1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _resultCapability_.[[Resolve]], _resultCapability_.[[Reject]] »).\n          ",
      {
        "normalizedName" : "PerformPromiseRace",
        "name" : "PerformPromiseRace",
        "htmlId" : "sec-performpromiserace",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    81,
    [
      "BinaryAnd",
      0,
      [
        [
          "x",
          false,
          "Int[0, 1]"
        ],
        [
          "y",
          false,
          "Int[0, 1]"
        ]
      ],
      "\n            1. If _x_ = 1 and _y_ = 1, return 1.\n            1. Else, return 0.\n          ",
      {
        "normalizedName" : "BinaryAnd",
        "name" : "BinaryAnd",
        "htmlId" : "sec-binaryand",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1524,
    [
      "CaseBlock[1,3].CaseBlockEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "input",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _V_ be *undefined*.\n        1. If the first |CaseClauses| is present, then\n          1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _A_ be a new empty List.\n        1. Let _found_ be *false*.\n        1. For each |CaseClause| _C_ of _A_, do\n          1. If _found_ is *false*, then\n            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n          1. If _found_ is *true*, then\n            1. Let _R_ be Completion(Evaluation of _C_).\n            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n            1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Let _foundInB_ be *false*.\n        1. If the second |CaseClauses| is present, then\n          1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _B_ be a new empty List.\n        1. If _found_ is *false*, then\n          1. For each |CaseClause| _C_ of _B_, do\n            1. If _foundInB_ is *false*, then\n              1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).\n            1. If _foundInB_ is *true*, then\n              1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n              1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n              1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. If _foundInB_ is *true*, return _V_.\n        1. Let _defaultR_ be Completion(Evaluation of |DefaultClause|).\n        1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].\n        1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).\n        1. NOTE: The following is another complete iteration of the second |CaseClauses|.\n        1. For each |CaseClause| _C_ of _B_, do\n          1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n          1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n          1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Return _V_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,3].CaseBlockEvaluation",
        "name" : "CaseBlock[1,3].CaseBlockEvaluation",
        "htmlId" : "sec-runtime-semantics-caseblockevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CaseBlockEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1048,
    [
      "Record[GlobalEnvironmentRecord].CreateGlobalVarBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "D",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n            1. Let _hasProperty_ be ? HasOwnProperty(_globalObject_, _N_).\n            1. Let _extensible_ be ? IsExtensible(_globalObject_).\n            1. If _hasProperty_ is *false* and _extensible_ is *true*, then\n              1. Perform ? <emu-meta effects=\"user-code\">_ObjRec_.CreateMutableBinding</emu-meta>(_N_, _D_).\n              1. Perform ? <emu-meta effects=\"user-code\">_ObjRec_.InitializeBinding</emu-meta>(_N_, *undefined*).\n            1. If _envRec_.[[VarNames]] does not contain _N_, then\n              1. Append _N_ to _envRec_.[[VarNames]].\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].CreateGlobalVarBinding",
        "name" : "Record[GlobalEnvironmentRecord].CreateGlobalVarBinding",
        "htmlId" : "sec-createglobalvarbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "CreateGlobalVarBinding"
        ]
      }
    ]
  ],
  [
    736,
    [
      "UpdateExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UpdateExpression[1,0].IsFunctionDefinition",
        "name" : "UpdateExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "++"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1349,
    [
      "UpdateExpression[3,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[3]]"
        ]
      ],
      "\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).\n          1. If _oldValue_ is a Number, then\n            1. Let _newValue_ be Number::add(_oldValue_, *1*<sub>𝔽</sub>).\n          1. Else,\n            1. Assert: _oldValue_ is a BigInt.\n            1. Let _newValue_ be BigInt::add(_oldValue_, *1*<sub>ℤ</sub>).\n          1. Perform ? PutValue(_expr_, _newValue_).\n          1. Return _newValue_.\n        ",
      {
        "normalizedName" : "UpdateExpression[3,0].Evaluation",
        "name" : "UpdateExpression[3,0].Evaluation",
        "htmlId" : "sec-prefix-increment-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "++"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2097,
    [
      "SymbolDescriptiveString",
      0,
      [
        [
          "sym",
          false,
          "Record[Symbol]"
        ]
      ],
      "\n            1. Let _desc_ be _sym_'s [[Description]] value.\n            1. If _desc_ is *undefined*, set _desc_ to the empty String.\n            1. Assert: _desc_ is a String.\n            1. Return the string-concatenation of *\"Symbol(\"*, _desc_, and *\")\"*.\n          ",
      {
        "normalizedName" : "SymbolDescriptiveString",
        "name" : "SymbolDescriptiveString",
        "htmlId" : "sec-symboldescriptivestring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    377,
    [
      "ForStatement[1,1].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ]
      ],
      "\n        1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n        1. Let _names2_ be VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ForStatement[1,1].VarDeclaredNames",
        "name" : "ForStatement[1,1].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    990,
    [
      "PropertyDefinition[0,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyDefinition[0]]"
        ]
      ],
      "\n        1. Return StringValue of |IdentifierReference|.\n      ",
      {
        "normalizedName" : "PropertyDefinition[0,0].PropName",
        "name" : "PropertyDefinition[0,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "PropertyDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierReference"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    996,
    [
      "ComputedPropertyName[0,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[ComputedPropertyName[0]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "ComputedPropertyName[0,0].PropName",
        "name" : "ComputedPropertyName[0,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ComputedPropertyName",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2284,
    [
      "ClassAtomNoDash[0,0].IsCharacterClass",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassAtomNoDash[0]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ClassAtomNoDash[0,0].IsCharacterClass",
        "name" : "ClassAtomNoDash[0,0].IsCharacterClass",
        "htmlId" : "sec-patterns-static-semantics-is-character-class",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsCharacterClass",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassAtomNoDash",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SourceCharacter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1933,
    [
      "Record[CyclicModuleRecord].Link",
      3,
      [
        [
          "module",
          false,
          "Record[CyclicModuleRecord]"
        ]
      ],
      "\n            1. Assert: _module_.[[Status]] is one of ~unlinked~, ~linked~, ~evaluating-async~, or ~evaluated~.\n            1. Let _stack_ be a new empty List.\n            1. Let _result_ be Completion(InnerModuleLinking(_module_, _stack_, 0)).\n            1. If _result_ is an abrupt completion, then\n              1. For each Cyclic Module Record _m_ of _stack_, do\n                1. Assert: _m_.[[Status]] is ~linking~.\n                1. Set _m_.[[Status]] to ~unlinked~.\n              1. Assert: _module_.[[Status]] is ~unlinked~.\n              1. Return ? _result_.\n            1. Assert: _module_.[[Status]] is one of ~linked~, ~evaluating-async~, or ~evaluated~.\n            1. Assert: _stack_ is empty.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[CyclicModuleRecord].Link",
        "name" : "Record[CyclicModuleRecord].Link",
        "htmlId" : "sec-moduledeclarationlinking",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "CyclicModuleRecord",
          "Link"
        ]
      }
    ]
  ],
  [
    2257,
    [
      "ToZeroPaddedDecimalString",
      0,
      [
        [
          "n",
          false,
          "Int[0+]"
        ],
        [
          "minLength",
          false,
          "Int[0+]"
        ]
      ],
      "\n            1. Let _S_ be the String representation of _n_, formatted as a decimal number.\n            1. Return StringPad(_S_, _minLength_, *\"0\"*, ~start~).\n          ",
      {
        "normalizedName" : "ToZeroPaddedDecimalString",
        "name" : "ToZeroPaddedDecimalString",
        "htmlId" : "sec-tozeropaddeddecimalstring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1589,
    [
      "FormalParameters[4,0].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameters[4]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FormalParameters[4,0].IsSimpleParameterList",
        "name" : "FormalParameters[4,0].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "FormalParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameterList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionRestParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2246,
    [
      "INTRINSICS.String.prototype.indexOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _searchStr_ be ? ToString(_searchString_).\n          1. Let _pos_ be ? ToIntegerOrInfinity(_position_).\n          1. Assert: If _position_ is *undefined*, then _pos_ is 0.\n          1. Let _len_ be the length of _S_.\n          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.\n          1. Return 𝔽(StringIndexOf(_S_, _searchStr_, _start_)).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.indexOf",
        "name" : "INTRINSICS.String.prototype.indexOf",
        "htmlId" : "sec-string.prototype.indexof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1492,
    [
      "ForBinding[1,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[ForBinding[1]]"
        ]
      ],
      "\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "ForBinding[1,0].IsDestructuring",
        "name" : "ForBinding[1,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1603,
    [
      "FormalParameters[4,0].ExpectedArgumentCount",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameters[4]]"
        ]
      ],
      "\n        1. Return ExpectedArgumentCount of |FormalParameterList|.\n      ",
      {
        "normalizedName" : "FormalParameters[4,0].ExpectedArgumentCount",
        "name" : "FormalParameters[4,0].ExpectedArgumentCount",
        "htmlId" : "sec-static-semantics-expectedargumentcount",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExpectedArgumentCount",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "FormalParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameterList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionRestParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2299,
    [
      "RegExpUnicodeEscapeSequence[5,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[RegExpUnicodeEscapeSequence[5]]"
        ]
      ],
      "\n          1. Return the MV of |CodePoint|.\n        ",
      {
        "normalizedName" : "RegExpUnicodeEscapeSequence[5,0].CharacterValue",
        "name" : "RegExpUnicodeEscapeSequence[5,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "RegExpUnicodeEscapeSequence",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "u{"
              },
              {
                "type" : "nonterminal",
                "value" : "CodePoint"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    230,
    [
      "BindingElementList[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElementList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be BoundNames of |BindingElementList|.\n        1. Let _names2_ be BoundNames of |BindingElisionElement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "BindingElementList[1,0].BoundNames",
        "name" : "BindingElementList[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElisionElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1542,
    [
      "Statement[6,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[6]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |Statement|.\n      ",
      {
        "normalizedName" : "Statement[6,0].LabelledEvaluation",
        "name" : "Statement[6,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ContinueStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    362,
    [
      "StatementListItem[1,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[1]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "StatementListItem[1,0].VarDeclaredNames",
        "name" : "StatementListItem[1,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    451,
    [
      "ForStatement[2,1].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[2,1].VarScopedDeclarations",
        "name" : "ForStatement[2,1].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    76,
    [
      "BigInt::subtract",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. Return _x_ - _y_.\n          ",
      {
        "normalizedName" : "BigInt::subtract",
        "name" : "BigInt::subtract",
        "htmlId" : "sec-numeric-types-bigint-subtract",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    567,
    [
      "TryStatement[2,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If ContainsDuplicateLabels of |Block| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsDuplicateLabels of |Catch| with argument _labelSet_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "TryStatement[2,0].ContainsDuplicateLabels",
        "name" : "TryStatement[2,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    7,
    [
      "HostPromiseRejectionTracker",
      0,
      [
        [
          "promise",
          false,
          "Record[Promise]"
        ],
        [
          "operation",
          false,
          "String[\"handle\", \"reject\"]"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1722,
    [
      "GeneratorMethod[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorMethod[0]]"
        ]
      ],
      "\n        1. Return ContainsArguments of |ClassElementName|.\n      ",
      {
        "normalizedName" : "GeneratorMethod[0,0].ContainsArguments",
        "name" : "GeneratorMethod[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2669,
    [
      "INTRINSICS.get DataView.prototype.buffer",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].\n          1. Return _buffer_.\n        ",
      {
        "normalizedName" : "INTRINSICS.get DataView.prototype.buffer",
        "name" : "INTRINSICS.get DataView.prototype.buffer",
        "htmlId" : "sec-get-dataview.prototype.buffer",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1144,
    [
      "ArraySetLength",
      0,
      [
        [
          "A",
          false,
          "Record[Array]"
        ],
        [
          "Desc",
          false,
          "Record[PropertyDescriptor]"
        ]
      ],
      "\n          1. If _Desc_ does not have a [[Value]] field, then\n            1. Return ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _Desc_).\n          1. Let _newLenDesc_ be a copy of _Desc_.\n          1. [id=\"step-arraysetlength-newlen\"] Let _newLen_ be ? ToUint32(_Desc_.[[Value]]).\n          1. [id=\"step-arraysetlength-numberlen\"] Let _numberLen_ be ? ToNumber(_Desc_.[[Value]]).\n          1. If SameValueZero(_newLen_, _numberLen_) is *false*, throw a *RangeError* exception.\n          1. Set _newLenDesc_.[[Value]] to _newLen_.\n          1. Let _oldLenDesc_ be OrdinaryGetOwnProperty(_A_, *\"length\"*).\n          1. Assert: IsDataDescriptor(_oldLenDesc_) is *true*.\n          1. Assert: _oldLenDesc_.[[Configurable]] is *false*.\n          1. Let _oldLen_ be _oldLenDesc_.[[Value]].\n          1. If _newLen_ ≥ _oldLen_, then\n            1. Return ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _newLenDesc_).\n          1. If _oldLenDesc_.[[Writable]] is *false*, return *false*.\n          1. If _newLenDesc_ does not have a [[Writable]] field or _newLenDesc_.[[Writable]] is *true*, then\n            1. Let _newWritable_ be *true*.\n          1. Else,\n            1. NOTE: Setting the [[Writable]] attribute to *false* is deferred in case any elements cannot be deleted.\n            1. Let _newWritable_ be *false*.\n            1. Set _newLenDesc_.[[Writable]] to *true*.\n          1. Let _succeeded_ be ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _newLenDesc_).\n          1. If _succeeded_ is *false*, return *false*.\n          1. For each own property key _P_ of _A_ such that _P_ is an array index and ! ToUint32(_P_) ≥ _newLen_, in descending numeric index order, do\n            1. Let _deleteSucceeded_ be ! _A_.[[Delete]](_P_).\n            1. If _deleteSucceeded_ is *false*, then\n              1. Set _newLenDesc_.[[Value]] to ! ToUint32(_P_) + *1*<sub>𝔽</sub>.\n              1. If _newWritable_ is *false*, set _newLenDesc_.[[Writable]] to *false*.\n              1. Perform ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _newLenDesc_).\n              1. Return *false*.\n          1. If _newWritable_ is *false*, then\n            1. Set _succeeded_ to ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, PropertyDescriptor { [[Writable]]: *false* }).\n            1. Assert: _succeeded_ is *true*.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "ArraySetLength",
        "name" : "ArraySetLength",
        "htmlId" : "sec-arraysetlength",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    245,
    [
      "GeneratorDeclaration[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorDeclaration[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingIdentifier|.\n      ",
      {
        "normalizedName" : "GeneratorDeclaration[0,0].BoundNames",
        "name" : "GeneratorDeclaration[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2116,
    [
      "INTRINSICS.Number.prototype.valueOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return ? ThisNumberValue(*this* value).\n        ",
      {
        "normalizedName" : "INTRINSICS.Number.prototype.valueOf",
        "name" : "INTRINSICS.Number.prototype.valueOf",
        "htmlId" : "sec-number.prototype.valueof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2839,
    [
      "INTRINSICS.Reflect.defineProperty",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n        1. Let _desc_ be ? ToPropertyDescriptor(_attributes_).\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[DefineOwnProperty]]</emu-meta>(_key_, _desc_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.defineProperty",
        "name" : "INTRINSICS.Reflect.defineProperty",
        "htmlId" : "sec-reflect.defineproperty",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1771,
    [
      "Statement[6,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[6]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[6,0].HasCallInTailPosition",
        "name" : "Statement[6,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ContinueStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    737,
    [
      "UpdateExpression[2,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UpdateExpression[2,0].IsFunctionDefinition",
        "name" : "UpdateExpression[2,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "--"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    318,
    [
      "ModuleItem[2,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[2]]"
        ]
      ],
      "\n        1. Return LexicallyDeclaredNames of |StatementListItem|.\n      ",
      {
        "normalizedName" : "ModuleItem[2,0].LexicallyDeclaredNames",
        "name" : "ModuleItem[2,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    509,
    [
      "LabelledItem[0,0].TopLevelVarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[0]]"
        ]
      ],
      "\n        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return TopLevelVarScopedDeclarations of |Statement|.\n        1. Return VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "LabelledItem[0,0].TopLevelVarScopedDeclarations",
        "name" : "LabelledItem[0,0].TopLevelVarScopedDeclarations",
        "htmlId" : "sec-static-semantics-toplevelvarscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelVarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    880,
    [
      "BindingIdentifier[1,0].BindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingIdentifier[1]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Return ? InitializeBoundName(*\"yield\"*, _value_, _environment_).\n      ",
      {
        "normalizedName" : "BindingIdentifier[1,0].BindingInitialization",
        "name" : "BindingIdentifier[1,0].BindingInitialization",
        "htmlId" : "sec-runtime-semantics-bindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingIdentifier",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "yield"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    39,
    [
      "__NEW_OBJ__",
      8,
      [
      ],
      "",
      null
    ]
  ],
  [
    649,
    [
      "StatementList[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of |StatementListItem| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "StatementList[1,0].ContainsUndefinedContinueTarget",
        "name" : "StatementList[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    434,
    [
      "IfStatement[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[0]]"
        ]
      ],
      "\n        1. Let _declarations1_ be VarScopedDeclarations of the first |Statement|.\n        1. Let _declarations2_ be VarScopedDeclarations of the second |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "IfStatement[0,0].VarScopedDeclarations",
        "name" : "IfStatement[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "else"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1043,
    [
      "Record[GlobalEnvironmentRecord].HasVarDeclaration",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ]
      ],
      "\n            1. Let _varDeclaredNames_ be _envRec_.[[VarNames]].\n            1. If _varDeclaredNames_ contains _N_, return *true*.\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].HasVarDeclaration",
        "name" : "Record[GlobalEnvironmentRecord].HasVarDeclaration",
        "htmlId" : "sec-hasvardeclaration",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "HasVarDeclaration"
        ]
      }
    ]
  ],
  [
    1801,
    [
      "ForStatement[2,3].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[2,3].HasCallInTailPosition",
        "name" : "ForStatement[2,3].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2856,
    [
      "ComposeWriteEventBytes",
      0,
      [
        [
          "execution",
          false,
          "Unknown[\"CandidateExecution\"]"
        ],
        [
          "byteIndex",
          false,
          "Int[0+]"
        ],
        [
          "Ws",
          false,
          "Unknown[\"ListOfEitherWriteSharedMemoryOrReadModifyWriteSharedMemoryEvent\"]"
        ]
      ],
      "\n        1. Let _byteLocation_ be _byteIndex_.\n        1. Let _bytesRead_ be a new empty List.\n        1. For each element _W_ of _Ws_, do\n          1. Assert: _W_ has _byteLocation_ in its range.\n          1. Let _payloadIndex_ be _byteLocation_ - _W_.[[ByteIndex]].\n          1. If _W_ is a WriteSharedMemory event, then\n            1. Let _byte_ be _W_.[[Payload]][_payloadIndex_].\n          1. Else,\n            1. Assert: _W_ is a ReadModifyWriteSharedMemory event.\n            1. Let _bytes_ be ValueOfReadEvent(_execution_, _W_).\n            1. Let _bytesModified_ be _W_.[[ModifyOp]](_bytes_, _W_.[[Payload]]).\n            1. Let _byte_ be _bytesModified_[_payloadIndex_].\n          1. Append _byte_ to _bytesRead_.\n          1. Set _byteLocation_ to _byteLocation_ + 1.\n        1. Return _bytesRead_.\n      ",
      {
        "normalizedName" : "ComposeWriteEventBytes",
        "name" : "ComposeWriteEventBytes",
        "htmlId" : "sec-composewriteeventbytes",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2802,
    [
      "GeneratorYield:cont0",
      7,
      [
        [
          "resumptionValue",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _genContext_ be the running execution context.\n          1. Assert: _genContext_ is the execution context of a generator.\n          1. Let _generator_ be the value of the Generator component of _genContext_.\n          1. Assert: GetGeneratorKind() is ~sync~.\n          1. Set _generator_.[[GeneratorState]] to ~suspended-yield~.\n          1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n          1. Let _callerContext_ be the running execution context.\n          1. Resume _callerContext_ passing NormalCompletion(_iterNextObj_). If _genContext_ is ever resumed again, let _resumptionValue_ be the Completion Record with which it is resumed.\n          1. Assert: If control reaches here, then _genContext_ is the running execution context again.\n          1. Return _resumptionValue_.\n        ",
      {
        "normalizedName" : "GeneratorYield",
        "name" : "GeneratorYield",
        "htmlId" : "sec-generatoryield",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : true,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    98,
    [
      "InitializeReferencedBinding",
      0,
      [
        [
          "V",
          false,
          "Record[ReferenceRecord]"
        ],
        [
          "W",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Assert: IsUnresolvableReference(_V_) is *false*.\n          1. Let _base_ be _V_.[[Base]].\n          1. Assert: _base_ is an Environment Record.\n          1. Return ? _base_.InitializeBinding(_V_.[[ReferencedName]], _W_).\n        ",
      {
        "normalizedName" : "InitializeReferencedBinding",
        "name" : "InitializeReferencedBinding",
        "htmlId" : "sec-initializereferencedbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    616,
    [
      "SwitchStatement[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[SwitchStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |CaseBlock| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "SwitchStatement[0,0].ContainsUndefinedBreakTarget",
        "name" : "SwitchStatement[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SwitchStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "switch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    303,
    [
      "DefaultClause[0,1].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the LexicallyDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "DefaultClause[0,1].LexicallyDeclaredNames",
        "name" : "DefaultClause[0,1].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1122,
    [
      "OrdinaryCallEvaluateBody",
      0,
      [
        [
          "F",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Return ? EvaluateBody of _F_.[[ECMAScriptCode]] with arguments _F_ and _argumentsList_.\n        ",
      {
        "normalizedName" : "OrdinaryCallEvaluateBody",
        "name" : "OrdinaryCallEvaluateBody",
        "htmlId" : "sec-ordinarycallevaluatebody",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2378,
    [
      "AtomEscape[0,0].CompileAtom",
      2,
      [
        [
          "this",
          false,
          "Ast[AtomEscape[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Let _n_ be the CapturingGroupNumber of |DecimalEscape|.\n          1. Assert: _n_ ≤ _rer_.[[CapturingGroupsCount]].\n          1. Return BackreferenceMatcher(_rer_, _n_, _direction_).\n        ",
      {
        "normalizedName" : "AtomEscape[0,0].CompileAtom",
        "name" : "AtomEscape[0,0].CompileAtom",
        "htmlId" : "sec-compileatom",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAtom",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AtomEscape",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DecimalEscape"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    271,
    [
      "HoistableDeclaration[3,0].DeclarationPart",
      2,
      [
        [
          "this",
          false,
          "Ast[HoistableDeclaration[3]]"
        ]
      ],
      "\n        1. Return |AsyncGeneratorDeclaration|.\n      ",
      {
        "normalizedName" : "HoistableDeclaration[3,0].DeclarationPart",
        "name" : "HoistableDeclaration[3,0].DeclarationPart",
        "htmlId" : "sec-static-semantics-declarationpart",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DeclarationPart",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "HoistableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1690,
    [
      "ClassElementName[1,0].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementName[1]]"
        ]
      ],
      "\n        1. Return a List whose sole element is the StringValue of |PrivateIdentifier|.\n      ",
      {
        "normalizedName" : "ClassElementName[1,0].PrivateBoundIdentifiers",
        "name" : "ClassElementName[1,0].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassElementName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    208,
    [
      "BindingIdentifier[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingIdentifier[1]]"
        ]
      ],
      "\n        1. Return « *\"yield\"* ».\n      ",
      {
        "normalizedName" : "BindingIdentifier[1,0].BoundNames",
        "name" : "BindingIdentifier[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingIdentifier",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "yield"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1571,
    [
      "BindingProperty[1,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingProperty[1]]"
        ]
      ],
      "\n        1. Let _has_ be IsComputedPropertyKey of |PropertyName|.\n        1. If _has_ is *true*, return *true*.\n        1. Return ContainsExpression of |BindingElement|.\n      ",
      {
        "normalizedName" : "BindingProperty[1,0].ContainsExpression",
        "name" : "BindingProperty[1,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingProperty",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PropertyName"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    599,
    [
      "ForStatement[1,3].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[1,3].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[1,3].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1376,
    [
      "EqualityExpression[4,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[4]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |EqualityExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _r_ be IsStrictlyEqual(_rval_, _lval_).\n        1. If _r_ is *true*, return *false*. Otherwise, return *true*.\n      ",
      {
        "normalizedName" : "EqualityExpression[4,0].Evaluation",
        "name" : "EqualityExpression[4,0].Evaluation",
        "htmlId" : "sec-equality-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "!=="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1439,
    [
      "VariableDeclaration[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[VariableDeclaration[0]]"
        ]
      ],
      "\n          1. Return ~empty~.\n        ",
      {
        "normalizedName" : "VariableDeclaration[0,0].Evaluation",
        "name" : "VariableDeclaration[0,0].Evaluation",
        "htmlId" : "sec-variable-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "VariableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2197,
    [
      "INTRINSICS.Date.prototype.getSeconds",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return SecFromTime(LocalTime(_t_)).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getSeconds",
        "name" : "INTRINSICS.Date.prototype.getSeconds",
        "htmlId" : "sec-date.prototype.getseconds",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1969,
    [
      "ModuleItemList[1,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ]
      ],
      "\n          1. Let _names1_ be ExportedBindings of |ModuleItemList|.\n          1. Let _names2_ be ExportedBindings of |ModuleItem|.\n          1. Return the list-concatenation of _names1_ and _names2_.\n        ",
      {
        "normalizedName" : "ModuleItemList[1,0].ExportedBindings",
        "name" : "ModuleItemList[1,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1307,
    [
      "EvaluatePropertyAccessWithIdentifierKey",
      0,
      [
        [
          "baseValue",
          false,
          "ESValue"
        ],
        [
          "identifierName",
          false,
          "Ast[IdentifierName]"
        ],
        [
          "strict",
          false,
          "Boolean"
        ]
      ],
      "\n        1. Let _propertyNameString_ be StringValue of _identifierName_.\n        1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameString_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.\n      ",
      {
        "normalizedName" : "EvaluatePropertyAccessWithIdentifierKey",
        "name" : "EvaluatePropertyAccessWithIdentifierKey",
        "htmlId" : "sec-evaluate-property-access-with-identifier-key",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    863,
    [
      "GeneratorMethod[0,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorMethod[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      ",
      {
        "normalizedName" : "GeneratorMethod[0,0].ComputedPropertyContains",
        "name" : "GeneratorMethod[0,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2065,
    [
      "INTRINSICS.Object.keys",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Let _keyList_ be ? EnumerableOwnProperties(_obj_, ~key~).\n          1. Return CreateArrayFromList(_keyList_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.keys",
        "name" : "INTRINSICS.Object.keys",
        "htmlId" : "sec-object.keys",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1175,
    [
      "TypedArraySetElement",
      0,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "index",
          false,
          "Number"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If _O_.[[ContentType]] is ~bigint~, let _numValue_ be ? ToBigInt(_value_).\n          1. Otherwise, let _numValue_ be ? ToNumber(_value_).\n          1. If IsValidIntegerIndex(_O_, _index_) is *true*, then\n            1. Let _offset_ be _O_.[[ByteOffset]].\n            1. Let _elementSize_ be TypedArrayElementSize(_O_).\n            1. Let _byteIndexInBuffer_ be (ℝ(_index_) × _elementSize_) + _offset_.\n            1. Let _elementType_ be TypedArrayElementType(_O_).\n            1. Perform SetValueInBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, _numValue_, *true*, ~unordered~).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "TypedArraySetElement",
        "name" : "TypedArraySetElement",
        "htmlId" : "sec-typedarraysetelement",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1344,
    [
      "CallExpression[6,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[6]]"
        ]
      ],
      "\n          1. Let _tagRef_ be ? Evaluation of |CallExpression|.\n          1. Let _tagFunc_ be ? GetValue(_tagRef_).\n          1. Let _thisCall_ be this |CallExpression|.\n          1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n          1. Return ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_).\n        ",
      {
        "normalizedName" : "CallExpression[6,0].Evaluation",
        "name" : "CallExpression[6,0].Evaluation",
        "htmlId" : "sec-tagged-templates-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    890,
    [
      "ArrayBindingPattern[0,0].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[0,0].IteratorBindingInitialization",
        "name" : "ArrayBindingPattern[0,0].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1667,
    [
      "ClassElement[4,0].ClassElementKind",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[4]]"
        ]
      ],
      "\n        1. Return ~non-constructor-method~.\n      ",
      {
        "normalizedName" : "ClassElement[4,0].ClassElementKind",
        "name" : "ClassElement[4,0].ClassElementKind",
        "htmlId" : "sec-static-semantics-classelementkind",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassElementKind",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassStaticBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2180,
    [
      "UTC",
      0,
      [
        [
          "t",
          false,
          "Number"
        ]
      ],
      "\n          1. If _t_ is not finite, return *NaN*.\n          1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().\n          1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then\n            1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).\n          1. Else,\n            1. Let _possibleInstants_ be GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_t_)), ℝ(MonthFromTime(_t_)) + 1, ℝ(DateFromTime(_t_)), ℝ(HourFromTime(_t_)), ℝ(MinFromTime(_t_)), ℝ(SecFromTime(_t_)), ℝ(msFromTime(_t_)), 0, 0).\n            1. NOTE: The following steps ensure that when _t_ represents local time repeating multiple times at a negative time zone transition (e.g. when the daylight saving time ends or the time zone offset is decreased due to a time zone rule change) or skipped local time at a positive time zone transition (e.g. when the daylight saving time starts or the time zone offset is increased due to a time zone rule change), _t_ is interpreted using the time zone offset before the transition.\n            1. If _possibleInstants_ is not empty, then\n              1. Let _disambiguatedInstant_ be _possibleInstants_[0].\n            1. Else,\n              1. NOTE: _t_ represents a local time skipped at a positive time zone transition (e.g. due to daylight saving time starting or a time zone rule change increasing the UTC offset).\n              1. [declared=\"tBefore\"] Let _possibleInstantsBefore_ be GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_tBefore_)), ℝ(MonthFromTime(_tBefore_)) + 1, ℝ(DateFromTime(_tBefore_)), ℝ(HourFromTime(_tBefore_)), ℝ(MinFromTime(_tBefore_)), ℝ(SecFromTime(_tBefore_)), ℝ(msFromTime(_tBefore_)), 0, 0), where _tBefore_ is the largest integral Number < _t_ for which _possibleInstantsBefore_ is not empty (i.e., _tBefore_ represents the last local time before the transition).\n              1. Let _disambiguatedInstant_ be the last element of _possibleInstantsBefore_.\n            1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, _disambiguatedInstant_).\n          1. Let _offsetMs_ be truncate(_offsetNs_ / 10<sup>6</sup>).\n          1. Return _t_ - 𝔽(_offsetMs_).\n        ",
      {
        "normalizedName" : "UTC",
        "name" : "UTC",
        "htmlId" : "sec-utc-t",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    477,
    [
      "TryStatement[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[0]]"
        ]
      ],
      "\n        1. Let _declarations1_ be VarScopedDeclarations of |Block|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Catch|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "TryStatement[0,0].VarScopedDeclarations",
        "name" : "TryStatement[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2824,
    [
      "CreateAsyncIteratorFromClosure",
      0,
      [
        [
          "closure",
          false,
          "Clo"
        ],
        [
          "generatorBrand",
          false,
          "Enum[~empty~] | String"
        ],
        [
          "generatorPrototype",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. NOTE: _closure_ can contain uses of the Await operation and uses of the Yield operation to yield an IteratorResult object.\n          1. Let _internalSlotsList_ be « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] ».\n          1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).\n          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.\n          1. Set _generator_.[[AsyncGeneratorState]] to *undefined*.\n          1. Let _callerContext_ be the running execution context.\n          1. Let _calleeContext_ be a new execution context.\n          1. Set the Function of _calleeContext_ to *null*.\n          1. Set the Realm of _calleeContext_ to the current Realm Record.\n          1. Set the ScriptOrModule of _calleeContext_ to _callerContext_'s ScriptOrModule.\n          1. If _callerContext_ is not already suspended, suspend _callerContext_.\n          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.\n          1. Perform AsyncGeneratorStart(_generator_, _closure_).\n          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n          1. Return _generator_.\n        ",
      {
        "normalizedName" : "CreateAsyncIteratorFromClosure",
        "name" : "CreateAsyncIteratorFromClosure",
        "htmlId" : "sec-createasynciteratorfromclosure",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    387,
    [
      "ForInOfStatement[5,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[5]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForInOfStatement[5,0].VarDeclaredNames",
        "name" : "ForInOfStatement[5,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    811,
    [
      "MemberExpression[6,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[6]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[6,0].IsIdentifierRef",
        "name" : "MemberExpression[6,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2182,
    [
      "MakeDay",
      0,
      [
        [
          "year",
          false,
          "Number"
        ],
        [
          "month",
          false,
          "Number"
        ],
        [
          "date",
          false,
          "Number"
        ]
      ],
      "\n          1. If _year_ is not finite, _month_ is not finite, or _date_ is not finite, return *NaN*.\n          1. Let _y_ be 𝔽(! ToIntegerOrInfinity(_year_)).\n          1. Let _m_ be 𝔽(! ToIntegerOrInfinity(_month_)).\n          1. Let _dt_ be 𝔽(! ToIntegerOrInfinity(_date_)).\n          1. Let _ym_ be _y_ + 𝔽(floor(ℝ(_m_) / 12)).\n          1. If _ym_ is not finite, return *NaN*.\n          1. Let _mn_ be 𝔽(ℝ(_m_) modulo 12).\n          1. Find a finite time value _t_ such that YearFromTime(_t_) is _ym_, MonthFromTime(_t_) is _mn_, and DateFromTime(_t_) is *1*<sub>𝔽</sub>; but if this is not possible (because some argument is out of range), return *NaN*.\n          1. Return Day(_t_) + _dt_ - *1*<sub>𝔽</sub>.\n        ",
      {
        "normalizedName" : "MakeDay",
        "name" : "MakeDay",
        "htmlId" : "sec-makeday",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1877,
    [
      "PrimaryExpression[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[2,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Literal"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1471,
    [
      "ForStatement[1,2].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Perform ? Evaluation of |VariableDeclarationList|.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        ",
      {
        "normalizedName" : "ForStatement[1,2].ForLoopEvaluation",
        "name" : "ForStatement[1,2].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    494,
    [
      "StatementListItem[0,0].TopLevelLexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "StatementListItem[0,0].TopLevelLexicallyDeclaredNames",
        "name" : "StatementListItem[0,0].TopLevelLexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-toplevellexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelLexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2025,
    [
      "ExportDeclaration[3,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[3]]"
        ]
      ],
      "\n          1. Return ? Evaluation of |Declaration|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[3,0].Evaluation",
        "name" : "ExportDeclaration[3,0].Evaluation",
        "htmlId" : "sec-exports-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2812,
    [
      "AsyncGeneratorValidate",
      0,
      [
        [
          "generator",
          false,
          "ESValue"
        ],
        [
          "generatorBrand",
          false,
          "Enum[~empty~] | String"
        ]
      ],
      "\n          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorContext]]).\n          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorState]]).\n          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorQueue]]).\n          1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncGeneratorValidate",
        "name" : "AsyncGeneratorValidate",
        "htmlId" : "sec-asyncgeneratorvalidate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1080,
    [
      "CleanupFinalizationRegistry",
      0,
      [
        [
          "finalizationRegistry",
          false,
          "Record[FinalizationRegistry]"
        ]
      ],
      "\n      1. Assert: _finalizationRegistry_ has [[Cells]] and [[CleanupCallback]] internal slots.\n      1. Let _callback_ be _finalizationRegistry_.[[CleanupCallback]].\n      1. While _finalizationRegistry_.[[Cells]] contains a Record _cell_ such that _cell_.[[WeakRefTarget]] is ~empty~, an implementation may perform the following steps:\n        1. Choose any such _cell_.\n        1. Remove _cell_ from _finalizationRegistry_.[[Cells]].\n        1. Perform ? HostCallJobCallback(_callback_, *undefined*, « _cell_.[[HeldValue]] »).\n      1. Return ~unused~.\n    ",
      {
        "normalizedName" : "CleanupFinalizationRegistry",
        "name" : "CleanupFinalizationRegistry",
        "htmlId" : "sec-cleanup-finalization-registry",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2632,
    [
      "IsFixedLengthArrayBuffer",
      0,
      [
        [
          "arrayBuffer",
          false,
          "Record[ArrayBuffer | SharedArrayBuffer]"
        ]
      ],
      "\n          1. If _arrayBuffer_ has an [[ArrayBufferMaxByteLength]] internal slot, return *false*.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "IsFixedLengthArrayBuffer",
        "name" : "IsFixedLengthArrayBuffer",
        "htmlId" : "sec-isfixedlengtharraybuffer",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    631,
    [
      "TryStatement[2,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If ContainsUndefinedBreakTarget of |Block| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsUndefinedBreakTarget of |Catch| with argument _labelSet_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of |Finally| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "TryStatement[2,0].ContainsUndefinedBreakTarget",
        "name" : "TryStatement[2,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2742,
    [
      "CreateAsyncFromSyncIterator",
      0,
      [
        [
          "syncIteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n          1. Let _asyncIterator_ be OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »).\n          1. Set _asyncIterator_.[[SyncIteratorRecord]] to _syncIteratorRecord_.\n          1. Let _nextMethod_ be ! Get(_asyncIterator_, *\"next\"*).\n          1. Let _iteratorRecord_ be the Iterator Record { [[Iterator]]: _asyncIterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.\n          1. Return _iteratorRecord_.\n        ",
      {
        "normalizedName" : "CreateAsyncFromSyncIterator",
        "name" : "CreateAsyncFromSyncIterator",
        "htmlId" : "sec-createasyncfromsynciterator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    758,
    [
      "RelationalExpression[4,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[4]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[4,0].IsFunctionDefinition",
        "name" : "RelationalExpression[4,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : ">="
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1339,
    [
      "ContinueDynamicImport:clo0",
      6,
      [
        [
          "reason",
          false,
          "Unknown"
        ]
      ],
      "\n            1. If _moduleCompletion_ is an abrupt completion, then\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).\n              1. Return ~unused~.\n            1. Let _module_ be _moduleCompletion_.[[Value]].\n            1. Let _loadPromise_ be _module_.LoadRequestedModules().\n            1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _reason_ »).\n              1. Return ~unused~.\n            1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n            1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, and _onRejected_ and performs the following steps when called:\n              1. Let _link_ be Completion(_module_.Link()).\n              1. If _link_ is an abrupt completion, then\n                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _link_.[[Value]] »).\n                1. Return ~unused~.\n              1. Let _evaluatePromise_ be _module_.Evaluate().\n              1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and _promiseCapability_ and performs the following steps when called:\n                1. Let _namespace_ be GetModuleNamespace(_module_).\n                1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _namespace_ »).\n                1. Return ~unused~.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *\"\"*, « »).\n              1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).\n              1. Return ~unused~.\n            1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, 0, *\"\"*, « »).\n            1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "ContinueDynamicImport",
        "name" : "ContinueDynamicImport",
        "htmlId" : "sec-ContinueDynamicImport",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2605,
    [
      "INTRINSICS.Set.prototype.add",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n          1. For each element _e_ of _S_.[[SetData]], do\n            1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, then\n              1. Return _S_.\n          1. If _value_ is *-0*<sub>𝔽</sub>, set _value_ to *+0*<sub>𝔽</sub>.\n          1. Append _value_ to _S_.[[SetData]].\n          1. Return _S_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Set.prototype.add",
        "name" : "INTRINSICS.Set.prototype.add",
        "htmlId" : "sec-set.prototype.add",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2610,
    [
      "INTRINSICS.Set.prototype.has",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n          1. For each element _e_ of _S_.[[SetData]], do\n            1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Set.prototype.has",
        "name" : "INTRINSICS.Set.prototype.has",
        "htmlId" : "sec-set.prototype.has",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    345,
    [
      "ModuleItem[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ModuleItem[0,0].LexicallyScopedDeclarations",
        "name" : "ModuleItem[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    858,
    [
      "PropertyName[0,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyName[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PropertyName[0,0].ComputedPropertyContains",
        "name" : "PropertyName[0,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "PropertyName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LiteralPropertyName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    552,
    [
      "SwitchStatement[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[SwitchStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |CaseBlock| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "SwitchStatement[0,0].ContainsDuplicateLabels",
        "name" : "SwitchStatement[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SwitchStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "switch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    367,
    [
      "WhileStatement[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[WhileStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "WhileStatement[0,0].VarDeclaredNames",
        "name" : "WhileStatement[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1557,
    [
      "ObjectBindingPattern[1,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectBindingPattern[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ObjectBindingPattern[1,0].ContainsExpression",
        "name" : "ObjectBindingPattern[1,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ObjectBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestProperty"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2314,
    [
      "UnicodePropertyValueExpression[0,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[UnicodePropertyValueExpression[0]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "UnicodePropertyValueExpression[0,0].MayContainStrings",
        "name" : "UnicodePropertyValueExpression[0,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "UnicodePropertyValueExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "UnicodePropertyName"
              },
              {
                "type" : "terminal",
                "value" : "="
              },
              {
                "type" : "nonterminal",
                "value" : "UnicodePropertyValue"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2129,
    [
      "INTRINSICS.Math.asinh",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n          1. Return an implementation-approximated Number value representing the result of the inverse hyperbolic sine of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.asinh",
        "name" : "INTRINSICS.Math.asinh",
        "htmlId" : "sec-math.asinh",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    535,
    [
      "ForStatement[1,1].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[1,1].ContainsDuplicateLabels",
        "name" : "ForStatement[1,1].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2343,
    [
      "Pattern[0,0].CompilePattern:clo0",
      6,
      [
        [
          "Input",
          false,
          "Unknown"
        ],
        [
          "index",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.\n          1. Return a new Abstract Closure with parameters (_Input_, _index_) that captures _rer_ and _m_ and performs the following steps when called:\n            1. Assert: _Input_ is a List of characters.\n            1. Assert: 0 ≤ _index_ ≤ the number of elements in _Input_.\n            1. Let _c_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Return _y_.\n            1. Let _cap_ be a List of _rer_.[[CapturingGroupsCount]] *undefined* values, indexed 1 through _rer_.[[CapturingGroupsCount]].\n            1. Let _x_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _index_, [[Captures]]: _cap_ }.\n            1. Return _m_(_x_, _c_).\n        ",
      {
        "normalizedName" : "Pattern[0,0].CompilePattern",
        "name" : "Pattern[0,0].CompilePattern",
        "htmlId" : "sec-compilepattern",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2625,
    [
      "AllocateArrayBuffer",
      0,
      [
        [
          "constructor",
          false,
          "Record[Constructor]"
        ],
        [
          "byteLength",
          false,
          "Int[0+]"
        ],
        [
          "maxByteLength",
          true,
          "Enum[~empty~] | Int[0+]"
        ]
      ],
      "\n          1. Let _slots_ be « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] ».\n          1. If _maxByteLength_ is present and _maxByteLength_ is not ~empty~, let _allocatingResizableBuffer_ be *true*; otherwise let _allocatingResizableBuffer_ be *false*.\n          1. If _allocatingResizableBuffer_ is *true*, then\n            1. If _byteLength_ > _maxByteLength_, throw a *RangeError* exception.\n            1. Append [[ArrayBufferMaxByteLength]] to _slots_.\n          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *\"%ArrayBuffer.prototype%\"*, _slots_).\n          1. Let _block_ be ? CreateByteDataBlock(_byteLength_).\n          1. Set _obj_.[[ArrayBufferData]] to _block_.\n          1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.\n          1. If _allocatingResizableBuffer_ is *true*, then\n            1. If it is not possible to create a Data Block _block_ consisting of _maxByteLength_ bytes, throw a *RangeError* exception.\n            1. NOTE: Resizable ArrayBuffers are designed to be implementable with in-place growth. Implementations may throw if, for example, virtual memory cannot be reserved up front.\n            1. Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "AllocateArrayBuffer",
        "name" : "AllocateArrayBuffer",
        "htmlId" : "sec-allocatearraybuffer",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    816,
    [
      "PrimaryExpression[12,0].NamedEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[12]]"
        ],
        [
          "name",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return ? NamedEvaluation of _expr_ with argument _name_.\n      ",
      {
        "normalizedName" : "PrimaryExpression[12,0].NamedEvaluation",
        "name" : "PrimaryExpression[12,0].NamedEvaluation",
        "htmlId" : "sec-runtime-semantics-namedevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NamedEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 12,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    103,
    [
      "FromPropertyDescriptor",
      0,
      [
        [
          "Desc",
          false,
          "Record[PropertyDescriptor] | Undefined"
        ]
      ],
      "\n          1. If _Desc_ is *undefined*, return *undefined*.\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Assert: _obj_ is an extensible ordinary object with no own properties.\n          1. If _Desc_ has a [[Value]] field, then\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"value\"*, _Desc_.[[Value]]).\n          1. If _Desc_ has a [[Writable]] field, then\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"writable\"*, _Desc_.[[Writable]]).\n          1. If _Desc_ has a [[Get]] field, then\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"get\"*, _Desc_.[[Get]]).\n          1. If _Desc_ has a [[Set]] field, then\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"set\"*, _Desc_.[[Set]]).\n          1. If _Desc_ has an [[Enumerable]] field, then\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"enumerable\"*, _Desc_.[[Enumerable]]).\n          1. If _Desc_ has a [[Configurable]] field, then\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"configurable\"*, _Desc_.[[Configurable]]).\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "FromPropertyDescriptor",
        "name" : "FromPropertyDescriptor",
        "htmlId" : "sec-frompropertydescriptor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    609,
    [
      "ForInOfStatement[5,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[5]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[5,0].ContainsUndefinedBreakTarget",
        "name" : "ForInOfStatement[5,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2111,
    [
      "INTRINSICS.Number.isSafeInteger",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If IsIntegralNumber(_number_) is *true*, then\n            1. If abs(ℝ(_number_)) ≤ 2<sup>53</sup> - 1, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Number.isSafeInteger",
        "name" : "INTRINSICS.Number.isSafeInteger",
        "htmlId" : "sec-number.issafeinteger",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    323,
    [
      "CaseBlock[1,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _declarations1_ be the LexicallyScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the LexicallyScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,0].LexicallyScopedDeclarations",
        "name" : "CaseBlock[1,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1630,
    [
      "GeneratorMethod[0,0].HasDirectSuper",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorMethod[0]]"
        ]
      ],
      "\n        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.\n        1. Return |GeneratorBody| Contains |SuperCall|.\n      ",
      {
        "normalizedName" : "GeneratorMethod[0,0].HasDirectSuper",
        "name" : "GeneratorMethod[0,0].HasDirectSuper",
        "htmlId" : "sec-static-semantics-hasdirectsuper",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasDirectSuper",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1993,
    [
      "ExportDeclaration[4,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[4]]"
        ]
      ],
      "\n          1. Return « *\"default\"* ».\n        ",
      {
        "normalizedName" : "ExportDeclaration[4,0].ExportedNames",
        "name" : "ExportDeclaration[4,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "HoistableDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2780,
    [
      "INTRINSICS.Promise.prototype.catch",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _promise_ be the *this* value.\n          1. Return ? Invoke(_promise_, *\"then\"*, « *undefined*, _onRejected_ »).\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.prototype.catch",
        "name" : "INTRINSICS.Promise.prototype.catch",
        "htmlId" : "sec-promise.prototype.catch",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2267,
    [
      "INTRINSICS.String.prototype.toLowerCase",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _sText_ be StringToCodePoints(_S_).\n          1. Let _lowerText_ be the result of toLowercase(_sText_), according to the Unicode Default Case Conversion algorithm.\n          1. Let _L_ be CodePointsToString(_lowerText_).\n          1. Return _L_.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.toLowerCase",
        "name" : "INTRINSICS.String.prototype.toLowerCase",
        "htmlId" : "sec-string.prototype.tolowercase",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2261,
    [
      "INTRINSICS.String.prototype.replaceAll",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. If _searchValue_ is neither *undefined* nor *null*, then\n            1. Let _isRegExp_ be ? IsRegExp(_searchValue_).\n            1. If _isRegExp_ is *true*, then\n              1. Let _flags_ be ? Get(_searchValue_, *\"flags\"*).\n              1. Perform ? RequireObjectCoercible(_flags_).\n              1. If ? ToString(_flags_) does not contain *\"g\"*, throw a *TypeError* exception.\n            1. Let _replacer_ be ? GetMethod(_searchValue_, @@replace).\n            1. If _replacer_ is not *undefined*, then\n              1. Return ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »).\n          1. Let _string_ be ? ToString(_O_).\n          1. Let _searchString_ be ? ToString(_searchValue_).\n          1. Let _functionalReplace_ be IsCallable(_replaceValue_).\n          1. If _functionalReplace_ is *false*, then\n            1. Set _replaceValue_ to ? ToString(_replaceValue_).\n          1. Let _searchLength_ be the length of _searchString_.\n          1. Let _advanceBy_ be max(1, _searchLength_).\n          1. Let _matchPositions_ be a new empty List.\n          1. Let _position_ be StringIndexOf(_string_, _searchString_, 0).\n          1. Repeat, while _position_ ≠ -1,\n            1. Append _position_ to _matchPositions_.\n            1. Set _position_ to StringIndexOf(_string_, _searchString_, _position_ + _advanceBy_).\n          1. Let _endOfLastMatch_ be 0.\n          1. Let _result_ be the empty String.\n          1. For each element _p_ of _matchPositions_, do\n            1. Let _preserved_ be the substring of _string_ from _endOfLastMatch_ to _p_.\n            1. If _functionalReplace_ is *true*, then\n              1. Let _replacement_ be ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_p_), _string_ »)).\n            1. Else,\n              1. Assert: _replaceValue_ is a String.\n              1. Let _captures_ be a new empty List.\n              1. Let _replacement_ be ! GetSubstitution(_searchString_, _string_, _p_, _captures_, *undefined*, _replaceValue_).\n            1. Set _result_ to the string-concatenation of _result_, _preserved_, and _replacement_.\n            1. Set _endOfLastMatch_ to _p_ + _searchLength_.\n          1. If _endOfLastMatch_ < the length of _string_, then\n            1. Set _result_ to the string-concatenation of _result_ and the substring of _string_ from _endOfLastMatch_.\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.replaceAll",
        "name" : "INTRINSICS.String.prototype.replaceAll",
        "htmlId" : "sec-string.prototype.replaceall",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1821,
    [
      "Catch[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[Catch[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Block| with argument _call_.\n      ",
      {
        "normalizedName" : "Catch[0,0].HasCallInTailPosition",
        "name" : "Catch[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Catch",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "catch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "CatchParameter"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1731,
    [
      "ClassElement[0,0].ClassElementEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[0]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Return ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and *false*.\n      ",
      {
        "normalizedName" : "ClassElement[0,0].ClassElementEvaluation",
        "name" : "ClassElement[0,0].ClassElementEvaluation",
        "htmlId" : "sec-static-semantics-classelementevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassElementEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MethodDefinition"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    594,
    [
      "ForStatement[0,6].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,6].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[0,6].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 6,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    140,
    [
      "ToBigUint64",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _n_ be ? ToBigInt(_argument_).\n        1. Let _int64bit_ be ℝ(_n_) modulo 2<sup>64</sup>.\n        1. Return ℤ(_int64bit_).\n      ",
      {
        "normalizedName" : "ToBigUint64",
        "name" : "ToBigUint64",
        "htmlId" : "sec-tobiguint64",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    799,
    [
      "PrimaryExpression[6,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[6]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[6,0].IsIdentifierRef",
        "name" : "PrimaryExpression[6,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1909,
    [
      "ParenthesizedExpression[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ParenthesizedExpression[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Expression| with argument _call_.\n      ",
      {
        "normalizedName" : "ParenthesizedExpression[0,0].HasCallInTailPosition",
        "name" : "ParenthesizedExpression[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ParenthesizedExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    213,
    [
      "LexicalBinding[0,1].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[LexicalBinding[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingIdentifier|.\n      ",
      {
        "normalizedName" : "LexicalBinding[0,1].BoundNames",
        "name" : "LexicalBinding[0,1].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "LexicalBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1162,
    [
      "Record[TypedArray].HasProperty",
      4,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. If _P_ is a String, then\n            1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n            1. If _numericIndex_ is not *undefined*, return IsValidIntegerIndex(_O_, _numericIndex_).\n          1. Return ? OrdinaryHasProperty(_O_, _P_).\n        ",
      {
        "normalizedName" : "Record[TypedArray].HasProperty",
        "name" : "Record[TypedArray].HasProperty",
        "htmlId" : "sec-typedarray-hasproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "TypedArray",
          "[[HasProperty]]"
        ]
      }
    ]
  ],
  [
    726,
    [
      "MemberExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[1,0].IsFunctionDefinition",
        "name" : "MemberExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2446,
    [
      "INTRINSICS.get RegExp[@@species]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return the *this* value.\n        ",
      {
        "normalizedName" : "INTRINSICS.get RegExp[@@species]",
        "name" : "INTRINSICS.get RegExp[@@species]",
        "htmlId" : "sec-get-regexp-@@species",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    621,
    [
      "CaseBlock[1,3].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,3].ContainsUndefinedBreakTarget",
        "name" : "CaseBlock[1,3].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2757,
    [
      "NewPromiseReactionJob:clo0",
      6,
      [
      ],
      "\n          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _reaction_ and _argument_ and performs the following steps when called:\n            1. Let _promiseCapability_ be _reaction_.[[Capability]].\n            1. Let _type_ be _reaction_.[[Type]].\n            1. Let _handler_ be _reaction_.[[Handler]].\n            1. If _handler_ is ~empty~, then\n              1. If _type_ is ~fulfill~, then\n                1. Let _handlerResult_ be NormalCompletion(_argument_).\n              1. Else,\n                1. Assert: _type_ is ~reject~.\n                1. Let _handlerResult_ be ThrowCompletion(_argument_).\n            1. Else,\n              1. Let _handlerResult_ be Completion(HostCallJobCallback(_handler_, *undefined*, « _argument_ »)).\n            1. If _promiseCapability_ is *undefined*, then\n              1. Assert: _handlerResult_ is not an abrupt completion.\n              1. Return ~empty~.\n            1. Assert: _promiseCapability_ is a PromiseCapability Record.\n            1. If _handlerResult_ is an abrupt completion, then\n              1. Return ? Call(_promiseCapability_.[[Reject]], *undefined*, « _handlerResult_.[[Value]] »).\n            1. Else,\n              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _handlerResult_.[[Value]] »).\n          1. Let _handlerRealm_ be *null*.\n          1. If _reaction_.[[Handler]] is not ~empty~, then\n            1. Let _getHandlerRealmResult_ be Completion(GetFunctionRealm(_reaction_.[[Handler]].[[Callback]])).\n            1. If _getHandlerRealmResult_ is a normal completion, set _handlerRealm_ to _getHandlerRealmResult_.[[Value]].\n            1. Else, set _handlerRealm_ to the current Realm Record.\n            1. NOTE: _handlerRealm_ is never *null* unless the handler is *undefined*. When the handler is a revoked Proxy and no ECMAScript code runs, _handlerRealm_ is used to create error objects.\n          1. Return the Record { [[Job]]: _job_, [[Realm]]: _handlerRealm_ }.\n        ",
      {
        "normalizedName" : "NewPromiseReactionJob",
        "name" : "NewPromiseReactionJob",
        "htmlId" : "sec-newpromisereactionjob",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    91,
    [
      "IsPropertyReference",
      0,
      [
        [
          "V",
          false,
          "Record[ReferenceRecord]"
        ]
      ],
      "\n          1. If _V_.[[Base]] is ~unresolvable~, return *false*.\n          1. If _V_.[[Base]] is an Environment Record, return *false*; otherwise return *true*.\n        ",
      {
        "normalizedName" : "IsPropertyReference",
        "name" : "IsPropertyReference",
        "htmlId" : "sec-ispropertyreference",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1862,
    [
      "UnaryExpression[8,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[8]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[8,0].HasCallInTailPosition",
        "name" : "UnaryExpression[8,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AwaitExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    483,
    [
      "ClassStaticBlockStatementList[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockStatementList[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ClassStaticBlockStatementList[0,0].VarScopedDeclarations",
        "name" : "ClassStaticBlockStatementList[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStaticBlockStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    848,
    [
      "AsyncArrowFunction[0,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowFunction[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.\n        1. Return |AsyncConciseBody| Contains _symbol_.\n      ",
      {
        "normalizedName" : "AsyncArrowFunction[0,0].Contains",
        "name" : "AsyncArrowFunction[0,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncArrowFunction",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncArrowBindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    700,
    [
      "ClassStaticBlockStatementList[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockStatementList[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassStaticBlockStatementList[0,0].ContainsUndefinedContinueTarget",
        "name" : "ClassStaticBlockStatementList[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStaticBlockStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    520,
    [
      "StatementListItem[1,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "StatementListItem[1,0].ContainsDuplicateLabels",
        "name" : "StatementListItem[1,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    66,
    [
      "NumberBitwiseOp",
      0,
      [
        [
          "op",
          false,
          "Unknown[\"`&`,`^`,Or``\"]"
        ],
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. Let _lnum_ be ! ToInt32(_x_).\n            1. Let _rnum_ be ! ToInt32(_y_).\n            1. Let _lbits_ be the 32-bit two's complement bit string representing ℝ(_lnum_).\n            1. Let _rbits_ be the 32-bit two's complement bit string representing ℝ(_rnum_).\n            1. If _op_ is `&`, then\n              1. Let _result_ be the result of applying the bitwise AND operation to _lbits_ and _rbits_.\n            1. Else if _op_ is `^`, then\n              1. Let _result_ be the result of applying the bitwise exclusive OR (XOR) operation to _lbits_ and _rbits_.\n            1. Else,\n              1. Assert: _op_ is `|`.\n              1. Let _result_ be the result of applying the bitwise inclusive OR operation to _lbits_ and _rbits_.\n            1. Return the Number value for the integer represented by the 32-bit two's complement bit string _result_.\n          ",
      {
        "normalizedName" : "NumberBitwiseOp",
        "name" : "NumberBitwiseOp",
        "htmlId" : "sec-numberbitwiseop",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    240,
    [
      "FunctionDeclaration[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[1]]"
        ]
      ],
      "\n        1. Return « *\"\\*default\\*\"* ».\n      ",
      {
        "normalizedName" : "FunctionDeclaration[1,0].BoundNames",
        "name" : "FunctionDeclaration[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    251,
    [
      "AsyncFunctionDeclaration[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionDeclaration[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingIdentifier|.\n      ",
      {
        "normalizedName" : "AsyncFunctionDeclaration[0,0].BoundNames",
        "name" : "AsyncFunctionDeclaration[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2410,
    [
      "ClassUnion[1,1].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassUnion[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of |ClassSetOperand| with argument _rer_.\n          1. If |ClassUnion| is present, then\n            1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.\n            1. Return the union of CharSets _A_ and _B_.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "ClassUnion[1,1].CompileToCharSet",
        "name" : "ClassUnion[1,1].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "ClassUnion",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassUnion"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1838,
    [
      "RelationalExpression[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[2,0].HasCallInTailPosition",
        "name" : "RelationalExpression[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : ">"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1325,
    [
      "TemplateLiteral[1,0].ArgumentListEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateLiteral[1]]"
        ]
      ],
      "\n          1. Let _templateLiteral_ be this |TemplateLiteral|.\n          1. Let _siteObj_ be GetTemplateObject(_templateLiteral_).\n          1. Let _remaining_ be ? ArgumentListEvaluation of |SubstitutionTemplate|.\n          1. Return the list-concatenation of « _siteObj_ » and _remaining_.\n        ",
      {
        "normalizedName" : "TemplateLiteral[1,0].ArgumentListEvaluation",
        "name" : "TemplateLiteral[1,0].ArgumentListEvaluation",
        "htmlId" : "sec-runtime-semantics-argumentlistevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArgumentListEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TemplateLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SubstitutionTemplate"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2785,
    [
      "INTRINSICS.Promise.prototype.finally",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _promise_ be the *this* value.\n          1. If _promise_ is not an Object, throw a *TypeError* exception.\n          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).\n          1. Assert: IsConstructor(_C_) is *true*.\n          1. If IsCallable(_onFinally_) is *false*, then\n            1. Let _thenFinally_ be _onFinally_.\n            1. Let _catchFinally_ be _onFinally_.\n          1. Else,\n            1. Let _thenFinallyClosure_ be a new Abstract Closure with parameters (_value_) that captures _onFinally_ and _C_ and performs the following steps when called:\n              1. Let _result_ be ? Call(_onFinally_, *undefined*).\n              1. Let _p_ be ? PromiseResolve(_C_, _result_).\n              1. Let _returnValue_ be a new Abstract Closure with no parameters that captures _value_ and performs the following steps when called:\n                1. Return _value_.\n              1. Let _valueThunk_ be CreateBuiltinFunction(_returnValue_, 0, *\"\"*, « »).\n              1. Return ? Invoke(_p_, *\"then\"*, « _valueThunk_ »).\n            1. Let _thenFinally_ be CreateBuiltinFunction(_thenFinallyClosure_, 1, *\"\"*, « »).\n            1. Let _catchFinallyClosure_ be a new Abstract Closure with parameters (_reason_) that captures _onFinally_ and _C_ and performs the following steps when called:\n              1. Let _result_ be ? Call(_onFinally_, *undefined*).\n              1. Let _p_ be ? PromiseResolve(_C_, _result_).\n              1. Let _throwReason_ be a new Abstract Closure with no parameters that captures _reason_ and performs the following steps when called:\n                1. Return ThrowCompletion(_reason_).\n              1. Let _thrower_ be CreateBuiltinFunction(_throwReason_, 0, *\"\"*, « »).\n              1. Return ? Invoke(_p_, *\"then\"*, « _thrower_ »).\n            1. Let _catchFinally_ be CreateBuiltinFunction(_catchFinallyClosure_, 1, *\"\"*, « »).\n          1. Return ? Invoke(_promise_, *\"then\"*, « _thenFinally_, _catchFinally_ »).\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.prototype.finally",
        "name" : "INTRINSICS.Promise.prototype.finally",
        "htmlId" : "sec-promise.prototype.finally",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2593,
    [
      "INTRINSICS.Map.prototype.forEach",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _entries_ be _M_.[[MapData]].\n          1. Let _numEntries_ be the number of elements in _entries_.\n          1. Let _index_ be 0.\n          1. Repeat, while _index_ < _numEntries_,\n            1. Let _e_ be _entries_[_index_].\n            1. Set _index_ to _index_ + 1.\n            1. If _e_.[[Key]] is not ~empty~, then\n              1. Perform ? Call(_callbackfn_, _thisArg_, « _e_.[[Value]], _e_.[[Key]], _M_ »).\n              1. NOTE: The number of elements in _entries_ may have increased during execution of _callbackfn_.\n              1. Set _numEntries_ to the number of elements in _entries_.\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Map.prototype.forEach",
        "name" : "INTRINSICS.Map.prototype.forEach",
        "htmlId" : "sec-map.prototype.foreach",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1029,
    [
      "Record[FunctionEnvironmentRecord].HasSuperBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[FunctionEnvironmentRecord]"
        ]
      ],
      "\n            1. If _envRec_.[[ThisBindingStatus]] is ~lexical~, return *false*.\n            1. If _envRec_.[[FunctionObject]].[[HomeObject]] is *undefined*, return *false*; otherwise, return *true*.\n          ",
      {
        "normalizedName" : "Record[FunctionEnvironmentRecord].HasSuperBinding",
        "name" : "Record[FunctionEnvironmentRecord].HasSuperBinding",
        "htmlId" : "sec-function-environment-records-hassuperbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "FunctionEnvironmentRecord",
          "HasSuperBinding"
        ]
      }
    ]
  ],
  [
    895,
    [
      "ArrayBindingPattern[2,1].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[2]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.\n        1. If |Elision| is present, then\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[2,1].IteratorBindingInitialization",
        "name" : "ArrayBindingPattern[2,1].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1149,
    [
      "StringGetOwnProperty",
      0,
      [
        [
          "S",
          false,
          "Unknown[\"ObjectThatHasA[[StringData]]InternalSlot\"]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. If _P_ is not a String, return *undefined*.\n          1. Let _index_ be CanonicalNumericIndexString(_P_).\n          1. If _index_ is *undefined*, return *undefined*.\n          1. If IsIntegralNumber(_index_) is *false*, return *undefined*.\n          1. If _index_ is *-0*<sub>𝔽</sub>, return *undefined*.\n          1. Let _str_ be _S_.[[StringData]].\n          1. Assert: _str_ is a String.\n          1. Let _len_ be the length of _str_.\n          1. If ℝ(_index_) < 0 or _len_ ≤ ℝ(_index_), return *undefined*.\n          1. Let _resultStr_ be the substring of _str_ from ℝ(_index_) to ℝ(_index_) + 1.\n          1. Return the PropertyDescriptor { [[Value]]: _resultStr_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }.\n        ",
      {
        "normalizedName" : "StringGetOwnProperty",
        "name" : "StringGetOwnProperty",
        "htmlId" : "sec-stringgetownproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    964,
    [
      "RelationalExpression[2,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[2]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "RelationalExpression[2,0].AssignmentTargetType",
        "name" : "RelationalExpression[2,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : ">"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    626,
    [
      "DefaultClause[0,1].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "DefaultClause[0,1].ContainsUndefinedBreakTarget",
        "name" : "DefaultClause[0,1].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    915,
    [
      "CallExpression[5,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[5]]"
        ]
      ],
      "\n        1. Return ~simple~.\n      ",
      {
        "normalizedName" : "CallExpression[5,0].AssignmentTargetType",
        "name" : "CallExpression[5,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1556,
    [
      "ObjectBindingPattern[0,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectBindingPattern[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ObjectBindingPattern[0,0].ContainsExpression",
        "name" : "ObjectBindingPattern[0,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ObjectBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    769,
    [
      "LogicalANDExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[LogicalANDExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "LogicalANDExpression[1,0].IsFunctionDefinition",
        "name" : "LogicalANDExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LogicalANDExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LogicalANDExpression"
              },
              {
                "type" : "terminal",
                "value" : "&&"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseORExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2542,
    [
      "INTRINSICS.TypedArray.prototype.filter",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _kept_ be a new empty List.\n          1. Let _captured_ be 0.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Let _selected_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n            1. If _selected_ is *true*, then\n              1. Append _kValue_ to _kept_.\n              1. Set _captured_ to _captured_ + 1.\n            1. Set _k_ to _k_ + 1.\n          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_captured_) »).\n          1. Let _n_ be 0.\n          1. For each element _e_ of _kept_, do\n            1. Perform ! Set(_A_, ! ToString(𝔽(_n_)), _e_, *true*).\n            1. Set _n_ to _n_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.filter",
        "name" : "INTRINSICS.TypedArray.prototype.filter",
        "htmlId" : "sec-%typedarray%.prototype.filter",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1460,
    [
      "WhileStatement[0,0].WhileLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[WhileStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _V_ be *undefined*.\n          1. Repeat,\n            1. Let _exprRef_ be ? Evaluation of |Expression|.\n            1. Let _exprValue_ be ? GetValue(_exprRef_).\n            1. If ToBoolean(_exprValue_) is *false*, return _V_.\n            1. Let _stmtResult_ be Completion(Evaluation of |Statement|).\n            1. If LoopContinues(_stmtResult_, _labelSet_) is *false*, return ? UpdateEmpty(_stmtResult_, _V_).\n            1. If _stmtResult_.[[Value]] is not ~empty~, set _V_ to _stmtResult_.[[Value]].\n        ",
      {
        "normalizedName" : "WhileStatement[0,0].WhileLoopEvaluation",
        "name" : "WhileStatement[0,0].WhileLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-whileloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "WhileLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2289,
    [
      "ClassAtom[0,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassAtom[0]]"
        ]
      ],
      "\n          1. Return the numeric value of U+002D (HYPHEN-MINUS).\n        ",
      {
        "normalizedName" : "ClassAtom[0,0].CharacterValue",
        "name" : "ClassAtom[0,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassAtom",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "-"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2647,
    [
      "INTRINSICS.get ArrayBuffer.prototype.detached",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. Return IsDetachedBuffer(_O_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get ArrayBuffer.prototype.detached",
        "name" : "INTRINSICS.get ArrayBuffer.prototype.detached",
        "htmlId" : "sec-get-arraybuffer.prototype.detached",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    943,
    [
      "LeftHandSideExpression[2,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[LeftHandSideExpression[2]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "LeftHandSideExpression[2,0].AssignmentTargetType",
        "name" : "LeftHandSideExpression[2,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "LeftHandSideExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1022,
    [
      "Record[ObjectEnvironmentRecord].GetBindingValue",
      3,
      [
        [
          "envRec",
          false,
          "Record[ObjectEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "S",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n            1. Let _value_ be ? HasProperty(_bindingObject_, _N_).\n            1. If _value_ is *false*, then\n              1. If _S_ is *false*, return *undefined*; otherwise throw a *ReferenceError* exception.\n            1. Return ? Get(_bindingObject_, _N_).\n          ",
      {
        "normalizedName" : "Record[ObjectEnvironmentRecord].GetBindingValue",
        "name" : "Record[ObjectEnvironmentRecord].GetBindingValue",
        "htmlId" : "sec-object-environment-records-getbindingvalue-n-s",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ObjectEnvironmentRecord",
          "GetBindingValue"
        ]
      }
    ]
  ],
  [
    2252,
    [
      "INTRINSICS.String.prototype.normalize",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. If _form_ is *undefined*, let _f_ be *\"NFC\"*.\n          1. Else, let _f_ be ? ToString(_form_).\n          1. If _f_ is not one of *\"NFC\"*, *\"NFD\"*, *\"NFKC\"*, or *\"NFKD\"*, throw a *RangeError* exception.\n          1. Let _ns_ be the String value that is the result of normalizing _S_ into the normalization form named by _f_ as specified in <a href=\"https://www.unicode.org/versions/latest/ch03.pdf\">the latest Unicode Standard, Normalization Forms</a>.\n          1. Return _ns_.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.normalize",
        "name" : "INTRINSICS.String.prototype.normalize",
        "htmlId" : "sec-string.prototype.normalize",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2664,
    [
      "GetViewByteLength",
      0,
      [
        [
          "viewRecord",
          false,
          "Record[DataViewWithBufferWitnessRecord]"
        ]
      ],
      "\n          1. Assert: IsViewOutOfBounds(_viewRecord_) is *false*.\n          1. Let _view_ be _viewRecord_.[[Object]].\n          1. If _view_.[[ByteLength]] is not ~auto~, return _view_.[[ByteLength]].\n          1. Assert: IsFixedLengthArrayBuffer(_view_.[[ViewedArrayBuffer]]) is *false*.\n          1. Let _byteOffset_ be _view_.[[ByteOffset]].\n          1. Let _byteLength_ be _viewRecord_.[[CachedBufferByteLength]].\n          1. Assert: _byteLength_ is not ~detached~.\n          1. Return _byteLength_ - _byteOffset_.\n        ",
      {
        "normalizedName" : "GetViewByteLength",
        "name" : "GetViewByteLength",
        "htmlId" : "sec-getviewbytelength",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1293,
    [
      "SubstitutionTemplate[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[SubstitutionTemplate[0]]"
        ]
      ],
      "\n          1. Let _head_ be the TV of |TemplateHead| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.\n          1. Let _subRef_ be ? Evaluation of |Expression|.\n          1. Let _sub_ be ? GetValue(_subRef_).\n          1. Let _middle_ be ? ToString(_sub_).\n          1. Let _tail_ be ? Evaluation of |TemplateSpans|.\n          1. Return the string-concatenation of _head_, _middle_, and _tail_.\n        ",
      {
        "normalizedName" : "SubstitutionTemplate[0,0].Evaluation",
        "name" : "SubstitutionTemplate[0,0].Evaluation",
        "htmlId" : "sec-template-literals-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SubstitutionTemplate",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateHead"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateSpans"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2278,
    [
      "INTRINSICS.StringIteratorPrototype.next",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Return ? <emu-meta suppress-effects=\"user-code\">GeneratorResume(*this* value, ~empty~, *\"%StringIteratorPrototype%\"*)</emu-meta>.\n          ",
      {
        "normalizedName" : "INTRINSICS.StringIteratorPrototype.next",
        "name" : "INTRINSICS.StringIteratorPrototype.next",
        "htmlId" : "sec-%stringiteratorprototype%.next",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2553,
    [
      "INTRINSICS.get TypedArray.prototype.length",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n          1. Assert: _O_ has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *+0*<sub>𝔽</sub>.\n          1. Let _length_ be TypedArrayLength(_taRecord_).\n          1. Return 𝔽(_length_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get TypedArray.prototype.length",
        "name" : "INTRINSICS.get TypedArray.prototype.length",
        "htmlId" : "sec-get-%typedarray%.prototype.length",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    668,
    [
      "ForStatement[2,2].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[2,2].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[2,2].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    155,
    [
      "SameValueZero",
      0,
      [
        [
          "x",
          false,
          "ESValue"
        ],
        [
          "y",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If Type(_x_) is not Type(_y_), return *false*.\n        1. If _x_ is a Number, then\n          1. Return Number::sameValueZero(_x_, _y_).\n        1. Return SameValueNonNumber(_x_, _y_).\n      ",
      {
        "normalizedName" : "SameValueZero",
        "name" : "SameValueZero",
        "htmlId" : "sec-samevaluezero",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    198,
    [
      "IteratorValue",
      0,
      [
        [
          "iterResult",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Return ? Get(_iterResult_, *\"value\"*).\n      ",
      {
        "normalizedName" : "IteratorValue",
        "name" : "IteratorValue",
        "htmlId" : "sec-iteratorvalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1177,
    [
      "Record[ModuleNamespaceExoticObject].GetPrototypeOf",
      4,
      [
        [
          "this",
          false,
          "Record[ModuleNamespaceExoticObject]"
        ]
      ],
      "\n          1. Return *null*.\n        ",
      {
        "normalizedName" : "Record[ModuleNamespaceExoticObject].GetPrototypeOf",
        "name" : "Record[ModuleNamespaceExoticObject].GetPrototypeOf",
        "htmlId" : "sec-module-namespace-exotic-objects-getprototypeof",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleNamespaceExoticObject",
          "[[GetPrototypeOf]]"
        ]
      }
    ]
  ],
  [
    1381,
    [
      "LogicalORExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[LogicalORExpression[1]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |LogicalORExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _lbool_ be ToBoolean(_lval_).\n        1. If _lbool_ is *true*, return _lval_.\n        1. Let _rref_ be ? Evaluation of |LogicalANDExpression|.\n        1. Return ? GetValue(_rref_).\n      ",
      {
        "normalizedName" : "LogicalORExpression[1,0].Evaluation",
        "name" : "LogicalORExpression[1,0].Evaluation",
        "htmlId" : "sec-binary-logical-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LogicalORExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LogicalORExpression"
              },
              {
                "type" : "terminal",
                "value" : "||"
              },
              {
                "type" : "nonterminal",
                "value" : "LogicalANDExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2461,
    [
      "INTRINSICS.RegExp.prototype[@@split]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _rx_ be the *this* value.\n          1. If _rx_ is not an Object, throw a *TypeError* exception.\n          1. Let _S_ be ? ToString(_string_).\n          1. Let _C_ be ? SpeciesConstructor(_rx_, %RegExp%).\n          1. Let _flags_ be ? ToString(? Get(_rx_, *\"flags\"*)).\n          1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _unicodeMatching_ be *true*.\n          1. Else, let _unicodeMatching_ be *false*.\n          1. If _flags_ contains *\"y\"*, let _newFlags_ be _flags_.\n          1. Else, let _newFlags_ be the string-concatenation of _flags_ and *\"y\"*.\n          1. Let _splitter_ be ? Construct(_C_, « _rx_, _newFlags_ »).\n          1. Let _A_ be ! ArrayCreate(0).\n          1. Let _lengthA_ be 0.\n          1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1; else let _lim_ be ℝ(? ToUint32(_limit_)).\n          1. If _lim_ = 0, return _A_.\n          1. If _S_ is the empty String, then\n            1. Let _z_ be ? RegExpExec(_splitter_, _S_).\n            1. If _z_ is not *null*, return _A_.\n            1. Perform ! CreateDataPropertyOrThrow(_A_, *\"0\"*, _S_).\n            1. Return _A_.\n          1. Let _size_ be the length of _S_.\n          1. Let _p_ be 0.\n          1. Let _q_ be _p_.\n          1. Repeat, while _q_ < _size_,\n            1. Perform ? Set(_splitter_, *\"lastIndex\"*, 𝔽(_q_), *true*).\n            1. Let _z_ be ? RegExpExec(_splitter_, _S_).\n            1. If _z_ is *null*, then\n              1. Set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).\n            1. Else,\n              1. Let _e_ be ℝ(? ToLength(? Get(_splitter_, *\"lastIndex\"*))).\n              1. Set _e_ to min(_e_, _size_).\n              1. If _e_ = _p_, then\n                1. Set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).\n              1. Else,\n                1. Let _T_ be the substring of _S_ from _p_ to _q_.\n                1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).\n                1. Set _lengthA_ to _lengthA_ + 1.\n                1. If _lengthA_ = _lim_, return _A_.\n                1. Set _p_ to _e_.\n                1. Let _numberOfCaptures_ be ? LengthOfArrayLike(_z_).\n                1. Set _numberOfCaptures_ to max(_numberOfCaptures_ - 1, 0).\n                1. Let _i_ be 1.\n                1. Repeat, while _i_ ≤ _numberOfCaptures_,\n                  1. Let _nextCapture_ be ? Get(_z_, ! ToString(𝔽(_i_))).\n                  1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _nextCapture_).\n                  1. Set _i_ to _i_ + 1.\n                  1. Set _lengthA_ to _lengthA_ + 1.\n                  1. If _lengthA_ = _lim_, return _A_.\n                1. Set _q_ to _p_.\n          1. Let _T_ be the substring of _S_ from _p_ to _size_.\n          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.RegExp.prototype[@@split]",
        "name" : "INTRINSICS.RegExp.prototype[@@split]",
        "htmlId" : "sec-regexp.prototype-@@split",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    108,
    [
      "CopyDataBlockBytes",
      0,
      [
        [
          "toBlock",
          false,
          "Record[DataBlock | SharedDataBlock]"
        ],
        [
          "toIndex",
          false,
          "Int[0+]"
        ],
        [
          "fromBlock",
          false,
          "Record[DataBlock | SharedDataBlock]"
        ],
        [
          "fromIndex",
          false,
          "Int[0+]"
        ],
        [
          "count",
          false,
          "Int[0+]"
        ]
      ],
      "\n          1. Assert: _fromBlock_ and _toBlock_ are distinct values.\n          1. Let _fromSize_ be the number of bytes in _fromBlock_.\n          1. Assert: _fromIndex_ + _count_ ≤ _fromSize_.\n          1. Let _toSize_ be the number of bytes in _toBlock_.\n          1. Assert: _toIndex_ + _count_ ≤ _toSize_.\n          1. Repeat, while _count_ > 0,\n            1. If _fromBlock_ is a Shared Data Block, then\n              1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n              1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n              1. Let _bytes_ be a List whose sole element is a nondeterministically chosen byte value.\n              1. NOTE: In implementations, _bytes_ is the result of a non-atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.\n              1. Let _readEvent_ be ReadSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _fromBlock_, [[ByteIndex]]: _fromIndex_, [[ElementSize]]: 1 }.\n              1. Append _readEvent_ to _eventsRecord_.[[EventList]].\n              1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _bytes_ } to _execution_.[[ChosenValues]].\n              1. If _toBlock_ is a Shared Data Block, then\n                1. Append WriteSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _toBlock_, [[ByteIndex]]: _toIndex_, [[ElementSize]]: 1, [[Payload]]: _bytes_ } to _eventsRecord_.[[EventList]].\n              1. Else,\n                1. Set _toBlock_[_toIndex_] to _bytes_[0].\n            1. Else,\n              1. Assert: _toBlock_ is not a Shared Data Block.\n              1. Set _toBlock_[_toIndex_] to _fromBlock_[_fromIndex_].\n            1. Set _toIndex_ to _toIndex_ + 1.\n            1. Set _fromIndex_ to _fromIndex_ + 1.\n            1. Set _count_ to _count_ - 1.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "CopyDataBlockBytes",
        "name" : "CopyDataBlockBytes",
        "htmlId" : "sec-copydatablockbytes",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    330,
    [
      "DefaultClause[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the LexicallyScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "DefaultClause[0,0].LexicallyScopedDeclarations",
        "name" : "DefaultClause[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2329,
    [
      "ClassString[0,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassString[0]]"
        ]
      ],
      "\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "ClassString[0,0].MayContainStrings",
        "name" : "ClassString[0,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassString",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2842,
    [
      "INTRINSICS.Reflect.getOwnPropertyDescriptor",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n        1. Let _desc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_key_).\n        1. Return FromPropertyDescriptor(_desc_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.getOwnPropertyDescriptor",
        "name" : "INTRINSICS.Reflect.getOwnPropertyDescriptor",
        "htmlId" : "sec-reflect.getownpropertydescriptor",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    462,
    [
      "ForInOfStatement[7,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[7]]"
        ]
      ],
      "\n        1. Let _declarations1_ be « |ForBinding| ».\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[7,0].VarScopedDeclarations",
        "name" : "ForInOfStatement[7,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    932,
    [
      "PrimaryExpression[11,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[11]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "PrimaryExpression[11,0].AssignmentTargetType",
        "name" : "PrimaryExpression[11,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 11,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1061,
    [
      "ResolvePrivateIdentifier",
      0,
      [
        [
          "privEnv",
          false,
          "Record[PrivateEnvironmentRecord]"
        ],
        [
          "identifier",
          false,
          "String"
        ]
      ],
      "\n          1. Let _names_ be _privEnv_.[[Names]].\n          1. For each Private Name _pn_ of _names_, do\n            1. If _pn_.[[Description]] is _identifier_, then\n              1. Return _pn_.\n          1. Let _outerPrivEnv_ be _privEnv_.[[OuterPrivateEnvironment]].\n          1. Assert: _outerPrivEnv_ is not *null*.\n          1. Return ResolvePrivateIdentifier(_outerPrivEnv_, _identifier_).\n        ",
      {
        "normalizedName" : "ResolvePrivateIdentifier",
        "name" : "ResolvePrivateIdentifier",
        "htmlId" : "sec-resolve-private-identifier",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1952,
    [
      "ModuleBody[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleBody[0]]"
        ]
      ],
      "\n          1. Let _result_ be Completion(Evaluation of |ModuleItemList|).\n          1. If _result_ is a normal completion and _result_.[[Value]] is ~empty~, then\n            1. Return *undefined*.\n          1. Return ? _result_.\n        ",
      {
        "normalizedName" : "ModuleBody[0,0].Evaluation",
        "name" : "ModuleBody[0,0].Evaluation",
        "htmlId" : "sec-module-semantics-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2710,
    [
      "AtomicReadModifyWrite",
      0,
      [
        [
          "typedArray",
          false,
          "ESValue"
        ],
        [
          "index",
          false,
          "ESValue"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "op",
          false,
          "Unknown[\"ReadmodifywriteModificationFunction\"]"
        ]
      ],
      "\n          1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).\n          1. If _typedArray_.[[ContentType]] is ~bigint~, let _v_ be ? ToBigInt(_value_).\n          1. Otherwise, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).\n          1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).\n          1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n          1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n          1. Return GetModifySetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, _op_).\n        ",
      {
        "normalizedName" : "AtomicReadModifyWrite",
        "name" : "AtomicReadModifyWrite",
        "htmlId" : "sec-atomicreadmodifywrite",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1820,
    [
      "TryStatement[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Finally| with argument _call_.\n      ",
      {
        "normalizedName" : "TryStatement[2,0].HasCallInTailPosition",
        "name" : "TryStatement[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1112,
    [
      "PrepareForOrdinaryCall",
      0,
      [
        [
          "F",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "newTarget",
          false,
          "Record[Object] | Undefined"
        ]
      ],
      "\n          1. Let _callerContext_ be the running execution context.\n          1. Let _calleeContext_ be a new ECMAScript code execution context.\n          1. Set the Function of _calleeContext_ to _F_.\n          1. Let _calleeRealm_ be _F_.[[Realm]].\n          1. Set the Realm of _calleeContext_ to _calleeRealm_.\n          1. Set the ScriptOrModule of _calleeContext_ to _F_.[[ScriptOrModule]].\n          1. Let _localEnv_ be NewFunctionEnvironment(_F_, _newTarget_).\n          1. Set the LexicalEnvironment of _calleeContext_ to _localEnv_.\n          1. Set the VariableEnvironment of _calleeContext_ to _localEnv_.\n          1. Set the PrivateEnvironment of _calleeContext_ to _F_.[[PrivateEnvironment]].\n          1. If _callerContext_ is not already suspended, suspend _callerContext_.\n          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.\n          1. NOTE: Any exception objects produced after this point are associated with _calleeRealm_.\n          1. Return _calleeContext_.\n        ",
      {
        "normalizedName" : "PrepareForOrdinaryCall",
        "name" : "PrepareForOrdinaryCall",
        "htmlId" : "sec-prepareforordinarycall",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2578,
    [
      "CompareTypedArrayElements",
      0,
      [
        [
          "x",
          false,
          "Number | BigInt"
        ],
        [
          "y",
          false,
          "Number | BigInt"
        ],
        [
          "comparefn",
          false,
          "Record[FunctionObject] | Undefined"
        ]
      ],
      "\n          1. Assert: _x_ is a Number and _y_ is a Number, or _x_ is a BigInt and _y_ is a BigInt.\n          1. If _comparefn_ is not *undefined*, then\n            1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, « _x_, _y_ »)).\n            1. If _v_ is *NaN*, return *+0*<sub>𝔽</sub>.\n            1. Return _v_.\n          1. If _x_ and _y_ are both *NaN*, return *+0*<sub>𝔽</sub>.\n          1. If _x_ is *NaN*, return *1*<sub>𝔽</sub>.\n          1. If _y_ is *NaN*, return *-1*<sub>𝔽</sub>.\n          1. If _x_ < _y_, return *-1*<sub>𝔽</sub>.\n          1. If _x_ > _y_, return *1*<sub>𝔽</sub>.\n          1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.\n          1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n          1. Return *+0*<sub>𝔽</sub>.\n        ",
      {
        "normalizedName" : "CompareTypedArrayElements",
        "name" : "CompareTypedArrayElements",
        "htmlId" : "sec-comparetypedarrayelements",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1688,
    [
      "FieldDefinition[0,0].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[FieldDefinition[0]]"
        ]
      ],
      "\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      ",
      {
        "normalizedName" : "FieldDefinition[0,0].PrivateBoundIdentifiers",
        "name" : "FieldDefinition[0,0].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FieldDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2086,
    [
      "INTRINSICS.Function.prototype.call",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _func_ be the *this* value.\n          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.\n          1. Perform PrepareForTailCall().\n          1. [id=\"step-function-proto-call-call\"] Return ? Call(_func_, _thisArg_, _args_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Function.prototype.call",
        "name" : "INTRINSICS.Function.prototype.call",
        "htmlId" : "sec-function.prototype.call",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1477,
    [
      "ForBodyEvaluation",
      0,
      [
        [
          "test",
          false,
          "Ast[Expression] | Enum[~empty~]"
        ],
        [
          "increment",
          false,
          "Ast[Expression] | Enum[~empty~]"
        ],
        [
          "stmt",
          false,
          "Ast[Statement]"
        ],
        [
          "perIterationBindings",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _V_ be *undefined*.\n          1. Perform ? CreatePerIterationEnvironment(_perIterationBindings_).\n          1. Repeat,\n            1. If _test_ is not ~empty~, then\n              1. Let _testRef_ be ? Evaluation of _test_.\n              1. Let _testValue_ be ? GetValue(_testRef_).\n              1. If ToBoolean(_testValue_) is *false*, return _V_.\n            1. Let _result_ be Completion(Evaluation of _stmt_).\n            1. If LoopContinues(_result_, _labelSet_) is *false*, return ? UpdateEmpty(_result_, _V_).\n            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].\n            1. Perform ? CreatePerIterationEnvironment(_perIterationBindings_).\n            1. If _increment_ is not ~empty~, then\n              1. Let _incRef_ be ? Evaluation of _increment_.\n              1. Perform ? GetValue(_incRef_).\n        ",
      {
        "normalizedName" : "ForBodyEvaluation",
        "name" : "ForBodyEvaluation",
        "htmlId" : "sec-forbodyevaluation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    912,
    [
      "IdentifierReference[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierReference[1]]"
        ]
      ],
      "\n        1. Return ~simple~.\n      ",
      {
        "normalizedName" : "IdentifierReference[1,0].AssignmentTargetType",
        "name" : "IdentifierReference[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IdentifierReference",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "yield"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    685,
    [
      "CaseBlock[1,1].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "CaseBlock[1,1].ContainsUndefinedContinueTarget",
        "name" : "CaseBlock[1,1].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    521,
    [
      "StatementList[1,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n        1. If _hasDuplicates_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of |StatementListItem| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "StatementList[1,0].ContainsDuplicateLabels",
        "name" : "StatementList[1,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1171,
    [
      "TypedArrayLength",
      0,
      [
        [
          "taRecord",
          false,
          "Record[TypedArrayWithBufferWitnessRecord]"
        ]
      ],
      "\n          1. Assert: IsTypedArrayOutOfBounds(_taRecord_) is *false*.\n          1. Let _O_ be _taRecord_.[[Object]].\n          1. If _O_.[[ArrayLength]] is not ~auto~, return _O_.[[ArrayLength]].\n          1. Assert: IsFixedLengthArrayBuffer(_O_.[[ViewedArrayBuffer]]) is *false*.\n          1. Let _byteOffset_ be _O_.[[ByteOffset]].\n          1. Let _elementSize_ be TypedArrayElementSize(_O_).\n          1. Let _byteLength_ be _taRecord_.[[CachedBufferByteLength]].\n          1. Assert: _byteLength_ is not ~detached~.\n          1. Return floor((_byteLength_ - _byteOffset_) / _elementSize_).\n        ",
      {
        "normalizedName" : "TypedArrayLength",
        "name" : "TypedArrayLength",
        "htmlId" : "sec-typedarraylength",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2770,
    [
      "INTRINSICS.Promise.any",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the *this* value.\n          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).\n          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).\n          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).\n          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).\n          1. Let _result_ be Completion(PerformPromiseAny(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).\n          1. If _result_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Return ? _result_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.any",
        "name" : "INTRINSICS.Promise.any",
        "htmlId" : "sec-promise.any",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    983,
    [
      "AssignmentExpression[3,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[3]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "AssignmentExpression[3,0].AssignmentTargetType",
        "name" : "AssignmentExpression[3,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncArrowFunction"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2075,
    [
      "INTRINSICS.Object.prototype.valueOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return ? ToObject(*this* value).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.prototype.valueOf",
        "name" : "INTRINSICS.Object.prototype.valueOf",
        "htmlId" : "sec-object.prototype.valueof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2418,
    [
      "ClassSetOperand[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSetOperand[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return CompileToCharSet of |NestedClass| with argument _rer_.\n        ",
      {
        "normalizedName" : "ClassSetOperand[0,0].CompileToCharSet",
        "name" : "ClassSetOperand[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassSetOperand",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NestedClass"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1198,
    [
      "Record[ProxyExoticObject].Get",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"get\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[Get]]</emu-meta>(_P_, _Receiver_).\n        1. Let _trapResult_ be ? Call(_trap_, _handler_, « _target_, _P_, _Receiver_ »).\n        1. Let _targetDesc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. If _targetDesc_ is not *undefined* and _targetDesc_.[[Configurable]] is *false*, then\n          1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Writable]] is *false*, then\n            1. If SameValue(_trapResult_, _targetDesc_.[[Value]]) is *false*, throw a *TypeError* exception.\n          1. If IsAccessorDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Get]] is *undefined*, then\n            1. If _trapResult_ is not *undefined*, throw a *TypeError* exception.\n        1. Return _trapResult_.\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].Get",
        "name" : "Record[ProxyExoticObject].Get",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[Get]]"
        ]
      }
    ]
  ],
  [
    130,
    [
      "RoundMVResult",
      0,
      [
        [
          "n",
          false,
          "Unknown[\"MathematicalValue\"]"
        ]
      ],
      "\n            1. If the decimal representation of _n_ has 20 or fewer significant digits, return 𝔽(_n_).\n            1. Let _option1_ be the mathematical value denoted by the result of replacing each significant digit in the decimal representation of _n_ after the 20th with a 0 digit.\n            1. Let _option2_ be the mathematical value denoted by the result of replacing each significant digit in the decimal representation of _n_ after the 20th with a 0 digit and then incrementing it at the 20th position (with carrying as necessary).\n            1. Let _chosen_ be an implementation-defined choice of either _option1_ or _option2_.\n            1. Return 𝔽(_chosen_).\n          ",
      {
        "normalizedName" : "RoundMVResult",
        "name" : "RoundMVResult",
        "htmlId" : "sec-roundmvresult",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1841,
    [
      "RelationalExpression[5,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[5]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[5,0].HasCallInTailPosition",
        "name" : "RelationalExpression[5,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "instanceof"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1396,
    [
      "ArrayAssignmentPattern[0,0].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayAssignmentPattern[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Return ? IteratorClose(_iteratorRecord_, NormalCompletion(~unused~)).\n        ",
      {
        "normalizedName" : "ArrayAssignmentPattern[0,0].DestructuringAssignmentEvaluation",
        "name" : "ArrayAssignmentPattern[0,0].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrayAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2439,
    [
      "NonEmptyClassString[0,0].CompileClassSetString",
      2,
      [
        [
          "this",
          false,
          "Ast[NonEmptyClassString[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _cs_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.\n          1. Let _s1_ be the sequence of characters that is the single CharSetElement of _cs_.\n          1. If |NonEmptyClassString| is present, then\n            1. Let _s2_ be CompileClassSetString of |NonEmptyClassString| with argument _rer_.\n            1. Return the concatenation of _s1_ and _s2_.\n          1. Return _s1_.\n        ",
      {
        "normalizedName" : "NonEmptyClassString[0,0].CompileClassSetString",
        "name" : "NonEmptyClassString[0,0].CompileClassSetString",
        "htmlId" : "sec-compileclasssetstring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileClassSetString",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NonEmptyClassString",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetCharacter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1926,
    [
      "ExportDeclaration[3,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[3]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ExportDeclaration[3,0].ModuleRequests",
        "name" : "ExportDeclaration[3,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    399,
    [
      "CaseBlock[1,3].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _names1_ be the VarDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be VarDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the VarDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,3].VarDeclaredNames",
        "name" : "CaseBlock[1,3].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2365,
    [
      "Quantifier[1,0].CompileQuantifier",
      2,
      [
        [
          "this",
          false,
          "Ast[Quantifier[1]]"
        ]
      ],
      "\n          1. Let _qp_ be CompileQuantifierPrefix of |QuantifierPrefix|.\n          1. Return the Record { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *false* }.\n        ",
      {
        "normalizedName" : "Quantifier[1,0].CompileQuantifier",
        "name" : "Quantifier[1,0].CompileQuantifier",
        "htmlId" : "sec-compilequantifier",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileQuantifier",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Quantifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "QuantifierPrefix"
              },
              {
                "type" : "terminal",
                "value" : "?"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1474,
    [
      "ForStatement[2,1].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n          1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.\n          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.\n          1. For each element _dn_ of _boundNames_, do\n            1. If _isConst_ is *true*, then\n              1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).\n            1. Else,\n              1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).\n          1. Set the running execution context's LexicalEnvironment to _loopEnv_.\n          1. Let _forDcl_ be Completion(Evaluation of |LexicalDeclaration|).\n          1. If _forDcl_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n            1. Return ? _forDcl_.\n          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be a new empty List.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).\n          1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n          1. Return ? _bodyResult_.\n        ",
      {
        "normalizedName" : "ForStatement[2,1].ForLoopEvaluation",
        "name" : "ForStatement[2,1].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2350,
    [
      "Term[2,0].CompileSubpattern",
      2,
      [
        [
          "this",
          false,
          "Ast[Term[2]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Let _m_ be CompileAtom of |Atom| with arguments _rer_ and _direction_.\n          1. Let _q_ be CompileQuantifier of |Quantifier|.\n          1. Assert: _q_.[[Min]] ≤ _q_.[[Max]].\n          1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Term|).\n          1. Let _parenCount_ be CountLeftCapturingParensWithin(|Atom|).\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_, _q_, _parenIndex_, and _parenCount_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Return RepeatMatcher(_m_, _q_.[[Min]], _q_.[[Max]], _q_.[[Greedy]], _x_, _c_, _parenIndex_, _parenCount_).\n        ",
      {
        "normalizedName" : "Term[2,0].CompileSubpattern",
        "name" : "Term[2,0].CompileSubpattern",
        "htmlId" : "sec-compilesubpattern",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileSubpattern",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "Term",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Atom"
              },
              {
                "type" : "nonterminal",
                "value" : "Quantifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2725,
    [
      "INTRINSICS.Atomics.xor",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _xor_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:\n          1. Return ByteListBitwiseOp(`^`, _xBytes_, _yBytes_).\n        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _xor_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.xor",
        "name" : "INTRINSICS.Atomics.xor",
        "htmlId" : "sec-atomics.xor",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1699,
    [
      "AsyncMethod[0,0].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncMethod[0]]"
        ]
      ],
      "\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      ",
      {
        "normalizedName" : "AsyncMethod[0,0].PrivateBoundIdentifiers",
        "name" : "AsyncMethod[0,0].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2401,
    [
      "CharacterClassEscape[4,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[4]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return MaybeSimpleCaseFolding(_rer_, WordCharacters(_rer_)).\n        ",
      {
        "normalizedName" : "CharacterClassEscape[4,0].CompileToCharSet",
        "name" : "CharacterClassEscape[4,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "w"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1594,
    [
      "AsyncArrowBindingIdentifier[0,0].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowBindingIdentifier[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "AsyncArrowBindingIdentifier[0,0].IsSimpleParameterList",
        "name" : "AsyncArrowBindingIdentifier[0,0].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncArrowBindingIdentifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2212,
    [
      "INTRINSICS.Date.prototype.setMinutes",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _m_ be ? ToNumber(_min_).\n          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Set _t_ to LocalTime(_t_).\n          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).\n          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).\n          1. Let _u_ be TimeClip(UTC(_date_)).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setMinutes",
        "name" : "INTRINSICS.Date.prototype.setMinutes",
        "htmlId" : "sec-date.prototype.setminutes",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    959,
    [
      "AdditiveExpression[2,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[AdditiveExpression[2]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "AdditiveExpression[2,0].AssignmentTargetType",
        "name" : "AdditiveExpression[2,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "AdditiveExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              },
              {
                "type" : "terminal",
                "value" : "-"
              },
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2171,
    [
      "MinFromTime",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. Return 𝔽(floor(ℝ(_t_ / msPerMinute)) modulo MinutesPerHour).\n        ",
      {
        "normalizedName" : "MinFromTime",
        "name" : "MinFromTime",
        "htmlId" : "sec-minfromtime",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1213,
    [
      "IdentifierStart[0,0].IdentifierCodePoint",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierStart[0]]"
        ]
      ],
      "\n          1. Return the code point matched by |IdentifierStartChar|.\n        ",
      {
        "normalizedName" : "IdentifierStart[0,0].IdentifierCodePoint",
        "name" : "IdentifierStart[0,0].IdentifierCodePoint",
        "htmlId" : "sec-identifiercodepoint",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IdentifierCodePoint",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IdentifierStart",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierStartChar"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    768,
    [
      "BitwiseORExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[BitwiseORExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "BitwiseORExpression[1,0].IsFunctionDefinition",
        "name" : "BitwiseORExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BitwiseORExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BitwiseORExpression"
              },
              {
                "type" : "terminal",
                "value" : "|"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseXORExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    827,
    [
      "FunctionDeclaration[0,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[0,0].Contains",
        "name" : "FunctionDeclaration[0,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2835,
    [
      "Await:cont2",
      7,
      [
        [
          "completion",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _asyncContext_ be the running execution context.\n          1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).\n          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_v_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using NormalCompletion(_v_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using ThrowCompletion(_reason_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n          1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n          1. Let _callerContext_ be the running execution context.\n          1. Resume _callerContext_ passing ~empty~. If _asyncContext_ is ever resumed again, let _completion_ be the Completion Record with which it is resumed.\n          1. Assert: If control reaches here, then _asyncContext_ is the running execution context again.\n          1. Return _completion_.\n        ",
      {
        "normalizedName" : "Await",
        "name" : "Await",
        "htmlId" : "await",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : true,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2051,
    [
      "INTRINSICS.Object.fromEntries:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Perform ? RequireObjectCoercible(_iterable_).\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Assert: _obj_ is an extensible ordinary object with no own properties.\n          1. Let _closure_ be a new Abstract Closure with parameters (_key_, _value_) that captures _obj_ and performs the following steps when called:\n            1. Let _propertyKey_ be ? ToPropertyKey(_key_).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, _propertyKey_, _value_).\n            1. Return *undefined*.\n          1. Let _adder_ be CreateBuiltinFunction(_closure_, 2, *\"\"*, « »).\n          1. Return ? AddEntriesFromIterable(_obj_, _iterable_, _adder_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.fromEntries",
        "name" : "INTRINSICS.Object.fromEntries",
        "htmlId" : "sec-object.fromentries",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2765,
    [
      "INTRINSICS.yet:`Promise.all`ResolveElementFunction",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _F_ be the active function object.\n            1. If _F_.[[AlreadyCalled]] is *true*, return *undefined*.\n            1. Set _F_.[[AlreadyCalled]] to *true*.\n            1. Let _index_ be _F_.[[Index]].\n            1. Let _values_ be _F_.[[Values]].\n            1. Let _promiseCapability_ be _F_.[[Capability]].\n            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].\n            1. Set _values_[_index_] to _x_.\n            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n            1. If _remainingElementsCount_.[[Value]] = 0, then\n              1. Let _valuesArray_ be CreateArrayFromList(_values_).\n              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n            1. Return *undefined*.\n          ",
      {
        "normalizedName" : "INTRINSICS.yet:Promise.allResolveElementFunction",
        "name" : "INTRINSICS.yet:`Promise.all`ResolveElementFunction",
        "htmlId" : "sec-promise.all-resolve-element-functions",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2550,
    [
      "INTRINSICS.TypedArray.prototype.join",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If _separator_ is *undefined*, let _sep_ be *\",\"*.\n          1. Else, let _sep_ be ? ToString(_separator_).\n          1. Let _R_ be the empty String.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _sep_.\n            1. Let _element_ be ! Get(_O_, ! ToString(𝔽(_k_))).\n            1. If _element_ is *undefined*, let _next_ be the empty String; otherwise, let _next_ be ! ToString(_element_).\n            1. Set _R_ to the string-concatenation of _R_ and _next_.\n            1. Set _k_ to _k_ + 1.\n          1. Return _R_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.join",
        "name" : "INTRINSICS.TypedArray.prototype.join",
        "htmlId" : "sec-%typedarray%.prototype.join",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    695,
    [
      "TryStatement[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « ».\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of |Catch| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "TryStatement[0,0].ContainsUndefinedContinueTarget",
        "name" : "TryStatement[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1245,
    [
      "Literal[3,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Literal[3]]"
        ]
      ],
      "\n          1. Return the SV of |StringLiteral| as defined in <emu-xref href=\"#sec-static-semantics-sv\"></emu-xref>.\n        ",
      {
        "normalizedName" : "Literal[3,0].Evaluation",
        "name" : "Literal[3,0].Evaluation",
        "htmlId" : "sec-literals-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "Literal",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StringLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2481,
    [
      "INTRINSICS.get Array[@@species]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return the *this* value.\n        ",
      {
        "normalizedName" : "INTRINSICS.get Array[@@species]",
        "name" : "INTRINSICS.get Array[@@species]",
        "htmlId" : "sec-get-array-@@species",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    636,
    [
      "ModuleItem[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ModuleItem[0,0].ContainsUndefinedBreakTarget",
        "name" : "ModuleItem[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1044,
    [
      "Record[GlobalEnvironmentRecord].HasLexicalDeclaration",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ]
      ],
      "\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. Return ! _DclRec_.HasBinding(_N_).\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].HasLexicalDeclaration",
        "name" : "Record[GlobalEnvironmentRecord].HasLexicalDeclaration",
        "htmlId" : "sec-haslexicaldeclaration",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "HasLexicalDeclaration"
        ]
      }
    ]
  ],
  [
    1066,
    [
      "GetActiveScriptOrModule",
      0,
      [
      ],
      "\n        1. If the execution context stack is empty, return *null*.\n        1. Let _ec_ be the topmost execution context on the execution context stack whose ScriptOrModule component is not *null*.\n        1. If no such execution context exists, return *null*. Otherwise, return _ec_'s ScriptOrModule.\n      ",
      {
        "normalizedName" : "GetActiveScriptOrModule",
        "name" : "GetActiveScriptOrModule",
        "htmlId" : "sec-getactivescriptormodule",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    278,
    [
      "FunctionDeclaration[1,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[1,0].IsConstantDeclaration",
        "name" : "FunctionDeclaration[1,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2620,
    [
      "INTRINSICS.WeakMap.prototype.set",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).\n          1. If CanBeHeldWeakly(_key_) is *false*, throw a *TypeError* exception.\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then\n              1. Set _p_.[[Value]] to _value_.\n              1. Return _M_.\n          1. Let _p_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.\n          1. Append _p_ to _M_.[[WeakMapData]].\n          1. Return _M_.\n        ",
      {
        "normalizedName" : "INTRINSICS.WeakMap.prototype.set",
        "name" : "INTRINSICS.WeakMap.prototype.set",
        "htmlId" : "sec-weakmap.prototype.set",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    868,
    [
      "AsyncMethod[0,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncMethod[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      ",
      {
        "normalizedName" : "AsyncMethod[0,0].ComputedPropertyContains",
        "name" : "AsyncMethod[0,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1445,
    [
      "BindingRestProperty[0,0].RestBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingRestProperty[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ],
        [
          "excludedNames",
          false,
          "List[Record[Symbol] | String]"
        ]
      ],
      "\n          1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).\n          1. Let _restObj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).\n          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _restObj_).\n          1. Return ? InitializeReferencedBinding(_lhs_, _restObj_).\n        ",
      {
        "normalizedName" : "BindingRestProperty[0,0].RestBindingInitialization",
        "name" : "BindingRestProperty[0,0].RestBindingInitialization",
        "htmlId" : "sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "RestBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BindingRestProperty",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "..."
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1528,
    [
      "CaseClause[0,1].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ]
      ],
      "\n        1. Return ? Evaluation of |StatementList|.\n      ",
      {
        "normalizedName" : "CaseClause[0,1].Evaluation",
        "name" : "CaseClause[0,1].Evaluation",
        "htmlId" : "sec-switch-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    780,
    [
      "AssignmentExpression[2,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[2]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[2,0].IsFunctionDefinition",
        "name" : "AssignmentExpression[2,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrowFunction"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1643,
    [
      "GeneratorMethod[0,0].MethodDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorMethod[0]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ],
        [
          "enumerable",
          false,
          "Boolean"
        ]
      ],
      "\n        1. Let _propKey_ be ? Evaluation of |ClassElementName|.\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |GeneratorMethod|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform MakeMethod(_closure_, _object_).\n        1. Perform SetFunctionName(_closure_, _propKey_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_).\n      ",
      {
        "normalizedName" : "GeneratorMethod[0,0].MethodDefinitionEvaluation",
        "name" : "GeneratorMethod[0,0].MethodDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-methoddefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MethodDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2139,
    [
      "INTRINSICS.Math.expm1",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *-∞*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of subtracting 1 from the exponential function of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.expm1",
        "name" : "INTRINSICS.Math.expm1",
        "htmlId" : "sec-math.expm1",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    455,
    [
      "ForInOfStatement[2,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[2]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForInOfStatement[2,0].VarScopedDeclarations",
        "name" : "ForInOfStatement[2,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    883,
    [
      "BindingPattern[1,0].BindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingPattern[1]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n        1. Let _result_ be Completion(IteratorBindingInitialization of |ArrayBindingPattern| with arguments _iteratorRecord_ and _environment_).\n        1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n        1. Return ? _result_.\n      ",
      {
        "normalizedName" : "BindingPattern[1,0].BindingInitialization",
        "name" : "BindingPattern[1,0].BindingInitialization",
        "htmlId" : "sec-runtime-semantics-bindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingPattern",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrayBindingPattern"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2064,
    [
      "INTRINSICS.Object.isSealed",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _O_ is not an Object, return *true*.\n          1. Return ? TestIntegrityLevel(_O_, ~sealed~).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.isSealed",
        "name" : "INTRINSICS.Object.isSealed",
        "htmlId" : "sec-object.issealed",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2369,
    [
      "QuantifierPrefix[3,0].CompileQuantifierPrefix",
      2,
      [
        [
          "this",
          false,
          "Ast[QuantifierPrefix[3]]"
        ]
      ],
      "\n          1. Let _i_ be the MV of |DecimalDigits| (see <emu-xref href=\"#sec-literals-numeric-literals\"></emu-xref>).\n          1. Return the Record { [[Min]]: _i_, [[Max]]: _i_ }.\n        ",
      {
        "normalizedName" : "QuantifierPrefix[3,0].CompileQuantifierPrefix",
        "name" : "QuantifierPrefix[3,0].CompileQuantifierPrefix",
        "htmlId" : "sec-compilequantifierprefix",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileQuantifierPrefix",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "QuantifierPrefix",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1015,
    [
      "Record[DeclarativeEnvironmentRecord].HasThisBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ]
      ],
      "\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "Record[DeclarativeEnvironmentRecord].HasThisBinding",
        "name" : "Record[DeclarativeEnvironmentRecord].HasThisBinding",
        "htmlId" : "sec-declarative-environment-records-hasthisbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "DeclarativeEnvironmentRecord",
          "HasThisBinding"
        ]
      }
    ]
  ],
  [
    1176,
    [
      "IsArrayBufferViewOutOfBounds",
      0,
      [
        [
          "O",
          false,
          "Record[DataView | TypedArray]"
        ]
      ],
      "\n          1. If _O_ has a [[DataView]] internal slot, then\n            1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).\n            1. Return IsViewOutOfBounds(_viewRecord_).\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. Return IsTypedArrayOutOfBounds(_taRecord_).\n        ",
      {
        "normalizedName" : "IsArrayBufferViewOutOfBounds",
        "name" : "IsArrayBufferViewOutOfBounds",
        "htmlId" : "sec-isarraybufferviewoutofbounds",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    223,
    [
      "ArrayBindingPattern[0,1].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingRestElement|.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[0,1].BoundNames",
        "name" : "ArrayBindingPattern[0,1].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    608,
    [
      "ForInOfStatement[4,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[4]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[4,0].ContainsUndefinedBreakTarget",
        "name" : "ForInOfStatement[4,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    394,
    [
      "SwitchStatement[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[SwitchStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |CaseBlock|.\n      ",
      {
        "normalizedName" : "SwitchStatement[0,0].VarDeclaredNames",
        "name" : "SwitchStatement[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SwitchStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "switch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    986,
    [
      "AssignmentExpression[6,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[6]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "AssignmentExpression[6,0].AssignmentTargetType",
        "name" : "AssignmentExpression[6,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "&&="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    306,
    [
      "LabelledItem[1,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[1]]"
        ]
      ],
      "\n        1. Return BoundNames of |FunctionDeclaration|.\n      ",
      {
        "normalizedName" : "LabelledItem[1,0].LexicallyDeclaredNames",
        "name" : "LabelledItem[1,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2288,
    [
      "ClassEscape[2,0].IsCharacterClass",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassEscape[2]]"
        ]
      ],
      "\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "ClassEscape[2,0].IsCharacterClass",
        "name" : "ClassEscape[2,0].IsCharacterClass",
        "htmlId" : "sec-patterns-static-semantics-is-character-class",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsCharacterClass",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ClassEscape",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CharacterClassEscape"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    135,
    [
      "ToUint16",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n        1. Let _int_ be truncate(ℝ(_number_)).\n        1. [id=\"step-touint16-mod\"] Let _int16bit_ be _int_ modulo 2<sup>16</sup>.\n        1. Return 𝔽(_int16bit_).\n      ",
      {
        "normalizedName" : "ToUint16",
        "name" : "ToUint16",
        "htmlId" : "sec-touint16",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1113,
    [
      "OrdinaryCallBindThis",
      0,
      [
        [
          "F",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "calleeContext",
          false,
          "Record[ExecutionContext]"
        ],
        [
          "thisArgument",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _thisMode_ be _F_.[[ThisMode]].\n          1. If _thisMode_ is ~lexical~, return ~unused~.\n          1. Let _calleeRealm_ be _F_.[[Realm]].\n          1. Let _localEnv_ be the LexicalEnvironment of _calleeContext_.\n          1. If _thisMode_ is ~strict~, then\n            1. Let _thisValue_ be _thisArgument_.\n          1. Else,\n            1. If _thisArgument_ is either *undefined* or *null*, then\n              1. Let _globalEnv_ be _calleeRealm_.[[GlobalEnv]].\n              1. Assert: _globalEnv_ is a Global Environment Record.\n              1. Let _thisValue_ be _globalEnv_.[[GlobalThisValue]].\n            1. Else,\n              1. Let _thisValue_ be ! ToObject(_thisArgument_).\n              1. NOTE: ToObject produces wrapper objects using _calleeRealm_.\n          1. Assert: _localEnv_ is a Function Environment Record.\n          1. Assert: The next step never returns an abrupt completion because _localEnv_.[[ThisBindingStatus]] is not ~initialized~.\n          1. Perform ! _localEnv_.BindThisValue(_thisValue_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "OrdinaryCallBindThis",
        "name" : "OrdinaryCallBindThis",
        "htmlId" : "sec-ordinarycallbindthis",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2797,
    [
      "GeneratorResume:cont0",
      7,
      [
        [
          "result",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).\n          1. If _state_ is ~completed~, return CreateIterResultObject(*undefined*, *true*).\n          1. Assert: _state_ is either ~suspended-start~ or ~suspended-yield~.\n          1. Let _genContext_ be _generator_.[[GeneratorContext]].\n          1. Let _methodContext_ be the running execution context.\n          1. Suspend _methodContext_.\n          1. Set _generator_.[[GeneratorState]] to ~executing~.\n          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _genContext_</emu-meta> using NormalCompletion(_value_) as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.\n          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.\n          1. Return ? _result_.\n        ",
      {
        "normalizedName" : "GeneratorResume",
        "name" : "GeneratorResume",
        "htmlId" : "sec-generatorresume",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : true,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    563,
    [
      "LabelledStatement[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _label_ be the StringValue of |LabelIdentifier|.\n        1. If _labelSet_ contains _label_, return *true*.\n        1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».\n        1. Return ContainsDuplicateLabels of |LabelledItem| with argument _newLabelSet_.\n      ",
      {
        "normalizedName" : "LabelledStatement[0,0].ContainsDuplicateLabels",
        "name" : "LabelledStatement[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelledItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2244,
    [
      "INTRINSICS.String.prototype.endsWith",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _isRegExp_ be ? IsRegExp(_searchString_).\n          1. If _isRegExp_ is *true*, throw a *TypeError* exception.\n          1. Let _searchStr_ be ? ToString(_searchString_).\n          1. Let _len_ be the length of _S_.\n          1. If _endPosition_ is *undefined*, let _pos_ be _len_; else let _pos_ be ? ToIntegerOrInfinity(_endPosition_).\n          1. Let _end_ be the result of clamping _pos_ between 0 and _len_.\n          1. Let _searchLength_ be the length of _searchStr_.\n          1. If _searchLength_ = 0, return *true*.\n          1. Let _start_ be _end_ - _searchLength_.\n          1. If _start_ < 0, return *false*.\n          1. Let _substring_ be the substring of _S_ from _start_ to _end_.\n          1. If _substring_ is _searchStr_, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.endsWith",
        "name" : "INTRINSICS.String.prototype.endsWith",
        "htmlId" : "sec-string.prototype.endswith",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1000,
    [
      "GeneratorMethod[0,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorMethod[0]]"
        ]
      ],
      "\n        1. Return PropName of |ClassElementName|.\n      ",
      {
        "normalizedName" : "GeneratorMethod[0,0].PropName",
        "name" : "GeneratorMethod[0,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2752,
    [
      "NewPromiseCapability:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n          1. NOTE: _C_ is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see <emu-xref href=\"#sec-promise-executor\"></emu-xref>).\n          1. Let _resolvingFunctions_ be the Record { [[Resolve]]: *undefined*, [[Reject]]: *undefined* }.\n          1. Let _executorClosure_ be a new Abstract Closure with parameters (_resolve_, _reject_) that captures _resolvingFunctions_ and performs the following steps when called:\n            1. If _resolvingFunctions_.[[Resolve]] is not *undefined*, throw a *TypeError* exception.\n            1. If _resolvingFunctions_.[[Reject]] is not *undefined*, throw a *TypeError* exception.\n            1. Set _resolvingFunctions_.[[Resolve]] to _resolve_.\n            1. Set _resolvingFunctions_.[[Reject]] to _reject_.\n            1. Return *undefined*.\n          1. Let _executor_ be CreateBuiltinFunction(_executorClosure_, 2, *\"\"*, « »).\n          1. Let _promise_ be ? Construct(_C_, « _executor_ »).\n          1. If IsCallable(_resolvingFunctions_.[[Resolve]]) is *false*, throw a *TypeError* exception.\n          1. If IsCallable(_resolvingFunctions_.[[Reject]]) is *false*, throw a *TypeError* exception.\n          1. Return the PromiseCapability Record { [[Promise]]: _promise_, [[Resolve]]: _resolvingFunctions_.[[Resolve]], [[Reject]]: _resolvingFunctions_.[[Reject]] }.\n        ",
      {
        "normalizedName" : "NewPromiseCapability",
        "name" : "NewPromiseCapability",
        "htmlId" : "sec-newpromisecapability",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1435,
    [
      "LexicalBinding[0,1].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[LexicalBinding[0]]"
        ]
      ],
      "\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Let _lhs_ be ! ResolveBinding(_bindingId_).\n          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.\n          1. Else,\n            1. Let _rhs_ be ? Evaluation of |Initializer|.\n            1. Let _value_ be ? GetValue(_rhs_).\n          1. Perform ! InitializeReferencedBinding(_lhs_, _value_).\n          1. Return ~empty~.\n        ",
      {
        "normalizedName" : "LexicalBinding[0,1].Evaluation",
        "name" : "LexicalBinding[0,1].Evaluation",
        "htmlId" : "sec-let-and-const-declarations-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "LexicalBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1775,
    [
      "Block[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[Block[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Block[0,0].HasCallInTailPosition",
        "name" : "Block[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Block",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2592,
    [
      "INTRINSICS.Map.prototype.entries",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Return ? CreateMapIterator(_M_, ~key+value~).\n        ",
      {
        "normalizedName" : "INTRINSICS.Map.prototype.entries",
        "name" : "INTRINSICS.Map.prototype.entries",
        "htmlId" : "sec-map.prototype.entries",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2633,
    [
      "IsUnsignedElementType",
      0,
      [
        [
          "type",
          false,
          "Unknown[\"TypedArrayElementType\"]"
        ]
      ],
      "\n          1. If _type_ is one of ~uint8~, ~uint8clamped~, ~uint16~, ~uint32~, or ~biguint64~, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "IsUnsignedElementType",
        "name" : "IsUnsignedElementType",
        "htmlId" : "sec-isunsignedelementtype",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2022,
    [
      "ExportDeclaration[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[0]]"
        ]
      ],
      "\n          1. Return ~empty~.\n        ",
      {
        "normalizedName" : "ExportDeclaration[0,0].Evaluation",
        "name" : "ExportDeclaration[0,0].Evaluation",
        "htmlId" : "sec-exports-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "ExportFromClause"
              },
              {
                "type" : "nonterminal",
                "value" : "FromClause"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    299,
    [
      "CaseClauses[1,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClauses[1]]"
        ]
      ],
      "\n        1. Let _names1_ be LexicallyDeclaredNames of |CaseClauses|.\n        1. Let _names2_ be LexicallyDeclaredNames of |CaseClause|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "CaseClauses[1,0].LexicallyDeclaredNames",
        "name" : "CaseClauses[1,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseClauses",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClause"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2535,
    [
      "INTRINSICS.get TypedArray.prototype.buffer",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].\n          1. Return _buffer_.\n        ",
      {
        "normalizedName" : "INTRINSICS.get TypedArray.prototype.buffer",
        "name" : "INTRINSICS.get TypedArray.prototype.buffer",
        "htmlId" : "sec-get-%typedarray%.prototype.buffer",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2101,
    [
      "KeyForSymbol",
      0,
      [
        [
          "sym",
          false,
          "Record[Symbol]"
        ]
      ],
      "\n          1. For each element _e_ of the GlobalSymbolRegistry List, do\n            1. If SameValue(_e_.[[Symbol]], _sym_) is *true*, return _e_.[[Key]].\n          1. Assert: GlobalSymbolRegistry does not currently contain an entry for _sym_.\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "KeyForSymbol",
        "name" : "KeyForSymbol",
        "htmlId" : "sec-keyforsymbol",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    226,
    [
      "ArrayBindingPattern[2,2].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[2]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingElementList|.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[2,2].BoundNames",
        "name" : "ArrayBindingPattern[2,2].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 2,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    3,
    [
      "HostEnqueuePromiseJob",
      0,
      [
        [
          "job",
          false,
          "Clo"
        ],
        [
          "realm",
          false,
          "Record[RealmRecord] | Null"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1726,
    [
      "FieldDefinition[0,1].ClassFieldDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[FieldDefinition[0]]"
        ],
        [
          "homeObject",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Let _name_ be ? Evaluation of |ClassElementName|.\n        1. If |Initializer| is present, then\n          1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.\n          1. Let _env_ be the LexicalEnvironment of the running execution context.\n          1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n          1. Let _sourceText_ be the empty sequence of Unicode code points.\n          1. Let _initializer_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |Initializer|, ~non-lexical-this~, _env_, _privateEnv_).\n          1. Perform MakeMethod(_initializer_, _homeObject_).\n          1. Set _initializer_.[[ClassFieldInitializerName]] to _name_.\n        1. Else,\n          1. Let _initializer_ be ~empty~.\n        1. Return the ClassFieldDefinition Record { [[Name]]: _name_, [[Initializer]]: _initializer_ }.\n      ",
      {
        "normalizedName" : "FieldDefinition[0,1].ClassFieldDefinitionEvaluation",
        "name" : "FieldDefinition[0,1].ClassFieldDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-classfielddefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassFieldDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FieldDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1364,
    [
      "ShiftExpression[3,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ShiftExpression[3]]"
        ]
      ],
      "\n          1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>>`, |AdditiveExpression|).\n        ",
      {
        "normalizedName" : "ShiftExpression[3,0].Evaluation",
        "name" : "ShiftExpression[3,0].Evaluation",
        "htmlId" : "sec-unsigned-right-shift-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ShiftExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              },
              {
                "type" : "terminal",
                "value" : ">>>"
              },
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2390,
    [
      "NonemptyClassRangesNoDash[1,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[NonemptyClassRangesNoDash[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of |ClassAtomNoDash| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of |NonemptyClassRangesNoDash| with argument _rer_.\n          1. Return the union of CharSets _A_ and _B_.\n        ",
      {
        "normalizedName" : "NonemptyClassRangesNoDash[1,0].CompileToCharSet",
        "name" : "NonemptyClassRangesNoDash[1,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "NonemptyClassRangesNoDash",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassAtomNoDash"
              },
              {
                "type" : "nonterminal",
                "value" : "NonemptyClassRangesNoDash"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1250,
    [
      "ElementList[1,0].ArrayAccumulation",
      2,
      [
        [
          "this",
          false,
          "Ast[ElementList[1]]"
        ],
        [
          "array",
          false,
          "Record[Array]"
        ],
        [
          "nextIndex",
          false,
          "Int"
        ]
      ],
      "\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.\n        ",
      {
        "normalizedName" : "ElementList[1,0].ArrayAccumulation",
        "name" : "ElementList[1,0].ArrayAccumulation",
        "htmlId" : "sec-runtime-semantics-arrayaccumulation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArrayAccumulation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SpreadElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1496,
    [
      "ForInOfStatement[1,0].ForInOfLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~).\n          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_).\n        ",
      {
        "normalizedName" : "ForInOfStatement[1,0].ForInOfLoopEvaluation",
        "name" : "ForInOfStatement[1,0].ForInOfLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forinofloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForInOfLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2303,
    [
      "CharacterEscape[5,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterEscape[5]]"
        ]
      ],
      "\n          1. Let _ch_ be the code point matched by |IdentityEscape|.\n          1. Return the numeric value of _ch_.\n        ",
      {
        "normalizedName" : "CharacterEscape[5,0].CharacterValue",
        "name" : "CharacterEscape[5,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "CharacterEscape",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentityEscape"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    267,
    [
      "ExportDeclaration[6,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[6]]"
        ]
      ],
      "\n        1. Return « *\"\\*default\\*\"* ».\n      ",
      {
        "normalizedName" : "ExportDeclaration[6,0].BoundNames",
        "name" : "ExportDeclaration[6,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    851,
    [
      "LiteralPropertyName[0,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[LiteralPropertyName[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "LiteralPropertyName[0,0].Contains",
        "name" : "LiteralPropertyName[0,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LiteralPropertyName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1102,
    [
      "OrdinarySetWithOwnDescriptor",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ],
        [
          "ownDesc",
          false,
          "Record[PropertyDescriptor] | Undefined"
        ]
      ],
      "\n          1. If _ownDesc_ is *undefined*, then\n            1. Let _parent_ be ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]</emu-meta>().\n            1. If _parent_ is not *null*, then\n              1. Return ? <emu-meta effects=\"user-code\">_parent_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_).\n            1. Else,\n              1. Set _ownDesc_ to the PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n          1. If IsDataDescriptor(_ownDesc_) is *true*, then\n            1. If _ownDesc_.[[Writable]] is *false*, return *false*.\n            1. If _Receiver_ is not an Object, return *false*.\n            1. Let _existingDescriptor_ be ? <emu-meta effects=\"user-code\">_Receiver_.[[GetOwnProperty]]</emu-meta>(_P_).\n            1. If _existingDescriptor_ is not *undefined*, then\n              1. If IsAccessorDescriptor(_existingDescriptor_) is *true*, return *false*.\n              1. If _existingDescriptor_.[[Writable]] is *false*, return *false*.\n              1. Let _valueDesc_ be the PropertyDescriptor { [[Value]]: _V_ }.\n              1. Return ? <emu-meta effects=\"user-code\">_Receiver_.[[DefineOwnProperty]]</emu-meta>(_P_, _valueDesc_).\n            1. Else,\n              1. Assert: _Receiver_ does not currently have a property _P_.\n              1. Return ? CreateDataProperty(_Receiver_, _P_, _V_).\n          1. Assert: IsAccessorDescriptor(_ownDesc_) is *true*.\n          1. Let _setter_ be _ownDesc_.[[Set]].\n          1. If _setter_ is *undefined*, return *false*.\n          1. Perform ? Call(_setter_, _Receiver_, « _V_ »).\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "OrdinarySetWithOwnDescriptor",
        "name" : "OrdinarySetWithOwnDescriptor",
        "htmlId" : "sec-ordinarysetwithowndescriptor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    505,
    [
      "StatementList[1,0].TopLevelVarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be TopLevelVarScopedDeclarations of |StatementList|.\n        1. Let _declarations2_ be TopLevelVarScopedDeclarations of |StatementListItem|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "StatementList[1,0].TopLevelVarScopedDeclarations",
        "name" : "StatementList[1,0].TopLevelVarScopedDeclarations",
        "htmlId" : "sec-static-semantics-toplevelvarscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelVarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2156,
    [
      "INTRINSICS.Math.tan",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the tangent of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.tan",
        "name" : "INTRINSICS.Math.tan",
        "htmlId" : "sec-math.tan",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    438,
    [
      "ForStatement[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,0].VarScopedDeclarations",
        "name" : "ForStatement[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2207,
    [
      "INTRINSICS.Date.prototype.getUTCSeconds",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return SecFromTime(_t_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getUTCSeconds",
        "name" : "INTRINSICS.Date.prototype.getUTCSeconds",
        "htmlId" : "sec-date.prototype.getutcseconds",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    431,
    [
      "StatementListItem[1,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[1]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "StatementListItem[1,0].VarScopedDeclarations",
        "name" : "StatementListItem[1,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    241,
    [
      "FormalParameters[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameters[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "FormalParameters[0,0].BoundNames",
        "name" : "FormalParameters[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FormalParameters",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    80,
    [
      "BigInt::equal",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. If ℝ(_x_) = ℝ(_y_), return *true*; otherwise return *false*.\n          ",
      {
        "normalizedName" : "BigInt::equal",
        "name" : "BigInt::equal",
        "htmlId" : "sec-numeric-types-bigint-equal",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    653,
    [
      "WhileStatement[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[WhileStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "WhileStatement[0,0].ContainsUndefinedContinueTarget",
        "name" : "WhileStatement[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1694,
    [
      "ClassElementList[1,0].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be PrivateBoundIdentifiers of |ClassElementList|.\n        1. Let _names2_ be PrivateBoundIdentifiers of |ClassElement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ClassElementList[1,0].PrivateBoundIdentifiers",
        "name" : "ClassElementList[1,0].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementList"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    922,
    [
      "PrimaryExpression[0,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[0]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "PrimaryExpression[0,0].AssignmentTargetType",
        "name" : "PrimaryExpression[0,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "this"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    167,
    [
      "DefinePropertyOrThrow",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "desc",
          false,
          "Record[PropertyDescriptor]"
        ]
      ],
      "\n        1. Let _success_ be ? <emu-meta effects=\"user-code\">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _desc_).\n        1. If _success_ is *false*, throw a *TypeError* exception.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "DefinePropertyOrThrow",
        "name" : "DefinePropertyOrThrow",
        "htmlId" : "sec-definepropertyorthrow",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2693,
    [
      "ValidateAtomicAccess",
      0,
      [
        [
          "taRecord",
          false,
          "Record[TypedArrayWithBufferWitnessRecord]"
        ],
        [
          "requestIndex",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _length_ be TypedArrayLength(_taRecord_).\n          1. Let _accessIndex_ be ? ToIndex(_requestIndex_).\n          1. Assert: _accessIndex_ ≥ 0.\n          1. If _accessIndex_ ≥ _length_, throw a *RangeError* exception.\n          1. Let _typedArray_ be _taRecord_.[[Object]].\n          1. Let _elementSize_ be TypedArrayElementSize(_typedArray_).\n          1. Let _offset_ be _typedArray_.[[ByteOffset]].\n          1. Return (_accessIndex_ × _elementSize_) + _offset_.\n        ",
      {
        "normalizedName" : "ValidateAtomicAccess",
        "name" : "ValidateAtomicAccess",
        "htmlId" : "sec-validateatomicaccess",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1973,
    [
      "ExportDeclaration[1,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[1]]"
        ]
      ],
      "\n          1. Return the ExportedBindings of |NamedExports|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[1,0].ExportedBindings",
        "name" : "ExportDeclaration[1,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "NamedExports"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    35,
    [
      "__GET_ITEMS__",
      8,
      [
        [
          "ast",
          false,
          "Ast"
        ],
        [
          "target",
          false,
          "GrammarSymbol"
        ],
        [
          "parent",
          false,
          "GrammarSymbol"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1805,
    [
      "WithStatement[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[WithStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "WithStatement[0,0].HasCallInTailPosition",
        "name" : "WithStatement[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WithStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "with"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2069,
    [
      "INTRINSICS.Object.values",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Let _valueList_ be ? EnumerableOwnProperties(_obj_, ~value~).\n          1. Return CreateArrayFromList(_valueList_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.values",
        "name" : "INTRINSICS.Object.values",
        "htmlId" : "sec-object.values",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    658,
    [
      "ForStatement[0,4].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[0,4].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[0,4].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 4,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2506,
    [
      "INTRINSICS.Array.prototype.push",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _argCount_ be the number of elements in _items_.\n          1. If _len_ + _argCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n          1. For each element _E_ of _items_, do\n            1. Perform ? Set(_O_, ! ToString(𝔽(_len_)), _E_, *true*).\n            1. Set _len_ to _len_ + 1.\n          1. Perform ? Set(_O_, *\"length\"*, 𝔽(_len_), *true*).\n          1. Return 𝔽(_len_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.push",
        "name" : "INTRINSICS.Array.prototype.push",
        "htmlId" : "sec-array.prototype.push",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1562,
    [
      "ArrayBindingPattern[0,3].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[0]]"
        ]
      ],
      "\n        1. Return ContainsExpression of |BindingRestElement|.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[0,3].ContainsExpression",
        "name" : "ArrayBindingPattern[0,3].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1626,
    [
      "ExpressionBody[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ExpressionBody[0]]"
        ]
      ],
      "\n        1. Let _exprRef_ be ? Evaluation of |AssignmentExpression|.\n        1. Let _exprValue_ be ? GetValue(_exprRef_).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _exprValue_, [[Target]]: ~empty~ }.\n      ",
      {
        "normalizedName" : "ExpressionBody[0,0].Evaluation",
        "name" : "ExpressionBody[0,0].Evaluation",
        "htmlId" : "sec-arrow-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExpressionBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1809,
    [
      "CaseBlock[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Let _has_ be *false*.\n        1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.\n        1. Return _has_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,0].HasCallInTailPosition",
        "name" : "CaseBlock[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1467,
    [
      "ForStatement[0,6].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        ",
      {
        "normalizedName" : "ForStatement[0,6].ForLoopEvaluation",
        "name" : "ForStatement[0,6].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 6,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    754,
    [
      "ShiftExpression[3,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[ShiftExpression[3]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ShiftExpression[3,0].IsFunctionDefinition",
        "name" : "ShiftExpression[3,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ShiftExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              },
              {
                "type" : "terminal",
                "value" : ">>>"
              },
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    553,
    [
      "CaseBlock[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CaseBlock[0,0].ContainsDuplicateLabels",
        "name" : "CaseBlock[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1049,
    [
      "Record[GlobalEnvironmentRecord].CreateGlobalFunctionBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "D",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n            1. Let _existingProp_ be ? <emu-meta effects=\"user-code\">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_).\n            1. If _existingProp_ is *undefined* or _existingProp_.[[Configurable]] is *true*, then\n              1. Let _desc_ be the PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }.\n            1. Else,\n              1. Let _desc_ be the PropertyDescriptor { [[Value]]: _V_ }.\n            1. Perform ? DefinePropertyOrThrow(_globalObject_, _N_, _desc_).\n            1. [id=\"step-createglobalfunctionbinding-set\"] Perform ? Set(_globalObject_, _N_, _V_, *false*).\n            1. If _envRec_.[[VarNames]] does not contain _N_, then\n              1. Append _N_ to _envRec_.[[VarNames]].\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].CreateGlobalFunctionBinding",
        "name" : "Record[GlobalEnvironmentRecord].CreateGlobalFunctionBinding",
        "htmlId" : "sec-createglobalfunctionbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "CreateGlobalFunctionBinding"
        ]
      }
    ]
  ],
  [
    2005,
    [
      "ExportDeclaration[1,0].ExportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[1]]"
        ]
      ],
      "\n          1. Return ExportEntriesForModule of |NamedExports| with argument *null*.\n        ",
      {
        "normalizedName" : "ExportDeclaration[1,0].ExportEntries",
        "name" : "ExportDeclaration[1,0].ExportEntries",
        "htmlId" : "sec-static-semantics-exportentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntries",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "NamedExports"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1413,
    [
      "AssignmentElisionElement[0,1].IteratorDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentElisionElement[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with argument _iteratorRecord_.\n        ",
      {
        "normalizedName" : "AssignmentElisionElement[0,1].IteratorDestructuringAssignmentEvaluation",
        "name" : "AssignmentElisionElement[0,1].IteratorDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AssignmentElisionElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    473,
    [
      "DefaultClause[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the VarScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "DefaultClause[0,0].VarScopedDeclarations",
        "name" : "DefaultClause[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1076,
    [
      "AgentCanSuspend",
      0,
      [
      ],
      "\n        1. Let _AR_ be the Agent Record of the surrounding agent.\n        1. Return _AR_.[[CanBlock]].\n      ",
      {
        "normalizedName" : "AgentCanSuspend",
        "name" : "AgentCanSuspend",
        "htmlId" : "sec-agentcansuspend",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2054,
    [
      "INTRINSICS.Object.getOwnPropertyDescriptors",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Let _ownKeys_ be ? <emu-meta effects=\"user-code\">_obj_.[[OwnPropertyKeys]]()</emu-meta>.\n          1. Let _descriptors_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. For each element _key_ of _ownKeys_, do\n            1. Let _desc_ be ? <emu-meta effects=\"user-code\">_obj_.[[GetOwnProperty]]</emu-meta>(_key_).\n            1. Let _descriptor_ be FromPropertyDescriptor(_desc_).\n            1. If _descriptor_ is not *undefined*, perform ! CreateDataPropertyOrThrow(_descriptors_, _key_, _descriptor_).\n          1. Return _descriptors_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.getOwnPropertyDescriptors",
        "name" : "INTRINSICS.Object.getOwnPropertyDescriptors",
        "htmlId" : "sec-object.getownpropertydescriptors",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    722,
    [
      "PrimaryExpression[3,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[3]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[3,0].IsFunctionDefinition",
        "name" : "PrimaryExpression[3,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrayLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1948,
    [
      "GetImportedModule",
      0,
      [
        [
          "referrer",
          false,
          "Record[CyclicModuleRecord]"
        ],
        [
          "specifier",
          false,
          "String"
        ]
      ],
      "\n          1. Assert: Exactly one element of _referrer_.[[LoadedModules]] is a Record whose [[Specifier]] is _specifier_, since LoadRequestedModules has completed successfully on _referrer_ prior to invoking this abstract operation.\n          1. Let _record_ be the Record in _referrer_.[[LoadedModules]] whose [[Specifier]] is _specifier_.\n          1. Return _record_.[[Module]].\n        ",
      {
        "normalizedName" : "GetImportedModule",
        "name" : "GetImportedModule",
        "htmlId" : "sec-GetImportedModule",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1034,
    [
      "Record[GlobalEnvironmentRecord].CreateImmutableBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "S",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, throw a *TypeError* exception.\n            1. Return ! _DclRec_.CreateImmutableBinding(_N_, _S_).\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].CreateImmutableBinding",
        "name" : "Record[GlobalEnvironmentRecord].CreateImmutableBinding",
        "htmlId" : "sec-global-environment-records-createimmutablebinding-n-s",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "CreateImmutableBinding"
        ]
      }
    ]
  ],
  [
    2239,
    [
      "INTRINSICS.String.prototype.at",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _len_ be the length of _S_.\n          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n          1. If _relativeIndex_ ≥ 0, then\n            1. Let _k_ be _relativeIndex_.\n          1. Else,\n            1. Let _k_ be _len_ + _relativeIndex_.\n          1. If _k_ < 0 or _k_ ≥ _len_, return *undefined*.\n          1. Return the substring of _S_ from _k_ to _k_ + 1.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.at",
        "name" : "INTRINSICS.String.prototype.at",
        "htmlId" : "sec-string.prototype.at",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    490,
    [
      "ModuleItemList[1,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be VarScopedDeclarations of |ModuleItemList|.\n        1. Let _declarations2_ be VarScopedDeclarations of |ModuleItem|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "ModuleItemList[1,0].VarScopedDeclarations",
        "name" : "ModuleItemList[1,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    675,
    [
      "ForInOfStatement[5,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[5]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForInOfStatement[5,0].ContainsUndefinedContinueTarget",
        "name" : "ForInOfStatement[5,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2816,
    [
      "AsyncGeneratorResume",
      0,
      [
        [
          "generator",
          false,
          "Record[AsyncGenerator]"
        ],
        [
          "completion",
          false,
          "Completion"
        ]
      ],
      "\n          1. Assert: _generator_.[[AsyncGeneratorState]] is either ~suspended-start~ or ~suspended-yield~.\n          1. Let _genContext_ be _generator_.[[AsyncGeneratorContext]].\n          1. Let _callerContext_ be the running execution context.\n          1. Suspend _callerContext_.\n          1. Set _generator_.[[AsyncGeneratorState]] to ~executing~.\n          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _genContext_</emu-meta> using _completion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.\n          1. Assert: _result_ is never an abrupt completion.\n          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _callerContext_ is the currently running execution context.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncGeneratorResume",
        "name" : "AsyncGeneratorResume",
        "htmlId" : "sec-asyncgeneratorresume",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1583,
    [
      "BindingElement[1,0].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElement[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "BindingElement[1,0].IsSimpleParameterList",
        "name" : "BindingElement[1,0].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1662,
    [
      "AsyncGeneratorExpression[0,1].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression|.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,1].Evaluation",
        "name" : "AsyncGeneratorExpression[0,1].Evaluation",
        "htmlId" : "sec-asyncgenerator-definitions-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2614,
    [
      "CreateSetIterator",
      0,
      [
        [
          "set",
          false,
          "ESValue"
        ],
        [
          "kind",
          false,
          "Enum[~key+value~, ~value~]"
        ]
      ],
      "\n          1. Perform ? RequireInternalSlot(_set_, [[SetData]]).\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _set_ and _kind_ and performs the following steps when called:\n            1. Let _index_ be 0.\n            1. Let _entries_ be _set_.[[SetData]].\n            1. Let _numEntries_ be the number of elements in _entries_.\n            1. Repeat, while _index_ < _numEntries_,\n              1. Let _e_ be _entries_[_index_].\n              1. Set _index_ to _index_ + 1.\n              1. If _e_ is not ~empty~, then\n                1. If _kind_ is ~key+value~, then\n                  1. Let _result_ be CreateArrayFromList(« _e_, _e_ »).\n                  1. Perform ? GeneratorYield(CreateIterResultObject(_result_, *false*)).\n                1. Else,\n                  1. Assert: _kind_ is ~value~.\n                  1. Perform ? GeneratorYield(CreateIterResultObject(_e_, *false*)).\n                1. NOTE: The number of elements in _entries_ may have increased while execution of this abstract operation was paused by Yield.\n                1. Set _numEntries_ to the number of elements in _entries_.\n            1. Return NormalCompletion(*undefined*).\n          1. Return CreateIteratorFromClosure(_closure_, *\"%SetIteratorPrototype%\"*, %SetIteratorPrototype%).\n        ",
      {
        "normalizedName" : "CreateSetIterator",
        "name" : "CreateSetIterator",
        "htmlId" : "sec-createsetiterator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2096,
    [
      "INTRINSICS.Symbol.prototype.toString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _sym_ be ? ThisSymbolValue(*this* value).\n          1. Return SymbolDescriptiveString(_sym_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Symbol.prototype.toString",
        "name" : "INTRINSICS.Symbol.prototype.toString",
        "htmlId" : "sec-symbol.prototype.tostring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1304,
    [
      "CallExpression[5,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[5]]"
        ]
      ],
      "\n          1. Let _baseReference_ be ? Evaluation of |CallExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If the source text matched by this |CallExpression| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_).\n        ",
      {
        "normalizedName" : "CallExpression[5,0].Evaluation",
        "name" : "CallExpression[5,0].Evaluation",
        "htmlId" : "sec-property-accessors-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1873,
    [
      "MemberExpression[6,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[6]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[6,0].HasCallInTailPosition",
        "name" : "MemberExpression[6,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    426,
    [
      "Statement[8,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[8]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[8,0].VarScopedDeclarations",
        "name" : "Statement[8,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ReturnStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1758,
    [
      "AsyncConciseBody[0,0].AsyncConciseBodyContainsUseStrict",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncConciseBody[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncConciseBody[0,0].AsyncConciseBodyContainsUseStrict",
        "name" : "AsyncConciseBody[0,0].AsyncConciseBodyContainsUseStrict",
        "htmlId" : "sec-static-semantics-asyncconcisebodycontainsusestrict",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AsyncConciseBodyContainsUseStrict",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1166,
    [
      "Record[TypedArray].Delete",
      4,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. If _P_ is a String, then\n            1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n            1. If _numericIndex_ is not *undefined*, then\n              1. If IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *true*; else return *false*.\n          1. Return ! OrdinaryDelete(_O_, _P_).\n        ",
      {
        "normalizedName" : "Record[TypedArray].Delete",
        "name" : "Record[TypedArray].Delete",
        "htmlId" : "sec-typedarray-delete",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "TypedArray",
          "[[Delete]]"
        ]
      }
    ]
  ],
  [
    2107,
    [
      "INTRINSICS.Number",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _value_ is present, then\n            1. Let _prim_ be ? ToNumeric(_value_).\n            1. If _prim_ is a BigInt, let _n_ be 𝔽(ℝ(_prim_)).\n            1. Otherwise, let _n_ be _prim_.\n          1. Else,\n            1. Let _n_ be *+0*<sub>𝔽</sub>.\n          1. If NewTarget is *undefined*, return _n_.\n          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Number.prototype%\"*, « [[NumberData]] »).\n          1. Set _O_.[[NumberData]] to _n_.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Number",
        "name" : "INTRINSICS.Number",
        "htmlId" : "sec-number-constructor-number-value",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1203,
    [
      "Record[ProxyExoticObject].Construct",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "newTarget",
          false,
          "Record[Constructor]"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Assert: IsConstructor(_target_) is *true*.\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"construct\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? Construct(_target_, _argumentsList_, _newTarget_).\n        1. Let _argArray_ be CreateArrayFromList(_argumentsList_).\n        1. Let _newObj_ be ? Call(_trap_, _handler_, « _target_, _argArray_, _newTarget_ »).\n        1. If _newObj_ is not an Object, throw a *TypeError* exception.\n        1. Return _newObj_.\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].Construct",
        "name" : "Record[ProxyExoticObject].Construct",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[Construct]]"
        ]
      }
    ]
  ],
  [
    1208,
    [
      "UTF16SurrogatePairToCodePoint",
      0,
      [
        [
          "lead",
          false,
          "Unknown[\"CodeUnit\"]"
        ],
        [
          "trail",
          false,
          "Unknown[\"CodeUnit\"]"
        ]
      ],
      "\n        1. Assert: _lead_ is a leading surrogate and _trail_ is a trailing surrogate.\n        1. Let _cp_ be (_lead_ - 0xD800) × 0x400 + (_trail_ - 0xDC00) + 0x10000.\n        1. Return the code point _cp_.\n      ",
      {
        "normalizedName" : "UTF16SurrogatePairToCodePoint",
        "name" : "UTF16SurrogatePairToCodePoint",
        "htmlId" : "sec-utf16decodesurrogatepair",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    589,
    [
      "ForStatement[0,1].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,1].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[0,1].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    162,
    [
      "GetV",
      0,
      [
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n        1. Let _O_ be ? ToObject(_V_).\n        1. Return ? <emu-meta effects=\"user-code\">_O_.[[Get]]</emu-meta>(_P_, _V_).\n      ",
      {
        "normalizedName" : "GetV",
        "name" : "GetV",
        "htmlId" : "sec-getv",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    531,
    [
      "ForStatement[0,5].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,5].ContainsDuplicateLabels",
        "name" : "ForStatement[0,5].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 5,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    944,
    [
      "UpdateExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "UpdateExpression[1,0].AssignmentTargetType",
        "name" : "UpdateExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "++"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2665,
    [
      "IsViewOutOfBounds",
      0,
      [
        [
          "viewRecord",
          false,
          "Record[DataViewWithBufferWitnessRecord]"
        ]
      ],
      "\n          1. Let _view_ be _viewRecord_.[[Object]].\n          1. Let _bufferByteLength_ be _viewRecord_.[[CachedBufferByteLength]].\n          1. Assert: IsDetachedBuffer(_view_.[[ViewedArrayBuffer]]) is *true* if and only if _bufferByteLength_ is ~detached~.\n          1. If _bufferByteLength_ is ~detached~, return *true*.\n          1. Let _byteOffsetStart_ be _view_.[[ByteOffset]].\n          1. If _view_.[[ByteLength]] is ~auto~, then\n            1. Let _byteOffsetEnd_ be _bufferByteLength_.\n          1. Else,\n            1. Let _byteOffsetEnd_ be _byteOffsetStart_ + _view_.[[ByteLength]].\n          1. If _byteOffsetStart_ > _bufferByteLength_ or _byteOffsetEnd_ > _bufferByteLength_, return *true*.\n          1. NOTE: 0-length DataViews are not considered out-of-bounds.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "IsViewOutOfBounds",
        "name" : "IsViewOutOfBounds",
        "htmlId" : "sec-isviewoutofbounds",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    795,
    [
      "PrimaryExpression[2,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[2,0].IsIdentifierRef",
        "name" : "PrimaryExpression[2,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Literal"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2318,
    [
      "ClassSetOperand[2,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSetOperand[2]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ClassSetOperand[2,0].MayContainStrings",
        "name" : "ClassSetOperand[2,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ClassSetOperand",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetCharacter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2784,
    [
      "INTRINSICS.Promise.prototype.finally:clo1",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _promise_ be the *this* value.\n          1. If _promise_ is not an Object, throw a *TypeError* exception.\n          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).\n          1. Assert: IsConstructor(_C_) is *true*.\n          1. If IsCallable(_onFinally_) is *false*, then\n            1. Let _thenFinally_ be _onFinally_.\n            1. Let _catchFinally_ be _onFinally_.\n          1. Else,\n            1. Let _thenFinallyClosure_ be a new Abstract Closure with parameters (_value_) that captures _onFinally_ and _C_ and performs the following steps when called:\n              1. Let _result_ be ? Call(_onFinally_, *undefined*).\n              1. Let _p_ be ? PromiseResolve(_C_, _result_).\n              1. Let _returnValue_ be a new Abstract Closure with no parameters that captures _value_ and performs the following steps when called:\n                1. Return _value_.\n              1. Let _valueThunk_ be CreateBuiltinFunction(_returnValue_, 0, *\"\"*, « »).\n              1. Return ? Invoke(_p_, *\"then\"*, « _valueThunk_ »).\n            1. Let _thenFinally_ be CreateBuiltinFunction(_thenFinallyClosure_, 1, *\"\"*, « »).\n            1. Let _catchFinallyClosure_ be a new Abstract Closure with parameters (_reason_) that captures _onFinally_ and _C_ and performs the following steps when called:\n              1. Let _result_ be ? Call(_onFinally_, *undefined*).\n              1. Let _p_ be ? PromiseResolve(_C_, _result_).\n              1. Let _throwReason_ be a new Abstract Closure with no parameters that captures _reason_ and performs the following steps when called:\n                1. Return ThrowCompletion(_reason_).\n              1. Let _thrower_ be CreateBuiltinFunction(_throwReason_, 0, *\"\"*, « »).\n              1. Return ? Invoke(_p_, *\"then\"*, « _thrower_ »).\n            1. Let _catchFinally_ be CreateBuiltinFunction(_catchFinallyClosure_, 1, *\"\"*, « »).\n          1. Return ? Invoke(_promise_, *\"then\"*, « _thenFinally_, _catchFinally_ »).\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.prototype.finally",
        "name" : "INTRINSICS.Promise.prototype.finally",
        "htmlId" : "sec-promise.prototype.finally",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2271,
    [
      "TrimString",
      0,
      [
        [
          "string",
          false,
          "ESValue"
        ],
        [
          "where",
          false,
          "Enum[~end~, ~start+end~, ~start~]"
        ]
      ],
      "\n            1. Let _str_ be ? RequireObjectCoercible(_string_).\n            1. Let _S_ be ? ToString(_str_).\n            1. If _where_ is ~start~, then\n              1. Let _T_ be the String value that is a copy of _S_ with leading white space removed.\n            1. Else if _where_ is ~end~, then\n              1. Let _T_ be the String value that is a copy of _S_ with trailing white space removed.\n            1. Else,\n              1. Assert: _where_ is ~start+end~.\n              1. Let _T_ be the String value that is a copy of _S_ with both leading and trailing white space removed.\n            1. Return _T_.\n          ",
      {
        "normalizedName" : "TrimString",
        "name" : "TrimString",
        "htmlId" : "sec-trimstring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    680,
    [
      "ContinueStatement[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ContinueStatement[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If _iterationSet_ does not contain the StringValue of |LabelIdentifier|, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ContinueStatement[1,0].ContainsUndefinedContinueTarget",
        "name" : "ContinueStatement[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ContinueStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "continue"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    663,
    [
      "ForStatement[1,1].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[1,1].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[1,1].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2652,
    [
      "INTRINSICS.ArrayBuffer.prototype.transfer",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Return ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~preserve-resizability~).\n        ",
      {
        "normalizedName" : "INTRINSICS.ArrayBuffer.prototype.transfer",
        "name" : "INTRINSICS.ArrayBuffer.prototype.transfer",
        "htmlId" : "sec-arraybuffer.prototype.transfer",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2471,
    [
      "GetMatchString",
      0,
      [
        [
          "S",
          false,
          "String"
        ],
        [
          "match",
          false,
          "Record[MatchRecord]"
        ]
      ],
      "\n          1. Assert: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ the length of _S_.\n          1. Return the substring of _S_ from _match_.[[StartIndex]] to _match_.[[EndIndex]].\n        ",
      {
        "normalizedName" : "GetMatchString",
        "name" : "GetMatchString",
        "htmlId" : "sec-getmatchstring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    548,
    [
      "ForInOfStatement[6,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[6]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[6,0].ContainsDuplicateLabels",
        "name" : "ForInOfStatement[6,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1905,
    [
      "OptionalChain[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. If this |OptionalChain| is _call_, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "OptionalChain[0,0].HasCallInTailPosition",
        "name" : "OptionalChain[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "?."
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1420,
    [
      "AssignmentElement[0,1].KeyedDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentElement[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "propertyName",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.\n          1. Let _v_ be ? GetV(_value_, _propertyName_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) and IsIdentifierRef of |DestructuringAssignmentTarget| are both *true*, then\n              1. Let _rhsValue_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Let _rhsValue_ be ? GetValue(_defaultValue_).\n          1. Else,\n            1. Let _rhsValue_ be _v_.\n          1. If |DestructuringAssignmentTarget| is either an |ObjectLiteral| or an |ArrayLiteral|, then\n            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n            1. Return ? DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _rhsValue_.\n          1. Return ? PutValue(_lref_, _rhsValue_).\n        ",
      {
        "normalizedName" : "AssignmentElement[0,1].KeyedDestructuringAssignmentEvaluation",
        "name" : "AssignmentElement[0,1].KeyedDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-keyeddestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "KeyedDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AssignmentElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DestructuringAssignmentTarget"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    927,
    [
      "PrimaryExpression[6,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[6]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "PrimaryExpression[6,0].AssignmentTargetType",
        "name" : "PrimaryExpression[6,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2037,
    [
      "INTRINSICS.decodeURIComponent",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _componentString_ be ? ToString(_encodedURIComponent_).\n          1. Let _preserveEscapeSet_ be the empty String.\n          1. Return ? Decode(_componentString_, _preserveEscapeSet_).\n        ",
      {
        "normalizedName" : "INTRINSICS.decodeURIComponent",
        "name" : "INTRINSICS.decodeURIComponent",
        "htmlId" : "sec-decodeuricomponent-encodeduricomponent",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    374,
    [
      "ForStatement[0,6].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,6].VarDeclaredNames",
        "name" : "ForStatement[0,6].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 6,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    255,
    [
      "ImportDeclaration[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportDeclaration[1]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ImportDeclaration[1,0].BoundNames",
        "name" : "ImportDeclaration[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ImportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "import"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleSpecifier"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2503,
    [
      "INTRINSICS.Array.prototype.lastIndexOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.\n          1. If _fromIndex_ is present, let _n_ be ? ToIntegerOrInfinity(_fromIndex_); else let _n_ be _len_ - 1.\n          1. If _n_ = -∞, return *-1*<sub>𝔽</sub>.\n          1. If _n_ ≥ 0, then\n            1. Let _k_ be min(_n_, _len_ - 1).\n          1. Else,\n            1. Let _k_ be _len_ + _n_.\n          1. Repeat, while _k_ ≥ 0,\n            1. Let _kPresent_ be ? HasProperty(_O_, ! ToString(𝔽(_k_))).\n            1. If _kPresent_ is *true*, then\n              1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).\n              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).\n            1. Set _k_ to _k_ - 1.\n          1. Return *-1*<sub>𝔽</sub>.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.lastIndexOf",
        "name" : "INTRINSICS.Array.prototype.lastIndexOf",
        "htmlId" : "sec-array.prototype.lastindexof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1684,
    [
      "OptionalChain[4,0].AllPrivateIdentifiersValid",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[4]]"
        ],
        [
          "names",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If _names_ contains the StringValue of |PrivateIdentifier|, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "OptionalChain[4,0].AllPrivateIdentifiersValid",
        "name" : "OptionalChain[4,0].AllPrivateIdentifiersValid",
        "htmlId" : "sec-static-semantics-allprivateidentifiersvalid",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AllPrivateIdentifiersValid",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "?."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1277,
    [
      "PropertyDefinition[3,0].PropertyDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyDefinition[3]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Perform ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and *true*.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "PropertyDefinition[3,0].PropertyDefinitionEvaluation",
        "name" : "PropertyDefinition[3,0].PropertyDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-propertydefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "PropertyDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MethodDefinition"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2124,
    [
      "ThisBigIntValue",
      0,
      [
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n            1. If _value_ is a BigInt, return _value_.\n            1. If _value_ is an Object and _value_ has a [[BigIntData]] internal slot, then\n              1. Assert: _value_.[[BigIntData]] is a BigInt.\n              1. Return _value_.[[BigIntData]].\n            1. Throw a *TypeError* exception.\n          ",
      {
        "normalizedName" : "ThisBigIntValue",
        "name" : "ThisBigIntValue",
        "htmlId" : "sec-thisbigintvalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2234,
    [
      "INTRINSICS.Date.prototype[@@toPrimitive]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. If _O_ is not an Object, throw a *TypeError* exception.\n          1. If _hint_ is either *\"string\"* or *\"default\"*, then\n            1. Let _tryFirst_ be ~string~.\n          1. Else if _hint_ is *\"number\"*, then\n            1. Let _tryFirst_ be ~number~.\n          1. Else,\n            1. Throw a *TypeError* exception.\n          1. Return ? OrdinaryToPrimitive(_O_, _tryFirst_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype[@@toPrimitive]",
        "name" : "INTRINSICS.Date.prototype[@@toPrimitive]",
        "htmlId" : "sec-date.prototype-@@toprimitive",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1134,
    [
      "Record[BuiltinFunctionObject].Call",
      4,
      [
        [
          "F",
          false,
          "Record[BuiltinFunctionObject]"
        ],
        [
          "thisArgument",
          false,
          "ESValue"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Return ? BuiltinCallOrConstruct(_F_, _thisArgument_, _argumentsList_, *undefined*).\n      ",
      {
        "normalizedName" : "Record[BuiltinFunctionObject].Call",
        "name" : "Record[BuiltinFunctionObject].Call",
        "htmlId" : "sec-built-in-function-objects-call-thisargument-argumentslist",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "BuiltinFunctionObject",
          "[[Call]]"
        ]
      }
    ]
  ],
  [
    648,
    [
      "BreakableStatement[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[BreakableStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _newIterationSet_ be the list-concatenation of _iterationSet_ and _labelSet_.\n        1. Return ContainsUndefinedContinueTarget of |IterationStatement| with arguments _newIterationSet_ and « ».\n      ",
      {
        "normalizedName" : "BreakableStatement[0,0].ContainsUndefinedContinueTarget",
        "name" : "BreakableStatement[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BreakableStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IterationStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    209,
    [
      "BindingIdentifier[2,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingIdentifier[2]]"
        ]
      ],
      "\n        1. Return « *\"await\"* ».\n      ",
      {
        "normalizedName" : "BindingIdentifier[2,0].BoundNames",
        "name" : "BindingIdentifier[2,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "BindingIdentifier",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "await"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    487,
    [
      "Script[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Script[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Script[0,0].VarScopedDeclarations",
        "name" : "Script[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Script",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2449,
    [
      "INTRINSICS.get RegExp.prototype.flags",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. If _R_ is not an Object, throw a *TypeError* exception.\n          1. Let _codeUnits_ be a new empty List.\n          1. Let _hasIndices_ be ToBoolean(? Get(_R_, *\"hasIndices\"*)).\n          1. If _hasIndices_ is *true*, append the code unit 0x0064 (LATIN SMALL LETTER D) to _codeUnits_.\n          1. Let _global_ be ToBoolean(? Get(_R_, *\"global\"*)).\n          1. If _global_ is *true*, append the code unit 0x0067 (LATIN SMALL LETTER G) to _codeUnits_.\n          1. Let _ignoreCase_ be ToBoolean(? Get(_R_, *\"ignoreCase\"*)).\n          1. If _ignoreCase_ is *true*, append the code unit 0x0069 (LATIN SMALL LETTER I) to _codeUnits_.\n          1. Let _multiline_ be ToBoolean(? Get(_R_, *\"multiline\"*)).\n          1. If _multiline_ is *true*, append the code unit 0x006D (LATIN SMALL LETTER M) to _codeUnits_.\n          1. Let _dotAll_ be ToBoolean(? Get(_R_, *\"dotAll\"*)).\n          1. If _dotAll_ is *true*, append the code unit 0x0073 (LATIN SMALL LETTER S) to _codeUnits_.\n          1. Let _unicode_ be ToBoolean(? Get(_R_, *\"unicode\"*)).\n          1. If _unicode_ is *true*, append the code unit 0x0075 (LATIN SMALL LETTER U) to _codeUnits_.\n          1. Let _unicodeSets_ be ToBoolean(? Get(_R_, *\"unicodeSets\"*)).\n          1. If _unicodeSets_ is *true*, append the code unit 0x0076 (LATIN SMALL LETTER V) to _codeUnits_.\n          1. Let _sticky_ be ToBoolean(? Get(_R_, *\"sticky\"*)).\n          1. If _sticky_ is *true*, append the code unit 0x0079 (LATIN SMALL LETTER Y) to _codeUnits_.\n          1. Return the String value whose code units are the elements of the List _codeUnits_. If _codeUnits_ has no elements, the empty String is returned.\n        ",
      {
        "normalizedName" : "INTRINSICS.get RegExp.prototype.flags",
        "name" : "INTRINSICS.get RegExp.prototype.flags",
        "htmlId" : "sec-get-regexp.prototype.flags",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    112,
    [
      "ToNumber",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If _argument_ is a Number, return _argument_.\n        1. If _argument_ is either a Symbol or a BigInt, throw a *TypeError* exception.\n        1. If _argument_ is *undefined*, return *NaN*.\n        1. If _argument_ is either *null* or *false*, return *+0*<sub>𝔽</sub>.\n        1. If _argument_ is *true*, return *1*<sub>𝔽</sub>.\n        1. If _argument_ is a String, return StringToNumber(_argument_).\n        1. Assert: _argument_ is an Object.\n        1. Let _primValue_ be ? ToPrimitive(_argument_, ~number~).\n        1. Assert: _primValue_ is not an Object.\n        1. Return ? ToNumber(_primValue_).\n      ",
      {
        "normalizedName" : "ToNumber",
        "name" : "ToNumber",
        "htmlId" : "sec-tonumber",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    812,
    [
      "MemberExpression[7,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[7]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[7,0].IsIdentifierRef",
        "name" : "MemberExpression[7,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1509,
    [
      "EnumerateObjectProperties",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Return an Iterator object (<emu-xref href=\"#sec-iterator-interface\"></emu-xref>) whose `next` method iterates over all the String-valued keys of enumerable properties of _O_. The iterator object is never directly accessible to ECMAScript code. The mechanics and order of enumerating the properties is not specified but must conform to the rules specified below.\n        ",
      {
        "normalizedName" : "EnumerateObjectProperties",
        "name" : "EnumerateObjectProperties",
        "htmlId" : "sec-enumerate-object-properties",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1081,
    [
      "CanBeHeldWeakly",
      0,
      [
        [
          "v",
          false,
          "ESValue"
        ]
      ],
      "\n      1. If _v_ is an Object, return *true*.\n      1. If _v_ is a Symbol and KeyForSymbol(_v_) is *undefined*, return *true*.\n      1. Return *false*.\n    ",
      {
        "normalizedName" : "CanBeHeldWeakly",
        "name" : "CanBeHeldWeakly",
        "htmlId" : "sec-canbeheldweakly",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    749,
    [
      "MultiplicativeExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[MultiplicativeExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MultiplicativeExpression[1,0].IsFunctionDefinition",
        "name" : "MultiplicativeExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "MultiplicativeExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeOperator"
              },
              {
                "type" : "nonterminal",
                "value" : "ExponentiationExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2629,
    [
      "DetachArrayBuffer",
      0,
      [
        [
          "arrayBuffer",
          false,
          "Record[ArrayBuffer]"
        ],
        [
          "key",
          true,
          "Unknown[\"Anything\"]"
        ]
      ],
      "\n          1. Assert: IsSharedArrayBuffer(_arrayBuffer_) is *false*.\n          1. If _key_ is not present, set _key_ to *undefined*.\n          1. If _arrayBuffer_.[[ArrayBufferDetachKey]] is not _key_, throw a *TypeError* exception.\n          1. Set _arrayBuffer_.[[ArrayBufferData]] to *null*.\n          1. Set _arrayBuffer_.[[ArrayBufferByteLength]] to 0.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "DetachArrayBuffer",
        "name" : "DetachArrayBuffer",
        "htmlId" : "sec-detacharraybuffer",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1990,
    [
      "ExportFromClause[2,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportFromClause[2]]"
        ]
      ],
      "\n          1. Return the ExportedNames of |NamedExports|.\n        ",
      {
        "normalizedName" : "ExportFromClause[2,0].ExportedNames",
        "name" : "ExportFromClause[2,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ExportFromClause",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NamedExports"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    617,
    [
      "CaseBlock[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CaseBlock[0,0].ContainsUndefinedBreakTarget",
        "name" : "CaseBlock[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    516,
    [
      "Statement[8,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[8]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[8,0].ContainsDuplicateLabels",
        "name" : "Statement[8,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ReturnStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2684,
    [
      "INTRINSICS.DataView.prototype.setFloat32",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~float32~, _value_).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.setFloat32",
        "name" : "INTRINSICS.DataView.prototype.setFloat32",
        "htmlId" : "sec-dataview.prototype.setfloat32",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2202,
    [
      "INTRINSICS.Date.prototype.getUTCFullYear",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return YearFromTime(_t_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getUTCFullYear",
        "name" : "INTRINSICS.Date.prototype.getUTCFullYear",
        "htmlId" : "sec-date.prototype.getutcfullyear",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    939,
    [
      "MemberExpression[3,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[3]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "MemberExpression[3,0].AssignmentTargetType",
        "name" : "MemberExpression[3,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1340,
    [
      "ContinueDynamicImport:clo1:clo0",
      6,
      [
      ],
      "\n            1. If _moduleCompletion_ is an abrupt completion, then\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).\n              1. Return ~unused~.\n            1. Let _module_ be _moduleCompletion_.[[Value]].\n            1. Let _loadPromise_ be _module_.LoadRequestedModules().\n            1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _reason_ »).\n              1. Return ~unused~.\n            1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n            1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, and _onRejected_ and performs the following steps when called:\n              1. Let _link_ be Completion(_module_.Link()).\n              1. If _link_ is an abrupt completion, then\n                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _link_.[[Value]] »).\n                1. Return ~unused~.\n              1. Let _evaluatePromise_ be _module_.Evaluate().\n              1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and _promiseCapability_ and performs the following steps when called:\n                1. Let _namespace_ be GetModuleNamespace(_module_).\n                1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _namespace_ »).\n                1. Return ~unused~.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *\"\"*, « »).\n              1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).\n              1. Return ~unused~.\n            1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, 0, *\"\"*, « »).\n            1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "ContinueDynamicImport",
        "name" : "ContinueDynamicImport",
        "htmlId" : "sec-ContinueDynamicImport",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    342,
    [
      "ScriptBody[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ScriptBody[0]]"
        ]
      ],
      "\n        1. Return TopLevelLexicallyScopedDeclarations of |StatementList|.\n      ",
      {
        "normalizedName" : "ScriptBody[0,0].LexicallyScopedDeclarations",
        "name" : "ScriptBody[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ScriptBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    123,
    [
      "StrUnsignedDecimalLiteral[1,1].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StrUnsignedDecimalLiteral[1]]"
        ]
      ],
      "\n            1. Let _a_ be MV of the first |DecimalDigits|.\n            1. If the second |DecimalDigits| is present, then\n              1. Let _b_ be MV of the second |DecimalDigits|.\n              1. Let _n_ be the number of code points in the second |DecimalDigits|.\n            1. Else,\n              1. Let _b_ be 0.\n              1. Let _n_ be 0.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Return RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>).\n          ",
      {
        "normalizedName" : "StrUnsignedDecimalLiteral[1,1].StringNumericValue",
        "name" : "StrUnsignedDecimalLiteral[1,1].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "StrUnsignedDecimalLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "ExponentPart"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1472,
    [
      "ForStatement[1,3].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Perform ? Evaluation of |VariableDeclarationList|.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        ",
      {
        "normalizedName" : "ForStatement[1,3].ForLoopEvaluation",
        "name" : "ForStatement[1,3].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2333,
    [
      "GroupSpecifiersThatMatch",
      0,
      [
        [
          "thisGroupName",
          false,
          "Ast[GroupName]"
        ]
      ],
      "\n          1. Let _name_ be the CapturingGroupName of _thisGroupName_.\n          1. Let _pattern_ be the |Pattern| containing _thisGroupName_.\n          1. Let _result_ be a new empty List.\n          1. For each |GroupSpecifier| _gs_ that _pattern_ contains, do\n            1. If the CapturingGroupName of _gs_ is _name_, then\n              1. Append _gs_ to _result_.\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "GroupSpecifiersThatMatch",
        "name" : "GroupSpecifiersThatMatch",
        "htmlId" : "sec-groupspecifiersthatmatch",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1145,
    [
      "Record[StringExoticObject].GetOwnProperty",
      4,
      [
        [
          "S",
          false,
          "Record[StringExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. Let _desc_ be OrdinaryGetOwnProperty(_S_, _P_).\n          1. If _desc_ is not *undefined*, return _desc_.\n          1. Return StringGetOwnProperty(_S_, _P_).\n        ",
      {
        "normalizedName" : "Record[StringExoticObject].GetOwnProperty",
        "name" : "Record[StringExoticObject].GetOwnProperty",
        "htmlId" : "sec-string-exotic-objects-getownproperty-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "StringExoticObject",
          "[[GetOwnProperty]]"
        ]
      }
    ]
  ],
  [
    2256,
    [
      "StringPad",
      0,
      [
        [
          "S",
          false,
          "String"
        ],
        [
          "maxLength",
          false,
          "Int[0+]"
        ],
        [
          "fillString",
          false,
          "String"
        ],
        [
          "placement",
          false,
          "Enum[~end~, ~start~]"
        ]
      ],
      "\n            1. Let _stringLength_ be the length of _S_.\n            1. If _maxLength_ ≤ _stringLength_, return _S_.\n            1. If _fillString_ is the empty String, return _S_.\n            1. Let _fillLen_ be _maxLength_ - _stringLength_.\n            1. Let _truncatedStringFiller_ be the String value consisting of repeated concatenations of _fillString_ truncated to length _fillLen_.\n            1. If _placement_ is ~start~, return the string-concatenation of _truncatedStringFiller_ and _S_.\n            1. Else, return the string-concatenation of _S_ and _truncatedStringFiller_.\n          ",
      {
        "normalizedName" : "StringPad",
        "name" : "StringPad",
        "htmlId" : "sec-stringpad",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2564,
    [
      "INTRINSICS.TypedArray.prototype.sort",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n          1. Let _obj_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_obj_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href=\"#sec-array.prototype.sort\"></emu-xref>.\n          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n            1. Return ? CompareTypedArrayElements(_x_, _y_, _comparefn_).\n          1. Let _sortedList_ be ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~read-through-holes~).\n          1. Let _j_ be 0.\n          1. Repeat, while _j_ < _len_,\n            1. Perform ! Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).\n            1. Set _j_ to _j_ + 1.\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.sort",
        "name" : "INTRINSICS.TypedArray.prototype.sort",
        "htmlId" : "sec-%typedarray%.prototype.sort",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2846,
    [
      "INTRINSICS.Reflect.ownKeys",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _keys_ be ? <emu-meta effects=\"user-code\">_target_.[[OwnPropertyKeys]]()</emu-meta>.\n        1. Return CreateArrayFromList(_keys_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.ownKeys",
        "name" : "INTRINSICS.Reflect.ownKeys",
        "htmlId" : "sec-reflect.ownkeys",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1018,
    [
      "Record[ObjectEnvironmentRecord].HasBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[ObjectEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ]
      ],
      "\n            1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n            1. Let _foundBinding_ be ? HasProperty(_bindingObject_, _N_).\n            1. If _foundBinding_ is *false*, return *false*.\n            1. If _envRec_.[[IsWithEnvironment]] is *false*, return *true*.\n            1. Let _unscopables_ be ? Get(_bindingObject_, @@unscopables).\n            1. If _unscopables_ is an Object, then\n              1. Let _blocked_ be ToBoolean(? Get(_unscopables_, _N_)).\n              1. If _blocked_ is *true*, return *false*.\n            1. Return *true*.\n          ",
      {
        "normalizedName" : "Record[ObjectEnvironmentRecord].HasBinding",
        "name" : "Record[ObjectEnvironmentRecord].HasBinding",
        "htmlId" : "sec-object-environment-records-hasbinding-n",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ObjectEnvironmentRecord",
          "HasBinding"
        ]
      }
    ]
  ],
  [
    2597,
    [
      "INTRINSICS.Map.prototype.set",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, then\n              1. Set _p_.[[Value]] to _value_.\n              1. Return _M_.\n          1. If _key_ is *-0*<sub>𝔽</sub>, set _key_ to *+0*<sub>𝔽</sub>.\n          1. Let _p_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.\n          1. Append _p_ to _M_.[[MapData]].\n          1. Return _M_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Map.prototype.set",
        "name" : "INTRINSICS.Map.prototype.set",
        "htmlId" : "sec-map.prototype.set",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1958,
    [
      "ModuleItem[2,0].ImportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[2]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ModuleItem[2,0].ImportEntries",
        "name" : "ModuleItem[2,0].ImportEntries",
        "htmlId" : "sec-static-semantics-importentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntries",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    355,
    [
      "Statement[6,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[6]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[6,0].VarDeclaredNames",
        "name" : "Statement[6,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ContinueStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    968,
    [
      "RelationalExpression[6,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[6]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "RelationalExpression[6,0].AssignmentTargetType",
        "name" : "RelationalExpression[6,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    458,
    [
      "ForInOfStatement[6,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[6]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForInOfStatement[6,0].VarScopedDeclarations",
        "name" : "ForInOfStatement[6,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1181,
    [
      "Record[ModuleNamespaceExoticObject].GetOwnProperty",
      4,
      [
        [
          "O",
          false,
          "Record[ModuleNamespaceExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. If _P_ is a Symbol, return OrdinaryGetOwnProperty(_O_, _P_).\n          1. Let _exports_ be _O_.[[Exports]].\n          1. If _exports_ does not contain _P_, return *undefined*.\n          1. Let _value_ be ? _O_.[[Get]](_P_, _O_).\n          1. Return PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }.\n        ",
      {
        "normalizedName" : "Record[ModuleNamespaceExoticObject].GetOwnProperty",
        "name" : "Record[ModuleNamespaceExoticObject].GetOwnProperty",
        "htmlId" : "sec-module-namespace-exotic-objects-getownproperty-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleNamespaceExoticObject",
          "[[GetOwnProperty]]"
        ]
      }
    ]
  ],
  [
    823,
    [
      "AsyncArrowFunction[0,0].NamedEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowFunction[0]]"
        ],
        [
          "name",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction| with argument _name_.\n      ",
      {
        "normalizedName" : "AsyncArrowFunction[0,0].NamedEvaluation",
        "name" : "AsyncArrowFunction[0,0].NamedEvaluation",
        "htmlId" : "sec-runtime-semantics-namedevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NamedEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncArrowFunction",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncArrowBindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    836,
    [
      "AsyncGeneratorDeclaration[1,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorDeclaration[1]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorDeclaration[1,0].Contains",
        "name" : "AsyncGeneratorDeclaration[1,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncGeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1551,
    [
      "Catch[1,0].CatchClauseEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Catch[1]]"
        ],
        [
          "thrownValue",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Return ? Evaluation of |Block|.\n      ",
      {
        "normalizedName" : "Catch[1,0].CatchClauseEvaluation",
        "name" : "Catch[1,0].CatchClauseEvaluation",
        "htmlId" : "sec-runtime-semantics-catchclauseevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CatchClauseEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Catch",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "catch"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2582,
    [
      "InitializeTypedArrayFromArrayBuffer",
      0,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "buffer",
          false,
          "Record[ArrayBuffer | SharedArrayBuffer]"
        ],
        [
          "byteOffset",
          false,
          "ESValue"
        ],
        [
          "length",
          false,
          "ESValue"
        ]
      ],
      "\n            1. Let _elementSize_ be TypedArrayElementSize(_O_).\n            1. Let _offset_ be ? ToIndex(_byteOffset_).\n            1. If _offset_ modulo _elementSize_ ≠ 0, throw a *RangeError* exception.\n            1. Let _bufferIsFixedLength_ be IsFixedLengthArrayBuffer(_buffer_).\n            1. If _length_ is not *undefined*, then\n              1. Let _newLength_ be ? ToIndex(_length_).\n            1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.\n            1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_, ~seq-cst~).\n            1. If _length_ is *undefined* and _bufferIsFixedLength_ is *false*, then\n              1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.\n              1. Set _O_.[[ByteLength]] to ~auto~.\n              1. Set _O_.[[ArrayLength]] to ~auto~.\n            1. Else,\n              1. If _length_ is *undefined*, then\n                1. If _bufferByteLength_ modulo _elementSize_ ≠ 0, throw a *RangeError* exception.\n                1. Let _newByteLength_ be _bufferByteLength_ - _offset_.\n                1. If _newByteLength_ < 0, throw a *RangeError* exception.\n              1. Else,\n                1. Let _newByteLength_ be _newLength_ × _elementSize_.\n                1. If _offset_ + _newByteLength_ > _bufferByteLength_, throw a *RangeError* exception.\n              1. Set _O_.[[ByteLength]] to _newByteLength_.\n              1. Set _O_.[[ArrayLength]] to _newByteLength_ / _elementSize_.\n            1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.\n            1. Set _O_.[[ByteOffset]] to _offset_.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "InitializeTypedArrayFromArrayBuffer",
        "name" : "InitializeTypedArrayFromArrayBuffer",
        "htmlId" : "sec-initializetypedarrayfromarraybuffer",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    194,
    [
      "GetIteratorFromMethod",
      0,
      [
        [
          "obj",
          false,
          "ESValue"
        ],
        [
          "method",
          false,
          "Record[FunctionObject]"
        ]
      ],
      "\n        1. Let _iterator_ be ? Call(_method_, _obj_).\n        1. If _iterator_ is not an Object, throw a *TypeError* exception.\n        1. Let _nextMethod_ be ? Get(_iterator_, *\"next\"*).\n        1. Let _iteratorRecord_ be the Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.\n        1. Return _iteratorRecord_.\n      ",
      {
        "normalizedName" : "GetIteratorFromMethod",
        "name" : "GetIteratorFromMethod",
        "htmlId" : "sec-getiteratorfrommethod",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    145,
    [
      "ToIndex",
      0,
      [
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _integer_ be ? ToIntegerOrInfinity(_value_).\n        1. If _integer_ is not in the inclusive interval from 0 to 2<sup>53</sup> - 1, throw a *RangeError* exception.\n        1. Return _integer_.\n      ",
      {
        "normalizedName" : "ToIndex",
        "name" : "ToIndex",
        "htmlId" : "sec-toindex",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2661,
    [
      "INTRINSICS.get SharedArrayBuffer.prototype.maxByteLength",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n          1. If IsFixedLengthArrayBuffer(_O_) is *true*, then\n            1. Let _length_ be _O_.[[ArrayBufferByteLength]].\n          1. Else,\n            1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].\n          1. Return 𝔽(_length_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get SharedArrayBuffer.prototype.maxByteLength",
        "name" : "INTRINSICS.get SharedArrayBuffer.prototype.maxByteLength",
        "htmlId" : "sec-get-sharedarraybuffer.prototype.maxbytelength",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1647,
    [
      "GeneratorDeclaration[0,0].InstantiateGeneratorFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorDeclaration[0]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Let _name_ be StringValue of |BindingIdentifier|.\n        1. Let _sourceText_ be the source text matched by |GeneratorDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, _name_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "GeneratorDeclaration[0,0].InstantiateGeneratorFunctionObject",
        "name" : "GeneratorDeclaration[0,0].InstantiateGeneratorFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiategeneratorfunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateGeneratorFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2720,
    [
      "INTRINSICS.Atomics.store",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).\n        1. If _typedArray_.[[ContentType]] is ~bigint~, let _v_ be ? ToBigInt(_value_).\n        1. Otherwise, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).\n        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).\n        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n        1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n        1. Perform SetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, *true*, ~seq-cst~).\n        1. Return _v_.\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.store",
        "name" : "INTRINSICS.Atomics.store",
        "htmlId" : "sec-atomics.store",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1531,
    [
      "IsLabelledFunction",
      0,
      [
        [
          "stmt",
          false,
          "Ast[Statement]"
        ]
      ],
      "\n        1. If _stmt_ is not a |LabelledStatement|, return *false*.\n        1. Let _item_ be the |LabelledItem| of _stmt_.\n        1. If _item_ is <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>, return *true*.\n        1. Let _subStmt_ be the |Statement| of _item_.\n        1. Return IsLabelledFunction(_subStmt_).\n      ",
      {
        "normalizedName" : "IsLabelledFunction",
        "name" : "IsLabelledFunction",
        "htmlId" : "sec-islabelledfunction",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1845,
    [
      "ShiftExpression[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ShiftExpression[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ShiftExpression[2,0].HasCallInTailPosition",
        "name" : "ShiftExpression[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ShiftExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              },
              {
                "type" : "terminal",
                "value" : ">>"
              },
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2513,
    [
      "INTRINSICS.Array.prototype.sort:clo0",
      6,
      [
        [
          "x",
          false,
          "Unknown"
        ],
        [
          "y",
          false,
          "Unknown"
        ]
      ],
      "\n          1. [id=\"step-array-sort-comparefn\"] If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n          1. Let _obj_ be ? ToObject(*this* value).\n          1. [id=\"step-array-sort-len\"] Let _len_ be ? LengthOfArrayLike(_obj_).\n          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n            1. Return ? CompareArrayElements(_x_, _y_, _comparefn_).\n          1. [id=\"step-array-sortindexedproperties\"] Let _sortedList_ be ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~skip-holes~).\n          1. Let _itemCount_ be the number of elements in _sortedList_.\n          1. Let _j_ be 0.\n          1. Repeat, while _j_ < _itemCount_,\n            1. Perform ? Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).\n            1. Set _j_ to _j_ + 1.\n          1. NOTE: The call to SortIndexedProperties in step <emu-xref href=\"#step-array-sortindexedproperties\"></emu-xref> uses ~skip-holes~. The remaining indices are deleted to preserve the number of holes that were detected and excluded from the sort.\n          1. Repeat, while _j_ < _len_,\n            1. Perform ? DeletePropertyOrThrow(_obj_, ! ToString(𝔽(_j_))).\n            1. Set _j_ to _j_ + 1.\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.sort",
        "name" : "INTRINSICS.Array.prototype.sort",
        "htmlId" : "sec-array.prototype.sort",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2567,
    [
      "INTRINSICS.TypedArray.prototype.toSorted:clo0",
      6,
      [
        [
          "x",
          false,
          "Unknown"
        ],
        [
          "y",
          false,
          "Unknown"
        ]
      ],
      "\n          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _A_ be ? TypedArrayCreateSameType(_O_, « 𝔽(_len_) »).\n          1. NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href=\"#sec-array.prototype.tosorted\"></emu-xref>.\n          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n            1. Return ? CompareTypedArrayElements(_x_, _y_, _comparefn_).\n          1. Let _sortedList_ be ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).\n          1. Let _j_ be 0.\n          1. Repeat, while _j_ < _len_,\n            1. Perform ! Set(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).\n            1. Set _j_ to _j_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.toSorted",
        "name" : "INTRINSICS.TypedArray.prototype.toSorted",
        "htmlId" : "sec-%typedarray%.prototype.tosorted",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1547,
    [
      "Statement[12,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[12]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |Statement|.\n      ",
      {
        "normalizedName" : "Statement[12,0].LabelledEvaluation",
        "name" : "Statement[12,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 12,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TryStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    776,
    [
      "AssignmentExpression[6,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[6]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[6,0].IsFunctionDefinition",
        "name" : "AssignmentExpression[6,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "&&="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1748,
    [
      "ClassElementName[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementName[1]]"
        ]
      ],
      "\n        1. Let _privateIdentifier_ be StringValue of |PrivateIdentifier|.\n        1. Let _privateEnvRec_ be the running execution context's PrivateEnvironment.\n        1. Let _names_ be _privateEnvRec_.[[Names]].\n        1. Assert: Exactly one element of _names_ is a Private Name whose [[Description]] is _privateIdentifier_.\n        1. Let _privateName_ be the Private Name in _names_ whose [[Description]] is _privateIdentifier_.\n        1. Return _privateName_.\n      ",
      {
        "normalizedName" : "ClassElementName[1,0].Evaluation",
        "name" : "ClassElementName[1,0].Evaluation",
        "htmlId" : "sec-class-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassElementName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1798,
    [
      "ForStatement[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[2,0].HasCallInTailPosition",
        "name" : "ForStatement[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    525,
    [
      "WhileStatement[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[WhileStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "WhileStatement[0,0].ContainsDuplicateLabels",
        "name" : "WhileStatement[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2298,
    [
      "RegExpUnicodeEscapeSequence[4,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[RegExpUnicodeEscapeSequence[4]]"
        ]
      ],
      "\n          1. Return the MV of |Hex4Digits|.\n        ",
      {
        "normalizedName" : "RegExpUnicodeEscapeSequence[4,0].CharacterValue",
        "name" : "RegExpUnicodeEscapeSequence[4,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "RegExpUnicodeEscapeSequence",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "u"
              },
              {
                "type" : "nonterminal",
                "value" : "Hex4Digits"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    48,
    [
      "RunJobs",
      0,
      [
      ],
      "\n    1. Perform ? InitializeHostDefinedRealm().\n    1. Let _scriptEvaluationJob_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n      1. Let _sourceText_ be the source code of a script.\n      1. Let _script_ be ParseScript(_sourceText_, the current Realm Record, ~empty~).\n      1. Perform ? ScriptEvaluation(_script_).\n      1. Return *undefined*.\n    1. Perform HostEnqueuePromiseJob(_scriptEvaluationJob_, the current Realm Record).\n    1. Let _errors_ be *undefined*.\n    1. Repeat,\n      1. Suspend the running execution context and remove it from the execution context stack.\n      1. Assert: The execution context stack is empty.\n      1. Let _nextQueue_ be a non-empty Job Queue chosen in an implementation-defined manner.\n      1. If all Job Queues are empty, the result is implementation-defined.\n      1. Let _nextPending_ be the PendingJob record at the front of _nextQueue_. Remove that record from _nextQueue_.\n      1. Let _newContext_ be a new execution context.\n      1. Set _newContext_'s Function to *null*.\n      1. Set _newContext_'s Realm to _nextPending_.[[Realm]].\n      1. Set _newContext_'s ScriptOrModule to _nextPending_.[[ScriptOrModule]].\n      1. Push _newContext_ onto the execution context stack; _newContext_ is now the running execution context.\n      1. Let _job_ be _nextPending_.[[Job]].\n      1. Let _result_ be _job_().\n      1. If _result_ is an abrupt completion,\n        1. If _errors_ is *undefined*, set _errors_ to « _result_.[[Value]] ».\n        1. Otherwise, append _result_.[[Value]] to _errors_.\n  ",
      {
        "normalizedName" : "RunJobs",
        "name" : "RunJobs",
        "htmlId" : "sec-runjobs",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    712,
    [
      "ClassExpression[0,0].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassExpression[0,0].HasName",
        "name" : "ClassExpression[0,0].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    557,
    [
      "CaseBlock[1,3].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,3].ContainsDuplicateLabels",
        "name" : "CaseBlock[1,3].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1003,
    [
      "ClassElement[5,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[5]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "ClassElement[5,0].PropName",
        "name" : "ClassElement[5,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1770,
    [
      "Statement[3,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[3]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[3,0].HasCallInTailPosition",
        "name" : "Statement[3,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    580,
    [
      "Statement[13,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[13]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[13,0].ContainsUndefinedBreakTarget",
        "name" : "Statement[13,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 13,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DebuggerStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    855,
    [
      "OptionalChain[2,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[2]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "OptionalChain[2,0].Contains",
        "name" : "OptionalChain[2,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "?."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2715,
    [
      "INTRINSICS.Atomics.compareExchange",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).\n        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n        1. Let _block_ be _buffer_.[[ArrayBufferData]].\n        1. If _typedArray_.[[ContentType]] is ~bigint~, then\n          1. Let _expected_ be ? ToBigInt(_expectedValue_).\n          1. Let _replacement_ be ? ToBigInt(_replacementValue_).\n        1. Else,\n          1. Let _expected_ be 𝔽(? ToIntegerOrInfinity(_expectedValue_)).\n          1. Let _replacement_ be 𝔽(? ToIntegerOrInfinity(_replacementValue_)).\n        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).\n        1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n        1. Let _elementSize_ be TypedArrayElementSize(_typedArray_).\n        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n        1. Let _expectedBytes_ be NumericToRawBytes(_elementType_, _expected_, _isLittleEndian_).\n        1. Let _replacementBytes_ be NumericToRawBytes(_elementType_, _replacement_, _isLittleEndian_).\n        1. If IsSharedArrayBuffer(_buffer_) is *true*, then\n          1. Let _rawBytesRead_ be AtomicCompareExchangeInSharedBlock(_block_, _byteIndexInBuffer_, _elementSize_, _expectedBytes_, _replacementBytes_).\n        1. Else,\n          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndexInBuffer_].\n          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then\n            1. Store the individual bytes of _replacementBytes_ into _block_, starting at _block_[_byteIndexInBuffer_].\n        1. Return RawBytesToNumeric(_elementType_, _rawBytesRead_, _isLittleEndian_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.compareExchange",
        "name" : "INTRINSICS.Atomics.compareExchange",
        "htmlId" : "sec-atomics.compareexchange",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    690,
    [
      "CaseClause[0,1].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CaseClause[0,1].ContainsUndefinedContinueTarget",
        "name" : "CaseClause[0,1].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1598,
    [
      "SingleNameBinding[0,0].HasInitializer",
      2,
      [
        [
          "this",
          false,
          "Ast[SingleNameBinding[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "SingleNameBinding[0,0].HasInitializer",
        "name" : "SingleNameBinding[0,0].HasInitializer",
        "htmlId" : "sec-static-semantics-hasinitializer",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasInitializer",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SingleNameBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1516,
    [
      "ReturnStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ReturnStatement[0]]"
        ]
      ],
      "\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: *undefined*, [[Target]]: ~empty~ }.\n      ",
      {
        "normalizedName" : "ReturnStatement[0,0].Evaluation",
        "name" : "ReturnStatement[0,0].Evaluation",
        "htmlId" : "sec-return-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ReturnStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "return"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    63,
    [
      "Number::equal",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. If _x_ is *NaN*, return *false*.\n            1. If _y_ is *NaN*, return *false*.\n            1. If _x_ is _y_, return *true*.\n            1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *true*.\n            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *true*.\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "Number::equal",
        "name" : "Number::equal",
        "htmlId" : "sec-numeric-types-number-equal",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    640,
    [
      "Statement[3,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[3]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[3,0].ContainsUndefinedContinueTarget",
        "name" : "Statement[3,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1961,
    [
      "ImportClause[3,0].ImportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportClause[3]]"
        ],
        [
          "module",
          false,
          "String"
        ]
      ],
      "\n          1. Let _entries1_ be ImportEntriesForModule of |ImportedDefaultBinding| with argument _module_.\n          1. Let _entries2_ be ImportEntriesForModule of |NameSpaceImport| with argument _module_.\n          1. Return the list-concatenation of _entries1_ and _entries2_.\n        ",
      {
        "normalizedName" : "ImportClause[3,0].ImportEntriesForModule",
        "name" : "ImportClause[3,0].ImportEntriesForModule",
        "htmlId" : "sec-static-semantics-importentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ImportClause",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportedDefaultBinding"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "NameSpaceImport"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2397,
    [
      "CharacterClassEscape[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return the ten-element CharSet containing the characters `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, and `9`.\n        ",
      {
        "normalizedName" : "CharacterClassEscape[0,0].CompileToCharSet",
        "name" : "CharacterClassEscape[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "d"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1025,
    [
      "Record[ObjectEnvironmentRecord].HasSuperBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[ObjectEnvironmentRecord]"
        ]
      ],
      "\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "Record[ObjectEnvironmentRecord].HasSuperBinding",
        "name" : "Record[ObjectEnvironmentRecord].HasSuperBinding",
        "htmlId" : "sec-object-environment-records-hassuperbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ObjectEnvironmentRecord",
          "HasSuperBinding"
        ]
      }
    ]
  ],
  [
    295,
    [
      "CaseBlock[1,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _names1_ be the LexicallyDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be LexicallyDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the LexicallyDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,0].LexicallyDeclaredNames",
        "name" : "CaseBlock[1,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    18,
    [
      "INTRINSICS.SyntaxError",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1070,
    [
      "GetNewTarget",
      0,
      [
      ],
      "\n        1. Let _envRec_ be GetThisEnvironment().\n        1. Assert: _envRec_ has a [[NewTarget]] field.\n        1. Return _envRec_.[[NewTarget]].\n      ",
      {
        "normalizedName" : "GetNewTarget",
        "name" : "GetNewTarget",
        "htmlId" : "sec-getnewtarget",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    872,
    [
      "FunctionDeclaration[1,0].InstantiateFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[1]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Return InstantiateOrdinaryFunctionObject of |FunctionDeclaration| with arguments _env_ and _privateEnv_.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[1,0].InstantiateFunctionObject",
        "name" : "FunctionDeclaration[1,0].InstantiateFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiatefunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    705,
    [
      "FunctionExpression[0,0].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,0].HasName",
        "name" : "FunctionExpression[0,0].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    282,
    [
      "AsyncGeneratorDeclaration[1,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorDeclaration[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorDeclaration[1,0].IsConstantDeclaration",
        "name" : "AsyncGeneratorDeclaration[1,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncGeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1611,
    [
      "FunctionBody[0,0].EvaluateFunctionBody",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).\n        1. Return ? Evaluation of |FunctionStatementList|.\n      ",
      {
        "normalizedName" : "FunctionBody[0,0].EvaluateFunctionBody",
        "name" : "FunctionBody[0,0].EvaluateFunctionBody",
        "htmlId" : "sec-runtime-semantics-evaluatefunctionbody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateFunctionBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionStatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2375,
    [
      "Atom[4,0].CompileAtom",
      2,
      [
        [
          "this",
          false,
          "Ast[Atom[4]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.\n          1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Atom|).\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _direction_, _m_, and _parenIndex_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _x_, _c_, _direction_, and _parenIndex_ and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Let _cap_ be a copy of _y_.[[Captures]].\n              1. Let _Input_ be _x_.[[Input]].\n              1. Let _xe_ be _x_.[[EndIndex]].\n              1. Let _ye_ be _y_.[[EndIndex]].\n              1. If _direction_ is ~forward~, then\n                1. Assert: _xe_ ≤ _ye_.\n                1. Let _r_ be the CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ }.\n              1. Else,\n                1. Assert: _direction_ is ~backward~.\n                1. Assert: _ye_ ≤ _xe_.\n                1. Let _r_ be the CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ }.\n              1. Set _cap_[_parenIndex_ + 1] to _r_.\n              1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ }.\n              1. Return _c_(_z_).\n            1. Return _m_(_x_, _d_).\n        ",
      {
        "normalizedName" : "Atom[4,0].CompileAtom",
        "name" : "Atom[4,0].CompileAtom",
        "htmlId" : "sec-compileatom",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAtom",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "Atom",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Disjunction"
              },
              {
                "type" : "terminal",
                "value" : ")"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1156,
    [
      "CreateMappedArgumentsObject",
      0,
      [
        [
          "func",
          false,
          "Record[Object]"
        ],
        [
          "formals",
          false,
          "Ast"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ]
      ],
      "\n          1. Assert: _formals_ does not contain a rest parameter, any binding patterns, or any initializers. It may contain duplicate identifiers.\n          1. Let _len_ be the number of elements in _argumentsList_.\n          1. Let _obj_ be MakeBasicObject(« [[Prototype]], [[Extensible]], [[ParameterMap]] »).\n          1. Set _obj_.[[GetOwnProperty]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-getownproperty-p\"></emu-xref>.\n          1. Set _obj_.[[DefineOwnProperty]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-defineownproperty-p-desc\"></emu-xref>.\n          1. Set _obj_.[[Get]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-get-p-receiver\"></emu-xref>.\n          1. Set _obj_.[[Set]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-set-p-v-receiver\"></emu-xref>.\n          1. Set _obj_.[[Delete]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-delete-p\"></emu-xref>.\n          1. Set _obj_.[[Prototype]] to %Object.prototype%.\n          1. Let _map_ be OrdinaryObjectCreate(*null*).\n          1. Set _obj_.[[ParameterMap]] to _map_.\n          1. Let _parameterNames_ be the BoundNames of _formals_.\n          1. Let _numberOfParameters_ be the number of elements in _parameterNames_.\n          1. Let _index_ be 0.\n          1. Repeat, while _index_ < _len_,\n            1. Let _val_ be _argumentsList_[_index_].\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_).\n            1. Set _index_ to _index_ + 1.\n          1. Perform ! DefinePropertyOrThrow(_obj_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n          1. Let _mappedNames_ be a new empty List.\n          1. Set _index_ to _numberOfParameters_ - 1.\n          1. Repeat, while _index_ ≥ 0,\n            1. Let _name_ be _parameterNames_[_index_].\n            1. If _mappedNames_ does not contain _name_, then\n              1. Append _name_ to _mappedNames_.\n              1. If _index_ < _len_, then\n                1. Let _g_ be MakeArgGetter(_name_, _env_).\n                1. Let _p_ be MakeArgSetter(_name_, _env_).\n                1. Perform ! _map_.[[DefineOwnProperty]](! ToString(𝔽(_index_)), PropertyDescriptor { [[Set]]: _p_, [[Get]]: _g_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n            1. Set _index_ to _index_ - 1.\n          1. Perform ! DefinePropertyOrThrow(_obj_, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n          1. Perform ! DefinePropertyOrThrow(_obj_, *\"callee\"*, PropertyDescriptor { [[Value]]: _func_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "CreateMappedArgumentsObject",
        "name" : "CreateMappedArgumentsObject",
        "htmlId" : "sec-createmappedargumentsobject",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1225,
    [
      "RegularExpressionLiteral[0,0].BodyText",
      2,
      [
        [
          "this",
          false,
          "Ast[RegularExpressionLiteral[0]]"
        ]
      ],
      "\n          1. Return the source text that was recognized as |RegularExpressionBody|.\n        ",
      {
        "normalizedName" : "RegularExpressionLiteral[0,0].BodyText",
        "name" : "RegularExpressionLiteral[0,0].BodyText",
        "htmlId" : "sec-static-semantics-bodytext",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BodyText",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "RegularExpressionLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "/"
              },
              {
                "type" : "nonterminal",
                "value" : "RegularExpressionBody"
              },
              {
                "type" : "terminal",
                "value" : "/"
              },
              {
                "type" : "nonterminal",
                "value" : "RegularExpressionFlags"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    150,
    [
      "IsIntegralNumber",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If _argument_ is not a Number, return *false*.\n        1. If _argument_ is not finite, return *false*.\n        1. If truncate(ℝ(_argument_)) ≠ ℝ(_argument_), return *false*.\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "IsIntegralNumber",
        "name" : "IsIntegralNumber",
        "htmlId" : "sec-isintegralnumber",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2060,
    [
      "INTRINSICS.Object.hasOwn",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Let _key_ be ? ToPropertyKey(_P_).\n          1. Return ? HasOwnProperty(_obj_, _key_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.hasOwn",
        "name" : "INTRINSICS.Object.hasOwn",
        "htmlId" : "sec-object.hasown",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1743,
    [
      "ClassDeclaration[0,0].BindingClassDeclarationEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassDeclaration[0]]"
        ]
      ],
      "\n        1. Let _className_ be StringValue of |BindingIdentifier|.\n        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments _className_ and _className_.\n        1. Set _value_.[[SourceText]] to the source text matched by |ClassDeclaration|.\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. Perform ? InitializeBoundName(_className_, _value_, _env_).\n        1. Return _value_.\n      ",
      {
        "normalizedName" : "ClassDeclaration[0,0].BindingClassDeclarationEvaluation",
        "name" : "ClassDeclaration[0,0].BindingClassDeclarationEvaluation",
        "htmlId" : "sec-runtime-semantics-bindingclassdeclarationevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BindingClassDeclarationEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1400,
    [
      "ArrayAssignmentPattern[1,0].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayAssignmentPattern[1]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "ArrayAssignmentPattern[1,0].DestructuringAssignmentEvaluation",
        "name" : "ArrayAssignmentPattern[1,0].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ArrayAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentElementList"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    707,
    [
      "AsyncGeneratorExpression[0,0].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,0].HasName",
        "name" : "AsyncGeneratorExpression[0,0].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2192,
    [
      "INTRINSICS.Date.prototype.getFullYear",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return YearFromTime(LocalTime(_t_)).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getFullYear",
        "name" : "INTRINSICS.Date.prototype.getFullYear",
        "htmlId" : "sec-date.prototype.getfullyear",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    887,
    [
      "ObjectBindingPattern[1,0].BindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectBindingPattern[1]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _excludedNames_ be a new empty List.\n        1. Return ? RestBindingInitialization of |BindingRestProperty| with arguments _value_, _environment_, and _excludedNames_.\n      ",
      {
        "normalizedName" : "ObjectBindingPattern[1,0].BindingInitialization",
        "name" : "ObjectBindingPattern[1,0].BindingInitialization",
        "htmlId" : "sec-runtime-semantics-bindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ObjectBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestProperty"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    414,
    [
      "ClassStaticBlockStatementList[0,1].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockStatementList[0]]"
        ]
      ],
      "\n        1. Return the TopLevelVarDeclaredNames of |StatementList|.\n      ",
      {
        "normalizedName" : "ClassStaticBlockStatementList[0,1].VarDeclaredNames",
        "name" : "ClassStaticBlockStatementList[0,1].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ClassStaticBlockStatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    971,
    [
      "EqualityExpression[2,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[2]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "EqualityExpression[2,0].AssignmentTargetType",
        "name" : "EqualityExpression[2,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "!="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    95,
    [
      "GetValue",
      0,
      [
        [
          "V",
          false,
          "ESValue | Record[ReferenceRecord]"
        ]
      ],
      "\n          1. If _V_ is not a Reference Record, return _V_.\n          1. If IsUnresolvableReference(_V_) is *true*, throw a *ReferenceError* exception.\n          1. If IsPropertyReference(_V_) is *true*, then\n            1. [id=\"step-getvalue-toobject\"] Let _baseObj_ be ? ToObject(_V_.[[Base]]).\n            1. If IsPrivateReference(_V_) is *true*, then\n              1. Return ? PrivateGet(_baseObj_, _V_.[[ReferencedName]]).\n            1. Return ? <emu-meta effects=\"user-code\">_baseObj_.[[Get]]</emu-meta>(_V_.[[ReferencedName]], GetThisValue(_V_)).\n          1. Else,\n            1. Let _base_ be _V_.[[Base]].\n            1. Assert: _base_ is an Environment Record.\n            1. Return ? <emu-meta effects=\"user-code\">_base_.GetBindingValue</emu-meta>(_V_.[[ReferencedName]], _V_.[[Strict]]) (see <emu-xref href=\"#sec-environment-records\"></emu-xref>).\n        ",
      {
        "normalizedName" : "GetValue",
        "name" : "GetValue",
        "htmlId" : "sec-getvalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1566,
    [
      "ArrayBindingPattern[2,3].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[2]]"
        ]
      ],
      "\n        1. Let _has_ be ContainsExpression of |BindingElementList|.\n        1. If _has_ is *true*, return *true*.\n        1. Return ContainsExpression of |BindingRestElement|.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[2,3].ContainsExpression",
        "name" : "ArrayBindingPattern[2,3].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 3,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2143,
    [
      "INTRINSICS.Math.imul",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _a_ be ℝ(? ToUint32(_x_)).\n          1. Let _b_ be ℝ(? ToUint32(_y_)).\n          1. Let _product_ be (_a_ × _b_) modulo 2<sup>32</sup>.\n          1. If _product_ ≥ 2<sup>31</sup>, return 𝔽(_product_ - 2<sup>32</sup>); otherwise return 𝔽(_product_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.imul",
        "name" : "INTRINSICS.Math.imul",
        "htmlId" : "sec-math.imul",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2012,
    [
      "ExportFromClause[1,0].ExportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportFromClause[1]]"
        ],
        [
          "module",
          false,
          "String | Null"
        ]
      ],
      "\n          1. Let _exportName_ be the StringValue of |ModuleExportName|.\n          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all~, [[LocalName]]: *null*, [[ExportName]]: _exportName_ }.\n          1. Return « _entry_ ».\n        ",
      {
        "normalizedName" : "ExportFromClause[1,0].ExportEntriesForModule",
        "name" : "ExportFromClause[1,0].ExportEntriesForModule",
        "htmlId" : "sec-static-semantics-exportentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportFromClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "as"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1605,
    [
      "FormalParameterList[1,0].ExpectedArgumentCount",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameterList[1]]"
        ]
      ],
      "\n        1. Let _count_ be ExpectedArgumentCount of |FormalParameterList|.\n        1. If HasInitializer of |FormalParameterList| is *true* or HasInitializer of |FormalParameter| is *true*, return _count_.\n        1. Return _count_ + 1.\n      ",
      {
        "normalizedName" : "FormalParameterList[1,0].ExpectedArgumentCount",
        "name" : "FormalParameterList[1,0].ExpectedArgumentCount",
        "htmlId" : "sec-static-semantics-expectedargumentcount",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExpectedArgumentCount",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FormalParameterList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameterList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2588,
    [
      "INTRINSICS.Map.groupBy",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _groups_ be ? GroupBy(_items_, _callbackfn_, ~zero~).\n          1. Let _map_ be ! Construct(%Map%).\n          1. For each Record { [[Key]], [[Elements]] } _g_ of _groups_, do\n            1. Let _elements_ be CreateArrayFromList(_g_.[[Elements]]).\n            1. Let _entry_ be the Record { [[Key]]: _g_.[[Key]], [[Value]]: _elements_ }.\n            1. Append _entry_ to _map_.[[MapData]].\n          1. Return _map_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Map.groupBy",
        "name" : "INTRINSICS.Map.groupBy",
        "htmlId" : "sec-map.groupby",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    327,
    [
      "CaseClauses[1,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClauses[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be LexicallyScopedDeclarations of |CaseClauses|.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |CaseClause|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "CaseClauses[1,0].LexicallyScopedDeclarations",
        "name" : "CaseClauses[1,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseClauses",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClause"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2732,
    [
      "SerializeJSONObject",
      0,
      [
        [
          "state",
          false,
          "Record[JSONSerializationRecord]"
        ],
        [
          "value",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. If _state_.[[Stack]] contains _value_, throw a *TypeError* exception because the structure is cyclical.\n          1. Append _value_ to _state_.[[Stack]].\n          1. Let _stepback_ be _state_.[[Indent]].\n          1. Set _state_.[[Indent]] to the string-concatenation of _state_.[[Indent]] and _state_.[[Gap]].\n          1. If _state_.[[PropertyList]] is not *undefined*, then\n            1. Let _K_ be _state_.[[PropertyList]].\n          1. Else,\n            1. Let _K_ be ? EnumerableOwnProperties(_value_, ~key~).\n          1. Let _partial_ be a new empty List.\n          1. For each element _P_ of _K_, do\n            1. Let _strP_ be ? SerializeJSONProperty(_state_, _P_, _value_).\n            1. If _strP_ is not *undefined*, then\n              1. Let _member_ be QuoteJSONString(_P_).\n              1. Set _member_ to the string-concatenation of _member_ and *\":\"*.\n              1. If _state_.[[Gap]] is not the empty String, then\n                1. Set _member_ to the string-concatenation of _member_ and the code unit 0x0020 (SPACE).\n              1. Set _member_ to the string-concatenation of _member_ and _strP_.\n              1. Append _member_ to _partial_.\n          1. If _partial_ is empty, then\n            1. Let _final_ be *\"{}\"*.\n          1. Else,\n            1. If _state_.[[Gap]] is the empty String, then\n              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.\n              1. Let _final_ be the string-concatenation of *\"{\"*, _properties_, and *\"}\"*.\n            1. Else,\n              1. Let _separator_ be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and _state_.[[Indent]].\n              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.\n              1. Let _final_ be the string-concatenation of *\"{\"*, the code unit 0x000A (LINE FEED), _state_.[[Indent]], _properties_, the code unit 0x000A (LINE FEED), _stepback_, and *\"}\"*.\n          1. Remove the last element of _state_.[[Stack]].\n          1. Set _state_.[[Indent]] to _stepback_.\n          1. Return _final_.\n        ",
      {
        "normalizedName" : "SerializeJSONObject",
        "name" : "SerializeJSONObject",
        "htmlId" : "sec-serializejsonobject",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1941,
    [
      "AsyncModuleExecutionFulfilled",
      0,
      [
        [
          "module",
          false,
          "Record[CyclicModuleRecord]"
        ]
      ],
      "\n              1. If _module_.[[Status]] is ~evaluated~, then\n                1. Assert: _module_.[[EvaluationError]] is not ~empty~.\n                1. Return ~unused~.\n              1. Assert: _module_.[[Status]] is ~evaluating-async~.\n              1. Assert: _module_.[[AsyncEvaluation]] is *true*.\n              1. Assert: _module_.[[EvaluationError]] is ~empty~.\n              1. Set _module_.[[AsyncEvaluation]] to *false*.\n              1. Set _module_.[[Status]] to ~evaluated~.\n              1. If _module_.[[TopLevelCapability]] is not ~empty~, then\n                1. Assert: _module_.[[CycleRoot]] is _module_.\n                1. Perform ! Call(_module_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* »).\n              1. Let _execList_ be a new empty List.\n              1. Perform GatherAvailableAncestors(_module_, _execList_).\n              1. Let _sortedExecList_ be a List whose elements are the elements of _execList_, in the order in which they had their [[AsyncEvaluation]] fields set to *true* in InnerModuleEvaluation.\n              1. Assert: All elements of _sortedExecList_ have their [[AsyncEvaluation]] field set to *true*, [[PendingAsyncDependencies]] field set to 0, and [[EvaluationError]] field set to ~empty~.\n              1. For each Cyclic Module Record _m_ of _sortedExecList_, do\n                1. If _m_.[[Status]] is ~evaluated~, then\n                  1. Assert: _m_.[[EvaluationError]] is not ~empty~.\n                1. Else if _m_.[[HasTLA]] is *true*, then\n                  1. Perform ExecuteAsyncModule(_m_).\n                1. Else,\n                  1. Let _result_ be <emu-meta effects=\"user-code\">_m_.ExecuteModule()</emu-meta>.\n                  1. If _result_ is an abrupt completion, then\n                    1. Perform AsyncModuleExecutionRejected(_m_, _result_.[[Value]]).\n                  1. Else,\n                    1. Set _m_.[[Status]] to ~evaluated~.\n                    1. If _m_.[[TopLevelCapability]] is not ~empty~, then\n                      1. Assert: _m_.[[CycleRoot]] is _m_.\n                      1. Perform ! Call(_m_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* »).\n              1. Return ~unused~.\n            ",
      {
        "normalizedName" : "AsyncModuleExecutionFulfilled",
        "name" : "AsyncModuleExecutionFulfilled",
        "htmlId" : "sec-async-module-execution-fulfilled",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    954,
    [
      "UnaryExpression[7,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[7]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "UnaryExpression[7,0].AssignmentTargetType",
        "name" : "UnaryExpression[7,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "!"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1252,
    [
      "ElementList[2,0].ArrayAccumulation",
      2,
      [
        [
          "this",
          false,
          "Ast[ElementList[2]]"
        ],
        [
          "array",
          false,
          "Record[Array]"
        ],
        [
          "nextIndex",
          false,
          "Int"
        ]
      ],
      "\n          1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Let _initResult_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _initValue_ be ? GetValue(_initResult_).\n          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).\n          1. Return _nextIndex_ + 1.\n        ",
      {
        "normalizedName" : "ElementList[2,0].ArrayAccumulation",
        "name" : "ElementList[2,0].ArrayAccumulation",
        "htmlId" : "sec-runtime-semantics-arrayaccumulation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArrayAccumulation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    739,
    [
      "UpdateExpression[4,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[4]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UpdateExpression[4,0].IsFunctionDefinition",
        "name" : "UpdateExpression[4,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "--"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2678,
    [
      "INTRINSICS.DataView.prototype.getInt32",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~int32~).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.getInt32",
        "name" : "INTRINSICS.DataView.prototype.getInt32",
        "htmlId" : "sec-dataview.prototype.getint32",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2518,
    [
      "INTRINSICS.Array.prototype.toLocaleString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _array_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_array_).\n          1. Let _separator_ be the implementation-defined list-separator String value appropriate for the host environment's current locale (such as *\", \"*).\n          1. Let _R_ be the empty String.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. If _k_ > 0, then\n              1. Set _R_ to the string-concatenation of _R_ and _separator_.\n            1. Let _nextElement_ be ? Get(_array_, ! ToString(𝔽(_k_))).\n            1. If _nextElement_ is neither *undefined* nor *null*, then\n              1. Let _S_ be ? ToString(? Invoke(_nextElement_, *\"toLocaleString\"*)).\n              1. Set _R_ to the string-concatenation of _R_ and _S_.\n            1. Set _k_ to _k_ + 1.\n          1. Return _R_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.toLocaleString",
        "name" : "INTRINSICS.Array.prototype.toLocaleString",
        "htmlId" : "sec-array.prototype.tolocalestring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1368,
    [
      "RelationalExpression[4,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[4]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _r_ be ? IsLessThan(_lval_, _rval_, *true*).\n        1. If _r_ is either *true* or *undefined*, return *false*. Otherwise, return *true*.\n      ",
      {
        "normalizedName" : "RelationalExpression[4,0].Evaluation",
        "name" : "RelationalExpression[4,0].Evaluation",
        "htmlId" : "sec-relational-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : ">="
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2175,
    [
      "GetNamedTimeZoneEpochNanoseconds",
      0,
      [
        [
          "timeZoneIdentifier",
          false,
          "String"
        ],
        [
          "year",
          false,
          "Int"
        ],
        [
          "month",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom1To12\"]"
        ],
        [
          "day",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom1To31\"]"
        ],
        [
          "hour",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom0To23\"]"
        ],
        [
          "minute",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom0To59\"]"
        ],
        [
          "second",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom0To59\"]"
        ],
        [
          "millisecond",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom0To999\"]"
        ],
        [
          "microsecond",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom0To999\"]"
        ],
        [
          "nanosecond",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom0To999\"]"
        ]
      ],
      "\n          1. Assert: _timeZoneIdentifier_ is *\"UTC\"*.\n          1. Let _epochNanoseconds_ be GetUTCEpochNanoseconds(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).\n          1. Return « _epochNanoseconds_ ».\n        ",
      {
        "normalizedName" : "GetNamedTimeZoneEpochNanoseconds",
        "name" : "GetNamedTimeZoneEpochNanoseconds",
        "htmlId" : "sec-getnamedtimezoneepochnanoseconds",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1780,
    [
      "ForInOfStatement[5,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[5]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ForInOfStatement[5,0].HasCallInTailPosition",
        "name" : "ForInOfStatement[5,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2821,
    [
      "AsyncGeneratorAwaitReturn:clo1",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].\n          1. Assert: _queue_ is not empty.\n          1. Let _next_ be the first element of _queue_.\n          1. Let _completion_ be Completion(_next_.[[Completion]]).\n          1. Assert: _completion_ is a return completion.\n          1. Let _promise_ be ? PromiseResolve(%Promise%, _completion_.[[Value]]).\n          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_value_) that captures _generator_ and performs the following steps when called:\n            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n            1. Let _result_ be NormalCompletion(_value_).\n            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).\n            1. Perform AsyncGeneratorDrainQueue(_generator_).\n            1. Return *undefined*.\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _generator_ and performs the following steps when called:\n            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n            1. Let _result_ be ThrowCompletion(_reason_).\n            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).\n            1. Perform AsyncGeneratorDrainQueue(_generator_).\n            1. Return *undefined*.\n          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncGeneratorAwaitReturn",
        "name" : "AsyncGeneratorAwaitReturn",
        "htmlId" : "sec-asyncgeneratorawaitreturn",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1753,
    [
      "AsyncFunctionExpression[0,1].InstantiateAsyncFunctionExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ],
        [
          "name",
          true,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Assert: _name_ is not present.\n        1. Set _name_ to StringValue of |BindingIdentifier|.\n        1. Let _outerEnv_ be the LexicalEnvironment of the running execution context.\n        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).\n        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).\n        1. Return _closure_.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,1].InstantiateAsyncFunctionExpression",
        "name" : "AsyncFunctionExpression[0,1].InstantiateAsyncFunctionExpression",
        "htmlId" : "sec-runtime-semantics-instantiateasyncfunctionexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateAsyncFunctionExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2386,
    [
      "CharacterClass[1,0].CompileCharacterClass",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClass[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.\n          1. If _rer_.[[UnicodeSets]] is *true*, then\n            1. Return the Record { [[CharSet]]: CharacterComplement(_rer_, _A_), [[Invert]]: *false* }.\n          1. Return the Record { [[CharSet]]: _A_, [[Invert]]: *true* }.\n        ",
      {
        "normalizedName" : "CharacterClass[1,0].CompileCharacterClass",
        "name" : "CharacterClass[1,0].CompileCharacterClass",
        "htmlId" : "sec-compilecharacterclass",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileCharacterClass",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CharacterClass",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "[^"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassContents"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2407,
    [
      "ClassUnion[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassUnion[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of |ClassSetRange| with argument _rer_.\n          1. If |ClassUnion| is present, then\n            1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.\n            1. Return the union of CharSets _A_ and _B_.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "ClassUnion[0,0].CompileToCharSet",
        "name" : "ClassUnion[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassUnion",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetRange"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1267,
    [
      "ObjectLiteral[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectLiteral[1]]"
        ]
      ],
      "\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with argument _obj_.\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "ObjectLiteral[1,0].Evaluation",
        "name" : "ObjectLiteral[1,0].Evaluation",
        "htmlId" : "sec-object-initializer-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ObjectLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "PropertyDefinitionList"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    409,
    [
      "TryStatement[2,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[2]]"
        ]
      ],
      "\n        1. Let _names1_ be VarDeclaredNames of |Block|.\n        1. Let _names2_ be VarDeclaredNames of |Catch|.\n        1. Let _names3_ be VarDeclaredNames of |Finally|.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      ",
      {
        "normalizedName" : "TryStatement[2,0].VarDeclaredNames",
        "name" : "TryStatement[2,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Catch"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1230,
    [
      "BindingIdentifier[1,0].StringValue",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingIdentifier[1]]"
        ]
      ],
      "\n        1. Return *\"yield\"*.\n      ",
      {
        "normalizedName" : "BindingIdentifier[1,0].StringValue",
        "name" : "BindingIdentifier[1,0].StringValue",
        "htmlId" : "sec-static-semantics-stringvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingIdentifier",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "yield"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2850,
    [
      "INTRINSICS.Proxy",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Return ? ProxyCreate(_target_, _handler_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Proxy",
        "name" : "INTRINSICS.Proxy",
        "htmlId" : "sec-proxy-target-handler",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1484,
    [
      "MemberExpression[5,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[5]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "MemberExpression[5,0].IsDestructuring",
        "name" : "MemberExpression[5,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MetaProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2160,
    [
      "TimeWithinDay",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. Return 𝔽(ℝ(_t_) modulo ℝ(msPerDay)).\n        ",
      {
        "normalizedName" : "TimeWithinDay",
        "name" : "TimeWithinDay",
        "htmlId" : "sec-timewithinday",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    263,
    [
      "ExportDeclaration[2,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[2]]"
        ]
      ],
      "\n        1. Return the BoundNames of |VariableStatement|.\n      ",
      {
        "normalizedName" : "ExportDeclaration[2,0].BoundNames",
        "name" : "ExportDeclaration[2,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1098,
    [
      "Record[OrdinaryObject].Get",
      4,
      [
        [
          "O",
          false,
          "Record[OrdinaryObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Return ? OrdinaryGet(_O_, _P_, _Receiver_).\n      ",
      {
        "normalizedName" : "Record[OrdinaryObject].Get",
        "name" : "Record[OrdinaryObject].Get",
        "htmlId" : "sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "OrdinaryObject",
          "[[Get]]"
        ]
      }
    ]
  ],
  [
    310,
    [
      "ClassStaticBlockStatementList[0,1].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockStatementList[0]]"
        ]
      ],
      "\n        1. Return the TopLevelLexicallyDeclaredNames of |StatementList|.\n      ",
      {
        "normalizedName" : "ClassStaticBlockStatementList[0,1].LexicallyDeclaredNames",
        "name" : "ClassStaticBlockStatementList[0,1].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ClassStaticBlockStatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2831,
    [
      "Await:clo0:cont0",
      7,
      [
      ],
      "\n          1. Let _asyncContext_ be the running execution context.\n          1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).\n          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_v_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using NormalCompletion(_v_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using ThrowCompletion(_reason_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n          1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n          1. Let _callerContext_ be the running execution context.\n          1. Resume _callerContext_ passing ~empty~. If _asyncContext_ is ever resumed again, let _completion_ be the Completion Record with which it is resumed.\n          1. Assert: If control reaches here, then _asyncContext_ is the running execution context again.\n          1. Return _completion_.\n        ",
      {
        "normalizedName" : "Await",
        "name" : "Await",
        "htmlId" : "await",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : true,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    993,
    [
      "LiteralPropertyName[0,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[LiteralPropertyName[0]]"
        ]
      ],
      "\n        1. Return StringValue of |IdentifierName|.\n      ",
      {
        "normalizedName" : "LiteralPropertyName[0,0].PropName",
        "name" : "LiteralPropertyName[0,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LiteralPropertyName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2689,
    [
      "INTRINSICS.DataView.prototype.setUint8",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. Return ? SetViewValue(_v_, _byteOffset_, *true*, ~uint8~, _value_).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.setUint8",
        "name" : "INTRINSICS.DataView.prototype.setUint8",
        "htmlId" : "sec-dataview.prototype.setuint8",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2569,
    [
      "INTRINSICS.TypedArray.prototype.values",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Return CreateArrayIterator(_O_, ~value~).\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.values",
        "name" : "INTRINSICS.TypedArray.prototype.values",
        "htmlId" : "sec-%typedarray%.prototype.values",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    67,
    [
      "Number::bitwiseAND",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. Return NumberBitwiseOp(`&`, _x_, _y_).\n          ",
      {
        "normalizedName" : "Number::bitwiseAND",
        "name" : "Number::bitwiseAND",
        "htmlId" : "sec-numeric-types-number-bitwiseAND",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    717,
    [
      "ClassExpression[0,1].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "ClassExpression[0,1].HasName",
        "name" : "ClassExpression[0,1].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ClassExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2429,
    [
      "CharacterRange",
      0,
      [
        [
          "A",
          false,
          "Record[CharSet]"
        ],
        [
          "B",
          false,
          "Record[CharSet]"
        ]
      ],
      "\n            1. Assert: _A_ and _B_ each contain exactly one character.\n            1. Let _a_ be the one character in CharSet _A_.\n            1. Let _b_ be the one character in CharSet _B_.\n            1. Let _i_ be the character value of character _a_.\n            1. Let _j_ be the character value of character _b_.\n            1. Assert: _i_ ≤ _j_.\n            1. Return the CharSet containing all characters with a character value in the inclusive interval from _i_ to _j_.\n          ",
      {
        "normalizedName" : "CharacterRange",
        "name" : "CharacterRange",
        "htmlId" : "sec-runtime-semantics-characterrange-abstract-operation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1679,
    [
      "ClassElementList[0,0].PrototypePropertyNameList",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementList[0]]"
        ]
      ],
      "\n        1. Let _propName_ be PropName of |ClassElement|.\n        1. If _propName_ is ~empty~, return a new empty List.\n        1. If IsStatic of |ClassElement| is *true*, return a new empty List.\n        1. Return « _propName_ ».\n      ",
      {
        "normalizedName" : "ClassElementList[0,0].PrototypePropertyNameList",
        "name" : "ClassElementList[0,0].PrototypePropertyNameList",
        "htmlId" : "sec-static-semantics-prototypepropertynamelist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrototypePropertyNameList",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2656,
    [
      "INTRINSICS.SharedArrayBuffer",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _byteLength_ be ? ToIndex(_length_).\n          1. Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).\n          1. Return ? AllocateSharedArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_).\n        ",
      {
        "normalizedName" : "INTRINSICS.SharedArrayBuffer",
        "name" : "INTRINSICS.SharedArrayBuffer",
        "htmlId" : "sec-sharedarraybuffer-length",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1711,
    [
      "AsyncGeneratorDeclaration[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorDeclaration[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorDeclaration[0,0].ContainsArguments",
        "name" : "AsyncGeneratorDeclaration[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2747,
    [
      "AsyncFromSyncIteratorContinuation",
      0,
      [
        [
          "result",
          false,
          "Record[Object]"
        ],
        [
          "promiseCapability",
          false,
          "Unknown[\"PromiseCapabilityRecordForAnIntrinsic%Promise%\"]"
        ]
      ],
      "\n          1. NOTE: Because _promiseCapability_ is derived from the intrinsic %Promise%, the calls to _promiseCapability_.[[Reject]] entailed by the use IfAbruptRejectPromise below are guaranteed not to throw.\n          1. Let _done_ be Completion(IteratorComplete(_result_)).\n          1. IfAbruptRejectPromise(_done_, _promiseCapability_).\n          1. Let _value_ be Completion(IteratorValue(_result_)).\n          1. IfAbruptRejectPromise(_value_, _promiseCapability_).\n          1. Let _valueWrapper_ be Completion(PromiseResolve(%Promise%, _value_)).\n          1. IfAbruptRejectPromise(_valueWrapper_, _promiseCapability_).\n          1. Let _unwrap_ be a new Abstract Closure with parameters (_v_) that captures _done_ and performs the following steps when called:\n            1. Return CreateIterResultObject(_v_, _done_).\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_unwrap_, 1, *\"\"*, « »).\n          1. NOTE: _onFulfilled_ is used when processing the *\"value\"* property of an IteratorResult object in order to wait for its value if it is a promise and re-package the result in a new \"unwrapped\" IteratorResult object.\n          1. Perform PerformPromiseThen(_valueWrapper_, _onFulfilled_, *undefined*, _promiseCapability_).\n          1. Return _promiseCapability_.[[Promise]].\n        ",
      {
        "normalizedName" : "AsyncFromSyncIteratorContinuation",
        "name" : "AsyncFromSyncIteratorContinuation",
        "htmlId" : "sec-asyncfromsynciteratorcontinuation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    50,
    [
      "StringIndexOf",
      0,
      [
        [
          "string",
          false,
          "String"
        ],
        [
          "searchValue",
          false,
          "String"
        ],
        [
          "fromIndex",
          false,
          "Int[0+]"
        ]
      ],
      "\n          1. Let _len_ be the length of _string_.\n          1. If _searchValue_ is the empty String and _fromIndex_ ≤ _len_, return _fromIndex_.\n          1. Let _searchLen_ be the length of _searchValue_.\n          1. For each integer _i_ such that _fromIndex_ ≤ _i_ ≤ _len_ - _searchLen_, in ascending order, do\n            1. Let _candidate_ be the substring of _string_ from _i_ to _i_ + _searchLen_.\n            1. If _candidate_ is _searchValue_, return _i_.\n          1. Return -1.\n        ",
      {
        "normalizedName" : "StringIndexOf",
        "name" : "StringIndexOf",
        "htmlId" : "sec-stringindexof",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1053,
    [
      "Record[ModuleEnvironmentRecord].CreateImportBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[ModuleEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "M",
          false,
          "Record[ModuleRecord]"
        ],
        [
          "N2",
          false,
          "String"
        ]
      ],
      "\n            1. Assert: _envRec_ does not already have a binding for _N_.\n            1. Assert: When _M_.[[Environment]] is instantiated, it will have a direct binding for _N2_.\n            1. Create an immutable indirect binding in _envRec_ for _N_ that references _M_ and _N2_ as its target binding and record that the binding is initialized.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[ModuleEnvironmentRecord].CreateImportBinding",
        "name" : "Record[ModuleEnvironmentRecord].CreateImportBinding",
        "htmlId" : "sec-createimportbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleEnvironmentRecord",
          "CreateImportBinding"
        ]
      }
    ]
  ],
  [
    1499,
    [
      "ForInOfStatement[4,0].ForInOfLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[4]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~).\n          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_).\n        ",
      {
        "normalizedName" : "ForInOfStatement[4,0].ForInOfLoopEvaluation",
        "name" : "ForInOfStatement[4,0].ForInOfLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forinofloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForInOfLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    199,
    [
      "IteratorStep",
      0,
      [
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n        1. Let _result_ be ? IteratorNext(_iteratorRecord_).\n        1. Let _done_ be ? IteratorComplete(_result_).\n        1. If _done_ is *true*, return *false*.\n        1. Return _result_.\n      ",
      {
        "normalizedName" : "IteratorStep",
        "name" : "IteratorStep",
        "htmlId" : "sec-iteratorstep",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    673,
    [
      "ForInOfStatement[3,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[3]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForInOfStatement[3,0].ContainsUndefinedContinueTarget",
        "name" : "ForInOfStatement[3,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2092,
    [
      "INTRINSICS.Symbol",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is not *undefined*, throw a *TypeError* exception.\n          1. If _description_ is *undefined*, let _descString_ be *undefined*.\n          1. Else, let _descString_ be ? ToString(_description_).\n          1. Return a new Symbol whose [[Description]] is _descString_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Symbol",
        "name" : "INTRINSICS.Symbol",
        "htmlId" : "sec-symbol-description",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1790,
    [
      "ForStatement[0,4].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[0,4].HasCallInTailPosition",
        "name" : "ForStatement[0,4].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 4,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1987,
    [
      "ExportDeclaration[0,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[0]]"
        ]
      ],
      "\n          1. Return the ExportedNames of |ExportFromClause|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[0,0].ExportedNames",
        "name" : "ExportDeclaration[0,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "ExportFromClause"
              },
              {
                "type" : "nonterminal",
                "value" : "FromClause"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1716,
    [
      "AsyncFunctionDeclaration[1,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionDeclaration[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncFunctionDeclaration[1,0].ContainsArguments",
        "name" : "AsyncFunctionDeclaration[1,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncFunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2224,
    [
      "INTRINSICS.Date.prototype.toISOString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _tv_ be _dateObject_.[[DateValue]].\n          1. If _tv_ is not finite, throw a *RangeError* exception.\n          1. If _tv_ corresponds with a year that cannot be represented in the <emu-xref href=\"#sec-date-time-string-format\">Date Time String Format</emu-xref>, throw a *RangeError* exception.\n          1. Return a String representation of _tv_ in the <emu-xref href=\"#sec-date-time-string-format\">Date Time String Format</emu-xref> on the UTC time scale, including all format elements and the UTC offset representation *\"Z\"*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.toISOString",
        "name" : "INTRINSICS.Date.prototype.toISOString",
        "htmlId" : "sec-date.prototype.toisostring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2454,
    [
      "INTRINSICS.RegExp.prototype[@@match]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _rx_ be the *this* value.\n          1. If _rx_ is not an Object, throw a *TypeError* exception.\n          1. Let _S_ be ? ToString(_string_).\n          1. Let _flags_ be ? ToString(? Get(_rx_, *\"flags\"*)).\n          1. If _flags_ does not contain *\"g\"*, then\n            1. Return ? RegExpExec(_rx_, _S_).\n          1. Else,\n            1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _fullUnicode_ be *true*. Otherwise, let _fullUnicode_ be *false*.\n            1. Perform ? Set(_rx_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n            1. Let _A_ be ! ArrayCreate(0).\n            1. Let _n_ be 0.\n            1. Repeat,\n              1. Let _result_ be ? RegExpExec(_rx_, _S_).\n              1. If _result_ is *null*, then\n                1. If _n_ = 0, return *null*.\n                1. Return _A_.\n              1. Else,\n                1. Let _matchStr_ be ? ToString(? Get(_result_, *\"0\"*)).\n                1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _matchStr_).\n                1. If _matchStr_ is the empty String, then\n                  1. Let _thisIndex_ be ℝ(? ToLength(? Get(_rx_, *\"lastIndex\"*))).\n                  1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).\n                  1. Perform ? Set(_rx_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).\n                1. Set _n_ to _n_ + 1.\n        ",
      {
        "normalizedName" : "INTRINSICS.RegExp.prototype[@@match]",
        "name" : "INTRINSICS.RegExp.prototype[@@match]",
        "htmlId" : "sec-regexp.prototype-@@match",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1432,
    [
      "LexicalDeclaration[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[LexicalDeclaration[0]]"
        ]
      ],
      "\n          1. Perform ? Evaluation of |BindingList|.\n          1. Return ~empty~.\n        ",
      {
        "normalizedName" : "LexicalDeclaration[0,0].Evaluation",
        "name" : "LexicalDeclaration[0,0].Evaluation",
        "htmlId" : "sec-let-and-const-declarations-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LexicalDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LetOrConst"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2165,
    [
      "DayWithinYear",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. Return Day(_t_) - DayFromYear(YearFromTime(_t_)).\n        ",
      {
        "normalizedName" : "DayWithinYear",
        "name" : "DayWithinYear",
        "htmlId" : "sec-daywithinyear",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1813,
    [
      "CaseClauses[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClauses[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Let _has_ be HasCallInTailPosition of |CaseClauses| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Return HasCallInTailPosition of |CaseClause| with argument _call_.\n      ",
      {
        "normalizedName" : "CaseClauses[1,0].HasCallInTailPosition",
        "name" : "CaseClauses[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseClauses",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClause"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1300,
    [
      "MemberExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[1]]"
        ]
      ],
      "\n          1. Let _baseReference_ be ? Evaluation of |MemberExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If the source text matched by this |MemberExpression| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_).\n        ",
      {
        "normalizedName" : "MemberExpression[1,0].Evaluation",
        "name" : "MemberExpression[1,0].Evaluation",
        "htmlId" : "sec-property-accessors-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1452,
    [
      "IfStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[0]]"
        ]
      ],
      "\n        1. Let _exprRef_ be ? Evaluation of |Expression|.\n        1. Let _exprValue_ be ToBoolean(? GetValue(_exprRef_)).\n        1. If _exprValue_ is *true*, then\n          1. Let _stmtCompletion_ be Completion(Evaluation of the first |Statement|).\n        1. Else,\n          1. Let _stmtCompletion_ be Completion(Evaluation of the second |Statement|).\n        1. Return ? UpdateEmpty(_stmtCompletion_, *undefined*).\n      ",
      {
        "normalizedName" : "IfStatement[0,0].Evaluation",
        "name" : "IfStatement[0,0].Evaluation",
        "htmlId" : "sec-if-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "else"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1637,
    [
      "MethodDefinition[4,0].SpecialMethod",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[4]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "MethodDefinition[4,0].SpecialMethod",
        "name" : "MethodDefinition[4,0].SpecialMethod",
        "htmlId" : "sec-static-semantics-specialmethod",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "SpecialMethod",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "get"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2688,
    [
      "INTRINSICS.DataView.prototype.setInt32",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~int32~, _value_).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.setInt32",
        "name" : "INTRINSICS.DataView.prototype.setInt32",
        "htmlId" : "sec-dataview.prototype.setint32",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    177,
    [
      "LengthOfArrayLike",
      0,
      [
        [
          "obj",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Return ℝ(? ToLength(? Get(_obj_, *\"length\"*))).\n      ",
      {
        "normalizedName" : "LengthOfArrayLike",
        "name" : "LengthOfArrayLike",
        "htmlId" : "sec-lengthofarraylike",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    791,
    [
      "ClassExpression[0,1].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "ClassExpression[0,1].IsFunctionDefinition",
        "name" : "ClassExpression[0,1].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ClassExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    182,
    [
      "EnumerableOwnProperties",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "kind",
          false,
          "Enum[~key+value~, ~key~, ~value~]"
        ]
      ],
      "\n        1. Let _ownKeys_ be ? <emu-meta effects=\"user-code\">_O_.[[OwnPropertyKeys]]</emu-meta>().\n        1. Let _results_ be a new empty List.\n        1. For each element _key_ of _ownKeys_, do\n          1. If _key_ is a String, then\n            1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_key_).\n            1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then\n              1. If _kind_ is ~key~, then\n                1. Append _key_ to _results_.\n              1. Else,\n                1. Let _value_ be ? Get(_O_, _key_).\n                1. If _kind_ is ~value~, then\n                  1. Append _value_ to _results_.\n                1. Else,\n                  1. Assert: _kind_ is ~key+value~.\n                  1. Let _entry_ be CreateArrayFromList(« _key_, _value_ »).\n                  1. Append _entry_ to _results_.\n        1. Return _results_.\n      ",
      {
        "normalizedName" : "EnumerableOwnProperties",
        "name" : "EnumerableOwnProperties",
        "htmlId" : "sec-enumerableownproperties",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    331,
    [
      "DefaultClause[0,1].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the LexicallyScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "DefaultClause[0,1].LexicallyScopedDeclarations",
        "name" : "DefaultClause[0,1].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1188,
    [
      "ModuleNamespaceCreate",
      0,
      [
        [
          "module",
          false,
          "Record[ModuleRecord]"
        ],
        [
          "exports",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Assert: _module_.[[Namespace]] is ~empty~.\n          1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href=\"#table-internal-slots-of-module-namespace-exotic-objects\"></emu-xref>.\n          1. Let _M_ be MakeBasicObject(_internalSlotsList_).\n          1. Set _M_'s essential internal methods to the definitions specified in <emu-xref href=\"#sec-module-namespace-exotic-objects\"></emu-xref>.\n          1. Set _M_.[[Module]] to _module_.\n          1. [declared=\"comparefn\"] Let _sortedExports_ be a List whose elements are the elements of _exports_ ordered as if an Array of the same values had been sorted using %Array.prototype.sort% using *undefined* as _comparefn_.\n          1. Set _M_.[[Exports]] to _sortedExports_.\n          1. Create own properties of _M_ corresponding to the definitions in <emu-xref href=\"#sec-module-namespace-objects\"></emu-xref>.\n          1. Set _module_.[[Namespace]] to _M_.\n          1. Return _M_.\n        ",
      {
        "normalizedName" : "ModuleNamespaceCreate",
        "name" : "ModuleNamespaceCreate",
        "htmlId" : "sec-modulenamespacecreate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2700,
    [
      "RemoveWaiter",
      0,
      [
        [
          "WL",
          false,
          "Record[WaiterListRecord]"
        ],
        [
          "waiterRecord",
          false,
          "Record[WaiterRecord]"
        ]
      ],
      "\n          1. Assert: The surrounding agent is in the critical section for _WL_.\n          1. Assert: _WL_.[[Waiters]] contains _waiterRecord_.\n          1. Remove _waiterRecord_ from _WL_.[[Waiters]].\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "RemoveWaiter",
        "name" : "RemoveWaiter",
        "htmlId" : "sec-removewaiter",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1186,
    [
      "Record[ModuleNamespaceExoticObject].Delete",
      4,
      [
        [
          "O",
          false,
          "Record[ModuleNamespaceExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. If _P_ is a Symbol, then\n            1. Return ! OrdinaryDelete(_O_, _P_).\n          1. Let _exports_ be _O_.[[Exports]].\n          1. If _exports_ contains _P_, return *false*.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "Record[ModuleNamespaceExoticObject].Delete",
        "name" : "Record[ModuleNamespaceExoticObject].Delete",
        "htmlId" : "sec-module-namespace-exotic-objects-delete-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleNamespaceExoticObject",
          "[[Delete]]"
        ]
      }
    ]
  ],
  [
    441,
    [
      "ForStatement[0,3].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,3].VarScopedDeclarations",
        "name" : "ForStatement[0,3].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    16,
    [
      "INTRINSICS.String.prototype.toLocaleUpperCase",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Object] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1038,
    [
      "Record[GlobalEnvironmentRecord].DeleteBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ]
      ],
      "\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, then\n              1. Return ! _DclRec_.DeleteBinding(_N_).\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n            1. Let _existingProp_ be ? HasOwnProperty(_globalObject_, _N_).\n            1. If _existingProp_ is *true*, then\n              1. Let _status_ be ? <emu-meta effects=\"user-code\">_ObjRec_.DeleteBinding</emu-meta>(_N_).\n              1. If _status_ is *true* and _envRec_.[[VarNames]] contains _N_, then\n                1. Remove _N_ from _envRec_.[[VarNames]].\n              1. Return _status_.\n            1. Return *true*.\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].DeleteBinding",
        "name" : "Record[GlobalEnvironmentRecord].DeleteBinding",
        "htmlId" : "sec-global-environment-records-deletebinding-n",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "DeleteBinding"
        ]
      }
    ]
  ],
  [
    585,
    [
      "IfStatement[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "IfStatement[1,0].ContainsUndefinedBreakTarget",
        "name" : "IfStatement[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    370,
    [
      "ForStatement[0,2].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,2].VarDeclaredNames",
        "name" : "ForStatement[0,2].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    502,
    [
      "LabelledStatement[0,0].TopLevelVarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledStatement[0]]"
        ]
      ],
      "\n        1. Return the TopLevelVarDeclaredNames of |LabelledItem|.\n      ",
      {
        "normalizedName" : "LabelledStatement[0,0].TopLevelVarDeclaredNames",
        "name" : "LabelledStatement[0,0].TopLevelVarDeclaredNames",
        "htmlId" : "sec-static-semantics-toplevelvardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelVarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelledItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1869,
    [
      "MemberExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[1,0].HasCallInTailPosition",
        "name" : "MemberExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    840,
    [
      "AsyncFunctionDeclaration[1,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionDeclaration[1]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncFunctionDeclaration[1,0].Contains",
        "name" : "AsyncFunctionDeclaration[1,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncFunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1785,
    [
      "WhileStatement[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[WhileStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "WhileStatement[0,0].HasCallInTailPosition",
        "name" : "WhileStatement[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1262,
    [
      "PropertyName[0,0].IsComputedPropertyKey",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyName[0]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "PropertyName[0,0].IsComputedPropertyKey",
        "name" : "PropertyName[0,0].IsComputedPropertyKey",
        "htmlId" : "sec-static-semantics-iscomputedpropertykey",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsComputedPropertyKey",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "PropertyName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LiteralPropertyName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1235,
    [
      "Identifier[0,0].StringValue",
      2,
      [
        [
          "this",
          false,
          "Ast[Identifier[0]]"
        ]
      ],
      "\n        1. Return the StringValue of |IdentifierName|.\n      ",
      {
        "normalizedName" : "Identifier[0,0].StringValue",
        "name" : "Identifier[0,0].StringValue",
        "htmlId" : "sec-static-semantics-stringvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Identifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    463,
    [
      "WithStatement[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[WithStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "WithStatement[0,0].VarScopedDeclarations",
        "name" : "WithStatement[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WithStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "with"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2337,
    [
      "RegExpIdentifierStart[0,0].RegExpIdentifierCodePoint",
      2,
      [
        [
          "this",
          false,
          "Ast[RegExpIdentifierStart[0]]"
        ]
      ],
      "\n          1. Return the code point matched by |IdentifierStartChar|.\n        ",
      {
        "normalizedName" : "RegExpIdentifierStart[0,0].RegExpIdentifierCodePoint",
        "name" : "RegExpIdentifierStart[0,0].RegExpIdentifierCodePoint",
        "htmlId" : "sec-regexpidentifiercodepoint",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "RegExpIdentifierCodePoint",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "RegExpIdentifierStart",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierStartChar"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2276,
    [
      "INTRINSICS.String.prototype[@@iterator]:clo0",
      6,
      [
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _s_ be ? ToString(_O_).\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _s_ and performs the following steps when called:\n            1. Let _len_ be the length of _s_.\n            1. Let _position_ be 0.\n            1. Repeat, while _position_ < _len_,\n              1. Let _cp_ be CodePointAt(_s_, _position_).\n              1. Let _nextIndex_ be _position_ + _cp_.[[CodeUnitCount]].\n              1. Let _resultString_ be the substring of _s_ from _position_ to _nextIndex_.\n              1. Set _position_ to _nextIndex_.\n              1. Perform ? GeneratorYield(CreateIterResultObject(_resultString_, *false*)).\n            1. Return *undefined*.\n          1. Return CreateIteratorFromClosure(_closure_, *\"%StringIteratorPrototype%\"*, %StringIteratorPrototype%).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype[@@iterator]",
        "name" : "INTRINSICS.String.prototype[@@iterator]",
        "htmlId" : "sec-string.prototype-@@iterator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    127,
    [
      "StrUnsignedDecimalLiteral[2,1].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StrUnsignedDecimalLiteral[2]]"
        ]
      ],
      "\n            1. Let _b_ be MV of |DecimalDigits|.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Let _n_ be the number of code points in |DecimalDigits|.\n            1. Return RoundMVResult(_b_ × 10<sup>_e_ - _n_</sup>).\n          ",
      {
        "normalizedName" : "StrUnsignedDecimalLiteral[2,1].StringNumericValue",
        "name" : "StrUnsignedDecimalLiteral[2,1].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "StrUnsignedDecimalLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "nonterminal",
                "value" : "ExponentPart"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2219,
    [
      "INTRINSICS.Date.prototype.setUTCMilliseconds",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Set _ms_ to ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_).\n          1. Let _v_ be TimeClip(MakeDate(Day(_t_), _time_)).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setUTCMilliseconds",
        "name" : "INTRINSICS.Date.prototype.setUTCMilliseconds",
        "htmlId" : "sec-date.prototype.setutcmilliseconds",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1980,
    [
      "ExportsList[1,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportsList[1]]"
        ]
      ],
      "\n          1. Let _names1_ be the ExportedBindings of |ExportsList|.\n          1. Let _names2_ be the ExportedBindings of |ExportSpecifier|.\n          1. Return the list-concatenation of _names1_ and _names2_.\n        ",
      {
        "normalizedName" : "ExportsList[1,0].ExportedBindings",
        "name" : "ExportsList[1,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportsList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExportsList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "ExportSpecifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2128,
    [
      "INTRINSICS.Math.asin",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ > *1*<sub>𝔽</sub> or _n_ < *-1*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the inverse sine of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.asin",
        "name" : "INTRINSICS.Math.asin",
        "htmlId" : "sec-math.asin",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1317,
    [
      "GetSuperConstructor",
      0,
      [
      ],
      "\n          1. Let _envRec_ be GetThisEnvironment().\n          1. Assert: _envRec_ is a Function Environment Record.\n          1. Let _activeFunction_ be _envRec_.[[FunctionObject]].\n          1. Assert: _activeFunction_ is an ECMAScript function object.\n          1. Let _superConstructor_ be ! _activeFunction_.[[GetPrototypeOf]]().\n          1. Return _superConstructor_.\n        ",
      {
        "normalizedName" : "GetSuperConstructor",
        "name" : "GetSuperConstructor",
        "htmlId" : "sec-getsuperconstructor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1830,
    [
      "BitwiseANDExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[BitwiseANDExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "BitwiseANDExpression[1,0].HasCallInTailPosition",
        "name" : "BitwiseANDExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BitwiseANDExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BitwiseANDExpression"
              },
              {
                "type" : "terminal",
                "value" : "&"
              },
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1763,
    [
      "AsyncArrowFunction[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowFunction[0]]"
        ]
      ],
      "\n        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction|.\n      ",
      {
        "normalizedName" : "AsyncArrowFunction[0,0].Evaluation",
        "name" : "AsyncArrowFunction[0,0].Evaluation",
        "htmlId" : "sec-async-arrow-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncArrowFunction",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncArrowBindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    338,
    [
      "ClassStaticBlockStatementList[0,1].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockStatementList[0]]"
        ]
      ],
      "\n        1. Return the TopLevelLexicallyScopedDeclarations of |StatementList|.\n      ",
      {
        "normalizedName" : "ClassStaticBlockStatementList[0,1].LexicallyScopedDeclarations",
        "name" : "ClassStaticBlockStatementList[0,1].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ClassStaticBlockStatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1901,
    [
      "OptionalChain[4,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[4]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "OptionalChain[4,0].HasCallInTailPosition",
        "name" : "OptionalChain[4,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "?."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1085,
    [
      "OrdinarySetPrototypeOf",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "V",
          false,
          "Record[Object] | Null"
        ]
      ],
      "\n          1. Let _current_ be _O_.[[Prototype]].\n          1. If SameValue(_V_, _current_) is *true*, return *true*.\n          1. Let _extensible_ be _O_.[[Extensible]].\n          1. If _extensible_ is *false*, return *false*.\n          1. Let _p_ be _V_.\n          1. Let _done_ be *false*.\n          1. [id=\"step-ordinarysetprototypeof-loop\"] Repeat, while _done_ is *false*,\n            1. If _p_ is *null*, then\n              1. Set _done_ to *true*.\n            1. Else if SameValue(_p_, _O_) is *true*, then\n              1. Return *false*.\n            1. Else,\n              1. If _p_.[[GetPrototypeOf]] is not the ordinary object internal method defined in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof\"></emu-xref>, set _done_ to *true*.\n              1. Else, set _p_ to _p_.[[Prototype]].\n          1. Set _O_.[[Prototype]] to _V_.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "OrdinarySetPrototypeOf",
        "name" : "OrdinarySetPrototypeOf",
        "htmlId" : "sec-ordinarysetprototypeof",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    470,
    [
      "CaseClauses[1,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClauses[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be VarScopedDeclarations of |CaseClauses|.\n        1. Let _declarations2_ be VarScopedDeclarations of |CaseClause|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "CaseClauses[1,0].VarScopedDeclarations",
        "name" : "CaseClauses[1,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseClauses",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClause"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    576,
    [
      "Statement[3,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[3]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[3,0].ContainsUndefinedBreakTarget",
        "name" : "Statement[3,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1658,
    [
      "AsyncGeneratorDeclaration[1,0].InstantiateAsyncGeneratorFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorDeclaration[1]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Let _sourceText_ be the source text matched by |AsyncGeneratorDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, *\"default\"*).\n        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "AsyncGeneratorDeclaration[1,0].InstantiateAsyncGeneratorFunctionObject",
        "name" : "AsyncGeneratorDeclaration[1,0].InstantiateAsyncGeneratorFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiateasyncgeneratorfunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateAsyncGeneratorFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncGeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2322,
    [
      "ClassUnion[1,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassUnion[1]]"
        ]
      ],
      "\n          1. If MayContainStrings of the |ClassSetOperand| is *true*, return *true*.\n          1. If |ClassUnion| is present, return MayContainStrings of the |ClassUnion|.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ClassUnion[1,0].MayContainStrings",
        "name" : "ClassUnion[1,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassUnion",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1538,
    [
      "Statement[1,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |Statement|.\n      ",
      {
        "normalizedName" : "Statement[1,0].LabelledEvaluation",
        "name" : "Statement[1,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "VariableStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2701,
    [
      "RemoveWaiters",
      0,
      [
        [
          "WL",
          false,
          "Record[WaiterListRecord]"
        ],
        [
          "c",
          false,
          "Int[0+] | +INF"
        ]
      ],
      "\n          1. Assert: The surrounding agent is in the critical section for _WL_.\n          1. Let _len_ be the number of elements in _WL_.[[Waiters]].\n          1. Let _n_ be min(_c_, _len_).\n          1. Let _L_ be a List whose elements are the first _n_ elements of _WL_.[[Waiters]].\n          1. Remove the first _n_ elements of _WL_.[[Waiters]].\n          1. Return _L_.\n        ",
      {
        "normalizedName" : "RemoveWaiters",
        "name" : "RemoveWaiters",
        "htmlId" : "sec-removewaiters",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2486,
    [
      "INTRINSICS.Array.prototype.entries",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Return CreateArrayIterator(_O_, ~key+value~).\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.entries",
        "name" : "INTRINSICS.Array.prototype.entries",
        "htmlId" : "sec-array.prototype.entries",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    951,
    [
      "UnaryExpression[4,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[4]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "UnaryExpression[4,0].AssignmentTargetType",
        "name" : "UnaryExpression[4,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "+"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    808,
    [
      "MemberExpression[3,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[3]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[3,0].IsIdentifierRef",
        "name" : "MemberExpression[3,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2545,
    [
      "INTRINSICS.TypedArray.prototype.findLast",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Value]].\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.findLast",
        "name" : "INTRINSICS.TypedArray.prototype.findLast",
        "htmlId" : "sec-%typedarray%.prototype.findlast",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2599,
    [
      "INTRINSICS.Map.prototype.values",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Return ? CreateMapIterator(_M_, ~value~).\n        ",
      {
        "normalizedName" : "INTRINSICS.Map.prototype.values",
        "name" : "INTRINSICS.Map.prototype.values",
        "htmlId" : "sec-map.prototype.values",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2044,
    [
      "INTRINSICS.Object.assign",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _to_ be ? ToObject(_target_).\n          1. If only one argument was passed, return _to_.\n          1. For each element _nextSource_ of _sources_, do\n            1. If _nextSource_ is neither *undefined* nor *null*, then\n              1. Let _from_ be ! ToObject(_nextSource_).\n              1. Let _keys_ be ? <emu-meta effects=\"user-code\">_from_.[[OwnPropertyKeys]]()</emu-meta>.\n              1. For each element _nextKey_ of _keys_, do\n                1. Let _desc_ be ? <emu-meta effects=\"user-code\">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_).\n                1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then\n                  1. Let _propValue_ be ? Get(_from_, _nextKey_).\n                  1. Perform ? Set(_to_, _nextKey_, _propValue_, *true*).\n          1. Return _to_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.assign",
        "name" : "INTRINSICS.Object.assign",
        "htmlId" : "sec-object.assign",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    359,
    [
      "Statement[13,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[13]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[13,0].VarDeclaredNames",
        "name" : "Statement[13,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 13,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DebuggerStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1130,
    [
      "DefineMethodProperty",
      0,
      [
        [
          "homeObject",
          false,
          "Record[Object]"
        ],
        [
          "key",
          false,
          "Record[PrivateName | Symbol] | String"
        ],
        [
          "closure",
          false,
          "Record[FunctionObject]"
        ],
        [
          "enumerable",
          false,
          "Boolean"
        ]
      ],
      "\n        1. Assert: _homeObject_ is an ordinary, extensible object.\n        1. If _key_ is a Private Name, then\n          1. Return PrivateElement { [[Key]]: _key_, [[Kind]]: ~method~, [[Value]]: _closure_ }.\n        1. Else,\n          1. Let _desc_ be the PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.\n          1. Perform ? DefinePropertyOrThrow(_homeObject_, _key_, _desc_).\n          1. NOTE: DefinePropertyOrThrow only returns an abrupt completion when attempting to define a class static method whose _key_ is *\"prototype\"*.\n          1. Return ~unused~.\n      ",
      {
        "normalizedName" : "DefineMethodProperty",
        "name" : "DefineMethodProperty",
        "htmlId" : "sec-definemethodproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1579,
    [
      "FormalParameterList[1,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameterList[1]]"
        ]
      ],
      "\n        1. If ContainsExpression of |FormalParameterList| is *true*, return *true*.\n        1. Return ContainsExpression of |FormalParameter|.\n      ",
      {
        "normalizedName" : "FormalParameterList[1,0].ContainsExpression",
        "name" : "FormalParameterList[1,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FormalParameterList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameterList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1285,
    [
      "TemplateMiddleList[1,0].TemplateStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateMiddleList[1]]"
        ],
        [
          "raw",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Let _front_ be TemplateStrings of |TemplateMiddleList| with argument _raw_.\n          1. Let _last_ be « TemplateString(|TemplateMiddle|, _raw_) ».\n          1. Return the list-concatenation of _front_ and _last_.\n        ",
      {
        "normalizedName" : "TemplateMiddleList[1,0].TemplateStrings",
        "name" : "TemplateMiddleList[1,0].TemplateStrings",
        "htmlId" : "sec-static-semantics-templatestrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TemplateStrings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TemplateMiddleList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateMiddleList"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateMiddle"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1738,
    [
      "ClassTail[0,1].ClassDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassTail[0]]"
        ],
        [
          "classBinding",
          false,
          "String | Undefined"
        ],
        [
          "className",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.\n        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n        1. If |ClassBody| is present, then\n          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do\n            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then\n              1. Assert: This is only possible for getter/setter pairs.\n            1. Else,\n              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.\n              1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n        1. If |ClassHeritage| is not present, then\n          1. Let _protoParent_ be %Object.prototype%.\n          1. Let _constructorParent_ be %Function.prototype%.\n        1. Else,\n          1. Set the running execution context's LexicalEnvironment to _classEnv_.\n          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).\n          1. Set the running execution context's LexicalEnvironment to _env_.\n          1. Let _superclass_ be ? GetValue(? _superclassRef_).\n          1. If _superclass_ is *null*, then\n            1. Let _protoParent_ be *null*.\n            1. Let _constructorParent_ be %Function.prototype%.\n          1. Else if IsConstructor(_superclass_) is *false*, then\n            1. Throw a *TypeError* exception.\n          1. Else,\n            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.\n            1. Let _constructorParent_ be _superclass_.\n        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n        1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n        1. Set the running execution context's LexicalEnvironment to _classEnv_.\n        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.\n        1. If _constructor_ is ~empty~, then\n          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n            1. If NewTarget is *undefined*, throw a *TypeError* exception.\n            1. Let _F_ be the active function object.\n            1. If _F_.[[ConstructorKind]] is ~derived~, then\n              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n            1. Else,\n              1. NOTE: This branch behaves similarly to `constructor() {}`.\n              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n            1. Perform ? InitializeInstanceElements(_result_, _F_).\n            1. Return _result_.\n          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n        1. Else,\n          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n          1. Let _F_ be _constructorInfo_.[[Closure]].\n          1. Perform MakeClassConstructor(_F_).\n          1. Perform SetFunctionName(_F_, _className_).\n        1. Perform MakeConstructor(_F_, *false*, _proto_).\n        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n        1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n        1. If |ClassBody| is not present, let _elements_ be a new empty List.\n        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n        1. Let _instancePrivateMethods_ be a new empty List.\n        1. Let _staticPrivateMethods_ be a new empty List.\n        1. Let _instanceFields_ be a new empty List.\n        1. Let _staticElements_ be a new empty List.\n        1. For each |ClassElement| _e_ of _elements_, do\n          1. If IsStatic of _e_ is *false*, then\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n          1. Else,\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n          1. If _element_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _env_.\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _element_.\n          1. Set _element_ to ! _element_.\n          1. If _element_ is a PrivateElement, then\n            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n            1. Else, let _container_ be _staticPrivateMethods_.\n            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.\n              1. If _element_.[[Get]] is *undefined*, then\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n              1. Else,\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n              1. Replace _pe_ in _container_ with _combined_.\n            1. Else,\n              1. Append _element_ to _container_.\n          1. Else if _element_ is a ClassFieldDefinition Record, then\n            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n            1. Else, append _element_ to _staticElements_.\n          1. Else if _element_ is a ClassStaticBlockDefinition Record, then\n            1. Append _element_ to _staticElements_.\n        1. Set the running execution context's LexicalEnvironment to _env_.\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n        1. Set _F_.[[Fields]] to _instanceFields_.\n        1. For each PrivateElement _method_ of _staticPrivateMethods_, do\n          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n        1. For each element _elementRecord_ of _staticElements_, do\n          1. If _elementRecord_ is a ClassFieldDefinition Record, then\n            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n          1. Else,\n            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.\n            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n          1. If _result_ is an abrupt completion, then\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _result_.\n        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "ClassTail[0,1].ClassDefinitionEvaluation",
        "name" : "ClassTail[0,1].ClassDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-classdefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ClassTail",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1218,
    [
      "NumericLiteral[2,0].NumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[NumericLiteral[2]]"
        ]
      ],
      "\n          1. Return 𝔽(MV of |NonDecimalIntegerLiteral|).\n        ",
      {
        "normalizedName" : "NumericLiteral[2,0].NumericValue",
        "name" : "NumericLiteral[2,0].NumericValue",
        "htmlId" : "sec-numericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NumericValue",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "NumericLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NonDecimalIntegerLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1336,
    [
      "OptionalChain[7,0].ChainEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[7]]"
        ],
        [
          "baseValue",
          false,
          "ESValue"
        ],
        [
          "baseReference",
          false,
          "ESValue | Record[ReferenceRecord]"
        ]
      ],
      "\n          1. Let _optionalChain_ be |OptionalChain|.\n          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n          1. Let _newValue_ be ? GetValue(_newReference_).\n          1. If the source text matched by this |OptionalChain| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return EvaluatePropertyAccessWithIdentifierKey(_newValue_, |IdentifierName|, _strict_).\n        ",
      {
        "normalizedName" : "OptionalChain[7,0].ChainEvaluation",
        "name" : "OptionalChain[7,0].ChainEvaluation",
        "htmlId" : "sec-optional-chaining-chain-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ChainEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    643,
    [
      "Statement[11,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[11]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[11,0].ContainsUndefinedContinueTarget",
        "name" : "Statement[11,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 11,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ThrowStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2468,
    [
      "RegExpBuiltinExec",
      0,
      [
        [
          "R",
          false,
          "Record[RegExp]"
        ],
        [
          "S",
          false,
          "String"
        ]
      ],
      "\n          1. Let _length_ be the length of _S_.\n          1. Let _lastIndex_ be ℝ(? ToLength(? Get(_R_, *\"lastIndex\"*))).\n          1. Let _flags_ be _R_.[[OriginalFlags]].\n          1. If _flags_ contains *\"g\"*, let _global_ be *true*; else let _global_ be *false*.\n          1. If _flags_ contains *\"y\"*, let _sticky_ be *true*; else let _sticky_ be *false*.\n          1. If _flags_ contains *\"d\"*, let _hasIndices_ be *true*; else let _hasIndices_ be *false*.\n          1. If _global_ is *false* and _sticky_ is *false*, set _lastIndex_ to 0.\n          1. Let _matcher_ be _R_.[[RegExpMatcher]].\n          1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _fullUnicode_ be *true*; else let _fullUnicode_ be *false*.\n          1. Let _matchSucceeded_ be *false*.\n          1. If _fullUnicode_ is *true*, let _input_ be StringToCodePoints(_S_). Otherwise, let _input_ be a List whose elements are the code units that are the elements of _S_.\n          1. NOTE: Each element of _input_ is considered to be a character.\n          1. Repeat, while _matchSucceeded_ is *false*,\n            1. If _lastIndex_ > _length_, then\n              1. If _global_ is *true* or _sticky_ is *true*, then\n                1. Perform ? Set(_R_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n              1. Return *null*.\n            1. Let _inputIndex_ be the index into _input_ of the character that was obtained from element _lastIndex_ of _S_.\n            1. Let _r_ be _matcher_(_input_, _inputIndex_).\n            1. If _r_ is ~failure~, then\n              1. If _sticky_ is *true*, then\n                1. Perform ? Set(_R_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n                1. Return *null*.\n              1. Set _lastIndex_ to AdvanceStringIndex(_S_, _lastIndex_, _fullUnicode_).\n            1. Else,\n              1. Assert: _r_ is a MatchState.\n              1. Set _matchSucceeded_ to *true*.\n          1. Let _e_ be _r_.[[EndIndex]].\n          1. If _fullUnicode_ is *true*, set _e_ to GetStringIndex(_S_, _e_).\n          1. If _global_ is *true* or _sticky_ is *true*, then\n            1. Perform ? Set(_R_, *\"lastIndex\"*, 𝔽(_e_), *true*).\n          1. Let _n_ be the number of elements in _r_.[[Captures]].\n          1. Assert: _n_ = _R_.[[RegExpRecord]].[[CapturingGroupsCount]].\n          1. Assert: _n_ < 2<sup>32</sup> - 1.\n          1. Let _A_ be ! ArrayCreate(_n_ + 1).\n          1. Assert: The mathematical value of _A_'s *\"length\"* property is _n_ + 1.\n          1. Perform ! CreateDataPropertyOrThrow(_A_, *\"index\"*, 𝔽(_lastIndex_)).\n          1. Perform ! CreateDataPropertyOrThrow(_A_, *\"input\"*, _S_).\n          1. Let _match_ be the Match Record { [[StartIndex]]: _lastIndex_, [[EndIndex]]: _e_ }.\n          1. Let _indices_ be a new empty List.\n          1. Let _groupNames_ be a new empty List.\n          1. Append _match_ to _indices_.\n          1. Let _matchedSubstr_ be GetMatchString(_S_, _match_).\n          1. Perform ! CreateDataPropertyOrThrow(_A_, *\"0\"*, _matchedSubstr_).\n          1. If _R_ contains any |GroupName|, then\n            1. Let _groups_ be OrdinaryObjectCreate(*null*).\n            1. Let _hasGroups_ be *true*.\n          1. Else,\n            1. Let _groups_ be *undefined*.\n            1. Let _hasGroups_ be *false*.\n          1. Perform ! CreateDataPropertyOrThrow(_A_, *\"groups\"*, _groups_).\n          1. For each integer _i_ such that 1 ≤ _i_ ≤ _n_, in ascending order, do\n            1. Let _captureI_ be _i_<sup>th</sup> element of _r_.[[Captures]].\n            1. If _captureI_ is *undefined*, then\n              1. Let _capturedValue_ be *undefined*.\n              1. Append *undefined* to _indices_.\n            1. Else,\n              1. Let _captureStart_ be _captureI_.[[StartIndex]].\n              1. Let _captureEnd_ be _captureI_.[[EndIndex]].\n              1. If _fullUnicode_ is *true*, then\n                1. Set _captureStart_ to GetStringIndex(_S_, _captureStart_).\n                1. Set _captureEnd_ to GetStringIndex(_S_, _captureEnd_).\n              1. Let _capture_ be the Match Record { [[StartIndex]]: _captureStart_, [[EndIndex]]: _captureEnd_ }.\n              1. Let _capturedValue_ be GetMatchString(_S_, _capture_).\n              1. Append _capture_ to _indices_.\n            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _capturedValue_).\n            1. If the _i_<sup>th</sup> capture of _R_ was defined with a |GroupName|, then\n              1. Let _s_ be the CapturingGroupName of that |GroupName|.\n              1. Perform ! CreateDataPropertyOrThrow(_groups_, _s_, _capturedValue_).\n              1. Append _s_ to _groupNames_.\n            1. Else,\n              1. Append *undefined* to _groupNames_.\n          1. If _hasIndices_ is *true*, then\n            1. Let _indicesArray_ be MakeMatchIndicesIndexPairArray(_S_, _indices_, _groupNames_, _hasGroups_).\n            1. Perform ! CreateDataPropertyOrThrow(_A_, *\"indices\"*, _indicesArray_).\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "RegExpBuiltinExec",
        "name" : "RegExpBuiltinExec",
        "htmlId" : "sec-regexpbuiltinexec",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1220,
    [
      "NumericLiteral[3,0].NumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[NumericLiteral[3]]"
        ]
      ],
      "\n          1. Return the BigInt value for the MV of |NonDecimalIntegerLiteral|.\n        ",
      {
        "normalizedName" : "NumericLiteral[3,0].NumericValue",
        "name" : "NumericLiteral[3,0].NumericValue",
        "htmlId" : "sec-numericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NumericValue",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "NumericLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NonDecimalIntegerLiteral"
              },
              {
                "type" : "nonterminal",
                "value" : "BigIntLiteralSuffix"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2354,
    [
      "MatchSequence",
      0,
      [
        [
          "m1",
          false,
          "Record[Matcher]"
        ],
        [
          "m2",
          false,
          "Record[Matcher]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n            1. If _direction_ is ~forward~, then\n              1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:\n                1. Assert: _x_ is a MatchState.\n                1. Assert: _c_ is a MatcherContinuation.\n                1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _c_ and _m2_ and performs the following steps when called:\n                  1. Assert: _y_ is a MatchState.\n                  1. Return _m2_(_y_, _c_).\n                1. Return _m1_(_x_, _d_).\n            1. Else,\n              1. Assert: _direction_ is ~backward~.\n              1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:\n                1. Assert: _x_ is a MatchState.\n                1. Assert: _c_ is a MatcherContinuation.\n                1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _c_ and _m1_ and performs the following steps when called:\n                  1. Assert: _y_ is a MatchState.\n                  1. Return _m1_(_y_, _c_).\n                1. Return _m2_(_x_, _d_).\n          ",
      {
        "normalizedName" : "MatchSequence",
        "name" : "MatchSequence",
        "htmlId" : "sec-matchsequence",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    544,
    [
      "ForInOfStatement[2,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[2,0].ContainsDuplicateLabels",
        "name" : "ForInOfStatement[2,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    907,
    [
      "FormalParameterList[1,0].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameterList[1]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Perform ? IteratorBindingInitialization of |FormalParameterList| with arguments _iteratorRecord_ and _environment_.\n        1. Return ? IteratorBindingInitialization of |FormalParameter| with arguments _iteratorRecord_ and _environment_.\n      ",
      {
        "normalizedName" : "FormalParameterList[1,0].IteratorBindingInitialization",
        "name" : "FormalParameterList[1,0].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FormalParameterList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameterList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    31,
    [
      "ToObject",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1934,
    [
      "InnerModuleLinking",
      0,
      [
        [
          "module",
          false,
          "Record[ModuleRecord]"
        ],
        [
          "stack",
          false,
          "List[Record[CyclicModuleRecord]]"
        ],
        [
          "index",
          false,
          "Int[0+]"
        ]
      ],
      "\n              1. If _module_ is not a Cyclic Module Record, then\n                1. Perform ? _module_.Link().\n                1. Return _index_.\n              1. If _module_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~, then\n                1. Return _index_.\n              1. Assert: _module_.[[Status]] is ~unlinked~.\n              1. Set _module_.[[Status]] to ~linking~.\n              1. Set _module_.[[DFSIndex]] to _index_.\n              1. Set _module_.[[DFSAncestorIndex]] to _index_.\n              1. Set _index_ to _index_ + 1.\n              1. Append _module_ to _stack_.\n              1. For each String _required_ of _module_.[[RequestedModules]], do\n                1. Let _requiredModule_ be GetImportedModule(_module_, _required_).\n                1. Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).\n                1. If _requiredModule_ is a Cyclic Module Record, then\n                  1. Assert: _requiredModule_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~.\n                  1. Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _stack_ contains _requiredModule_.\n                  1. If _requiredModule_.[[Status]] is ~linking~, then\n                    1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).\n              1. Perform ? _module_.InitializeEnvironment().\n              1. Assert: _module_ occurs exactly once in _stack_.\n              1. Assert: _module_.[[DFSAncestorIndex]] ≤ _module_.[[DFSIndex]].\n              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then\n                1. Let _done_ be *false*.\n                1. Repeat, while _done_ is *false*,\n                  1. Let _requiredModule_ be the last element of _stack_.\n                  1. Remove the last element of _stack_.\n                  1. Assert: _requiredModule_ is a Cyclic Module Record.\n                  1. Set _requiredModule_.[[Status]] to ~linked~.\n                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.\n              1. Return _index_.\n            ",
      {
        "normalizedName" : "InnerModuleLinking",
        "name" : "InnerModuleLinking",
        "htmlId" : "sec-InnerModuleLinking",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    613,
    [
      "BreakStatement[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[BreakStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "BreakStatement[0,0].ContainsUndefinedBreakTarget",
        "name" : "BreakStatement[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BreakStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "break"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2543,
    [
      "INTRINSICS.TypedArray.prototype.find",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Value]].\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.find",
        "name" : "INTRINSICS.TypedArray.prototype.find",
        "htmlId" : "sec-%typedarray%.prototype.find",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    314,
    [
      "ScriptBody[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ScriptBody[0]]"
        ]
      ],
      "\n        1. Return TopLevelLexicallyDeclaredNames of |StatementList|.\n      ",
      {
        "normalizedName" : "ScriptBody[0,0].LexicallyDeclaredNames",
        "name" : "ScriptBody[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ScriptBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2848,
    [
      "INTRINSICS.Reflect.set",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n        1. If _receiver_ is not present, then\n          1. Set _receiver_ to _target_.\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[Set]]</emu-meta>(_key_, _V_, _receiver_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.set",
        "name" : "INTRINSICS.Reflect.set",
        "htmlId" : "sec-reflect.set",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2584,
    [
      "InitializeTypedArrayFromArrayLike",
      0,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "arrayLike",
          false,
          "Unknown[\"Object,ButNotATypedArrayOrAnArrayBuffer\"]"
        ]
      ],
      "\n            1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).\n            1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).\n            1. Let _k_ be 0.\n            1. Repeat, while _k_ < _len_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).\n              1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).\n              1. Set _k_ to _k_ + 1.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "InitializeTypedArrayFromArrayLike",
        "name" : "InitializeTypedArrayFromArrayLike",
        "htmlId" : "sec-initializetypedarrayfromarraylike",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    859,
    [
      "PropertyName[1,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyName[1]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return the result of |ComputedPropertyName| Contains _symbol_.\n      ",
      {
        "normalizedName" : "PropertyName[1,0].ComputedPropertyContains",
        "name" : "PropertyName[1,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "PropertyName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ComputedPropertyName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2675,
    [
      "INTRINSICS.DataView.prototype.getFloat64",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~float64~).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.getFloat64",
        "name" : "INTRINSICS.DataView.prototype.getFloat64",
        "htmlId" : "sec-dataview.prototype.getfloat64",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2056,
    [
      "INTRINSICS.Object.getOwnPropertySymbols",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~symbol~)).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.getOwnPropertySymbols",
        "name" : "INTRINSICS.Object.getOwnPropertySymbols",
        "htmlId" : "sec-object.getownpropertysymbols",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1404,
    [
      "ArrayAssignmentPattern[2,3].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayAssignmentPattern[2]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n          1. If _status_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n            1. Return ? _status_.\n          1. If |Elision| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n            1. If _status_ is an abrupt completion, then\n              1. Assert: _iteratorRecord_.[[Done]] is *true*.\n              1. Return ? _status_.\n          1. If |AssignmentRestElement| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n          1. Return ? _status_.\n        ",
      {
        "normalizedName" : "ArrayAssignmentPattern[2,3].DestructuringAssignmentEvaluation",
        "name" : "ArrayAssignmentPattern[2,3].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 3,
            "astName" : "ArrayAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1358,
    [
      "ExponentiationExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ExponentiationExpression[1]]"
        ]
      ],
      "\n        1. Return ? EvaluateStringOrNumericBinaryExpression(|UpdateExpression|, `**`, |ExponentiationExpression|).\n      ",
      {
        "normalizedName" : "ExponentiationExpression[1,0].Evaluation",
        "name" : "ExponentiationExpression[1,0].Evaluation",
        "htmlId" : "sec-exp-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExponentiationExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "UpdateExpression"
              },
              {
                "type" : "terminal",
                "value" : "**"
              },
              {
                "type" : "nonterminal",
                "value" : "ExponentiationExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2247,
    [
      "INTRINSICS.String.prototype.isWellFormed",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Return IsStringWellFormedUnicode(_S_).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.isWellFormed",
        "name" : "INTRINSICS.String.prototype.isWellFormed",
        "htmlId" : "sec-string.prototype.iswellformed",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2411,
    [
      "ClassIntersection[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassIntersection[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of the first |ClassSetOperand| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of the second |ClassSetOperand| with argument _rer_.\n          1. Return the intersection of CharSets _A_ and _B_.\n        ",
      {
        "normalizedName" : "ClassIntersection[0,0].CompileToCharSet",
        "name" : "ClassIntersection[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassIntersection",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              },
              {
                "type" : "terminal",
                "value" : "&&"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2500,
    [
      "INTRINSICS.Array.prototype.indexOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.\n          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.\n          1. If _n_ = +∞, return *-1*<sub>𝔽</sub>.\n          1. Else if _n_ = -∞, set _n_ to 0.\n          1. If _n_ ≥ 0, then\n            1. Let _k_ be _n_.\n          1. Else,\n            1. Let _k_ be _len_ + _n_.\n            1. If _k_ < 0, set _k_ to 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _kPresent_ be ? HasProperty(_O_, ! ToString(𝔽(_k_))).\n            1. If _kPresent_ is *true*, then\n              1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).\n              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).\n            1. Set _k_ to _k_ + 1.\n          1. Return *-1*<sub>𝔽</sub>.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.indexOf",
        "name" : "INTRINSICS.Array.prototype.indexOf",
        "htmlId" : "sec-array.prototype.indexof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    744,
    [
      "UnaryExpression[5,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[5]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[5,0].IsFunctionDefinition",
        "name" : "UnaryExpression[5,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "-"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1543,
    [
      "Statement[7,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[7]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |Statement|.\n      ",
      {
        "normalizedName" : "Statement[7,0].LabelledEvaluation",
        "name" : "Statement[7,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BreakStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1766,
    [
      "FunctionStatementList[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,0].HasCallInTailPosition",
        "name" : "FunctionStatementList[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    336,
    [
      "FunctionStatementList[0,1].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ]
      ],
      "\n        1. Return the TopLevelLexicallyScopedDeclarations of |StatementList|.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,1].LexicallyScopedDeclarations",
        "name" : "FunctionStatementList[0,1].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1898,
    [
      "OptionalExpression[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalExpression[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |OptionalChain| with argument _call_.\n      ",
      {
        "normalizedName" : "OptionalExpression[2,0].HasCallInTailPosition",
        "name" : "OptionalExpression[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "OptionalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1849,
    [
      "MultiplicativeExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[MultiplicativeExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MultiplicativeExpression[1,0].HasCallInTailPosition",
        "name" : "MultiplicativeExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "MultiplicativeExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeOperator"
              },
              {
                "type" : "nonterminal",
                "value" : "ExponentiationExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1257,
    [
      "ArrayLiteral[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayLiteral[0]]"
        ]
      ],
      "\n          1. Let _array_ be ! ArrayCreate(0).\n          1. If |Elision| is present, then\n            1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and 0.\n          1. Return _array_.\n        ",
      {
        "normalizedName" : "ArrayLiteral[0,0].Evaluation",
        "name" : "ArrayLiteral[0,0].Evaluation",
        "htmlId" : "sec-array-initializer-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrayLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2838,
    [
      "INTRINSICS.Reflect.construct",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If IsConstructor(_target_) is *false*, throw a *TypeError* exception.\n        1. If _newTarget_ is not present, set _newTarget_ to _target_.\n        1. Else if IsConstructor(_newTarget_) is *false*, throw a *TypeError* exception.\n        1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).\n        1. Return ? Construct(_target_, _args_, _newTarget_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.construct",
        "name" : "INTRINSICS.Reflect.construct",
        "htmlId" : "sec-reflect.construct",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2558,
    [
      "INTRINSICS.TypedArray.prototype.set",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _target_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_target_, [[TypedArrayName]]).\n          1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _targetOffset_ be ? ToIntegerOrInfinity(_offset_).\n          1. If _targetOffset_ < 0, throw a *RangeError* exception.\n          1. If _source_ is an Object that has a [[TypedArrayName]] internal slot, then\n            1. Perform ? SetTypedArrayFromTypedArray(_target_, _targetOffset_, _source_).\n          1. Else,\n            1. Perform ? SetTypedArrayFromArrayLike(_target_, _targetOffset_, _source_).\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.set",
        "name" : "INTRINSICS.TypedArray.prototype.set",
        "htmlId" : "sec-%typedarray%.prototype.set",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2113,
    [
      "INTRINSICS.Number.prototype.toFixed",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _x_ be ? ThisNumberValue(*this* value).\n          1. Let _f_ be ? ToIntegerOrInfinity(_fractionDigits_).\n          1. Assert: If _fractionDigits_ is *undefined*, then _f_ is 0.\n          1. If _f_ is not finite, throw a *RangeError* exception.\n          1. If _f_ < 0 or _f_ > 100, throw a *RangeError* exception.\n          1. If _x_ is not finite, return Number::toString(_x_, 10).\n          1. Set _x_ to ℝ(_x_).\n          1. Let _s_ be the empty String.\n          1. If _x_ < 0, then\n            1. Set _s_ to *\"-\"*.\n            1. Set _x_ to -_x_.\n          1. If _x_ ≥ 10<sup>21</sup>, then\n            1. Let _m_ be ! ToString(𝔽(_x_)).\n          1. Else,\n            1. Let _n_ be an integer for which _n_ / 10<sup>_f_</sup> - _x_ is as close to zero as possible. If there are two such _n_, pick the larger _n_.\n            1. If _n_ = 0, let _m_ be *\"0\"*. Otherwise, let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).\n            1. If _f_ ≠ 0, then\n              1. Let _k_ be the length of _m_.\n              1. If _k_ ≤ _f_, then\n                1. Let _z_ be the String value consisting of _f_ + 1 - _k_ occurrences of the code unit 0x0030 (DIGIT ZERO).\n                1. Set _m_ to the string-concatenation of _z_ and _m_.\n                1. Set _k_ to _f_ + 1.\n              1. Let _a_ be the first _k_ - _f_ code units of _m_.\n              1. Let _b_ be the other _f_ code units of _m_.\n              1. Set _m_ to the string-concatenation of _a_, *\".\"*, and _b_.\n          1. Return the string-concatenation of _s_ and _m_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Number.prototype.toFixed",
        "name" : "INTRINSICS.Number.prototype.toFixed",
        "htmlId" : "sec-number.prototype.tofixed",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    703,
    [
      "ModuleItem[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ModuleItem[1,0].ContainsUndefinedContinueTarget",
        "name" : "ModuleItem[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1141,
    [
      "Record[Array].DefineOwnProperty",
      4,
      [
        [
          "A",
          false,
          "Record[Array]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Desc",
          false,
          "Record[PropertyDescriptor]"
        ]
      ],
      "\n          1. If _P_ is *\"length\"*, then\n            1. Return ? ArraySetLength(_A_, _Desc_).\n          1. Else if _P_ is an array index, then\n            1. Let _lengthDesc_ be OrdinaryGetOwnProperty(_A_, *\"length\"*).\n            1. Assert: IsDataDescriptor(_lengthDesc_) is *true*.\n            1. Assert: _lengthDesc_.[[Configurable]] is *false*.\n            1. Let _length_ be _lengthDesc_.[[Value]].\n            1. Assert: _length_ is a non-negative integral Number.\n            1. Let _index_ be ! ToUint32(_P_).\n            1. If _index_ ≥ _length_ and _lengthDesc_.[[Writable]] is *false*, return *false*.\n            1. Let _succeeded_ be ! OrdinaryDefineOwnProperty(_A_, _P_, _Desc_).\n            1. If _succeeded_ is *false*, return *false*.\n            1. If _index_ ≥ _length_, then\n              1. Set _lengthDesc_.[[Value]] to _index_ + *1*<sub>𝔽</sub>.\n              1. Set _succeeded_ to ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _lengthDesc_).\n              1. Assert: _succeeded_ is *true*.\n            1. Return *true*.\n          1. Return ? OrdinaryDefineOwnProperty(_A_, _P_, _Desc_).\n        ",
      {
        "normalizedName" : "Record[Array].DefineOwnProperty",
        "name" : "Record[Array].DefineOwnProperty",
        "htmlId" : "sec-array-exotic-objects-defineownproperty-p-desc",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "Array",
          "[[DefineOwnProperty]]"
        ]
      }
    ]
  ],
  [
    2426,
    [
      "ClassSetCharacter[1,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSetCharacter[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _cv_ be the CharacterValue of this |ClassSetCharacter|.\n          1. Let _c_ be the character whose character value is _cv_.\n          1. Return the CharSet containing the single character _c_.\n        ",
      {
        "normalizedName" : "ClassSetCharacter[1,0].CompileToCharSet",
        "name" : "ClassSetCharacter[1,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassSetCharacter",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "\\"
              },
              {
                "type" : "nonterminal",
                "value" : "CharacterEscape"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1536,
    [
      "LabelledItem[1,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |FunctionDeclaration|.\n      ",
      {
        "normalizedName" : "LabelledItem[1,0].LabelledEvaluation",
        "name" : "LabelledItem[1,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1981,
    [
      "ExportSpecifier[0,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportSpecifier[0]]"
        ]
      ],
      "\n          1. Return a List whose sole element is the StringValue of |ModuleExportName|.\n        ",
      {
        "normalizedName" : "ExportSpecifier[0,0].ExportedBindings",
        "name" : "ExportSpecifier[0,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportSpecifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    656,
    [
      "ForStatement[0,2].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[0,2].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[0,2].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1802,
    [
      "ForInOfStatement[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[0,0].HasCallInTailPosition",
        "name" : "ForInOfStatement[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1023,
    [
      "Record[ObjectEnvironmentRecord].DeleteBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[ObjectEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ]
      ],
      "\n            1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n            1. Return ? <emu-meta effects=\"user-code\">_bindingObject_.[[Delete]]</emu-meta>(_N_).\n          ",
      {
        "normalizedName" : "Record[ObjectEnvironmentRecord].DeleteBinding",
        "name" : "Record[ObjectEnvironmentRecord].DeleteBinding",
        "htmlId" : "sec-object-environment-records-deletebinding-n",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ObjectEnvironmentRecord",
          "DeleteBinding"
        ]
      }
    ]
  ],
  [
    1702,
    [
      "IdentifierReference[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierReference[0]]"
        ]
      ],
      "\n        1. If the StringValue of |Identifier| is *\"arguments\"*, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "IdentifierReference[0,0].ContainsArguments",
        "name" : "IdentifierReference[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IdentifierReference",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Identifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2379,
    [
      "AtomEscape[2,0].CompileAtom",
      2,
      [
        [
          "this",
          false,
          "Ast[AtomEscape[2]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Let _cv_ be the CharacterValue of |CharacterEscape|.\n          1. Let _ch_ be the character whose character value is _cv_.\n          1. Let _A_ be a one-element CharSet containing the character _ch_.\n          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).\n        ",
      {
        "normalizedName" : "AtomEscape[2,0].CompileAtom",
        "name" : "AtomEscape[2,0].CompileAtom",
        "htmlId" : "sec-compileatom",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAtom",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "AtomEscape",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CharacterEscape"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1221,
    [
      "DecimalBigIntegerLiteral[0,0].NumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[DecimalBigIntegerLiteral[0]]"
        ]
      ],
      "\n          1. Return *0*<sub>ℤ</sub>.\n        ",
      {
        "normalizedName" : "DecimalBigIntegerLiteral[0,0].NumericValue",
        "name" : "DecimalBigIntegerLiteral[0,0].NumericValue",
        "htmlId" : "sec-numericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NumericValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DecimalBigIntegerLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "0"
              },
              {
                "type" : "nonterminal",
                "value" : "BigIntLiteralSuffix"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    154,
    [
      "SameValue",
      0,
      [
        [
          "x",
          false,
          "ESValue"
        ],
        [
          "y",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If Type(_x_) is not Type(_y_), return *false*.\n        1. If _x_ is a Number, then\n          1. Return Number::sameValue(_x_, _y_).\n        1. Return SameValueNonNumber(_x_, _y_).\n      ",
      {
        "normalizedName" : "SameValue",
        "name" : "SameValue",
        "htmlId" : "sec-samevalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1284,
    [
      "TemplateMiddleList[0,0].TemplateStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateMiddleList[0]]"
        ],
        [
          "raw",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Return « TemplateString(|TemplateMiddle|, _raw_) ».\n        ",
      {
        "normalizedName" : "TemplateMiddleList[0,0].TemplateStrings",
        "name" : "TemplateMiddleList[0,0].TemplateStrings",
        "htmlId" : "sec-static-semantics-templatestrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TemplateStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TemplateMiddleList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateMiddle"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1353,
    [
      "UnaryExpression[3,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[3]]"
        ]
      ],
      "\n          1. Let _val_ be ? Evaluation of |UnaryExpression|.\n          1. If _val_ is a Reference Record, then\n            1. If IsUnresolvableReference(_val_) is *true*, return *\"undefined\"*.\n          1. Set _val_ to ? GetValue(_val_).\n          1. If _val_ is *undefined*, return *\"undefined\"*.\n          1. If _val_ is *null*, return *\"object\"*.\n          1. If _val_ is a String, return *\"string\"*.\n          1. If _val_ is a Symbol, return *\"symbol\"*.\n          1. If _val_ is a Boolean, return *\"boolean\"*.\n          1. If _val_ is a Number, return *\"number\"*.\n          1. If _val_ is a BigInt, return *\"bigint\"*.\n          1. Assert: _val_ is an Object.\n          1. [id=\"step-typeof-web-compat-insertion-point\"] NOTE: This step is replaced in section <emu-xref href=\"#sec-IsHTMLDDA-internal-slot-typeof\"></emu-xref>.\n          1. If _val_ has a [[Call]] internal slot, return *\"function\"*.\n          1. Return *\"object\"*.\n        ",
      {
        "normalizedName" : "UnaryExpression[3,0].Evaluation",
        "name" : "UnaryExpression[3,0].Evaluation",
        "htmlId" : "sec-typeof-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "typeof"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2279,
    [
      "CountLeftCapturingParensWithin",
      0,
      [
        [
          "node",
          false,
          "Ast"
        ]
      ],
      "\n          1. Assert: _node_ is an instance of a production in <emu-xref href=\"#sec-patterns\">the RegExp Pattern grammar</emu-xref>.\n          1. Return the number of <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> Parse Nodes contained within _node_.\n        ",
      {
        "normalizedName" : "CountLeftCapturingParensWithin",
        "name" : "CountLeftCapturingParensWithin",
        "htmlId" : "sec-countleftcapturingparenswithin",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2357,
    [
      "Assertion[2,0].CompileAssertion",
      2,
      [
        [
          "this",
          false,
          "Ast[Assertion[2]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _e_ be _x_.[[EndIndex]].\n            1. Let _a_ be IsWordChar(_rer_, _Input_, _e_ - 1).\n            1. Let _b_ be IsWordChar(_rer_, _Input_, _e_).\n            1. If _a_ is *true* and _b_ is *false*, or if _a_ is *false* and _b_ is *true*, return _c_(_x_).\n            1. Return ~failure~.\n        ",
      {
        "normalizedName" : "Assertion[2,0].CompileAssertion",
        "name" : "Assertion[2,0].CompileAssertion",
        "htmlId" : "sec-compileassertion",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAssertion",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "Assertion",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "\\b"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    600,
    [
      "ForStatement[2,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[2,0].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[2,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1955,
    [
      "Module[0,0].ImportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[Module[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "Module[0,0].ImportEntries",
        "name" : "Module[0,0].ImportEntries",
        "htmlId" : "sec-static-semantics-importentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntries",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Module",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2843,
    [
      "INTRINSICS.Reflect.getPrototypeOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[GetPrototypeOf]]()</emu-meta>.\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.getPrototypeOf",
        "name" : "INTRINSICS.Reflect.getPrototypeOf",
        "htmlId" : "sec-reflect.getprototypeof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2145,
    [
      "INTRINSICS.Math.log1p",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *-1*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n          1. If _n_ < *-1*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the natural logarithm of 1 + ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.log1p",
        "name" : "INTRINSICS.Math.log1p",
        "htmlId" : "sec-math.log1p",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1485,
    [
      "MemberExpression[6,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[6]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "MemberExpression[6,0].IsDestructuring",
        "name" : "MemberExpression[6,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1972,
    [
      "ExportDeclaration[0,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ExportDeclaration[0,0].ExportedBindings",
        "name" : "ExportDeclaration[0,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "ExportFromClause"
              },
              {
                "type" : "nonterminal",
                "value" : "FromClause"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2320,
    [
      "ClassUnion[0,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassUnion[0]]"
        ]
      ],
      "\n          1. If the |ClassUnion| is present, return MayContainStrings of the |ClassUnion|.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ClassUnion[0,0].MayContainStrings",
        "name" : "ClassUnion[0,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassUnion",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetRange"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1052,
    [
      "Record[ModuleEnvironmentRecord].GetThisBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[ModuleEnvironmentRecord]"
        ]
      ],
      "\n            1. Return *undefined*.\n          ",
      {
        "normalizedName" : "Record[ModuleEnvironmentRecord].GetThisBinding",
        "name" : "Record[ModuleEnvironmentRecord].GetThisBinding",
        "htmlId" : "sec-module-environment-records-getthisbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleEnvironmentRecord",
          "GetThisBinding"
        ]
      }
    ]
  ],
  [
    2711,
    [
      "ByteListBitwiseOp",
      0,
      [
        [
          "op",
          false,
          "Unknown[\"`&`,`^`,Or``\"]"
        ],
        [
          "xBytes",
          false,
          "Unknown[\"ListOfByteValue\"]"
        ],
        [
          "yBytes",
          false,
          "Unknown[\"ListOfByteValue\"]"
        ]
      ],
      "\n          1. Assert: _xBytes_ and _yBytes_ have the same number of elements.\n          1. Let _result_ be a new empty List.\n          1. Let _i_ be 0.\n          1. For each element _xByte_ of _xBytes_, do\n            1. Let _yByte_ be _yBytes_[_i_].\n            1. If _op_ is `&`, then\n              1. Let _resultByte_ be the result of applying the bitwise AND operation to _xByte_ and _yByte_.\n            1. Else if _op_ is `^`, then\n              1. Let _resultByte_ be the result of applying the bitwise exclusive OR (XOR) operation to _xByte_ and _yByte_.\n            1. Else,\n              1. Assert: _op_ is `|`.\n              1. Let _resultByte_ be the result of applying the bitwise inclusive OR operation to _xByte_ and _yByte_.\n            1. Set _i_ to _i_ + 1.\n            1. Append _resultByte_ to _result_.\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "ByteListBitwiseOp",
        "name" : "ByteListBitwiseOp",
        "htmlId" : "sec-bytelistbitwiseop",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1506,
    [
      "BindingIdentifier[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingIdentifier[0]]"
        ]
      ],
      "\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Return ? ResolveBinding(_bindingId_).\n        ",
      {
        "normalizedName" : "BindingIdentifier[0,0].Evaluation",
        "name" : "BindingIdentifier[0,0].Evaluation",
        "htmlId" : "sec-for-in-and-for-of-statements-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BindingIdentifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Identifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2579,
    [
      "INTRINSICS._TypedArray_",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for this <var>TypedArray</var> constructor.\n          1. Let _proto_ be <code>\"%<var>TypedArray</var>.prototype%\"</code>.\n          1. Let _numberOfArgs_ be the number of elements in _args_.\n          1. If _numberOfArgs_ = 0, then\n            1. Return ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, 0).\n          1. Else,\n            1. Let _firstArgument_ be _args_[0].\n            1. If _firstArgument_ is an Object, then\n              1. Let _O_ be ? AllocateTypedArray(_constructorName_, NewTarget, _proto_).\n              1. If _firstArgument_ has a [[TypedArrayName]] internal slot, then\n                1. Perform ? InitializeTypedArrayFromTypedArray(_O_, _firstArgument_).\n              1. Else if _firstArgument_ has an [[ArrayBufferData]] internal slot, then\n                1. If _numberOfArgs_ > 1, let _byteOffset_ be _args_[1]; else let _byteOffset_ be *undefined*.\n                1. If _numberOfArgs_ > 2, let _length_ be _args_[2]; else let _length_ be *undefined*.\n                1. Perform ? InitializeTypedArrayFromArrayBuffer(_O_, _firstArgument_, _byteOffset_, _length_).\n              1. Else,\n                1. Assert: _firstArgument_ is an Object and _firstArgument_ does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.\n                1. Let _usingIterator_ be ? GetMethod(_firstArgument_, @@iterator).\n                1. If _usingIterator_ is not *undefined*, then\n                  1. Let _values_ be ? IteratorToList(? GetIteratorFromMethod(_firstArgument_, _usingIterator_)).\n                  1. Perform ? InitializeTypedArrayFromList(_O_, _values_).\n                1. Else,\n                  1. NOTE: _firstArgument_ is not an Iterable so assume it is already an array-like object.\n                  1. Perform ? InitializeTypedArrayFromArrayLike(_O_, _firstArgument_).\n              1. Return _O_.\n            1. Else,\n              1. Assert: _firstArgument_ is not an Object.\n              1. Let _elementLength_ be ? ToIndex(_firstArgument_).\n              1. Return ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, _elementLength_).\n        ",
      {
        "normalizedName" : "INTRINSICS._TypedArray_",
        "name" : "INTRINSICS._TypedArray_",
        "htmlId" : "sec-typedarray",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    864,
    [
      "AsyncGeneratorMethod[0,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorMethod[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      ",
      {
        "normalizedName" : "AsyncGeneratorMethod[0,0].ComputedPropertyContains",
        "name" : "AsyncGeneratorMethod[0,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1749,
    [
      "ClassStaticBlockStatementList[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockStatementList[0]]"
        ]
      ],
      "\n        1. Return *undefined*.\n      ",
      {
        "normalizedName" : "ClassStaticBlockStatementList[0,0].Evaluation",
        "name" : "ClassStaticBlockStatementList[0,0].Evaluation",
        "htmlId" : "sec-class-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStaticBlockStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    11,
    [
      "INTRINSICS.Math.random",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Object] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1427,
    [
      "BreakableStatement[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BreakableStatement[1]]"
        ]
      ],
      "\n        1. Let _newLabelSet_ be a new empty List.\n        1. Return ? LabelledEvaluation of this |BreakableStatement| with argument _newLabelSet_.\n      ",
      {
        "normalizedName" : "BreakableStatement[1,0].Evaluation",
        "name" : "BreakableStatement[1,0].Evaluation",
        "htmlId" : "sec-statement-semantics-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BreakableStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SwitchStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1504,
    [
      "ForIn/OfHeadEvaluation",
      0,
      [
        [
          "uninitializedBoundNames",
          false,
          "List[String]"
        ],
        [
          "expr",
          false,
          "Ast[AssignmentExpression | Expression]"
        ],
        [
          "iterationKind",
          false,
          "Enum[~async-iterate~, ~enumerate~, ~iterate~]"
        ]
      ],
      "\n          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n          1. If _uninitializedBoundNames_ is not empty, then\n            1. Assert: _uninitializedBoundNames_ has no duplicate entries.\n            1. Let _newEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n            1. For each String _name_ of _uninitializedBoundNames_, do\n              1. Perform ! _newEnv_.CreateMutableBinding(_name_, *false*).\n            1. Set the running execution context's LexicalEnvironment to _newEnv_.\n          1. Let _exprRef_ be Completion(Evaluation of _expr_).\n          1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n          1. Let _exprValue_ be ? GetValue(? _exprRef_).\n          1. If _iterationKind_ is ~enumerate~, then\n            1. If _exprValue_ is either *undefined* or *null*, then\n              1. Return Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.\n            1. Let _obj_ be ! ToObject(_exprValue_).\n            1. Let _iterator_ be EnumerateObjectProperties(_obj_).\n            1. Let _nextMethod_ be ! GetV(_iterator_, *\"next\"*).\n            1. Return the Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.\n          1. Else,\n            1. Assert: _iterationKind_ is either ~iterate~ or ~async-iterate~.\n            1. If _iterationKind_ is ~async-iterate~, let _iteratorKind_ be ~async~.\n            1. Else, let _iteratorKind_ be ~sync~.\n            1. Return ? GetIterator(_exprValue_, _iteratorKind_).\n        ",
      {
        "normalizedName" : "ForInOfHeadEvaluation",
        "name" : "ForIn/OfHeadEvaluation",
        "htmlId" : "sec-runtime-semantics-forinofheadevaluation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    727,
    [
      "MemberExpression[2,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[2,0].IsFunctionDefinition",
        "name" : "MemberExpression[2,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    72,
    [
      "BigInt::multiply",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. Return _x_ × _y_.\n          ",
      {
        "normalizedName" : "BigInt::multiply",
        "name" : "BigInt::multiply",
        "htmlId" : "sec-numeric-types-bigint-multiply",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1585,
    [
      "SingleNameBinding[0,0].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[SingleNameBinding[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "SingleNameBinding[0,0].IsSimpleParameterList",
        "name" : "SingleNameBinding[0,0].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SingleNameBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    175,
    [
      "TestIntegrityLevel",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "level",
          false,
          "Enum[~frozen~, ~sealed~]"
        ]
      ],
      "\n        1. Let _extensible_ be ? IsExtensible(_O_).\n        1. If _extensible_ is *true*, return *false*.\n        1. NOTE: If the object is extensible, none of its properties are examined.\n        1. Let _keys_ be ? _O_.[[OwnPropertyKeys]]().\n        1. For each element _k_ of _keys_, do\n          1. Let _currentDesc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_k_).\n          1. If _currentDesc_ is not *undefined*, then\n            1. If _currentDesc_.[[Configurable]] is *true*, return *false*.\n            1. If _level_ is ~frozen~ and IsDataDescriptor(_currentDesc_) is *true*, then\n              1. If _currentDesc_.[[Writable]] is *true*, return *false*.\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "TestIntegrityLevel",
        "name" : "TestIntegrityLevel",
        "htmlId" : "sec-testintegritylevel",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    386,
    [
      "ForInOfStatement[3,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[3]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForInOfStatement[3,0].VarDeclaredNames",
        "name" : "ForInOfStatement[3,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2511,
    [
      "INTRINSICS.Array.prototype.slice",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _k_ be 0.\n          1. Else if _relativeStart_ < 0, let _k_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _k_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _final_ be 0.\n          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _final_ be min(_relativeEnd_, _len_).\n          1. Let _count_ be max(_final_ - _k_, 0).\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, _count_).\n          1. Let _n_ be 0.\n          1. Repeat, while _k_ < _final_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _kValue_).\n            1. Set _k_ to _k_ + 1.\n            1. Set _n_ to _n_ + 1.\n          1. [id=\"step-array-proto-slice-set-length\"] Perform ? Set(_A_, *\"length\"*, 𝔽(_n_), *true*).\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.slice",
        "name" : "INTRINSICS.Array.prototype.slice",
        "htmlId" : "sec-array.prototype.slice",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1094,
    [
      "IsCompatiblePropertyDescriptor",
      0,
      [
        [
          "Extensible",
          false,
          "Boolean"
        ],
        [
          "Desc",
          false,
          "Record[PropertyDescriptor]"
        ],
        [
          "Current",
          false,
          "Record[PropertyDescriptor] | Undefined"
        ]
      ],
      "\n          1. Return ValidateAndApplyPropertyDescriptor(*undefined*, *\"\"*, _Extensible_, _Desc_, _Current_).\n        ",
      {
        "normalizedName" : "IsCompatiblePropertyDescriptor",
        "name" : "IsCompatiblePropertyDescriptor",
        "htmlId" : "sec-iscompatiblepropertydescriptor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    978,
    [
      "LogicalORExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[LogicalORExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "LogicalORExpression[1,0].AssignmentTargetType",
        "name" : "LogicalORExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LogicalORExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LogicalORExpression"
              },
              {
                "type" : "terminal",
                "value" : "||"
              },
              {
                "type" : "nonterminal",
                "value" : "LogicalANDExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1140,
    [
      "BoundFunctionCreate",
      0,
      [
        [
          "targetFunction",
          false,
          "Record[FunctionObject]"
        ],
        [
          "boundThis",
          false,
          "ESValue"
        ],
        [
          "boundArgs",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Let _proto_ be ? <emu-meta effects=\"user-code\">_targetFunction_.[[GetPrototypeOf]]</emu-meta>().\n          1. Let _internalSlotsList_ be the list-concatenation of « [[Prototype]], [[Extensible]] » and the internal slots listed in <emu-xref href=\"#table-internal-slots-of-bound-function-exotic-objects\"></emu-xref>.\n          1. Let _obj_ be MakeBasicObject(_internalSlotsList_).\n          1. Set _obj_.[[Prototype]] to _proto_.\n          1. Set _obj_.[[Call]] as described in <emu-xref href=\"#sec-bound-function-exotic-objects-call-thisargument-argumentslist\"></emu-xref>.\n          1. If IsConstructor(_targetFunction_) is *true*, then\n            1. Set _obj_.[[Construct]] as described in <emu-xref href=\"#sec-bound-function-exotic-objects-construct-argumentslist-newtarget\"></emu-xref>.\n          1. Set _obj_.[[BoundTargetFunction]] to _targetFunction_.\n          1. Set _obj_.[[BoundThis]] to _boundThis_.\n          1. Set _obj_.[[BoundArguments]] to _boundArgs_.\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "BoundFunctionCreate",
        "name" : "BoundFunctionCreate",
        "htmlId" : "sec-boundfunctioncreate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1670,
    [
      "ClassElementList[1,0].ConstructorMethod",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementList[1]]"
        ]
      ],
      "\n        1. Let _head_ be ConstructorMethod of |ClassElementList|.\n        1. If _head_ is not ~empty~, return _head_.\n        1. If ClassElementKind of |ClassElement| is ~constructor-method~, return |ClassElement|.\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "ClassElementList[1,0].ConstructorMethod",
        "name" : "ClassElementList[1,0].ConstructorMethod",
        "htmlId" : "sec-static-semantics-constructormethod",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ConstructorMethod",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementList"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1797,
    [
      "ForStatement[1,3].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[1,3].HasCallInTailPosition",
        "name" : "ForStatement[1,3].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2722,
    [
      "INTRINSICS.Atomics.wait",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Return ? DoWait(~sync~, _typedArray_, _index_, _value_, _timeout_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.wait",
        "name" : "INTRINSICS.Atomics.wait",
        "htmlId" : "sec-atomics.wait",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1008,
    [
      "Record[DeclarativeEnvironmentRecord].HasBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ]
      ],
      "\n            1. If _envRec_ has a binding for _N_, return *true*.\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "Record[DeclarativeEnvironmentRecord].HasBinding",
        "name" : "Record[DeclarativeEnvironmentRecord].HasBinding",
        "htmlId" : "sec-declarative-environment-records-hasbinding-n",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "DeclarativeEnvironmentRecord",
          "HasBinding"
        ]
      }
    ]
  ],
  [
    2728,
    [
      "INTRINSICS.JSON.stringify",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _stack_ be a new empty List.\n        1. Let _indent_ be the empty String.\n        1. Let _PropertyList_ be *undefined*.\n        1. Let _ReplacerFunction_ be *undefined*.\n        1. If _replacer_ is an Object, then\n          1. If IsCallable(_replacer_) is *true*, then\n            1. Set _ReplacerFunction_ to _replacer_.\n          1. Else,\n            1. Let _isArray_ be ? IsArray(_replacer_).\n            1. If _isArray_ is *true*, then\n              1. Set _PropertyList_ to a new empty List.\n              1. Let _len_ be ? LengthOfArrayLike(_replacer_).\n              1. Let _k_ be 0.\n              1. Repeat, while _k_ < _len_,\n                1. Let _prop_ be ! ToString(𝔽(_k_)).\n                1. Let _v_ be ? Get(_replacer_, _prop_).\n                1. Let _item_ be *undefined*.\n                1. If _v_ is a String, then\n                  1. Set _item_ to _v_.\n                1. Else if _v_ is a Number, then\n                  1. Set _item_ to ! ToString(_v_).\n                1. Else if _v_ is an Object, then\n                  1. If _v_ has a [[StringData]] or [[NumberData]] internal slot, set _item_ to ? ToString(_v_).\n                1. If _item_ is not *undefined* and _PropertyList_ does not contain _item_, then\n                  1. Append _item_ to _PropertyList_.\n                1. Set _k_ to _k_ + 1.\n        1. If _space_ is an Object, then\n          1. If _space_ has a [[NumberData]] internal slot, then\n            1. Set _space_ to ? ToNumber(_space_).\n          1. Else if _space_ has a [[StringData]] internal slot, then\n            1. Set _space_ to ? ToString(_space_).\n        1. If _space_ is a Number, then\n          1. Let _spaceMV_ be ! ToIntegerOrInfinity(_space_).\n          1. Set _spaceMV_ to min(10, _spaceMV_).\n          1. If _spaceMV_ < 1, let _gap_ be the empty String; otherwise let _gap_ be the String value containing _spaceMV_ occurrences of the code unit 0x0020 (SPACE).\n        1. Else if _space_ is a String, then\n          1. If the length of _space_ ≤ 10, let _gap_ be _space_; otherwise let _gap_ be the substring of _space_ from 0 to 10.\n        1. Else,\n          1. Let _gap_ be the empty String.\n        1. Let _wrapper_ be OrdinaryObjectCreate(%Object.prototype%).\n        1. Perform ! CreateDataPropertyOrThrow(_wrapper_, the empty String, _value_).\n        1. Let _state_ be the JSON Serialization Record { [[ReplacerFunction]]: _ReplacerFunction_, [[Stack]]: _stack_, [[Indent]]: _indent_, [[Gap]]: _gap_, [[PropertyList]]: _PropertyList_ }.\n        1. Return ? SerializeJSONProperty(_state_, the empty String, _wrapper_).\n      ",
      {
        "normalizedName" : "INTRINSICS.JSON.stringify",
        "name" : "INTRINSICS.JSON.stringify",
        "htmlId" : "sec-json.stringify",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1717,
    [
      "AsyncFunctionExpression[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,0].ContainsArguments",
        "name" : "AsyncFunctionExpression[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2030,
    [
      "PerformEval",
      0,
      [
        [
          "x",
          false,
          "ESValue"
        ],
        [
          "strictCaller",
          false,
          "Boolean"
        ],
        [
          "direct",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Assert: If _direct_ is *false*, then _strictCaller_ is also *false*.\n          1. If _x_ is not a String, return _x_.\n          1. Let _evalRealm_ be the current Realm Record.\n          1. NOTE: In the case of a direct eval, _evalRealm_ is the realm of both the caller of `eval` and of the `eval` function itself.\n          1. Perform ? HostEnsureCanCompileStrings(_evalRealm_, « », _x_, _direct_).\n          1. Let _inFunction_ be *false*.\n          1. Let _inMethod_ be *false*.\n          1. Let _inDerivedConstructor_ be *false*.\n          1. Let _inClassFieldInitializer_ be *false*.\n          1. If _direct_ is *true*, then\n            1. Let _thisEnvRec_ be GetThisEnvironment().\n            1. If _thisEnvRec_ is a Function Environment Record, then\n              1. Let _F_ be _thisEnvRec_.[[FunctionObject]].\n              1. Set _inFunction_ to *true*.\n              1. Set _inMethod_ to _thisEnvRec_.HasSuperBinding().\n              1. If IsConstructor(_F_) is *true* and _F_.[[ConstructorKind]] is ~derived~, set _inDerivedConstructor_ to *true*.\n              1. Let _classFieldInitializerName_ be _F_.[[ClassFieldInitializerName]].\n              1. If _classFieldInitializerName_ is not ~empty~, set _inClassFieldInitializer_ to *true*.\n          1. Perform the following substeps in an implementation-defined order, possibly interleaving parsing and error detection:\n            1. Let _script_ be ParseText(StringToCodePoints(_x_), |Script|).\n            1. If _script_ is a List of errors, throw a *SyntaxError* exception.\n            1. If _script_ Contains |ScriptBody| is *false*, return *undefined*.\n            1. Let _body_ be the |ScriptBody| of _script_.\n            1. If _inFunction_ is *false* and _body_ Contains |NewTarget|, throw a *SyntaxError* exception.\n            1. If _inMethod_ is *false* and _body_ Contains |SuperProperty|, throw a *SyntaxError* exception.\n            1. If _inDerivedConstructor_ is *false* and _body_ Contains |SuperCall|, throw a *SyntaxError* exception.\n            1. If _inClassFieldInitializer_ is *true* and ContainsArguments of _body_ is *true*, throw a *SyntaxError* exception.\n          1. If _strictCaller_ is *true*, let _strictEval_ be *true*.\n          1. Else, let _strictEval_ be IsStrict of _script_.\n          1. Let _runningContext_ be the running execution context.\n          1. NOTE: If _direct_ is *true*, _runningContext_ will be the execution context that performed the direct eval. If _direct_ is *false*, _runningContext_ will be the execution context for the invocation of the `eval` function.\n          1. If _direct_ is *true*, then\n            1. Let _lexEnv_ be NewDeclarativeEnvironment(_runningContext_'s LexicalEnvironment).\n            1. Let _varEnv_ be _runningContext_'s VariableEnvironment.\n            1. Let _privateEnv_ be _runningContext_'s PrivateEnvironment.\n          1. Else,\n            1. Let _lexEnv_ be NewDeclarativeEnvironment(_evalRealm_.[[GlobalEnv]]).\n            1. Let _varEnv_ be _evalRealm_.[[GlobalEnv]].\n            1. Let _privateEnv_ be *null*.\n          1. If _strictEval_ is *true*, set _varEnv_ to _lexEnv_.\n          1. If _runningContext_ is not already suspended, suspend _runningContext_.\n          1. Let _evalContext_ be a new ECMAScript code execution context.\n          1. Set _evalContext_'s Function to *null*.\n          1. Set _evalContext_'s Realm to _evalRealm_.\n          1. Set _evalContext_'s ScriptOrModule to _runningContext_'s ScriptOrModule.\n          1. Set _evalContext_'s VariableEnvironment to _varEnv_.\n          1. Set _evalContext_'s LexicalEnvironment to _lexEnv_.\n          1. Set _evalContext_'s PrivateEnvironment to _privateEnv_.\n          1. Push _evalContext_ onto the execution context stack; _evalContext_ is now the running execution context.\n          1. Let _result_ be Completion(EvalDeclarationInstantiation(_body_, _varEnv_, _lexEnv_, _privateEnv_, _strictEval_)).\n          1. If _result_ is a normal completion, then\n            1. Set _result_ to Completion(Evaluation of _body_).\n          1. If _result_ is a normal completion and _result_.[[Value]] is ~empty~, then\n            1. Set _result_ to NormalCompletion(*undefined*).\n          1. Suspend _evalContext_ and remove it from the execution context stack.\n          1. Resume the context that is now on the top of the execution context stack as the running execution context.\n          1. Return ? _result_.\n        ",
      {
        "normalizedName" : "PerformEval",
        "name" : "PerformEval",
        "htmlId" : "sec-performeval",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    446,
    [
      "ForStatement[1,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "ForStatement[1,0].VarScopedDeclarations",
        "name" : "ForStatement[1,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    571,
    [
      "ModuleItemList[1,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |ModuleItemList| with argument _labelSet_.\n        1. If _hasDuplicates_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of |ModuleItem| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ModuleItemList[1,0].ContainsDuplicateLabels",
        "name" : "ModuleItemList[1,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1372,
    [
      "InstanceofOperator",
      0,
      [
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "target",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _instOfHandler_ be ? GetMethod(_target_, @@hasInstance).\n        1. If _instOfHandler_ is not *undefined*, then\n          1. Return ToBoolean(? Call(_instOfHandler_, _target_, « _V_ »)).\n        1. [id=\"step-instanceof-check-function\"] If IsCallable(_target_) is *false*, throw a *TypeError* exception.\n        1. [id=\"step-instanceof-fallback\"] Return ? OrdinaryHasInstance(_target_, _V_).\n      ",
      {
        "normalizedName" : "InstanceofOperator",
        "name" : "InstanceofOperator",
        "htmlId" : "sec-instanceofoperator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    595,
    [
      "ForStatement[0,7].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,7].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[0,7].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 7,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1881,
    [
      "PrimaryExpression[6,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[6]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[6,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[6,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2807,
    [
      "INTRINSICS.AsyncGeneratorFunction.prototype.prototype.return",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _generator_ be the *this* value.\n          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n          1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).\n          1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Let _completion_ be Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n          1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).\n          1. Let _state_ be _generator_.[[AsyncGeneratorState]].\n          1. If _state_ is either ~suspended-start~ or ~completed~, then\n            1. Set _generator_.[[AsyncGeneratorState]] to ~awaiting-return~.\n            1. Perform ! AsyncGeneratorAwaitReturn(_generator_).\n          1. Else if _state_ is ~suspended-yield~, then\n            1. Perform AsyncGeneratorResume(_generator_, _completion_).\n          1. Else,\n            1. Assert: _state_ is either ~executing~ or ~awaiting-return~.\n          1. Return _promiseCapability_.[[Promise]].\n        ",
      {
        "normalizedName" : "INTRINSICS.AsyncGeneratorFunction.prototype.prototype.return",
        "name" : "INTRINSICS.AsyncGeneratorFunction.prototype.prototype.return",
        "htmlId" : "sec-asyncgenerator-prototype-return",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1272,
    [
      "ComputedPropertyName[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ComputedPropertyName[0]]"
        ]
      ],
      "\n          1. Let _exprValue_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _propName_ be ? GetValue(_exprValue_).\n          1. Return ? ToPropertyKey(_propName_).\n        ",
      {
        "normalizedName" : "ComputedPropertyName[0,0].Evaluation",
        "name" : "ComputedPropertyName[0,0].Evaluation",
        "htmlId" : "sec-object-initializer-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ComputedPropertyName",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    612,
    [
      "ForInOfStatement[8,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[8]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[8,0].ContainsUndefinedBreakTarget",
        "name" : "ForInOfStatement[8,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    143,
    [
      "ToLength",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _len_ be ? ToIntegerOrInfinity(_argument_).\n        1. If _len_ ≤ 0, return *+0*<sub>𝔽</sub>.\n        1. Return 𝔽(min(_len_, 2<sup>53</sup> - 1)).\n      ",
      {
        "normalizedName" : "ToLength",
        "name" : "ToLength",
        "htmlId" : "sec-tolength",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    497,
    [
      "StatementListItem[0,0].TopLevelLexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "StatementListItem[0,0].TopLevelLexicallyScopedDeclarations",
        "name" : "StatementListItem[0,0].TopLevelLexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-toplevellexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelLexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2266,
    [
      "INTRINSICS.String.prototype.substring",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _len_ be the length of _S_.\n          1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _end_ is *undefined*, let _intEnd_ be _len_; else let _intEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. Let _finalStart_ be the result of clamping _intStart_ between 0 and _len_.\n          1. Let _finalEnd_ be the result of clamping _intEnd_ between 0 and _len_.\n          1. Let _from_ be min(_finalStart_, _finalEnd_).\n          1. Let _to_ be max(_finalStart_, _finalEnd_).\n          1. Return the substring of _S_ from _from_ to _to_.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.substring",
        "name" : "INTRINSICS.String.prototype.substring",
        "htmlId" : "sec-string.prototype.substring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    876,
    [
      "AsyncGeneratorDeclaration[1,0].InstantiateFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorDeclaration[1]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Return InstantiateAsyncGeneratorFunctionObject of |AsyncGeneratorDeclaration| with arguments _env_ and _privateEnv_.\n      ",
      {
        "normalizedName" : "AsyncGeneratorDeclaration[1,0].InstantiateFunctionObject",
        "name" : "AsyncGeneratorDeclaration[1,0].InstantiateFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiatefunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AsyncGeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1240,
    [
      "IdentifierReference[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierReference[2]]"
        ]
      ],
      "\n        1. Return ? ResolveBinding(*\"await\"*).\n      ",
      {
        "normalizedName" : "IdentifierReference[2,0].Evaluation",
        "name" : "IdentifierReference[2,0].Evaluation",
        "htmlId" : "sec-identifiers-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "IdentifierReference",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "await"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    991,
    [
      "PropertyDefinition[4,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyDefinition[4]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "PropertyDefinition[4,0].PropName",
        "name" : "PropertyDefinition[4,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "PropertyDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "..."
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1617,
    [
      "FunctionDeclaration[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[1]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[1,0].Evaluation",
        "name" : "FunctionDeclaration[1,0].Evaluation",
        "htmlId" : "sec-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1940,
    [
      "GatherAvailableAncestors",
      0,
      [
        [
          "module",
          false,
          "Record[CyclicModuleRecord]"
        ],
        [
          "execList",
          false,
          "List[Record[CyclicModuleRecord]]"
        ]
      ],
      "\n              1. For each Cyclic Module Record _m_ of _module_.[[AsyncParentModules]], do\n                1. If _execList_ does not contain _m_ and _m_.[[CycleRoot]].[[EvaluationError]] is ~empty~, then\n                  1. Assert: _m_.[[Status]] is ~evaluating-async~.\n                  1. Assert: _m_.[[EvaluationError]] is ~empty~.\n                  1. Assert: _m_.[[AsyncEvaluation]] is *true*.\n                  1. Assert: _m_.[[PendingAsyncDependencies]] > 0.\n                  1. Set _m_.[[PendingAsyncDependencies]] to _m_.[[PendingAsyncDependencies]] - 1.\n                  1. If _m_.[[PendingAsyncDependencies]] = 0, then\n                    1. Append _m_ to _execList_.\n                    1. If _m_.[[HasTLA]] is *false*, perform GatherAvailableAncestors(_m_, _execList_).\n              1. Return ~unused~.\n            ",
      {
        "normalizedName" : "GatherAvailableAncestors",
        "name" : "GatherAvailableAncestors",
        "htmlId" : "sec-gather-available-ancestors",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1839,
    [
      "RelationalExpression[3,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[3]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[3,0].HasCallInTailPosition",
        "name" : "RelationalExpression[3,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "<="
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2479,
    [
      "INTRINSICS.Array.isArray",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return ? IsArray(_arg_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.isArray",
        "name" : "INTRINSICS.Array.isArray",
        "htmlId" : "sec-array.isarray",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2088,
    [
      "INTRINSICS.Boolean",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _b_ be ToBoolean(_value_).\n          1. If NewTarget is *undefined*, return _b_.\n          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Boolean.prototype%\"*, « [[BooleanData]] »).\n          1. Set _O_.[[BooleanData]] to _b_.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Boolean",
        "name" : "INTRINSICS.Boolean",
        "htmlId" : "sec-boolean-constructor-boolean-value",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1108,
    [
      "OrdinaryCreateFromConstructor",
      0,
      [
        [
          "constructor",
          false,
          "Record[Constructor]"
        ],
        [
          "intrinsicDefaultProto",
          false,
          "String"
        ],
        [
          "internalSlotsList",
          true,
          "Unknown[\"ListOfNamesOfInternalSlot\"]"
        ]
      ],
      "\n        1. Assert: _intrinsicDefaultProto_ is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.\n        1. Let _proto_ be ? GetPrototypeFromConstructor(_constructor_, _intrinsicDefaultProto_).\n        1. If _internalSlotsList_ is present, let _slotsList_ be _internalSlotsList_.\n        1. Else, let _slotsList_ be a new empty List.\n        1. Return OrdinaryObjectCreate(_proto_, _slotsList_).\n      ",
      {
        "normalizedName" : "OrdinaryCreateFromConstructor",
        "name" : "OrdinaryCreateFromConstructor",
        "htmlId" : "sec-ordinarycreatefromconstructor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1998,
    [
      "ExportSpecifier[0,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportSpecifier[0]]"
        ]
      ],
      "\n          1. Return a List whose sole element is the StringValue of |ModuleExportName|.\n        ",
      {
        "normalizedName" : "ExportSpecifier[0,0].ExportedNames",
        "name" : "ExportSpecifier[0,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportSpecifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2435,
    [
      "UnicodeMatchProperty",
      0,
      [
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "p",
          false,
          "Unknown[\"ECMAScriptSourceText\"]"
        ]
      ],
      "\n            1. If _rer_.[[UnicodeSets]] is *true* and _p_ is a Unicode <emu-not-ref>property name</emu-not-ref> listed in the “<emu-not-ref>Property name</emu-not-ref>” column of <emu-xref href=\"#table-binary-unicode-properties-of-strings\"></emu-xref>, then\n              1. Return the List of Unicode code points _p_.\n            1. Assert: _p_ is a Unicode <emu-not-ref>property name</emu-not-ref> or property alias listed in the “<emu-not-ref>Property name</emu-not-ref> and aliases” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref> or <emu-xref href=\"#table-binary-unicode-properties\"></emu-xref>.\n            1. Let _c_ be the canonical <emu-not-ref>property name</emu-not-ref> of _p_ as given in the “Canonical <emu-not-ref>property name</emu-not-ref>” column of the corresponding row.\n            1. Return the List of Unicode code points _c_.\n          ",
      {
        "normalizedName" : "UnicodeMatchProperty",
        "name" : "UnicodeMatchProperty",
        "htmlId" : "sec-runtime-semantics-unicodematchproperty-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    845,
    [
      "ClassStaticBlock[0,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlock[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassStaticBlock[0,0].Contains",
        "name" : "ClassStaticBlock[0,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStaticBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "static"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassStaticBlockBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2760,
    [
      "NewPromiseResolveThenableJob",
      0,
      [
        [
          "promiseToResolve",
          false,
          "Record[Promise]"
        ],
        [
          "thenable",
          false,
          "Record[Object]"
        ],
        [
          "then",
          false,
          "Record[JobCallbackRecord]"
        ]
      ],
      "\n          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _promiseToResolve_, _thenable_, and _then_ and performs the following steps when called:\n            1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promiseToResolve_).\n            1. Let _thenCallResult_ be Completion(HostCallJobCallback(_then_, _thenable_, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)).\n            1. If _thenCallResult_ is an abrupt completion, then\n              1. Return ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _thenCallResult_.[[Value]] »).\n            1. Return ? _thenCallResult_.\n          1. Let _getThenRealmResult_ be Completion(GetFunctionRealm(_then_.[[Callback]])).\n          1. If _getThenRealmResult_ is a normal completion, let _thenRealm_ be _getThenRealmResult_.[[Value]].\n          1. Else, let _thenRealm_ be the current Realm Record.\n          1. NOTE: _thenRealm_ is never *null*. When _then_.[[Callback]] is a revoked Proxy and no code runs, _thenRealm_ is used to create error objects.\n          1. Return the Record { [[Job]]: _job_, [[Realm]]: _thenRealm_ }.\n        ",
      {
        "normalizedName" : "NewPromiseResolveThenableJob",
        "name" : "NewPromiseResolveThenableJob",
        "htmlId" : "sec-newpromiseresolvethenablejob",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1421,
    [
      "Expression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Expression[1]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |Expression|.\n        1. Perform ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n        1. Return ? GetValue(_rref_).\n      ",
      {
        "normalizedName" : "Expression[1,0].Evaluation",
        "name" : "Expression[1,0].Evaluation",
        "htmlId" : "sec-comma-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Expression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2013,
    [
      "NamedExports[0,0].ExportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[NamedExports[0]]"
        ],
        [
          "module",
          false,
          "String | Null"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "NamedExports[0,0].ExportEntriesForModule",
        "name" : "NamedExports[0,0].ExportEntriesForModule",
        "htmlId" : "sec-static-semantics-exportentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NamedExports",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    250,
    [
      "ClassDeclaration[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassDeclaration[1]]"
        ]
      ],
      "\n        1. Return « *\"\\*default\\*\"* ».\n      ",
      {
        "normalizedName" : "ClassDeclaration[1,0].BoundNames",
        "name" : "ClassDeclaration[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    465,
    [
      "CaseBlock[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "CaseBlock[0,0].VarScopedDeclarations",
        "name" : "CaseBlock[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    231,
    [
      "BindingElisionElement[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElisionElement[0]]"
        ]
      ],
      "\n        1. Return BoundNames of |BindingElement|.\n      ",
      {
        "normalizedName" : "BindingElisionElement[0,0].BoundNames",
        "name" : "BindingElisionElement[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BindingElisionElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2458,
    [
      "INTRINSICS.RegExp.prototype[@@search]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _rx_ be the *this* value.\n          1. If _rx_ is not an Object, throw a *TypeError* exception.\n          1. Let _S_ be ? ToString(_string_).\n          1. Let _previousLastIndex_ be ? Get(_rx_, *\"lastIndex\"*).\n          1. If SameValue(_previousLastIndex_, *+0*<sub>𝔽</sub>) is *false*, then\n            1. Perform ? Set(_rx_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n          1. Let _result_ be ? RegExpExec(_rx_, _S_).\n          1. Let _currentLastIndex_ be ? Get(_rx_, *\"lastIndex\"*).\n          1. If SameValue(_currentLastIndex_, _previousLastIndex_) is *false*, then\n            1. Perform ? Set(_rx_, *\"lastIndex\"*, _previousLastIndex_, *true*).\n          1. If _result_ is *null*, return *-1*<sub>𝔽</sub>.\n          1. Return ? Get(_result_, *\"index\"*).\n        ",
      {
        "normalizedName" : "INTRINSICS.RegExp.prototype[@@search]",
        "name" : "INTRINSICS.RegExp.prototype[@@search]",
        "htmlId" : "sec-regexp.prototype-@@search",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    627,
    [
      "LabelledStatement[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _label_ be the StringValue of |LabelIdentifier|.\n        1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».\n        1. Return ContainsUndefinedBreakTarget of |LabelledItem| with argument _newLabelSet_.\n      ",
      {
        "normalizedName" : "LabelledStatement[0,0].ContainsUndefinedBreakTarget",
        "name" : "LabelledStatement[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelledItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2626,
    [
      "ArrayBufferByteLength",
      0,
      [
        [
          "arrayBuffer",
          false,
          "Record[ArrayBuffer | SharedArrayBuffer]"
        ],
        [
          "order",
          false,
          "Enum[~seq-cst~, ~unordered~]"
        ]
      ],
      "\n          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true* and _arrayBuffer_ has an [[ArrayBufferByteLengthData]] internal slot, then\n            1. Let _bufferByteLengthBlock_ be _arrayBuffer_.[[ArrayBufferByteLengthData]].\n            1. Let _rawLength_ be GetRawBytesFromSharedBlock(_bufferByteLengthBlock_, 0, ~biguint64~, *true*, _order_).\n            1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n            1. Return ℝ(RawBytesToNumeric(~biguint64~, _rawLength_, _isLittleEndian_)).\n          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.\n          1. Return _arrayBuffer_.[[ArrayBufferByteLength]].\n        ",
      {
        "normalizedName" : "ArrayBufferByteLength",
        "name" : "ArrayBufferByteLength",
        "htmlId" : "sec-arraybufferbytelength",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1918,
    [
      "ModuleItemList[0,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[0]]"
        ]
      ],
      "\n          1. Return ModuleRequests of |ModuleItem|.\n        ",
      {
        "normalizedName" : "ModuleItemList[0,0].ModuleRequests",
        "name" : "ModuleItemList[0,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1316,
    [
      "SuperCall[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[SuperCall[0]]"
        ]
      ],
      "\n          1. Let _newTarget_ be GetNewTarget().\n          1. Assert: _newTarget_ is an Object.\n          1. Let _func_ be GetSuperConstructor().\n          1. Let _argList_ be ? ArgumentListEvaluation of |Arguments|.\n          1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n          1. Let _result_ be ? Construct(_func_, _argList_, _newTarget_).\n          1. Let _thisER_ be GetThisEnvironment().\n          1. Perform ? _thisER_.BindThisValue(_result_).\n          1. Let _F_ be _thisER_.[[FunctionObject]].\n          1. Assert: _F_ is an ECMAScript function object.\n          1. Perform ? InitializeInstanceElements(_result_, _F_).\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "SuperCall[0,0].Evaluation",
        "name" : "SuperCall[0,0].Evaluation",
        "htmlId" : "sec-super-keyword-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SuperCall",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "super"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1649,
    [
      "GeneratorExpression[0,0].InstantiateGeneratorFunctionExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ],
        [
          "name",
          true,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |GeneratorExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return _closure_.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,0].InstantiateGeneratorFunctionExpression",
        "name" : "GeneratorExpression[0,0].InstantiateGeneratorFunctionExpression",
        "htmlId" : "sec-runtime-semantics-instantiategeneratorfunctionexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateGeneratorFunctionExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    450,
    [
      "ForStatement[2,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[2,0].VarScopedDeclarations",
        "name" : "ForStatement[2,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2352,
    [
      "EmptyMatcher",
      0,
      [
      ],
      "\n            1. Return a new Matcher with parameters (_x_, _c_) that captures nothing and performs the following steps when called:\n              1. Assert: _x_ is a MatchState.\n              1. Assert: _c_ is a MatcherContinuation.\n              1. Return _c_(_x_).\n          ",
      {
        "normalizedName" : "EmptyMatcher",
        "name" : "EmptyMatcher",
        "htmlId" : "sec-emptymatcher",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1084,
    [
      "Record[OrdinaryObject].SetPrototypeOf",
      4,
      [
        [
          "O",
          false,
          "Record[OrdinaryObject]"
        ],
        [
          "V",
          false,
          "Record[Object] | Null"
        ]
      ],
      "\n        1. Return OrdinarySetPrototypeOf(_O_, _V_).\n      ",
      {
        "normalizedName" : "Record[OrdinaryObject].SetPrototypeOf",
        "name" : "Record[OrdinaryObject].SetPrototypeOf",
        "htmlId" : "sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "OrdinaryObject",
          "[[SetPrototypeOf]]"
        ]
      }
    ]
  ],
  [
    1459,
    [
      "DoWhileStatement[0,0].DoWhileLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[DoWhileStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _V_ be *undefined*.\n          1. Repeat,\n            1. Let _stmtResult_ be Completion(Evaluation of |Statement|).\n            1. If LoopContinues(_stmtResult_, _labelSet_) is *false*, return ? UpdateEmpty(_stmtResult_, _V_).\n            1. If _stmtResult_.[[Value]] is not ~empty~, set _V_ to _stmtResult_.[[Value]].\n            1. Let _exprRef_ be ? Evaluation of |Expression|.\n            1. Let _exprValue_ be ? GetValue(_exprRef_).\n            1. If ToBoolean(_exprValue_) is *false*, return _V_.\n        ",
      {
        "normalizedName" : "DoWhileStatement[0,0].DoWhileLoopEvaluation",
        "name" : "DoWhileStatement[0,0].DoWhileLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-dowhileloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DoWhileLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DoWhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "do"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2045,
    [
      "INTRINSICS.Object.create",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _O_ is not an Object and _O_ is not *null*, throw a *TypeError* exception.\n          1. Let _obj_ be OrdinaryObjectCreate(_O_).\n          1. If _Properties_ is not *undefined*, then\n            1. Return ? ObjectDefineProperties(_obj_, _Properties_).\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.create",
        "name" : "INTRINSICS.Object.create",
        "htmlId" : "sec-object.create",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    99,
    [
      "MakePrivateReference",
      0,
      [
        [
          "baseValue",
          false,
          "ESValue"
        ],
        [
          "privateIdentifier",
          false,
          "String"
        ]
      ],
      "\n          1. Let _privEnv_ be the running execution context's PrivateEnvironment.\n          1. Assert: _privEnv_ is not *null*.\n          1. Let _privateName_ be ResolvePrivateIdentifier(_privEnv_, _privateIdentifier_).\n          1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _privateName_, [[Strict]]: *true*, [[ThisValue]]: ~empty~ }.\n        ",
      {
        "normalizedName" : "MakePrivateReference",
        "name" : "MakePrivateReference",
        "htmlId" : "sec-makeprivatereference",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2818,
    [
      "AsyncGeneratorYield:cont0",
      7,
      [
        [
          "resumptionValue",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _genContext_ be the running execution context.\n          1. Assert: _genContext_ is the execution context of a generator.\n          1. Let _generator_ be the value of the Generator component of _genContext_.\n          1. Assert: GetGeneratorKind() is ~async~.\n          1. Let _completion_ be NormalCompletion(_value_).\n          1. Assert: The execution context stack has at least two elements.\n          1. Let _previousContext_ be the second to top element of the execution context stack.\n          1. Let _previousRealm_ be _previousContext_'s Realm.\n          1. Perform AsyncGeneratorCompleteStep(_generator_, _completion_, *false*, _previousRealm_).\n          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].\n          1. If _queue_ is not empty, then\n            1. NOTE: Execution continues without suspending the generator.\n            1. Let _toYield_ be the first element of _queue_.\n            1. Let _resumptionValue_ be Completion(_toYield_.[[Completion]]).\n            1. Return ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_).\n          1. Else,\n            1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-yield~.\n            1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. Let _callerContext_ be the running execution context.\n            1. Resume _callerContext_ passing *undefined*. If _genContext_ is ever resumed again, let _resumptionValue_ be the Completion Record with which it is resumed.\n            1. Assert: If control reaches here, then _genContext_ is the running execution context again.\n            1. Return ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_).\n        ",
      {
        "normalizedName" : "AsyncGeneratorYield",
        "name" : "AsyncGeneratorYield",
        "htmlId" : "sec-asyncgeneratoryield",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : true,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1180,
    [
      "Record[ModuleNamespaceExoticObject].PreventExtensions",
      4,
      [
        [
          "this",
          false,
          "Record[ModuleNamespaceExoticObject]"
        ]
      ],
      "\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "Record[ModuleNamespaceExoticObject].PreventExtensions",
        "name" : "Record[ModuleNamespaceExoticObject].PreventExtensions",
        "htmlId" : "sec-module-namespace-exotic-objects-preventextensions",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleNamespaceExoticObject",
          "[[PreventExtensions]]"
        ]
      }
    ]
  ],
  [
    1966,
    [
      "ImportsList[1,0].ImportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportsList[1]]"
        ],
        [
          "module",
          false,
          "String"
        ]
      ],
      "\n          1. Let _specs1_ be the ImportEntriesForModule of |ImportsList| with argument _module_.\n          1. Let _specs2_ be the ImportEntriesForModule of |ImportSpecifier| with argument _module_.\n          1. Return the list-concatenation of _specs1_ and _specs2_.\n        ",
      {
        "normalizedName" : "ImportsList[1,0].ImportEntriesForModule",
        "name" : "ImportsList[1,0].ImportEntriesForModule",
        "htmlId" : "sec-static-semantics-importentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ImportsList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportsList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "ImportSpecifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    363,
    [
      "VariableStatement[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[VariableStatement[0]]"
        ]
      ],
      "\n        1. Return BoundNames of |VariableDeclarationList|.\n      ",
      {
        "normalizedName" : "VariableStatement[0,0].VarDeclaredNames",
        "name" : "VariableStatement[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "VariableStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    556,
    [
      "CaseBlock[1,2].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,2].ContainsDuplicateLabels",
        "name" : "CaseBlock[1,2].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    931,
    [
      "PrimaryExpression[10,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[10]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "PrimaryExpression[10,0].AssignmentTargetType",
        "name" : "PrimaryExpression[10,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 10,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RegularExpressionLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1685,
    [
      "OptionalChain[9,0].AllPrivateIdentifiersValid",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[9]]"
        ],
        [
          "names",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If _names_ contains the StringValue of |PrivateIdentifier|, then\n          1. Return AllPrivateIdentifiersValid of |OptionalChain| with argument _names_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "OptionalChain[9,0].AllPrivateIdentifiersValid",
        "name" : "OptionalChain[9,0].AllPrivateIdentifiersValid",
        "htmlId" : "sec-static-semantics-allprivateidentifiersvalid",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AllPrivateIdentifiersValid",
          "type" : "base",
          "prod" : {
            "i" : 9,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "PrivateIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    539,
    [
      "ForStatement[2,1].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[2,1].ContainsDuplicateLabels",
        "name" : "ForStatement[2,1].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2696,
    [
      "GetWaiterList",
      0,
      [
        [
          "block",
          false,
          "Record[SharedDataBlock]"
        ],
        [
          "i",
          false,
          "Unknown[\"NonnegativeIntegerThatIsEvenlyDivisibleBy4\"]"
        ]
      ],
      "\n          1. Assert: _i_ and _i_ + 3 are valid byte offsets within the memory of _block_.\n          1. Return the WaiterList Record that is referenced by the pair (_block_, _i_).\n        ",
      {
        "normalizedName" : "GetWaiterList",
        "name" : "GetWaiterList",
        "htmlId" : "sec-getwaiterlist",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1553,
    [
      "TryStatement[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[1]]"
        ]
      ],
      "\n        1. Let _B_ be Completion(Evaluation of |Block|).\n        1. Let _F_ be Completion(Evaluation of |Finally|).\n        1. If _F_ is a normal completion, set _F_ to _B_.\n        1. Return ? UpdateEmpty(_F_, *undefined*).\n      ",
      {
        "normalizedName" : "TryStatement[1,0].Evaluation",
        "name" : "TryStatement[1,0].Evaluation",
        "htmlId" : "sec-try-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    87,
    [
      "BigInt::bitwiseOR",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. Return BigIntBitwiseOp(`|`, _x_, _y_).\n          ",
      {
        "normalizedName" : "BigInt::bitwiseOR",
        "name" : "BigInt::bitwiseOR",
        "htmlId" : "sec-numeric-types-bigint-bitwiseOR",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1949,
    [
      "FinishLoadingImportedModule",
      0,
      [
        [
          "referrer",
          false,
          "Record[CyclicModuleRecord | RealmRecord | ScriptRecord]"
        ],
        [
          "specifier",
          false,
          "String"
        ],
        [
          "payload",
          false,
          "Record[GraphLoadingStateRecord | PromiseCapabilityRecord]"
        ],
        [
          "result",
          false,
          "Normal[Record[ModuleRecord]] | Throw"
        ]
      ],
      "\n          1. If _result_ is a normal completion, then\n            1. If _referrer_.[[LoadedModules]] contains a Record whose [[Specifier]] is _specifier_, then\n              1. Assert: That Record's [[Module]] is _result_.[[Value]].\n            1. Else,\n              1. Append the Record { [[Specifier]]: _specifier_, [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].\n          1. If _payload_ is a GraphLoadingState Record, then\n            1. Perform ContinueModuleLoading(_payload_, _result_).\n          1. Else,\n            1. Perform ContinueDynamicImport(_payload_, _result_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "FinishLoadingImportedModule",
        "name" : "FinishLoadingImportedModule",
        "htmlId" : "sec-FinishLoadingImportedModule",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2828,
    [
      "AsyncBlockStart:cont1",
      7,
      [
      ],
      "\n          1. Assert: _promiseCapability_ is a PromiseCapability Record.\n          1. Let _runningContext_ be the running execution context.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _promiseCapability_ and _asyncBody_ and performs the following steps when called:\n            1. Let _acAsyncContext_ be the running execution context.\n            1. Let _result_ be Completion(Evaluation of _asyncBody_).\n            1. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.\n            1. Remove _acAsyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. If _result_ is a normal completion, then\n              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).\n            1. Else if _result_ is a return completion, then\n              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] »).\n            1. Else,\n              1. Assert: _result_ is a throw completion.\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] »).\n            1. [id=\"step-asyncblockstart-return-undefined\"] Return ~unused~.\n          1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta>. Let _result_ be the value returned by the resumed computation.\n          1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.\n          1. Assert: _result_ is a normal completion with a value of ~unused~. The possible sources of this value are Await or, if the async function doesn't await anything, step <emu-xref href=\"#step-asyncblockstart-return-undefined\"></emu-xref> above.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncBlockStart",
        "name" : "AsyncBlockStart",
        "htmlId" : "sec-asyncblockstart",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : true,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    482,
    [
      "FunctionStatementList[0,1].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ]
      ],
      "\n        1. Return the TopLevelVarScopedDeclarations of |StatementList|.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,1].VarScopedDeclarations",
        "name" : "FunctionStatementList[0,1].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    203,
    [
      "CreateIterResultObject",
      0,
      [
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "done",
          false,
          "Boolean"
        ]
      ],
      "\n        1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n        1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"value\"*, _value_).\n        1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"done\"*, _done_).\n        1. Return _obj_.\n      ",
      {
        "normalizedName" : "CreateIterResultObject",
        "name" : "CreateIterResultObject",
        "htmlId" : "sec-createiterresultobject",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    671,
    [
      "ForInOfStatement[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForInOfStatement[1,0].ContainsUndefinedContinueTarget",
        "name" : "ForInOfStatement[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1817,
    [
      "DefaultClause[0,1].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "DefaultClause[0,1].HasCallInTailPosition",
        "name" : "DefaultClause[0,1].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1157,
    [
      "MakeArgGetter:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n            1. Let _getterClosure_ be a new Abstract Closure with no parameters that captures _name_ and _env_ and performs the following steps when called:\n              1. Return _env_.GetBindingValue(_name_, *false*).\n            1. Let _getter_ be CreateBuiltinFunction(_getterClosure_, 0, *\"\"*, « »).\n            1. NOTE: _getter_ is never directly accessible to ECMAScript code.\n            1. Return _getter_.\n          ",
      {
        "normalizedName" : "MakeArgGetter",
        "name" : "MakeArgGetter",
        "htmlId" : "sec-makearggetter",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2078,
    [
      "INTRINSICS.Object.prototype.__defineGetter__",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _O_ be ? ToObject(*this* value).\n            1. If IsCallable(_getter_) is *false*, throw a *TypeError* exception.\n            1. Let _desc_ be PropertyDescriptor { [[Get]]: _getter_, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n            1. Let _key_ be ? ToPropertyKey(_P_).\n            1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).\n            1. Return *undefined*.\n          ",
      {
        "normalizedName" : "INTRINSICS.Object.prototype.__defineGetter__",
        "name" : "INTRINSICS.Object.prototype.__defineGetter__",
        "htmlId" : "sec-object.prototype.__defineGetter__",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1321,
    [
      "ArgumentList[1,0].ArgumentListEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArgumentList[1]]"
        ]
      ],
      "\n          1. Let _list_ be a new empty List.\n          1. Let _spreadRef_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _spreadObj_ be ? GetValue(_spreadRef_).\n          1. Let _iteratorRecord_ be ? GetIterator(_spreadObj_, ~sync~).\n          1. Repeat,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is ~done~, return _list_.\n            1. Append _next_ to _list_.\n        ",
      {
        "normalizedName" : "ArgumentList[1,0].ArgumentListEvaluation",
        "name" : "ArgumentList[1,0].ArgumentListEvaluation",
        "htmlId" : "sec-runtime-semantics-argumentlistevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArgumentListEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ArgumentList",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "..."
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1834,
    [
      "EqualityExpression[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "EqualityExpression[2,0].HasCallInTailPosition",
        "name" : "EqualityExpression[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "!="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1913,
    [
      "ParseScript",
      0,
      [
        [
          "sourceText",
          false,
          "Unknown[\"ECMAScriptSourceText\"]"
        ],
        [
          "realm",
          false,
          "Record[RealmRecord] | Undefined"
        ],
        [
          "hostDefined",
          false,
          "Unknown[\"Anything\"]"
        ]
      ],
      "\n        1. Let _script_ be ParseText(_sourceText_, |Script|).\n        1. If _script_ is a List of errors, return _script_.\n        1. Return Script Record { [[Realm]]: _realm_, [[ECMAScriptCode]]: _script_, [[LoadedModules]]: « », [[HostDefined]]: _hostDefined_ }.\n      ",
      {
        "normalizedName" : "ParseScript",
        "name" : "ParseScript",
        "htmlId" : "sec-parse-script",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2310,
    [
      "CharacterClassEscape[3,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[3]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "CharacterClassEscape[3,0].MayContainStrings",
        "name" : "CharacterClassEscape[3,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "S"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    976,
    [
      "BitwiseORExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[BitwiseORExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "BitwiseORExpression[1,0].AssignmentTargetType",
        "name" : "BitwiseORExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BitwiseORExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BitwiseORExpression"
              },
              {
                "type" : "terminal",
                "value" : "|"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseXORExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1844,
    [
      "ShiftExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ShiftExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ShiftExpression[1,0].HasCallInTailPosition",
        "name" : "ShiftExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ShiftExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              },
              {
                "type" : "terminal",
                "value" : "<<"
              },
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    688,
    [
      "CaseClauses[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClauses[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |CaseClauses| with arguments _iterationSet_ and « ».\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of |CaseClause| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "CaseClauses[1,0].ContainsUndefinedContinueTarget",
        "name" : "CaseClauses[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseClauses",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClause"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    903,
    [
      "BindingRestElement[0,0].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingRestElement[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).\n        1. Let _A_ be ! ArrayCreate(0).\n        1. Let _n_ be 0.\n        1. Repeat,\n          1. Let _next_ be ~done~.\n          1. If _iteratorRecord_.[[Done]] is *false*, then\n            1. Set _next_ to ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is ~done~, then\n            1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _A_).\n            1. Return ? InitializeReferencedBinding(_lhs_, _A_).\n          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_).\n          1. Set _n_ to _n_ + 1.\n      ",
      {
        "normalizedName" : "BindingRestElement[0,0].IteratorBindingInitialization",
        "name" : "BindingRestElement[0,0].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BindingRestElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "..."
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    524,
    [
      "DoWhileStatement[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[DoWhileStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "DoWhileStatement[0,0].ContainsDuplicateLabels",
        "name" : "DoWhileStatement[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DoWhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "do"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2194,
    [
      "INTRINSICS.Date.prototype.getMilliseconds",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return msFromTime(LocalTime(_t_)).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getMilliseconds",
        "name" : "INTRINSICS.Date.prototype.getMilliseconds",
        "htmlId" : "sec-date.prototype.getmilliseconds",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    581,
    [
      "Block[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Block[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Block[0,0].ContainsUndefinedBreakTarget",
        "name" : "Block[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Block",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2347,
    [
      "Alternative[1,0].CompileSubpattern",
      2,
      [
        [
          "this",
          false,
          "Ast[Alternative[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Let _m1_ be CompileSubpattern of |Alternative| with arguments _rer_ and _direction_.\n          1. Let _m2_ be CompileSubpattern of |Term| with arguments _rer_ and _direction_.\n          1. Return MatchSequence(_m1_, _m2_, _direction_).\n        ",
      {
        "normalizedName" : "Alternative[1,0].CompileSubpattern",
        "name" : "Alternative[1,0].CompileSubpattern",
        "htmlId" : "sec-compilesubpattern",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileSubpattern",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Alternative",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Alternative"
              },
              {
                "type" : "nonterminal",
                "value" : "Term"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    495,
    [
      "StatementListItem[1,0].TopLevelLexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[1]]"
        ]
      ],
      "\n        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>, then\n          1. Return a new empty List.\n        1. Return the BoundNames of |Declaration|.\n      ",
      {
        "normalizedName" : "StatementListItem[1,0].TopLevelLexicallyDeclaredNames",
        "name" : "StatementListItem[1,0].TopLevelLexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-toplevellexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelLexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Declaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1654,
    [
      "YieldExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[YieldExpression[1]]"
        ]
      ],
      "\n        1. Let _exprRef_ be ? Evaluation of |AssignmentExpression|.\n        1. Let _value_ be ? GetValue(_exprRef_).\n        1. Return ? Yield(_value_).\n      ",
      {
        "normalizedName" : "YieldExpression[1,0].Evaluation",
        "name" : "YieldExpression[1,0].Evaluation",
        "htmlId" : "sec-generator-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "YieldExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "yield"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1412,
    [
      "AssignmentElisionElement[0,0].IteratorDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentElisionElement[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with argument _iteratorRecord_.\n        ",
      {
        "normalizedName" : "AssignmentElisionElement[0,0].IteratorDestructuringAssignmentEvaluation",
        "name" : "AssignmentElisionElement[0,0].IteratorDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AssignmentElisionElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AssignmentElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2215,
    [
      "INTRINSICS.Date.prototype.setTime",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be ? ToNumber(_time_).\n          1. Let _v_ be TimeClip(_t_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setTime",
        "name" : "INTRINSICS.Date.prototype.setTime",
        "htmlId" : "sec-date.prototype.settime",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1517,
    [
      "ReturnStatement[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ReturnStatement[1]]"
        ]
      ],
      "\n        1. Let _exprRef_ be ? Evaluation of |Expression|.\n        1. Let _exprValue_ be ? GetValue(_exprRef_).\n        1. If GetGeneratorKind() is ~async~, set _exprValue_ to ? Await(_exprValue_).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _exprValue_, [[Target]]: ~empty~ }.\n      ",
      {
        "normalizedName" : "ReturnStatement[1,0].Evaluation",
        "name" : "ReturnStatement[1,0].Evaluation",
        "htmlId" : "sec-return-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ReturnStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "return"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2611,
    [
      "INTRINSICS.get Set.prototype.size",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n          1. Let _count_ be 0.\n          1. For each element _e_ of _S_.[[SetData]], do\n            1. If _e_ is not ~empty~, set _count_ to _count_ + 1.\n          1. Return 𝔽(_count_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get Set.prototype.size",
        "name" : "INTRINSICS.get Set.prototype.size",
        "htmlId" : "sec-get-set.prototype.size",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2325,
    [
      "ClassIntersection[1,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassIntersection[1]]"
        ]
      ],
      "\n          1. If MayContainStrings of the |ClassIntersection| is *false*, return *false*.\n          1. If MayContainStrings of the |ClassSetOperand| is *false*, return *false*.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "ClassIntersection[1,0].MayContainStrings",
        "name" : "ClassIntersection[1,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassIntersection",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassIntersection"
              },
              {
                "type" : "terminal",
                "value" : "&&"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassSetOperand"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    759,
    [
      "RelationalExpression[5,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[5]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[5,0].IsFunctionDefinition",
        "name" : "RelationalExpression[5,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "instanceof"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1781,
    [
      "CaseBlock[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CaseBlock[0,0].HasCallInTailPosition",
        "name" : "CaseBlock[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1216,
    [
      "UnicodeEscapeSequence[1,0].IdentifierCodePoint",
      2,
      [
        [
          "this",
          false,
          "Ast[UnicodeEscapeSequence[1]]"
        ]
      ],
      "\n          1. Return the code point whose numeric value is the MV of |CodePoint|.\n        ",
      {
        "normalizedName" : "UnicodeEscapeSequence[1,0].IdentifierCodePoint",
        "name" : "UnicodeEscapeSequence[1,0].IdentifierCodePoint",
        "htmlId" : "sec-identifiercodepoint",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IdentifierCodePoint",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "UnicodeEscapeSequence",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "u{"
              },
              {
                "type" : "nonterminal",
                "value" : "CodePoint"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    891,
    [
      "ArrayBindingPattern[0,2].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Return ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[0,2].IteratorBindingInitialization",
        "name" : "ArrayBindingPattern[0,2].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 2,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2209,
    [
      "INTRINSICS.Date.prototype.setFullYear",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _y_ be ? ToNumber(_year_).\n          1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>; otherwise, set _t_ to LocalTime(_t_).\n          1. If _month_ is not present, let _m_ be MonthFromTime(_t_); otherwise, let _m_ be ? ToNumber(_month_).\n          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise, let _dt_ be ? ToNumber(_date_).\n          1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).\n          1. Let _u_ be TimeClip(UTC(_newDate_)).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setFullYear",
        "name" : "INTRINSICS.Date.prototype.setFullYear",
        "htmlId" : "sec-date.prototype.setfullyear",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    218,
    [
      "VariableDeclaration[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[VariableDeclaration[1]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingPattern|.\n      ",
      {
        "normalizedName" : "VariableDeclaration[1,0].BoundNames",
        "name" : "VariableDeclaration[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "VariableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1126,
    [
      "INTRINSICS.ThrowTypeError",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Throw a *TypeError* exception.\n        ",
      {
        "normalizedName" : "INTRINSICS.ThrowTypeError",
        "name" : "INTRINSICS.ThrowTypeError",
        "htmlId" : "sec-%throwtypeerror%",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2743,
    [
      "INTRINSICS.AsyncFromSyncIteratorPrototype.next",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _O_ be the *this* value.\n            1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.\n            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n            1. Let _syncIteratorRecord_ be _O_.[[SyncIteratorRecord]].\n            1. If _value_ is present, then\n              1. Let _result_ be Completion(IteratorNext(_syncIteratorRecord_, _value_)).\n            1. Else,\n              1. Let _result_ be Completion(IteratorNext(_syncIteratorRecord_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n            1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_).\n          ",
      {
        "normalizedName" : "INTRINSICS.AsyncFromSyncIteratorPrototype.next",
        "name" : "INTRINSICS.AsyncFromSyncIteratorPrototype.next",
        "htmlId" : "sec-%asyncfromsynciteratorprototype%.next",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1448,
    [
      "SingleNameBinding[0,0].KeyedBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[SingleNameBinding[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ],
        [
          "propertyName",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).\n          1. Let _v_ be ? GetV(_value_, _propertyName_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n              1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Set _v_ to ? GetValue(_defaultValue_).\n          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).\n          1. Return ? InitializeReferencedBinding(_lhs_, _v_).\n        ",
      {
        "normalizedName" : "SingleNameBinding[0,0].KeyedBindingInitialization",
        "name" : "SingleNameBinding[0,0].KeyedBindingInitialization",
        "htmlId" : "sec-runtime-semantics-keyedbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "KeyedBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SingleNameBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2490,
    [
      "INTRINSICS.Array.prototype.find",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Value]].\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.find",
        "name" : "INTRINSICS.Array.prototype.find",
        "htmlId" : "sec-array.prototype.find",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    104,
    [
      "ToPropertyDescriptor",
      0,
      [
        [
          "Obj",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If _Obj_ is not an Object, throw a *TypeError* exception.\n          1. Let _desc_ be a new Property Descriptor that initially has no fields.\n          1. Let _hasEnumerable_ be ? HasProperty(_Obj_, *\"enumerable\"*).\n          1. If _hasEnumerable_ is *true*, then\n            1. Let _enumerable_ be ToBoolean(? Get(_Obj_, *\"enumerable\"*)).\n            1. Set _desc_.[[Enumerable]] to _enumerable_.\n          1. Let _hasConfigurable_ be ? HasProperty(_Obj_, *\"configurable\"*).\n          1. If _hasConfigurable_ is *true*, then\n            1. Let _configurable_ be ToBoolean(? Get(_Obj_, *\"configurable\"*)).\n            1. Set _desc_.[[Configurable]] to _configurable_.\n          1. Let _hasValue_ be ? HasProperty(_Obj_, *\"value\"*).\n          1. If _hasValue_ is *true*, then\n            1. Let _value_ be ? Get(_Obj_, *\"value\"*).\n            1. Set _desc_.[[Value]] to _value_.\n          1. Let _hasWritable_ be ? HasProperty(_Obj_, *\"writable\"*).\n          1. If _hasWritable_ is *true*, then\n            1. Let _writable_ be ToBoolean(? Get(_Obj_, *\"writable\"*)).\n            1. Set _desc_.[[Writable]] to _writable_.\n          1. Let _hasGet_ be ? HasProperty(_Obj_, *\"get\"*).\n          1. If _hasGet_ is *true*, then\n            1. Let _getter_ be ? Get(_Obj_, *\"get\"*).\n            1. If IsCallable(_getter_) is *false* and _getter_ is not *undefined*, throw a *TypeError* exception.\n            1. Set _desc_.[[Get]] to _getter_.\n          1. Let _hasSet_ be ? HasProperty(_Obj_, *\"set\"*).\n          1. If _hasSet_ is *true*, then\n            1. Let _setter_ be ? Get(_Obj_, *\"set\"*).\n            1. If IsCallable(_setter_) is *false* and _setter_ is not *undefined*, throw a *TypeError* exception.\n            1. Set _desc_.[[Set]] to _setter_.\n          1. If _desc_ has a [[Get]] field or _desc_ has a [[Set]] field, then\n            1. If _desc_ has a [[Value]] field or _desc_ has a [[Writable]] field, throw a *TypeError* exception.\n          1. Return _desc_.\n        ",
      {
        "normalizedName" : "ToPropertyDescriptor",
        "name" : "ToPropertyDescriptor",
        "htmlId" : "sec-topropertydescriptor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2187,
    [
      "ParseTimeZoneOffsetString",
      0,
      [
        [
          "offsetString",
          false,
          "String"
        ]
      ],
      "\n            1. Let _parseResult_ be ParseText(StringToCodePoints(_offsetString_), |UTCOffset|).\n            1. Assert: _parseResult_ is not a List of errors.\n            1. Assert: _parseResult_ contains a |TemporalSign| Parse Node.\n            1. Let _parsedSign_ be the source text matched by the |TemporalSign| Parse Node contained within _parseResult_.\n            1. If _parsedSign_ is the single code point U+002D (HYPHEN-MINUS) or U+2212 (MINUS SIGN), then\n              1. Let _sign_ be -1.\n            1. Else,\n              1. Let _sign_ be 1.\n            1. NOTE: Applications of StringToNumber below do not lose precision, since each of the parsed values is guaranteed to be a sufficiently short string of decimal digits.\n            1. Assert: _parseResult_ contains an |Hour| Parse Node.\n            1. Let _parsedHours_ be the source text matched by the |Hour| Parse Node contained within _parseResult_.\n            1. Let _hours_ be ℝ(StringToNumber(CodePointsToString(_parsedHours_))).\n            1. If _parseResult_ does not contain a |MinuteSecond| Parse Node, then\n              1. Let _minutes_ be 0.\n            1. Else,\n              1. Let _parsedMinutes_ be the source text matched by the first |MinuteSecond| Parse Node contained within _parseResult_.\n              1. Let _minutes_ be ℝ(StringToNumber(CodePointsToString(_parsedMinutes_))).\n            1. If _parseResult_ does not contain two |MinuteSecond| Parse Nodes, then\n              1. Let _seconds_ be 0.\n            1. Else,\n              1. Let _parsedSeconds_ be the source text matched by the second |MinuteSecond| Parse Node contained within _parseResult_.\n              1. Let _seconds_ be ℝ(StringToNumber(CodePointsToString(_parsedSeconds_))).\n            1. If _parseResult_ does not contain a |TemporalDecimalFraction| Parse Node, then\n              1. Let _nanoseconds_ be 0.\n            1. Else,\n              1. Let _parsedFraction_ be the source text matched by the |TemporalDecimalFraction| Parse Node contained within _parseResult_.\n              1. Let _fraction_ be the string-concatenation of CodePointsToString(_parsedFraction_) and *\"000000000\"*.\n              1. Let _nanosecondsString_ be the substring of _fraction_ from 1 to 10.\n              1. Let _nanoseconds_ be ℝ(StringToNumber(_nanosecondsString_)).\n            1. Return _sign_ × (((_hours_ × 60 + _minutes_) × 60 + _seconds_) × 10<sup>9</sup> + _nanoseconds_).\n          ",
      {
        "normalizedName" : "ParseTimeZoneOffsetString",
        "name" : "ParseTimeZoneOffsetString",
        "htmlId" : "sec-parsetimezoneoffsetstring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1189,
    [
      "Record[ImmutablePrototypeExoticObject].SetPrototypeOf",
      4,
      [
        [
          "O",
          false,
          "Record[ImmutablePrototypeExoticObject]"
        ],
        [
          "V",
          false,
          "Record[Object] | Null"
        ]
      ],
      "\n          1. Return ? SetImmutablePrototype(_O_, _V_).\n        ",
      {
        "normalizedName" : "Record[ImmutablePrototypeExoticObject].SetPrototypeOf",
        "name" : "Record[ImmutablePrototypeExoticObject].SetPrototypeOf",
        "htmlId" : "sec-immutable-prototype-exotic-objects-setprototypeof-v",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ImmutablePrototypeExoticObject",
          "[[SetPrototypeOf]]"
        ]
      }
    ]
  ],
  [
    2110,
    [
      "INTRINSICS.Number.isNaN",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _number_ is not a Number, return *false*.\n          1. If _number_ is *NaN*, return *true*.\n          1. Otherwise, return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Number.isNaN",
        "name" : "INTRINSICS.Number.isNaN",
        "htmlId" : "sec-number.isnan",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1010,
    [
      "Record[DeclarativeEnvironmentRecord].CreateImmutableBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "S",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Assert: _envRec_ does not already have a binding for _N_.\n            1. Create an immutable binding in _envRec_ for _N_ and record that it is uninitialized. If _S_ is *true*, record that the newly created binding is a strict binding.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[DeclarativeEnvironmentRecord].CreateImmutableBinding",
        "name" : "Record[DeclarativeEnvironmentRecord].CreateImmutableBinding",
        "htmlId" : "sec-declarative-environment-records-createimmutablebinding-n-s",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "DeclarativeEnvironmentRecord",
          "CreateImmutableBinding"
        ]
      }
    ]
  ],
  [
    1390,
    [
      "EvaluateStringOrNumericBinaryExpression",
      0,
      [
        [
          "leftOperand",
          false,
          "Ast"
        ],
        [
          "opText",
          false,
          "Unknown[\"SequenceOfUnicodeCodePoint\"]"
        ],
        [
          "rightOperand",
          false,
          "Ast"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of _leftOperand_.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of _rightOperand_.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Return ? ApplyStringOrNumericBinaryOperator(_lval_, _opText_, _rval_).\n      ",
      {
        "normalizedName" : "EvaluateStringOrNumericBinaryExpression",
        "name" : "EvaluateStringOrNumericBinaryExpression",
        "htmlId" : "sec-evaluatestringornumericbinaryexpression",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2305,
    [
      "ClassSetCharacter[2,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSetCharacter[2]]"
        ]
      ],
      "\n          1. Let _ch_ be the code point matched by |ClassSetReservedPunctuator|.\n          1. Return the numeric value of _ch_.\n        ",
      {
        "normalizedName" : "ClassSetCharacter[2,0].CharacterValue",
        "name" : "ClassSetCharacter[2,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ClassSetCharacter",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "\\"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassSetReservedPunctuator"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2342,
    [
      "RegExpIdentifierPart[2,0].RegExpIdentifierCodePoint",
      2,
      [
        [
          "this",
          false,
          "Ast[RegExpIdentifierPart[2]]"
        ]
      ],
      "\n          1. Let _lead_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeLeadSurrogate|.\n          1. Let _trail_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeTrailSurrogate|.\n          1. Return UTF16SurrogatePairToCodePoint(_lead_, _trail_).\n        ",
      {
        "normalizedName" : "RegExpIdentifierPart[2,0].RegExpIdentifierCodePoint",
        "name" : "RegExpIdentifierPart[2,0].RegExpIdentifierCodePoint",
        "htmlId" : "sec-regexpidentifiercodepoint",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "RegExpIdentifierCodePoint",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "RegExpIdentifierPart",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "UnicodeLeadSurrogate"
              },
              {
                "type" : "nonterminal",
                "value" : "UnicodeTrailSurrogate"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1575,
    [
      "BindingRestElement[0,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingRestElement[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "BindingRestElement[0,0].ContainsExpression",
        "name" : "BindingRestElement[0,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BindingRestElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "..."
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1289,
    [
      "TemplateSpans[1,0].SubstitutionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateSpans[1]]"
        ]
      ],
      "\n          1. Return ? SubstitutionEvaluation of |TemplateMiddleList|.\n        ",
      {
        "normalizedName" : "TemplateSpans[1,0].SubstitutionEvaluation",
        "name" : "TemplateSpans[1,0].SubstitutionEvaluation",
        "htmlId" : "sec-runtime-semantics-substitutionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "SubstitutionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TemplateSpans",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateMiddleList"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    368,
    [
      "ForStatement[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,0].VarDeclaredNames",
        "name" : "ForStatement[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    844,
    [
      "ClassTail[0,3].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassTail[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. If _symbol_ is |ClassBody|, return *true*.\n        1. If _symbol_ is |ClassHeritage|, then\n          1. If |ClassHeritage| is present, return *true*; otherwise return *false*.\n        1. If |ClassHeritage| is present, then\n          1. If |ClassHeritage| Contains _symbol_ is *true*, return *true*.\n        1. Return the result of ComputedPropertyContains of |ClassBody| with argument _symbol_.\n      ",
      {
        "normalizedName" : "ClassTail[0,3].Contains",
        "name" : "ClassTail[0,3].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ClassTail",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassHeritage"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2226,
    [
      "INTRINSICS.Date.prototype.toString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _tv_ be _dateObject_.[[DateValue]].\n          1. Return ToDateString(_tv_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.toString",
        "name" : "INTRINSICS.Date.prototype.toString",
        "htmlId" : "sec-date.prototype.tostring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1453,
    [
      "IfStatement[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[1]]"
        ]
      ],
      "\n        1. Let _exprRef_ be ? Evaluation of |Expression|.\n        1. Let _exprValue_ be ToBoolean(? GetValue(_exprRef_)).\n        1. If _exprValue_ is *false*, then\n          1. Return *undefined*.\n        1. Else,\n          1. Let _stmtCompletion_ be Completion(Evaluation of |Statement|).\n          1. Return ? UpdateEmpty(_stmtCompletion_, *undefined*).\n      ",
      {
        "normalizedName" : "IfStatement[1,0].Evaluation",
        "name" : "IfStatement[1,0].Evaluation",
        "htmlId" : "sec-if-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2643,
    [
      "INTRINSICS.ArrayBuffer",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _byteLength_ be ? ToIndex(_length_).\n          1. Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).\n          1. Return ? AllocateArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_).\n        ",
      {
        "normalizedName" : "INTRINSICS.ArrayBuffer",
        "name" : "INTRINSICS.ArrayBuffer",
        "htmlId" : "sec-arraybuffer-length",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1866,
    [
      "CallExpression[5,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[5]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CallExpression[5,0].HasCallInTailPosition",
        "name" : "CallExpression[5,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2071,
    [
      "INTRINSICS.Object.prototype.isPrototypeOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. [id=\"step-isprototypeof-check-object\"] If _V_ is not an Object, return *false*.\n          1. [id=\"step-isprototypeof-toobject\"] Let _O_ be ? ToObject(*this* value).\n          1. Repeat,\n            1. Set _V_ to ? <emu-meta effects=\"user-code\">_V_.[[GetPrototypeOf]]()</emu-meta>.\n            1. If _V_ is *null*, return *false*.\n            1. If SameValue(_O_, _V_) is *true*, return *true*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.prototype.isPrototypeOf",
        "name" : "INTRINSICS.Object.prototype.isPrototypeOf",
        "htmlId" : "sec-object.prototype.isprototypeof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2658,
    [
      "INTRINSICS.get SharedArrayBuffer.prototype.byteLength",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n          1. Let _length_ be ArrayBufferByteLength(_O_, ~seq-cst~).\n          1. Return 𝔽(_length_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get SharedArrayBuffer.prototype.byteLength",
        "name" : "INTRINSICS.get SharedArrayBuffer.prototype.byteLength",
        "htmlId" : "sec-get-sharedarraybuffer.prototype.bytelength",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2775,
    [
      "INTRINSICS.Promise.reject",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _C_ be the *this* value.\n          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n          1. Perform ? Call(_promiseCapability_.[[Reject]], *undefined*, « _r_ »).\n          1. Return _promiseCapability_.[[Promise]].\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.reject",
        "name" : "INTRINSICS.Promise.reject",
        "htmlId" : "sec-promise.reject",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1734,
    [
      "ClassElement[5,0].ClassElementEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[5]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "ClassElement[5,0].ClassElementEvaluation",
        "name" : "ClassElement[5,0].ClassElementEvaluation",
        "htmlId" : "sec-static-semantics-classelementevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassElementEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2792,
    [
      "INTRINSICS.GeneratorFunction.prototype.prototype.throw",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _g_ be the *this* value.\n          1. Let _C_ be ThrowCompletion(_exception_).\n          1. Return ? GeneratorResumeAbrupt(_g_, _C_, ~empty~).\n        ",
      {
        "normalizedName" : "INTRINSICS.GeneratorFunction.prototype.prototype.throw",
        "name" : "INTRINSICS.GeneratorFunction.prototype.prototype.throw",
        "htmlId" : "sec-generator.prototype.throw",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1807,
    [
      "ReturnStatement[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ReturnStatement[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Expression| with argument _call_.\n      ",
      {
        "normalizedName" : "ReturnStatement[1,0].HasCallInTailPosition",
        "name" : "ReturnStatement[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ReturnStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "return"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    771,
    [
      "CoalesceExpression[0,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[CoalesceExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CoalesceExpression[0,0].IsFunctionDefinition",
        "name" : "CoalesceExpression[0,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CoalesceExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoalesceExpressionHead"
              },
              {
                "type" : "terminal",
                "value" : "??"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseORExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1326,
    [
      "SubstitutionTemplate[0,0].ArgumentListEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[SubstitutionTemplate[0]]"
        ]
      ],
      "\n          1. Let _firstSubRef_ be ? Evaluation of |Expression|.\n          1. Let _firstSub_ be ? GetValue(_firstSubRef_).\n          1. Let _restSub_ be ? SubstitutionEvaluation of |TemplateSpans|.\n          1. Assert: _restSub_ is a possibly empty List.\n          1. Return the list-concatenation of « _firstSub_ » and _restSub_.\n        ",
      {
        "normalizedName" : "SubstitutionTemplate[0,0].ArgumentListEvaluation",
        "name" : "SubstitutionTemplate[0,0].ArgumentListEvaluation",
        "htmlId" : "sec-runtime-semantics-argumentlistevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArgumentListEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SubstitutionTemplate",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateHead"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateSpans"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1481,
    [
      "MemberExpression[2,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[2]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "MemberExpression[2,0].IsDestructuring",
        "name" : "MemberExpression[2,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1745,
    [
      "ClassDeclaration[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassDeclaration[0]]"
        ]
      ],
      "\n        1. Perform ? BindingClassDeclarationEvaluation of this |ClassDeclaration|.\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "ClassDeclaration[0,0].Evaluation",
        "name" : "ClassDeclaration[0,0].Evaluation",
        "htmlId" : "sec-class-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    632,
    [
      "Catch[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Catch[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "Catch[0,0].ContainsUndefinedBreakTarget",
        "name" : "Catch[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Catch",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "catch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "CatchParameter"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    781,
    [
      "AssignmentExpression[3,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[3]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[3,0].IsFunctionDefinition",
        "name" : "AssignmentExpression[3,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncArrowFunction"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    23,
    [
      "Number::toString",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "radix",
          true,
          "Math"
        ]
      ],
      "\n            1. If _x_ is *NaN*, return *\"NaN\"*.\n            1. If _x_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *\"0\"*.\n            1. If _x_ < *-0*<sub>𝔽</sub>, return the string-concatenation of *\"-\"* and Number::toString(-_x_, _radix_).\n            1. If _x_ is *+∞*<sub>𝔽</sub>, return *\"Infinity\"*.\n            1. [id=\"step-number-tostring-intermediate-values\"] Let _n_, _k_, and _s_ be integers such that _k_ ≥ 1, _radix_<sup>_k_ - 1</sup> ≤ _s_ < _radix_<sup>_k_</sup>, 𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>) is _x_, and _k_ is as small as possible. Note that _k_ is the number of digits in the representation of _s_ using radix _radix_, that _s_ is not divisible by _radix_, and that the least significant digit of _s_ is not necessarily uniquely determined by these criteria.\n            1. If _radix_ ≠ 10 or _n_ is in the inclusive interval from -5 to 21, then\n              1. If _n_ ≥ _k_, then\n                1. Return the string-concatenation of:\n                  * the code units of the _k_ digits of the representation of _s_ using radix _radix_\n                  * _n_ - _k_ occurrences of the code unit 0x0030 (DIGIT ZERO)\n              1. Else if _n_ > 0, then\n                1. Return the string-concatenation of:\n                  * the code units of the most significant _n_ digits of the representation of _s_ using radix _radix_\n                  * the code unit 0x002E (FULL STOP)\n                  * the code units of the remaining _k_ - _n_ digits of the representation of _s_ using radix _radix_\n              1. Else,\n                1. Assert: _n_ ≤ 0.\n                1. Return the string-concatenation of:\n                  * the code unit 0x0030 (DIGIT ZERO)\n                  * the code unit 0x002E (FULL STOP)\n                  * -_n_ occurrences of the code unit 0x0030 (DIGIT ZERO)\n                  * the code units of the _k_ digits of the representation of _s_ using radix _radix_\n            1. NOTE: In this case, the input will be represented using scientific E notation, such as `1.2e+3`.\n            1. Assert: _radix_ is 10.\n            1. If _n_ < 0, then\n              1. Let _exponentSign_ be the code unit 0x002D (HYPHEN-MINUS).\n            1. Else,\n              1. Let _exponentSign_ be the code unit 0x002B (PLUS SIGN).\n            1. If _k_ = 1, then\n              1. Return the string-concatenation of:\n                * the code unit of the single digit of _s_\n                * the code unit 0x0065 (LATIN SMALL LETTER E)\n                * _exponentSign_\n                * the code units of the decimal representation of abs(_n_ - 1)\n            1. Return the string-concatenation of:\n              * the code unit of the most significant digit of the decimal representation of _s_\n              * the code unit 0x002E (FULL STOP)\n              * the code units of the remaining _k_ - 1 digits of the decimal representation of _s_\n              * the code unit 0x0065 (LATIN SMALL LETTER E)\n              * _exponentSign_\n              * the code units of the decimal representation of abs(_n_ - 1)\n          ",
      {
        "normalizedName" : "Number::toString",
        "name" : "Number::toString",
        "htmlId" : "sec-numeric-types-number-tostring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2394,
    [
      "ClassEscape[0,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassEscape[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _cv_ be the CharacterValue of this |ClassEscape|.\n          1. Let _c_ be the character whose character value is _cv_.\n          1. Return the CharSet containing the single character _c_.\n        ",
      {
        "normalizedName" : "ClassEscape[0,0].CompileToCharSet",
        "name" : "ClassEscape[0,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "b"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1276,
    [
      "PropertyDefinition[2,0].PropertyDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyDefinition[2]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Let _propKey_ be ? Evaluation of |PropertyName|.\n          1. If this |PropertyDefinition| is contained within a |Script| that is being evaluated for JSON.parse (see step <emu-xref href=\"#step-json-parse-eval\"></emu-xref> of <emu-xref href=\"#sec-json.parse\">JSON.parse</emu-xref>), then\n            1. Let _isProtoSetter_ be *false*.\n          1. Else if _propKey_ is *\"__proto__\"* and IsComputedPropertyKey of |PropertyName| is *false*, then\n            1. Let _isProtoSetter_ be *true*.\n          1. Else,\n            1. Let _isProtoSetter_ be *false*.\n          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and _isProtoSetter_ is *false*, then\n            1. Let _propValue_ be ? NamedEvaluation of |AssignmentExpression| with argument _propKey_.\n          1. Else,\n            1. Let _exprValueRef_ be ? Evaluation of |AssignmentExpression|.\n            1. Let _propValue_ be ? GetValue(_exprValueRef_).\n          1. If _isProtoSetter_ is *true*, then\n            1. If _propValue_ is an Object or _propValue_ is *null*, then\n              1. Perform ! <emu-meta effects=\"user-code\">_object_.[[SetPrototypeOf]]</emu-meta>(_propValue_).\n            1. Return ~unused~.\n          1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.\n          1. Perform ! CreateDataPropertyOrThrow(_object_, _propKey_, _propValue_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "PropertyDefinition[2,0].PropertyDefinitionEvaluation",
        "name" : "PropertyDefinition[2,0].PropertyDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-propertydefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "PropertyDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PropertyName"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2591,
    [
      "INTRINSICS.Map.prototype.delete",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, then\n              1. Set _p_.[[Key]] to ~empty~.\n              1. Set _p_.[[Value]] to ~empty~.\n              1. Return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Map.prototype.delete",
        "name" : "INTRINSICS.Map.prototype.delete",
        "htmlId" : "sec-map.prototype.delete",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1590,
    [
      "FormalParameterList[1,0].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameterList[1]]"
        ]
      ],
      "\n        1. If IsSimpleParameterList of |FormalParameterList| is *false*, return *false*.\n        1. Return IsSimpleParameterList of |FormalParameter|.\n      ",
      {
        "normalizedName" : "FormalParameterList[1,0].IsSimpleParameterList",
        "name" : "FormalParameterList[1,0].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FormalParameterList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameterList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1646,
    [
      "GeneratorBody[0,0].EvaluateGeneratorBody",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).\n        1. Let _G_ be ? OrdinaryCreateFromConstructor(_functionObject_, *\"%GeneratorFunction.prototype.prototype%\"*, « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] »).\n        1. Set _G_.[[GeneratorBrand]] to ~empty~.\n        1. Set _G_.[[GeneratorState]] to *undefined*.\n        1. Perform GeneratorStart(_G_, |FunctionBody|).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _G_, [[Target]]: ~empty~ }.\n      ",
      {
        "normalizedName" : "GeneratorBody[0,0].EvaluateGeneratorBody",
        "name" : "GeneratorBody[0,0].EvaluateGeneratorBody",
        "htmlId" : "sec-runtime-semantics-evaluategeneratorbody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateGeneratorBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2443,
    [
      "RegExpInitialize",
      0,
      [
        [
          "obj",
          false,
          "Record[Object]"
        ],
        [
          "pattern",
          false,
          "ESValue"
        ],
        [
          "flags",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If _pattern_ is *undefined*, let _P_ be the empty String.\n          1. Else, let _P_ be ? ToString(_pattern_).\n          1. If _flags_ is *undefined*, let _F_ be the empty String.\n          1. Else, let _F_ be ? ToString(_flags_).\n          1. If _F_ contains any code unit other than *\"d\"*, *\"g\"*, *\"i\"*, *\"m\"*, *\"s\"*, *\"u\"*, *\"v\"*, or *\"y\"*, or if _F_ contains any code unit more than once, throw a *SyntaxError* exception.\n          1. If _F_ contains *\"i\"*, let _i_ be *true*; else let _i_ be *false*.\n          1. If _F_ contains *\"m\"*, let _m_ be *true*; else let _m_ be *false*.\n          1. If _F_ contains *\"s\"*, let _s_ be *true*; else let _s_ be *false*.\n          1. If _F_ contains *\"u\"*, let _u_ be *true*; else let _u_ be *false*.\n          1. If _F_ contains *\"v\"*, let _v_ be *true*; else let _v_ be *false*.\n          1. If _u_ is *true* or _v_ is *true*, then\n            1. Let _patternText_ be StringToCodePoints(_P_).\n          1. Else,\n            1. Let _patternText_ be the result of interpreting each of _P_'s 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.\n          1. Let _parseResult_ be ParsePattern(_patternText_, _u_, _v_).\n          1. If _parseResult_ is a non-empty List of *SyntaxError* objects, throw a *SyntaxError* exception.\n          1. Assert: _parseResult_ is a |Pattern| Parse Node.\n          1. Set _obj_.[[OriginalSource]] to _P_.\n          1. Set _obj_.[[OriginalFlags]] to _F_.\n          1. Let _capturingGroupsCount_ be CountLeftCapturingParensWithin(_parseResult_).\n          1. Let _rer_ be the RegExp Record { [[IgnoreCase]]: _i_, [[Multiline]]: _m_, [[DotAll]]: _s_, [[Unicode]]: _u_, [[UnicodeSets]]: _v_, [[CapturingGroupsCount]]: _capturingGroupsCount_ }.\n          1. Set _obj_.[[RegExpRecord]] to _rer_.\n          1. Set _obj_.[[RegExpMatcher]] to CompilePattern of _parseResult_ with argument _rer_.\n          1. Perform ? Set(_obj_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "RegExpInitialize",
        "name" : "RegExpInitialize",
        "htmlId" : "sec-regexpinitialize",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    588,
    [
      "ForStatement[0,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,0].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[0,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2707,
    [
      "EnqueueAtomicsWaitAsyncTimeoutJob:clo0",
      6,
      [
      ],
      "\n          1. Let _timeoutJob_ be a new Job Abstract Closure with no parameters that captures _WL_ and _waiterRecord_ and performs the following steps when called:\n            1. Perform EnterCriticalSection(_WL_).\n            1. If _WL_.[[Waiters]] contains _waiterRecord_, then\n              1. Let _timeOfJobExecution_ be the time value (UTC) identifying the current time.\n              1. Assert: ℝ(_timeOfJobExecution_) ≥ _waiterRecord_.[[TimeoutTime]] (ignoring potential non-monotonicity of time values).\n              1. Set _waiterRecord_.[[Result]] to *\"timed-out\"*.\n              1. Perform RemoveWaiter(_WL_, _waiterRecord_).\n              1. Perform NotifyWaiter(_WL_, _waiterRecord_).\n            1. Perform LeaveCriticalSection(_WL_).\n            1. Return ~unused~.\n          1. Let _now_ be the time value (UTC) identifying the current time.\n          1. Let _currentRealm_ be the current Realm Record.\n          1. Perform HostEnqueueTimeoutJob(_timeoutJob_, _currentRealm_, 𝔽(_waiterRecord_.[[TimeoutTime]]) - _now_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "EnqueueAtomicsWaitAsyncTimeoutJob",
        "name" : "EnqueueAtomicsWaitAsyncTimeoutJob",
        "htmlId" : "sec-enqueueatomicswaitasynctimeoutjob",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1253,
    [
      "ElementList[2,1].ArrayAccumulation",
      2,
      [
        [
          "this",
          false,
          "Ast[ElementList[2]]"
        ],
        [
          "array",
          false,
          "Record[Array]"
        ],
        [
          "nextIndex",
          false,
          "Int"
        ]
      ],
      "\n          1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Let _initResult_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _initValue_ be ? GetValue(_initResult_).\n          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).\n          1. Return _nextIndex_ + 1.\n        ",
      {
        "normalizedName" : "ElementList[2,1].ArrayAccumulation",
        "name" : "ElementList[2,1].ArrayAccumulation",
        "htmlId" : "sec-runtime-semantics-arrayaccumulation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArrayAccumulation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    699,
    [
      "FunctionStatementList[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionStatementList[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionStatementList[0,0].ContainsUndefinedContinueTarget",
        "name" : "FunctionStatementList[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    961,
    [
      "ShiftExpression[2,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[ShiftExpression[2]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "ShiftExpression[2,0].AssignmentTargetType",
        "name" : "ShiftExpression[2,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ShiftExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              },
              {
                "type" : "terminal",
                "value" : ">>"
              },
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    813,
    [
      "NewExpression[1,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[NewExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "NewExpression[1,0].IsIdentifierRef",
        "name" : "NewExpression[1,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "NewExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "nonterminal",
                "value" : "NewExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1385,
    [
      "AssignmentExpression[5,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[5]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |LeftHandSideExpression|.\n        1. [id=\"step-assignmentexpression-evaluation-compound-getvalue\"] Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _assignmentOpText_ be the source text matched by |AssignmentOperator|.\n        1. Let _opText_ be the sequence of Unicode code points associated with _assignmentOpText_ in the following table:\n          <figure>\n            <!-- emu-format ignore -->\n            <table class=\"lightweight-table\">\n              <tbody><tr><th> _assignmentOpText_ </th><th> _opText_       </th></tr>\n              <tr><td> `**=`              </td><td> `**`           </td></tr>\n              <tr><td> `*=`               </td><td> `*`            </td></tr>\n              <tr><td> `/=`               </td><td> `/`            </td></tr>\n              <tr><td> `%=`               </td><td> `%`            </td></tr>\n              <tr><td> `+=`               </td><td> `+`            </td></tr>\n              <tr><td> `-=`               </td><td> `-`            </td></tr>\n              <tr><td> `<<=`        </td><td> `<<`     </td></tr>\n              <tr><td> `>>=`        </td><td> `>>`     </td></tr>\n              <tr><td> `>>>=`    </td><td> `>>>` </td></tr>\n              <tr><td> `&=`           </td><td> `&`        </td></tr>\n              <tr><td> `^=`               </td><td> `^`            </td></tr>\n              <tr><td> `|=`               </td><td> `|`            </td></tr>\n            </tbody></table>\n          </figure>\n        1. Let _r_ be ? ApplyStringOrNumericBinaryOperator(_lval_, _opText_, _rval_).\n        1. [id=\"step-assignmentexpression-evaluation-compound-putvalue\"] Perform ? PutValue(_lref_, _r_).\n        1. Return _r_.\n      ",
      {
        "normalizedName" : "AssignmentExpression[5,0].Evaluation",
        "name" : "AssignmentExpression[5,0].Evaluation",
        "htmlId" : "sec-assignment-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentOperator"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2594,
    [
      "INTRINSICS.Map.prototype.get",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Map.prototype.get",
        "name" : "INTRINSICS.Map.prototype.get",
        "htmlId" : "sec-map.prototype.get",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1721,
    [
      "MethodDefinition[5,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[5]]"
        ]
      ],
      "\n        1. Return ContainsArguments of |ClassElementName|.\n      ",
      {
        "normalizedName" : "MethodDefinition[5,0].ContainsArguments",
        "name" : "MethodDefinition[5,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "set"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "PropertySetParameterList"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    963,
    [
      "RelationalExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "RelationalExpression[1,0].AssignmentTargetType",
        "name" : "RelationalExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "<"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    517,
    [
      "Statement[11,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[11]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[11,0].ContainsDuplicateLabels",
        "name" : "Statement[11,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 11,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ThrowStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2167,
    [
      "MonthFromTime",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. Let _inLeapYear_ be InLeapYear(_t_).\n          1. Let _dayWithinYear_ be DayWithinYear(_t_).\n          1. If _dayWithinYear_ < *31*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *59*<sub>𝔽</sub> + _inLeapYear_, return *1*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *90*<sub>𝔽</sub> + _inLeapYear_, return *2*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *120*<sub>𝔽</sub> + _inLeapYear_, return *3*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *151*<sub>𝔽</sub> + _inLeapYear_, return *4*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *181*<sub>𝔽</sub> + _inLeapYear_, return *5*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *212*<sub>𝔽</sub> + _inLeapYear_, return *6*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *243*<sub>𝔽</sub> + _inLeapYear_, return *7*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *273*<sub>𝔽</sub> + _inLeapYear_, return *8*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *304*<sub>𝔽</sub> + _inLeapYear_, return *9*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *334*<sub>𝔽</sub> + _inLeapYear_, return *10*<sub>𝔽</sub>.\n          1. Assert: _dayWithinYear_ < *365*<sub>𝔽</sub> + _inLeapYear_.\n          1. Return *11*<sub>𝔽</sub>.\n        ",
      {
        "normalizedName" : "MonthFromTime",
        "name" : "MonthFromTime",
        "htmlId" : "sec-monthfromtime",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2273,
    [
      "INTRINSICS.String.prototype.trimStart",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Return ? TrimString(_S_, ~start~).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.trimStart",
        "name" : "INTRINSICS.String.prototype.trimStart",
        "htmlId" : "sec-string.prototype.trimstart",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2174,
    [
      "GetUTCEpochNanoseconds",
      0,
      [
        [
          "year",
          false,
          "Int"
        ],
        [
          "month",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom1To12\"]"
        ],
        [
          "day",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom1To31\"]"
        ],
        [
          "hour",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom0To23\"]"
        ],
        [
          "minute",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom0To59\"]"
        ],
        [
          "second",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom0To59\"]"
        ],
        [
          "millisecond",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom0To999\"]"
        ],
        [
          "microsecond",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom0To999\"]"
        ],
        [
          "nanosecond",
          false,
          "Unknown[\"IntegerInTheInclusiveIntervalFrom0To999\"]"
        ]
      ],
      "\n          1. Let _date_ be MakeDay(𝔽(_year_), 𝔽(_month_ - 1), 𝔽(_day_)).\n          1. Let _time_ be MakeTime(𝔽(_hour_), 𝔽(_minute_), 𝔽(_second_), 𝔽(_millisecond_)).\n          1. Let _ms_ be MakeDate(_date_, _time_).\n          1. Assert: _ms_ is an integral Number.\n          1. Return ℤ(ℝ(_ms_) × 10<sup>6</sup> + _microsecond_ × 10<sup>3</sup> + _nanosecond_).\n        ",
      {
        "normalizedName" : "GetUTCEpochNanoseconds",
        "name" : "GetUTCEpochNanoseconds",
        "htmlId" : "sec-getutcepochnanoseconds",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2283,
    [
      "ClassAtom[0,0].IsCharacterClass",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassAtom[0]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ClassAtom[0,0].IsCharacterClass",
        "name" : "ClassAtom[0,0].IsCharacterClass",
        "htmlId" : "sec-patterns-static-semantics-is-character-class",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsCharacterClass",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassAtom",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "-"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2389,
    [
      "NonemptyClassRanges[2,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[NonemptyClassRanges[2]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of the first |ClassAtom| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of the second |ClassAtom| with argument _rer_.\n          1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.\n          1. Let _D_ be CharacterRange(_A_, _B_).\n          1. Return the union of _D_ and _C_.\n        ",
      {
        "normalizedName" : "NonemptyClassRanges[2,0].CompileToCharSet",
        "name" : "NonemptyClassRanges[2,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "NonemptyClassRanges",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassAtom"
              },
              {
                "type" : "terminal",
                "value" : "-"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassAtom"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassContents"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    319,
    [
      "StatementList[1,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be LexicallyScopedDeclarations of |StatementList|.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |StatementListItem|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "StatementList[1,0].LexicallyScopedDeclarations",
        "name" : "StatementList[1,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1476,
    [
      "ForStatement[2,3].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n          1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.\n          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.\n          1. For each element _dn_ of _boundNames_, do\n            1. If _isConst_ is *true*, then\n              1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).\n            1. Else,\n              1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).\n          1. Set the running execution context's LexicalEnvironment to _loopEnv_.\n          1. Let _forDcl_ be Completion(Evaluation of |LexicalDeclaration|).\n          1. If _forDcl_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n            1. Return ? _forDcl_.\n          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be a new empty List.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).\n          1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n          1. Return ? _bodyResult_.\n        ",
      {
        "normalizedName" : "ForStatement[2,3].ForLoopEvaluation",
        "name" : "ForStatement[2,3].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1341,
    [
      "ContinueDynamicImport:clo1",
      6,
      [
      ],
      "\n            1. If _moduleCompletion_ is an abrupt completion, then\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).\n              1. Return ~unused~.\n            1. Let _module_ be _moduleCompletion_.[[Value]].\n            1. Let _loadPromise_ be _module_.LoadRequestedModules().\n            1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _reason_ »).\n              1. Return ~unused~.\n            1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n            1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, and _onRejected_ and performs the following steps when called:\n              1. Let _link_ be Completion(_module_.Link()).\n              1. If _link_ is an abrupt completion, then\n                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _link_.[[Value]] »).\n                1. Return ~unused~.\n              1. Let _evaluatePromise_ be _module_.Evaluate().\n              1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and _promiseCapability_ and performs the following steps when called:\n                1. Let _namespace_ be GetModuleNamespace(_module_).\n                1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _namespace_ »).\n                1. Return ~unused~.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *\"\"*, « »).\n              1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).\n              1. Return ~unused~.\n            1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, 0, *\"\"*, « »).\n            1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "ContinueDynamicImport",
        "name" : "ContinueDynamicImport",
        "htmlId" : "sec-ContinueDynamicImport",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    896,
    [
      "ArrayBindingPattern[2,3].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[2]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.\n        1. If |Elision| is present, then\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[2,3].IteratorBindingInitialization",
        "name" : "ArrayBindingPattern[2,3].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 3,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2098,
    [
      "INTRINSICS.Symbol.prototype.valueOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return ? ThisSymbolValue(*this* value).\n        ",
      {
        "normalizedName" : "INTRINSICS.Symbol.prototype.valueOf",
        "name" : "INTRINSICS.Symbol.prototype.valueOf",
        "htmlId" : "sec-symbol.prototype.valueof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    748,
    [
      "ExponentiationExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[ExponentiationExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ExponentiationExpression[1,0].IsFunctionDefinition",
        "name" : "ExponentiationExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExponentiationExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "UpdateExpression"
              },
              {
                "type" : "terminal",
                "value" : "**"
              },
              {
                "type" : "nonterminal",
                "value" : "ExponentiationExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1674,
    [
      "ClassElement[3,0].IsStatic",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[3]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "ClassElement[3,0].IsStatic",
        "name" : "ClassElement[3,0].IsStatic",
        "htmlId" : "sec-static-semantics-isstatic",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsStatic",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "static"
              },
              {
                "type" : "nonterminal",
                "value" : "FieldDefinition"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2855,
    [
      "HostEventSet",
      0,
      [
        [
          "execution",
          false,
          "Unknown[\"CandidateExecution\"]"
        ]
      ],
      "\n        1. Let _events_ be an empty Set.\n        1. For each event _E_ of EventSet(_execution_), do\n          1. If _E_ is not in SharedDataBlockEventSet(_execution_), add _E_ to _events_.\n        1. Return _events_.\n      ",
      {
        "normalizedName" : "HostEventSet",
        "name" : "HostEventSet",
        "htmlId" : "sec-hosteventset",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1639,
    [
      "MethodDefinition[0,0].DefineMethod",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[0]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ],
        [
          "functionPrototype",
          true,
          "Record[Object]"
        ]
      ],
      "\n        1. Let _propKey_ be ? Evaluation of |ClassElementName|.\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. If _functionPrototype_ is present, then\n          1. Let _prototype_ be _functionPrototype_.\n        1. Else,\n          1. Let _prototype_ be %Function.prototype%.\n        1. Let _sourceText_ be the source text matched by |MethodDefinition|.\n        1. Let _closure_ be OrdinaryFunctionCreate(_prototype_, _sourceText_, |UniqueFormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform MakeMethod(_closure_, _object_).\n        1. Return the Record { [[Key]]: _propKey_, [[Closure]]: _closure_ }.\n      ",
      {
        "normalizedName" : "MethodDefinition[0,0].DefineMethod",
        "name" : "MethodDefinition[0,0].DefineMethod",
        "htmlId" : "sec-runtime-semantics-definemethod",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DefineMethod",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2853,
    [
      "EventSet",
      0,
      [
        [
          "execution",
          false,
          "Unknown[\"CandidateExecution\"]"
        ]
      ],
      "\n        1. Let _events_ be an empty Set.\n        1. For each Agent Events Record _aer_ of _execution_.[[EventsRecords]], do\n          1. For each event _E_ of _aer_.[[EventList]], do\n            1. Add _E_ to _events_.\n        1. Return _events_.\n      ",
      {
        "normalizedName" : "EventSet",
        "name" : "EventSet",
        "htmlId" : "sec-event-set",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2251,
    [
      "INTRINSICS.String.prototype.matchAll",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. If _regexp_ is neither *undefined* nor *null*, then\n            1. Let _isRegExp_ be ? IsRegExp(_regexp_).\n            1. If _isRegExp_ is *true*, then\n              1. Let _flags_ be ? Get(_regexp_, *\"flags\"*).\n              1. Perform ? RequireObjectCoercible(_flags_).\n              1. If ? ToString(_flags_) does not contain *\"g\"*, throw a *TypeError* exception.\n            1. Let _matcher_ be ? GetMethod(_regexp_, @@matchAll).\n            1. If _matcher_ is not *undefined*, then\n              1. Return ? Call(_matcher_, _regexp_, « _O_ »).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _rx_ be ? RegExpCreate(_regexp_, *\"g\"*).\n          1. Return ? Invoke(_rx_, @@matchAll, « _S_ »).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.matchAll",
        "name" : "INTRINSICS.String.prototype.matchAll",
        "htmlId" : "sec-string.prototype.matchall",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2290,
    [
      "ClassAtomNoDash[0,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassAtomNoDash[0]]"
        ]
      ],
      "\n          1. Let _ch_ be the code point matched by |SourceCharacter|.\n          1. Return the numeric value of _ch_.\n        ",
      {
        "normalizedName" : "ClassAtomNoDash[0,0].CharacterValue",
        "name" : "ClassAtomNoDash[0,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassAtomNoDash",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "SourceCharacter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    40,
    [
      "__REMOVE_ELEM__",
      8,
      [
        [
          "elem",
          false,
          "Any"
        ],
        [
          "list",
          false,
          "List"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1903,
    [
      "OptionalChain[7,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[7]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "OptionalChain[7,0].HasCallInTailPosition",
        "name" : "OptionalChain[7,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2135,
    [
      "INTRINSICS.Math.clz32",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToUint32(_x_).\n          1. Let _p_ be the number of leading zero bits in the unsigned 32-bit binary representation of _n_.\n          1. Return 𝔽(_p_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.clz32",
        "name" : "INTRINSICS.Math.clz32",
        "htmlId" : "sec-math.clz32",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2406,
    [
      "UnicodePropertyValueExpression[1,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[UnicodePropertyValueExpression[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _s_ be the source text matched by |LoneUnicodePropertyNameOrValue|.\n          1. If UnicodeMatchPropertyValue(`General_Category`, _s_) is a Unicode property value or property value alias for the General_Category (gc) property listed in <a href=\"https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt\"><code>PropertyValueAliases.txt</code></a>, then\n            1. Return the CharSet containing all Unicode code points whose character database definition includes the property “General_Category” with value _s_.\n          1. Let _p_ be UnicodeMatchProperty(_rer_, _s_).\n          1. Assert: _p_ is a binary Unicode property or binary property alias listed in the “<emu-not-ref>Property name</emu-not-ref> and aliases” column of <emu-xref href=\"#table-binary-unicode-properties\"></emu-xref>, or a binary Unicode property of strings listed in the “<emu-not-ref>Property name</emu-not-ref>” column of <emu-xref href=\"#table-binary-unicode-properties-of-strings\"></emu-xref>.\n          1. Let _A_ be the CharSet containing all CharSetElements whose character database definition includes the property _p_ with value “True”.\n          1. Return MaybeSimpleCaseFolding(_rer_, _A_).\n        ",
      {
        "normalizedName" : "UnicodePropertyValueExpression[1,0].CompileToCharSet",
        "name" : "UnicodePropertyValueExpression[1,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "UnicodePropertyValueExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LoneUnicodePropertyNameOrValue"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2554,
    [
      "INTRINSICS.TypedArray.prototype.map",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_len_) »).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Let _mappedValue_ be ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n            1. Perform ? Set(_A_, _Pk_, _mappedValue_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.map",
        "name" : "INTRINSICS.TypedArray.prototype.map",
        "htmlId" : "sec-%typedarray%.prototype.map",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    304,
    [
      "LabelledStatement[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledStatement[0]]"
        ]
      ],
      "\n        1. Return the LexicallyDeclaredNames of |LabelledItem|.\n      ",
      {
        "normalizedName" : "LabelledStatement[0,0].LexicallyDeclaredNames",
        "name" : "LabelledStatement[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelledItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1062,
    [
      "CreateRealm",
      0,
      [
      ],
      "\n        1. Let _realmRec_ be a new Realm Record.\n        1. Perform CreateIntrinsics(_realmRec_).\n        1. Set _realmRec_.[[AgentSignifier]] to AgentSignifier().\n        1. Set _realmRec_.[[GlobalObject]] to *undefined*.\n        1. Set _realmRec_.[[GlobalEnv]] to *undefined*.\n        1. Set _realmRec_.[[TemplateMap]] to a new empty List.\n        1. Return _realmRec_.\n      ",
      {
        "normalizedName" : "CreateRealm",
        "name" : "CreateRealm",
        "htmlId" : "sec-createrealm",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2532,
    [
      "INTRINSICS.TypedArray.of",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _len_ be the number of elements in _items_.\n          1. Let _C_ be the *this* value.\n          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n          1. Let _newObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _kValue_ be _items_[_k_].\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Perform ? Set(_newObj_, _Pk_, _kValue_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _newObj_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.of",
        "name" : "INTRINSICS.TypedArray.of",
        "htmlId" : "sec-%typedarray%.of",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    26,
    [
      "StringToBigInt",
      0,
      [
        [
          "str",
          false,
          "String"
        ]
      ],
      "\n        1. Let _text_ be StringToCodePoints(_str_).\n        1. Let _literal_ be ParseText(_text_, |StringIntegerLiteral|).\n        1. If _literal_ is a List of errors, return *undefined*.\n        1. Let _mv_ be the MV of _literal_.\n        1. Assert: _mv_ is an integer.\n        1. Return ℤ(_mv_).\n      ",
      {
        "normalizedName" : "StringToBigInt",
        "name" : "StringToBigInt",
        "htmlId" : "sec-stringtobigint",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1508,
    [
      "BindingIdentifier[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingIdentifier[2]]"
        ]
      ],
      "\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Return ? ResolveBinding(_bindingId_).\n        ",
      {
        "normalizedName" : "BindingIdentifier[2,0].Evaluation",
        "name" : "BindingIdentifier[2,0].Evaluation",
        "htmlId" : "sec-for-in-and-for-of-statements-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "BindingIdentifier",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "await"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    946,
    [
      "UpdateExpression[3,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[3]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "UpdateExpression[3,0].AssignmentTargetType",
        "name" : "UpdateExpression[3,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "++"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1101,
    [
      "OrdinarySet",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _ownDesc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. Return ? OrdinarySetWithOwnDescriptor(_O_, _P_, _V_, _Receiver_, _ownDesc_).\n        ",
      {
        "normalizedName" : "OrdinarySet",
        "name" : "OrdinarySet",
        "htmlId" : "sec-ordinaryset",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    258,
    [
      "NamedImports[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[NamedImports[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "NamedImports[0,0].BoundNames",
        "name" : "NamedImports[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "NamedImports",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    158,
    [
      "IsLooselyEqual",
      0,
      [
        [
          "x",
          false,
          "ESValue"
        ],
        [
          "y",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If Type(_x_) is Type(_y_), then\n          1. Return IsStrictlyEqual(_x_, _y_).\n        1. If _x_ is *null* and _y_ is *undefined*, return *true*.\n        1. If _x_ is *undefined* and _y_ is *null*, return *true*.\n        1. [id=\"step-abstract-equality-comparison-web-compat-insertion-point\"] NOTE: This step is replaced in section <emu-xref href=\"#sec-IsHTMLDDA-internal-slot-aec\"></emu-xref>.\n        1. If _x_ is a Number and _y_ is a String, return ! IsLooselyEqual(_x_, ! ToNumber(_y_)).\n        1. If _x_ is a String and _y_ is a Number, return ! IsLooselyEqual(! ToNumber(_x_), _y_).\n        1. If _x_ is a BigInt and _y_ is a String, then\n          1. Let _n_ be StringToBigInt(_y_).\n          1. If _n_ is *undefined*, return *false*.\n          1. Return ! IsLooselyEqual(_x_, _n_).\n        1. If _x_ is a String and _y_ is a BigInt, return ! IsLooselyEqual(_y_, _x_).\n        1. If _x_ is a Boolean, return ! IsLooselyEqual(! ToNumber(_x_), _y_).\n        1. If _y_ is a Boolean, return ! IsLooselyEqual(_x_, ! ToNumber(_y_)).\n        1. If _x_ is either a String, a Number, a BigInt, or a Symbol and _y_ is an Object, return ! IsLooselyEqual(_x_, ? ToPrimitive(_y_)).\n        1. If _x_ is an Object and _y_ is either a String, a Number, a BigInt, or a Symbol, return ! IsLooselyEqual(? ToPrimitive(_x_), _y_).\n        1. If _x_ is a BigInt and _y_ is a Number, or if _x_ is a Number and _y_ is a BigInt, then\n          1. If _x_ is not finite or _y_ is not finite, return *false*.\n          1. If ℝ(_x_) = ℝ(_y_), return *true*; otherwise return *false*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "IsLooselyEqual",
        "name" : "IsLooselyEqual",
        "htmlId" : "sec-islooselyequal",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    652,
    [
      "DoWhileStatement[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[DoWhileStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "DoWhileStatement[0,0].ContainsUndefinedContinueTarget",
        "name" : "DoWhileStatement[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DoWhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "do"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    351,
    [
      "ExportDeclaration[5,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[5]]"
        ]
      ],
      "\n        1. Return a List whose sole element is |ClassDeclaration|.\n      ",
      {
        "normalizedName" : "ExportDeclaration[5,0].LexicallyScopedDeclarations",
        "name" : "ExportDeclaration[5,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2823,
    [
      "AsyncGeneratorDrainQueue",
      0,
      [
        [
          "generator",
          false,
          "Record[AsyncGenerator]"
        ]
      ],
      "\n          1. Assert: _generator_.[[AsyncGeneratorState]] is ~completed~.\n          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].\n          1. If _queue_ is empty, return ~unused~.\n          1. Let _done_ be *false*.\n          1. Repeat, while _done_ is *false*,\n            1. Let _next_ be the first element of _queue_.\n            1. Let _completion_ be Completion(_next_.[[Completion]]).\n            1. If _completion_ is a return completion, then\n              1. Set _generator_.[[AsyncGeneratorState]] to ~awaiting-return~.\n              1. Perform ! AsyncGeneratorAwaitReturn(_generator_).\n              1. Set _done_ to *true*.\n            1. Else,\n              1. If _completion_ is a normal completion, then\n                1. Set _completion_ to NormalCompletion(*undefined*).\n              1. Perform AsyncGeneratorCompleteStep(_generator_, _completion_, *true*).\n              1. If _queue_ is empty, set _done_ to *true*.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncGeneratorDrainQueue",
        "name" : "AsyncGeneratorDrainQueue",
        "htmlId" : "sec-asyncgeneratordrainqueue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    390,
    [
      "ForInOfStatement[1,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[1]]"
        ]
      ],
      "\n        1. Let _names1_ be the BoundNames of |ForBinding|.\n        1. Let _names2_ be the VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[1,0].VarDeclaredNames",
        "name" : "ForInOfStatement[1,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2811,
    [
      "AsyncGeneratorStart",
      0,
      [
        [
          "generator",
          false,
          "Record[AsyncGenerator]"
        ],
        [
          "generatorBody",
          false,
          "Clo | Ast[FunctionBody]"
        ]
      ],
      "\n          1. Assert: _generator_.[[AsyncGeneratorState]] is *undefined*.\n          1. Let _genContext_ be the running execution context.\n          1. Set the Generator component of _genContext_ to _generator_.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:\n            1. Let _acGenContext_ be the running execution context.\n            1. Let _acGenerator_ be the Generator component of _acGenContext_.\n            1. If _generatorBody_ is a Parse Node, then\n              1. Let _result_ be Completion(Evaluation of _generatorBody_).\n            1. Else,\n              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.\n              1. Let _result_ be Completion(_generatorBody_()).\n            1. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.\n            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. Set _acGenerator_.[[AsyncGeneratorState]] to ~completed~.\n            1. If _result_ is a normal completion, set _result_ to NormalCompletion(*undefined*).\n            1. If _result_ is a return completion, set _result_ to NormalCompletion(_result_.[[Value]]).\n            1. Perform AsyncGeneratorCompleteStep(_acGenerator_, _result_, *true*).\n            1. Perform AsyncGeneratorDrainQueue(_acGenerator_).\n            1. Return *undefined*.\n          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Set _generator_.[[AsyncGeneratorContext]] to _genContext_.\n          1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-start~.\n          1. Set _generator_.[[AsyncGeneratorQueue]] to a new empty List.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncGeneratorStart",
        "name" : "AsyncGeneratorStart",
        "htmlId" : "sec-asyncgeneratorstart",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2004,
    [
      "ExportDeclaration[0,0].ExportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[0]]"
        ]
      ],
      "\n          1. Let _module_ be the sole element of ModuleRequests of |FromClause|.\n          1. Return ExportEntriesForModule of |ExportFromClause| with argument _module_.\n        ",
      {
        "normalizedName" : "ExportDeclaration[0,0].ExportEntries",
        "name" : "ExportDeclaration[0,0].ExportEntries",
        "htmlId" : "sec-static-semantics-exportentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntries",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "ExportFromClause"
              },
              {
                "type" : "nonterminal",
                "value" : "FromClause"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1629,
    [
      "MethodDefinition[5,0].HasDirectSuper",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[5]]"
        ]
      ],
      "\n        1. If |PropertySetParameterList| Contains |SuperCall| is *true*, return *true*.\n        1. Return |FunctionBody| Contains |SuperCall|.\n      ",
      {
        "normalizedName" : "MethodDefinition[5,0].HasDirectSuper",
        "name" : "MethodDefinition[5,0].HasDirectSuper",
        "htmlId" : "sec-static-semantics-hasdirectsuper",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasDirectSuper",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "set"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "PropertySetParameterList"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    186,
    [
      "PrivateFieldAdd",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[PrivateName]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If the host is a web browser, then\n          1. Perform ? HostEnsureCanAddPrivateElement(_O_).\n        1. Let _entry_ be PrivateElementFind(_O_, _P_).\n        1. If _entry_ is not ~empty~, throw a *TypeError* exception.\n        1. Append PrivateElement { [[Key]]: _P_, [[Kind]]: ~field~, [[Value]]: _value_ } to _O_.[[PrivateElements]].\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "PrivateFieldAdd",
        "name" : "PrivateFieldAdd",
        "htmlId" : "sec-privatefieldadd",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    55,
    [
      "Number::divide",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. If _x_ is *NaN* or _y_ is *NaN*, return *NaN*.\n            1. If _x_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, then\n              1. If _y_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.\n              1. If _y_ is *+0*<sub>𝔽</sub> or _y_ > *+0*<sub>𝔽</sub>, return _x_.\n              1. Return -_x_.\n            1. If _y_ is *+∞*<sub>𝔽</sub>, then\n              1. If _x_ is *+0*<sub>𝔽</sub> or _x_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>. Otherwise, return *-0*<sub>𝔽</sub>.\n            1. If _y_ is *-∞*<sub>𝔽</sub>, then\n              1. If _x_ is *+0*<sub>𝔽</sub> or _x_ > *+0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.\n            1. If _x_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, then\n              1. If _y_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *NaN*.\n              1. If _y_ > *+0*<sub>𝔽</sub>, return _x_.\n              1. Return -_x_.\n            1. If _y_ is *+0*<sub>𝔽</sub>, then\n              1. If _x_ > *+0*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>. Otherwise, return *-∞*<sub>𝔽</sub>.\n            1. If _y_ is *-0*<sub>𝔽</sub>, then\n              1. If _x_ > *+0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.\n            1. Return 𝔽(ℝ(_x_) / ℝ(_y_)).\n          ",
      {
        "normalizedName" : "Number::divide",
        "name" : "Number::divide",
        "htmlId" : "sec-numeric-types-number-divide",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2026,
    [
      "ExportDeclaration[4,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[4]]"
        ]
      ],
      "\n          1. Return ? Evaluation of |HoistableDeclaration|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[4,0].Evaluation",
        "name" : "ExportDeclaration[4,0].Evaluation",
        "htmlId" : "sec-exports-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "HoistableDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    114,
    [
      "StringNumericLiteral[0,1].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StringNumericLiteral[0]]"
        ]
      ],
      "\n            1. Return *+0*<sub>𝔽</sub>.\n          ",
      {
        "normalizedName" : "StringNumericLiteral[0,1].StringNumericValue",
        "name" : "StringNumericLiteral[0,1].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "StringNumericLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StrWhiteSpace"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1854,
    [
      "UpdateExpression[4,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[4]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UpdateExpression[4,0].HasCallInTailPosition",
        "name" : "UpdateExpression[4,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "--"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    401,
    [
      "CaseClause[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the VarDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "CaseClause[0,0].VarDeclaredNames",
        "name" : "CaseClause[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2608,
    [
      "INTRINSICS.Set.prototype.entries",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Return ? CreateSetIterator(_S_, ~key+value~).\n        ",
      {
        "normalizedName" : "INTRINSICS.Set.prototype.entries",
        "name" : "INTRINSICS.Set.prototype.entries",
        "htmlId" : "sec-set.prototype.entries",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    171,
    [
      "HasOwnProperty",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n        1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. If _desc_ is *undefined*, return *false*.\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "HasOwnProperty",
        "name" : "HasOwnProperty",
        "htmlId" : "sec-hasownproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2431,
    [
      "WordCharacters",
      0,
      [
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n            1. Let _basicWordChars_ be the CharSet containing every character in the ASCII word characters.\n            1. Let _extraWordChars_ be the CharSet containing all characters _c_ such that _c_ is not in _basicWordChars_ but Canonicalize(_rer_, _c_) is in _basicWordChars_.\n            1. Assert: _extraWordChars_ is empty unless HasEitherUnicodeFlag(_rer_) is *true* and _rer_.[[IgnoreCase]] is *true*.\n            1. Return the union of _basicWordChars_ and _extraWordChars_.\n          ",
      {
        "normalizedName" : "WordCharacters",
        "name" : "WordCharacters",
        "htmlId" : "sec-wordcharacters",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    139,
    [
      "ToBigInt64",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _n_ be ? ToBigInt(_argument_).\n        1. Let _int64bit_ be ℝ(_n_) modulo 2<sup>64</sup>.\n        1. If _int64bit_ ≥ 2<sup>63</sup>, return ℤ(_int64bit_ - 2<sup>64</sup>); otherwise return ℤ(_int64bit_).\n      ",
      {
        "normalizedName" : "ToBigInt64",
        "name" : "ToBigInt64",
        "htmlId" : "sec-tobigint64",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1244,
    [
      "Literal[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Literal[2]]"
        ]
      ],
      "\n          1. Return the NumericValue of |NumericLiteral| as defined in <emu-xref href=\"#sec-literals-numeric-literals\"></emu-xref>.\n        ",
      {
        "normalizedName" : "Literal[2,0].Evaluation",
        "name" : "Literal[2,0].Evaluation",
        "htmlId" : "sec-literals-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "Literal",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NumericLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2764,
    [
      "PerformPromiseAll",
      0,
      [
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "constructor",
          false,
          "Record[Constructor]"
        ],
        [
          "resultCapability",
          false,
          "Record[PromiseCapabilityRecord]"
        ],
        [
          "promiseResolve",
          false,
          "Record[FunctionObject]"
        ]
      ],
      "\n            1. Let _values_ be a new empty List.\n            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.\n            1. Let _index_ be 0.\n            1. Repeat,\n              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n              1. If _next_ is ~done~, then\n                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n                1. If _remainingElementsCount_.[[Value]] = 0, then\n                  1. Let _valuesArray_ be CreateArrayFromList(_values_).\n                  1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n                1. Return _resultCapability_.[[Promise]].\n              1. Append *undefined* to _values_.\n              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).\n              1. Let _steps_ be the algorithm steps defined in <emu-xref href=\"#sec-promise.all-resolve-element-functions\" title></emu-xref>.\n              1. Let _length_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.all-resolve-element-functions\" title></emu-xref>.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_steps_, _length_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).\n              1. Set _onFulfilled_.[[AlreadyCalled]] to *false*.\n              1. Set _onFulfilled_.[[Index]] to _index_.\n              1. Set _onFulfilled_.[[Values]] to _values_.\n              1. Set _onFulfilled_.[[Capability]] to _resultCapability_.\n              1. Set _onFulfilled_.[[RemainingElements]] to _remainingElementsCount_.\n              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.\n              1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _onFulfilled_, _resultCapability_.[[Reject]] »).\n              1. Set _index_ to _index_ + 1.\n          ",
      {
        "normalizedName" : "PerformPromiseAll",
        "name" : "PerformPromiseAll",
        "htmlId" : "sec-performpromiseall",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1822,
    [
      "AssignmentExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[1,0].HasCallInTailPosition",
        "name" : "AssignmentExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "YieldExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1523,
    [
      "CaseBlock[1,2].CaseBlockEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "input",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _V_ be *undefined*.\n        1. If the first |CaseClauses| is present, then\n          1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _A_ be a new empty List.\n        1. Let _found_ be *false*.\n        1. For each |CaseClause| _C_ of _A_, do\n          1. If _found_ is *false*, then\n            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n          1. If _found_ is *true*, then\n            1. Let _R_ be Completion(Evaluation of _C_).\n            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n            1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Let _foundInB_ be *false*.\n        1. If the second |CaseClauses| is present, then\n          1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _B_ be a new empty List.\n        1. If _found_ is *false*, then\n          1. For each |CaseClause| _C_ of _B_, do\n            1. If _foundInB_ is *false*, then\n              1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).\n            1. If _foundInB_ is *true*, then\n              1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n              1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n              1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. If _foundInB_ is *true*, return _V_.\n        1. Let _defaultR_ be Completion(Evaluation of |DefaultClause|).\n        1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].\n        1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).\n        1. NOTE: The following is another complete iteration of the second |CaseClauses|.\n        1. For each |CaseClause| _C_ of _B_, do\n          1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n          1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n          1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Return _V_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,2].CaseBlockEvaluation",
        "name" : "CaseBlock[1,2].CaseBlockEvaluation",
        "htmlId" : "sec-runtime-semantics-caseblockevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CaseBlockEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2130,
    [
      "INTRINSICS.Math.atan",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing π / 2.\n          1. If _n_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π / 2.\n          1. Return an implementation-approximated Number value representing the result of the inverse tangent of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.atan",
        "name" : "INTRINSICS.Math.atan",
        "htmlId" : "sec-math.atan",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    731,
    [
      "MemberExpression[6,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[6]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[6,0].IsFunctionDefinition",
        "name" : "MemberExpression[6,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    418,
    [
      "ScriptBody[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ScriptBody[0]]"
        ]
      ],
      "\n        1. Return TopLevelVarDeclaredNames of |StatementList|.\n      ",
      {
        "normalizedName" : "ScriptBody[0,0].VarDeclaredNames",
        "name" : "ScriptBody[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ScriptBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    786,
    [
      "AsyncGeneratorExpression[0,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,0].IsFunctionDefinition",
        "name" : "AsyncGeneratorExpression[0,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2526,
    [
      "INTRINSICS.Array.prototype.with",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n          1. If _relativeIndex_ ≥ 0, let _actualIndex_ be _relativeIndex_.\n          1. Else, let _actualIndex_ be _len_ + _relativeIndex_.\n          1. If _actualIndex_ ≥ _len_ or _actualIndex_ < 0, throw a *RangeError* exception.\n          1. Let _A_ be ? ArrayCreate(_len_).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. If _k_ is _actualIndex_, let _fromValue_ be _value_.\n            1. Else, let _fromValue_ be ? Get(_O_, _Pk_).\n            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.with",
        "name" : "INTRINSICS.Array.prototype.with",
        "htmlId" : "sec-array.prototype.with",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2416,
    [
      "ClassSetOperand[2,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSetOperand[2]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.\n          1. Return MaybeSimpleCaseFolding(_rer_, _A_).\n        ",
      {
        "normalizedName" : "ClassSetOperand[2,0].CompileToCharSet",
        "name" : "ClassSetOperand[2,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ClassSetOperand",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetCharacter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    995,
    [
      "LiteralPropertyName[2,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[LiteralPropertyName[2]]"
        ]
      ],
      "\n        1. Let _nbr_ be the NumericValue of |NumericLiteral|.\n        1. Return ! ToString(_nbr_).\n      ",
      {
        "normalizedName" : "LiteralPropertyName[2,0].PropName",
        "name" : "LiteralPropertyName[2,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "LiteralPropertyName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NumericLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1558,
    [
      "ObjectBindingPattern[3,1].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectBindingPattern[3]]"
        ]
      ],
      "\n        1. Return ContainsExpression of |BindingPropertyList|.\n      ",
      {
        "normalizedName" : "ObjectBindingPattern[3,1].ContainsExpression",
        "name" : "ObjectBindingPattern[3,1].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 1,
            "astName" : "ObjectBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingPropertyList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestProperty"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2152,
    [
      "INTRINSICS.Math.sign",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ < *-0*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.\n          1. Return *1*<sub>𝔽</sub>.\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.sign",
        "name" : "INTRINSICS.Math.sign",
        "htmlId" : "sec-math.sign",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2262,
    [
      "INTRINSICS.String.prototype.search",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. If _regexp_ is neither *undefined* nor *null*, then\n            1. Let _searcher_ be ? GetMethod(_regexp_, @@search).\n            1. If _searcher_ is not *undefined*, then\n              1. Return ? Call(_searcher_, _regexp_, « _O_ »).\n          1. Let _string_ be ? ToString(_O_).\n          1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).\n          1. Return ? Invoke(_rx_, @@search, « _string_ »).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.search",
        "name" : "INTRINSICS.String.prototype.search",
        "htmlId" : "sec-string.prototype.search",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2447,
    [
      "INTRINSICS.RegExp.prototype.exec",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).\n          1. Let _S_ be ? ToString(_string_).\n          1. Return ? RegExpBuiltinExec(_R_, _S_).\n        ",
      {
        "normalizedName" : "INTRINSICS.RegExp.prototype.exec",
        "name" : "INTRINSICS.RegExp.prototype.exec",
        "htmlId" : "sec-regexp.prototype.exec",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    568,
    [
      "Catch[0,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[Catch[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Block| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "Catch[0,0].ContainsDuplicateLabels",
        "name" : "Catch[0,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Catch",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "catch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "CatchParameter"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    207,
    [
      "BindingIdentifier[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingIdentifier[0]]"
        ]
      ],
      "\n        1. Return a List whose sole element is the StringValue of |Identifier|.\n      ",
      {
        "normalizedName" : "BindingIdentifier[0,0].BoundNames",
        "name" : "BindingIdentifier[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BindingIdentifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Identifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2120,
    [
      "INTRINSICS.BigInt.asIntN",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Set _bits_ to ? ToIndex(_bits_).\n          1. Set _bigint_ to ? ToBigInt(_bigint_).\n          1. Let _mod_ be ℝ(_bigint_) modulo 2<sup>_bits_</sup>.\n          1. If _mod_ ≥ 2<sup>_bits_ - 1</sup>, return ℤ(_mod_ - 2<sup>_bits_</sup>); otherwise, return ℤ(_mod_).\n        ",
      {
        "normalizedName" : "INTRINSICS.BigInt.asIntN",
        "name" : "INTRINSICS.BigInt.asIntN",
        "htmlId" : "sec-bigint.asintn",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2315,
    [
      "NestedClass[1,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[NestedClass[1]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "NestedClass[1,0].MayContainStrings",
        "name" : "NestedClass[1,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "NestedClass",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "[^"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassContents"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2623,
    [
      "INTRINSICS.WeakSet.prototype.delete",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).\n          1. If CanBeHeldWeakly(_value_) is *false*, return *false*.\n          1. For each element _e_ of _S_.[[WeakSetData]], do\n            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then\n              1. Replace the element of _S_.[[WeakSetData]] whose value is _e_ with an element whose value is ~empty~.\n              1. Return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.WeakSet.prototype.delete",
        "name" : "INTRINSICS.WeakSet.prototype.delete",
        "htmlId" : "sec-weakset.prototype.delete",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1994,
    [
      "ExportDeclaration[5,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[5]]"
        ]
      ],
      "\n          1. Return « *\"default\"* ».\n        ",
      {
        "normalizedName" : "ExportDeclaration[5,0].ExportedNames",
        "name" : "ExportDeclaration[5,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2009,
    [
      "ExportDeclaration[5,0].ExportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[5]]"
        ]
      ],
      "\n          1. Let _names_ be BoundNames of |ClassDeclaration|.\n          1. Let _localName_ be the sole element of _names_.\n          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *\"default\"* }.\n        ",
      {
        "normalizedName" : "ExportDeclaration[5,0].ExportEntries",
        "name" : "ExportDeclaration[5,0].ExportEntries",
        "htmlId" : "sec-static-semantics-exportentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntries",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    8,
    [
      "INTRINSICS.EvalError",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1861,
    [
      "UnaryExpression[7,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[7]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[7,0].HasCallInTailPosition",
        "name" : "UnaryExpression[7,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "!"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    75,
    [
      "BigInt::add",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. Return _x_ + _y_.\n          ",
      {
        "normalizedName" : "BigInt::add",
        "name" : "BigInt::add",
        "htmlId" : "sec-numeric-types-bigint-add",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1030,
    [
      "Record[FunctionEnvironmentRecord].GetThisBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[FunctionEnvironmentRecord]"
        ]
      ],
      "\n            1. Assert: _envRec_.[[ThisBindingStatus]] is not ~lexical~.\n            1. If _envRec_.[[ThisBindingStatus]] is ~uninitialized~, throw a *ReferenceError* exception.\n            1. Return _envRec_.[[ThisValue]].\n          ",
      {
        "normalizedName" : "Record[FunctionEnvironmentRecord].GetThisBinding",
        "name" : "Record[FunctionEnvironmentRecord].GetThisBinding",
        "htmlId" : "sec-function-environment-records-getthisbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "FunctionEnvironmentRecord",
          "GetThisBinding"
        ]
      }
    ]
  ],
  [
    1491,
    [
      "ForBinding[0,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[ForBinding[0]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ForBinding[0,0].IsDestructuring",
        "name" : "ForBinding[0,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1689,
    [
      "FieldDefinition[0,1].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[FieldDefinition[0]]"
        ]
      ],
      "\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      ",
      {
        "normalizedName" : "FieldDefinition[0,1].PrivateBoundIdentifiers",
        "name" : "FieldDefinition[0,1].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FieldDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2081,
    [
      "INTRINSICS.Object.prototype.__lookupSetter__",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _O_ be ? ToObject(*this* value).\n            1. Let _key_ be ? ToPropertyKey(_P_).\n            1. Repeat,\n              1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_key_).\n              1. If _desc_ is not *undefined*, then\n                1. If IsAccessorDescriptor(_desc_) is *true*, return _desc_.[[Set]].\n                1. Return *undefined*.\n              1. Set _O_ to ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]()</emu-meta>.\n              1. If _O_ is *null*, return *undefined*.\n          ",
      {
        "normalizedName" : "INTRINSICS.Object.prototype.__lookupSetter__",
        "name" : "INTRINSICS.Object.prototype.__lookupSetter__",
        "htmlId" : "sec-object.prototype.__lookupSetter__",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2384,
    [
      "Canonicalize",
      0,
      [
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "ch",
          false,
          "Unknown[\"Character\"]"
        ]
      ],
      "\n            1. If HasEitherUnicodeFlag(_rer_) is *true* and _rer_.[[IgnoreCase]] is *true*, then\n              1. If the file <a href=\"https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt\"><code>CaseFolding.txt</code></a> of the Unicode Character Database provides a simple or common case folding mapping for _ch_, return the result of applying that mapping to _ch_.\n              1. Return _ch_.\n            1. If _rer_.[[IgnoreCase]] is *false*, return _ch_.\n            1. Assert: _ch_ is a UTF-16 code unit.\n            1. Let _cp_ be the code point whose numeric value is the numeric value of _ch_.\n            1. Let _u_ be the result of toUppercase(« _cp_ »), according to the Unicode Default Case Conversion algorithm.\n            1. Let _uStr_ be CodePointsToString(_u_).\n            1. If the length of _uStr_ ≠ 1, return _ch_.\n            1. Let _cu_ be _uStr_'s single code unit element.\n            1. If the numeric value of _ch_ ≥ 128 and the numeric value of _cu_ < 128, return _ch_.\n            1. Return _cu_.\n          ",
      {
        "normalizedName" : "Canonicalize",
        "name" : "Canonicalize",
        "htmlId" : "sec-runtime-semantics-canonicalize-ch",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2475,
    [
      "CreateRegExpStringIterator",
      0,
      [
        [
          "R",
          false,
          "Record[Object]"
        ],
        [
          "S",
          false,
          "String"
        ],
        [
          "global",
          false,
          "Boolean"
        ],
        [
          "fullUnicode",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _R_, _S_, _global_, and _fullUnicode_ and performs the following steps when called:\n            1. Repeat,\n              1. Let _match_ be ? RegExpExec(_R_, _S_).\n              1. If _match_ is *null*, return *undefined*.\n              1. If _global_ is *false*, then\n                1. Perform ? GeneratorYield(CreateIterResultObject(_match_, *false*)).\n                1. Return *undefined*.\n              1. Let _matchStr_ be ? ToString(? Get(_match_, *\"0\"*)).\n              1. If _matchStr_ is the empty String, then\n                1. Let _thisIndex_ be ℝ(? ToLength(? Get(_R_, *\"lastIndex\"*))).\n                1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).\n                1. Perform ? Set(_R_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).\n              1. Perform ? GeneratorYield(CreateIterResultObject(_match_, *false*)).\n          1. Return CreateIteratorFromClosure(_closure_, *\"%RegExpStringIteratorPrototype%\"*, %RegExpStringIteratorPrototype%).\n        ",
      {
        "normalizedName" : "CreateRegExpStringIterator",
        "name" : "CreateRegExpStringIterator",
        "htmlId" : "sec-createregexpstringiterator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2786,
    [
      "INTRINSICS.Promise.prototype.then",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _promise_ be the *this* value.\n          1. If IsPromise(_promise_) is *false*, throw a *TypeError* exception.\n          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).\n          1. Let _resultCapability_ be ? NewPromiseCapability(_C_).\n          1. Return PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_, _resultCapability_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.prototype.then",
        "name" : "INTRINSICS.Promise.prototype.then",
        "htmlId" : "sec-promise.prototype.then",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2796,
    [
      "GeneratorValidate",
      0,
      [
        [
          "generator",
          false,
          "ESValue"
        ],
        [
          "generatorBrand",
          false,
          "Enum[~empty~] | String"
        ]
      ],
      "\n          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorState]]).\n          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorBrand]]).\n          1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.\n          1. Assert: _generator_ also has a [[GeneratorContext]] internal slot.\n          1. Let _state_ be _generator_.[[GeneratorState]].\n          1. If _state_ is ~executing~, throw a *TypeError* exception.\n          1. Return _state_.\n        ",
      {
        "normalizedName" : "GeneratorValidate",
        "name" : "GeneratorValidate",
        "htmlId" : "sec-generatorvalidate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    290,
    [
      "Block[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[Block[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Block[0,0].LexicallyDeclaredNames",
        "name" : "Block[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Block",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    119,
    [
      "StrNumericLiteral[1,0].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StrNumericLiteral[1]]"
        ]
      ],
      "\n            1. Return 𝔽(MV of |NonDecimalIntegerLiteral|).\n          ",
      {
        "normalizedName" : "StrNumericLiteral[1,0].StringNumericValue",
        "name" : "StrNumericLiteral[1,0].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StrNumericLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NonDecimalIntegerLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    58,
    [
      "Number::subtract",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. Return Number::add(_x_, Number::unaryMinus(_y_)).\n          ",
      {
        "normalizedName" : "Number::subtract",
        "name" : "Number::subtract",
        "htmlId" : "sec-numeric-types-number-subtract",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    914,
    [
      "CallExpression[4,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[4]]"
        ]
      ],
      "\n        1. Return ~simple~.\n      ",
      {
        "normalizedName" : "CallExpression[4,0].AssignmentTargetType",
        "name" : "CallExpression[4,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    378,
    [
      "ForStatement[1,2].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ]
      ],
      "\n        1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n        1. Let _names2_ be VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ForStatement[1,2].VarDeclaredNames",
        "name" : "ForStatement[1,2].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    235,
    [
      "SingleNameBinding[0,1].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[SingleNameBinding[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingIdentifier|.\n      ",
      {
        "normalizedName" : "SingleNameBinding[0,1].BoundNames",
        "name" : "SingleNameBinding[0,1].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "SingleNameBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    246,
    [
      "GeneratorDeclaration[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorDeclaration[1]]"
        ]
      ],
      "\n        1. Return « *\"\\*default\\*\"* ».\n      ",
      {
        "normalizedName" : "GeneratorDeclaration[1,0].BoundNames",
        "name" : "GeneratorDeclaration[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "GeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2399,
    [
      "CharacterClassEscape[2,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[2]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return the CharSet containing all characters corresponding to a code point on the right-hand side of the |WhiteSpace| or |LineTerminator| productions.\n        ",
      {
        "normalizedName" : "CharacterClassEscape[2,0].CompileToCharSet",
        "name" : "CharacterClassEscape[2,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "s"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2041,
    [
      "Decode",
      0,
      [
        [
          "string",
          false,
          "String"
        ],
        [
          "preserveEscapeSet",
          false,
          "String"
        ]
      ],
      "\n          1. Let _len_ be the length of _string_.\n          1. Let _R_ be the empty String.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _C_ be the code unit at index _k_ within _string_.\n            1. Let _S_ be _C_.\n            1. If _C_ is the code unit 0x0025 (PERCENT SIGN), then\n              1. If _k_ + 3 > _len_, throw a *URIError* exception.\n              1. Let _escape_ be the substring of _string_ from _k_ to _k_ + 3.\n              1. Let _B_ be ParseHexOctet(_string_, _k_ + 1).\n              1. If _B_ is not an integer, throw a *URIError* exception.\n              1. Set _k_ to _k_ + 2.\n              1. Let _n_ be the number of leading 1 bits in _B_.\n              1. If _n_ = 0, then\n                1. Let _asciiChar_ be the code unit whose numeric value is _B_.\n                1. If _preserveEscapeSet_ contains _asciiChar_, set _S_ to _escape_. Otherwise, set _S_ to _asciiChar_.\n              1. Else,\n                1. If _n_ = 1 or _n_ > 4, throw a *URIError* exception.\n                1. Let _Octets_ be « _B_ ».\n                1. Let _j_ be 1.\n                1. Repeat, while _j_ < _n_,\n                  1. Set _k_ to _k_ + 1.\n                  1. If _k_ + 3 > _len_, throw a *URIError* exception.\n                  1. If the code unit at index _k_ within _string_ is not the code unit 0x0025 (PERCENT SIGN), throw a *URIError* exception.\n                  1. Let _continuationByte_ be ParseHexOctet(_string_, _k_ + 1).\n                  1. If _continuationByte_ is not an integer, throw a *URIError* exception.\n                  1. Append _continuationByte_ to _Octets_.\n                  1. Set _k_ to _k_ + 2.\n                  1. Set _j_ to _j_ + 1.\n                1. Assert: The length of _Octets_ is _n_.\n                1. If _Octets_ does not contain a valid UTF-8 encoding of a Unicode code point, throw a *URIError* exception.\n                1. Let _V_ be the code point obtained by applying the UTF-8 transformation to _Octets_, that is, from a List of octets into a 21-bit value.\n                1. Set _S_ to UTF16EncodeCodePoint(_V_).\n            1. Set _R_ to the string-concatenation of _R_ and _S_.\n            1. Set _k_ to _k_ + 1.\n          1. Return _R_.\n        ",
      {
        "normalizedName" : "Decode",
        "name" : "Decode",
        "htmlId" : "sec-decode",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    433,
    [
      "VariableDeclarationList[1,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[VariableDeclarationList[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n        1. Return the list-concatenation of _declarations1_ and « |VariableDeclaration| ».\n      ",
      {
        "normalizedName" : "VariableDeclarationList[1,0].VarScopedDeclarations",
        "name" : "VariableDeclarationList[1,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "VariableDeclarationList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    510,
    [
      "LabelledItem[1,0].TopLevelVarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[1]]"
        ]
      ],
      "\n        1. Return « |FunctionDeclaration| ».\n      ",
      {
        "normalizedName" : "LabelledItem[1,0].TopLevelVarScopedDeclarations",
        "name" : "LabelledItem[1,0].TopLevelVarScopedDeclarations",
        "htmlId" : "sec-static-semantics-toplevelvarscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelVarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2648,
    [
      "INTRINSICS.get ArrayBuffer.prototype.maxByteLength",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>𝔽</sub>.\n          1. If IsFixedLengthArrayBuffer(_O_) is *true*, then\n            1. Let _length_ be _O_.[[ArrayBufferByteLength]].\n          1. Else,\n            1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].\n          1. Return 𝔽(_length_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get ArrayBuffer.prototype.maxByteLength",
        "name" : "INTRINSICS.get ArrayBuffer.prototype.maxByteLength",
        "htmlId" : "sec-get-arraybuffer.prototype.maxbytelength",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1777,
    [
      "LabelledItem[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "LabelledItem[1,0].HasCallInTailPosition",
        "name" : "LabelledItem[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    667,
    [
      "ForStatement[2,1].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[2,1].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[2,1].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1294,
    [
      "TemplateSpans[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateSpans[0]]"
        ]
      ],
      "\n          1. Return the TV of |TemplateTail| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.\n        ",
      {
        "normalizedName" : "TemplateSpans[0,0].Evaluation",
        "name" : "TemplateSpans[0,0].Evaluation",
        "htmlId" : "sec-template-literals-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TemplateSpans",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2462,
    [
      "INTRINSICS.get RegExp.prototype.sticky",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0079 (LATIN SMALL LETTER Y).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get RegExp.prototype.sticky",
        "name" : "INTRINSICS.get RegExp.prototype.sticky",
        "htmlId" : "sec-get-regexp.prototype.sticky",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1440,
    [
      "VariableDeclaration[0,1].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[VariableDeclaration[0]]"
        ]
      ],
      "\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Let _lhs_ be ? ResolveBinding(_bindingId_).\n          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.\n          1. Else,\n            1. Let _rhs_ be ? Evaluation of |Initializer|.\n            1. Let _value_ be ? GetValue(_rhs_).\n          1. [id=\"step-vardecllist-evaluation-putvalue\"] Perform ? PutValue(_lhs_, _value_).\n          1. Return ~empty~.\n        ",
      {
        "normalizedName" : "VariableDeclaration[0,1].Evaluation",
        "name" : "VariableDeclaration[0,1].Evaluation",
        "htmlId" : "sec-variable-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "VariableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    929,
    [
      "PrimaryExpression[8,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[8]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "PrimaryExpression[8,0].AssignmentTargetType",
        "name" : "PrimaryExpression[8,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2330,
    [
      "ClassString[1,0].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassString[1]]"
        ]
      ],
      "\n          1. Return MayContainStrings of the |NonEmptyClassString|.\n        ",
      {
        "normalizedName" : "ClassString[1,0].MayContainStrings",
        "name" : "ClassString[1,0].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassString",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NonEmptyClassString"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1308,
    [
      "NewExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[NewExpression[1]]"
        ]
      ],
      "\n          1. Return ? EvaluateNew(|NewExpression|, ~empty~).\n        ",
      {
        "normalizedName" : "NewExpression[1,0].Evaluation",
        "name" : "NewExpression[1,0].Evaluation",
        "htmlId" : "sec-new-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "NewExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "nonterminal",
                "value" : "NewExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2198,
    [
      "INTRINSICS.Date.prototype.getTime",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Return _dateObject_.[[DateValue]].\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getTime",
        "name" : "INTRINSICS.Date.prototype.getTime",
        "htmlId" : "sec-date.prototype.gettime",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2576,
    [
      "TypedArrayElementSize",
      0,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ]
      ],
      "\n          1. Return the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _O_.[[TypedArrayName]].\n        ",
      {
        "normalizedName" : "TypedArrayElementSize",
        "name" : "TypedArrayElementSize",
        "htmlId" : "sec-typedarrayelementsize",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2066,
    [
      "INTRINSICS.Object.preventExtensions",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _O_ is not an Object, return _O_.\n          1. Let _status_ be ? <emu-meta effects=\"user-code\">_O_.[[PreventExtensions]]()</emu-meta>.\n          1. If _status_ is *false*, throw a *TypeError* exception.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.preventExtensions",
        "name" : "INTRINSICS.Object.preventExtensions",
        "htmlId" : "sec-object.preventextensions",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1706,
    [
      "FunctionExpression[0,1].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,1].ContainsArguments",
        "name" : "FunctionExpression[0,1].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1193,
    [
      "Record[ProxyExoticObject].IsExtensible",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"isExtensible\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? IsExtensible(_target_).\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_ »)).\n        1. Let _targetResult_ be ? IsExtensible(_target_).\n        1. If _booleanTrapResult_ is not _targetResult_, throw a *TypeError* exception.\n        1. Return _booleanTrapResult_.\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].IsExtensible",
        "name" : "Record[ProxyExoticObject].IsExtensible",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-isextensible",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[IsExtensible]]"
        ]
      }
    ]
  ],
  [
    1077,
    [
      "HostEnqueueFinalizationRegistryCleanupJob",
      0,
      [
        [
          "finalizationRegistry",
          false,
          "Record[FinalizationRegistry]"
        ]
      ],
      "\n          1. Let _cleanupResult_ be Completion(CleanupFinalizationRegistry(_finalizationRegistry_)).\n          1. If _cleanupResult_ is an abrupt completion, perform any host-defined steps for reporting the error.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "HostEnqueueFinalizationRegistryCleanupJob",
        "name" : "HostEnqueueFinalizationRegistryCleanupJob",
        "htmlId" : "sec-host-cleanup-finalization-registry",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    478,
    [
      "TryStatement[1,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be VarScopedDeclarations of |Block|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Finally|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "TryStatement[1,0].VarScopedDeclarations",
        "name" : "TryStatement[1,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2362,
    [
      "Assertion[7,0].CompileAssertion",
      2,
      [
        [
          "this",
          false,
          "Ast[Assertion[7]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~backward~.\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Return _y_.\n            1. Let _r_ be _m_(_x_, _d_).\n            1. If _r_ is not ~failure~, return ~failure~.\n            1. Return _c_(_x_).\n        ",
      {
        "normalizedName" : "Assertion[7,0].CompileAssertion",
        "name" : "Assertion[7,0].CompileAssertion",
        "htmlId" : "sec-compileassertion",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAssertion",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "Assertion",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "(?<!"
              },
              {
                "type" : "nonterminal",
                "value" : "Disjunction"
              },
              {
                "type" : "terminal",
                "value" : ")"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2162,
    [
      "DayFromYear",
      0,
      [
        [
          "y",
          false,
          "NumberInt"
        ]
      ],
      "\n          1. Let _ry_ be ℝ(_y_).\n          1. [declared=\"numYears1,numYears4,numYears100,numYears400\"] NOTE: In the following steps, _numYears1_, _numYears4_, _numYears100_, and _numYears400_ represent the number of years divisible by 1, 4, 100, and 400, respectively, that occur between the epoch and the start of year _y_. The number is negative if _y_ is before the epoch.\n          1. Let _numYears1_ be (_ry_ - 1970).\n          1. Let _numYears4_ be floor((_ry_ - 1969) / 4).\n          1. Let _numYears100_ be floor((_ry_ - 1901) / 100).\n          1. Let _numYears400_ be floor((_ry_ - 1601) / 400).\n          1. Return 𝔽(365 × _numYears1_ + _numYears4_ - _numYears100_ + _numYears400_).\n        ",
      {
        "normalizedName" : "DayFromYear",
        "name" : "DayFromYear",
        "htmlId" : "sec-dayfromyear",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2680,
    [
      "INTRINSICS.DataView.prototype.getUint16",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~uint16~).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.getUint16",
        "name" : "INTRINSICS.DataView.prototype.getUint16",
        "htmlId" : "sec-dataview.prototype.getuint16",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2183,
    [
      "MakeDate",
      0,
      [
        [
          "day",
          false,
          "Number"
        ],
        [
          "time",
          false,
          "Number"
        ]
      ],
      "\n          1. If _day_ is not finite or _time_ is not finite, return *NaN*.\n          1. Let _tv_ be _day_ × msPerDay + _time_.\n          1. If _tv_ is not finite, return *NaN*.\n          1. Return _tv_.\n        ",
      {
        "normalizedName" : "MakeDate",
        "name" : "MakeDate",
        "htmlId" : "sec-makedate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1212,
    [
      "IdentifierName[1,0].IdentifierCodePoints",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierName[1]]"
        ]
      ],
      "\n          1. Let _cps_ be IdentifierCodePoints of the derived |IdentifierName|.\n          1. Let _cp_ be IdentifierCodePoint of |IdentifierPart|.\n          1. Return the list-concatenation of _cps_ and « _cp_ ».\n        ",
      {
        "normalizedName" : "IdentifierName[1,0].IdentifierCodePoints",
        "name" : "IdentifierName[1,0].IdentifierCodePoints",
        "htmlId" : "sec-identifiercodepoints",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IdentifierCodePoints",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IdentifierName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierPart"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1607,
    [
      "ArrowParameters[1,0].ExpectedArgumentCount",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowParameters[1]]"
        ]
      ],
      "\n        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return ExpectedArgumentCount of _formals_.\n      ",
      {
        "normalizedName" : "ArrowParameters[1,0].ExpectedArgumentCount",
        "name" : "ArrowParameters[1,0].ExpectedArgumentCount",
        "htmlId" : "sec-static-semantics-expectedargumentcount",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExpectedArgumentCount",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ArrowParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    763,
    [
      "EqualityExpression[2,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "EqualityExpression[2,0].IsFunctionDefinition",
        "name" : "EqualityExpression[2,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "!="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    272,
    [
      "Declaration[1,0].DeclarationPart",
      2,
      [
        [
          "this",
          false,
          "Ast[Declaration[1]]"
        ]
      ],
      "\n        1. Return |ClassDeclaration|.\n      ",
      {
        "normalizedName" : "Declaration[1,0].DeclarationPart",
        "name" : "Declaration[1,0].DeclarationPart",
        "htmlId" : "sec-static-semantics-declarationpart",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DeclarationPart",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "Declaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    383,
    [
      "ForStatement[2,3].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[2,3].VarDeclaredNames",
        "name" : "ForStatement[2,3].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1513,
    [
      "ContinueStatement[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ContinueStatement[1]]"
        ]
      ],
      "\n        1. Let _label_ be the StringValue of |LabelIdentifier|.\n        1. Return Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: _label_ }.\n      ",
      {
        "normalizedName" : "ContinueStatement[1,0].Evaluation",
        "name" : "ContinueStatement[1,0].Evaluation",
        "htmlId" : "sec-continue-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ContinueStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "continue"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    899,
    [
      "SingleNameBinding[0,0].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[SingleNameBinding[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n        1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).\n        1. Let _v_ be *undefined*.\n        1. If _iteratorRecord_.[[Done]] is *false*, then\n          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is not ~done~, then\n            1. Set _v_ to _next_.\n        1. If |Initializer| is present and _v_ is *undefined*, then\n          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n            1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.\n          1. Else,\n            1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n            1. Set _v_ to ? GetValue(_defaultValue_).\n        1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).\n        1. Return ? InitializeReferencedBinding(_lhs_, _v_).\n      ",
      {
        "normalizedName" : "SingleNameBinding[0,0].IteratorBindingInitialization",
        "name" : "SingleNameBinding[0,0].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SingleNameBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1661,
    [
      "AsyncGeneratorExpression[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression|.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,0].Evaluation",
        "name" : "AsyncGeneratorExpression[0,0].Evaluation",
        "htmlId" : "sec-asyncgenerator-definitions-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2095,
    [
      "INTRINSICS.get Symbol.prototype.description",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _s_ be the *this* value.\n          1. Let _sym_ be ? ThisSymbolValue(_s_).\n          1. Return _sym_.[[Description]].\n        ",
      {
        "normalizedName" : "INTRINSICS.get Symbol.prototype.description",
        "name" : "INTRINSICS.get Symbol.prototype.description",
        "htmlId" : "sec-symbol.prototype.description",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    832,
    [
      "GeneratorDeclaration[1,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorDeclaration[1]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "GeneratorDeclaration[1,0].Contains",
        "name" : "GeneratorDeclaration[1,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "GeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    684,
    [
      "CaseBlock[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "CaseBlock[1,0].ContainsUndefinedContinueTarget",
        "name" : "CaseBlock[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2230,
    [
      "ToDateString",
      0,
      [
        [
          "tv",
          false,
          "NumberInt | NaN"
        ]
      ],
      "\n            1. If _tv_ is *NaN*, return *\"Invalid Date\"*.\n            1. Let _t_ be LocalTime(_tv_).\n            1. Return the string-concatenation of DateString(_t_), the code unit 0x0020 (SPACE), TimeString(_t_), and TimeZoneString(_tv_).\n          ",
      {
        "normalizedName" : "ToDateString",
        "name" : "ToDateString",
        "htmlId" : "sec-todatestring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    346,
    [
      "ExportDeclaration[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ExportDeclaration[0,0].LexicallyScopedDeclarations",
        "name" : "ExportDeclaration[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "ExportFromClause"
              },
              {
                "type" : "nonterminal",
                "value" : "FromClause"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2036,
    [
      "INTRINSICS.decodeURI",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _uriString_ be ? ToString(_encodedURI_).\n          1. Let _preserveEscapeSet_ be *\";/?:@&=+$,#\"*.\n          1. Return ? Decode(_uriString_, _preserveEscapeSet_).\n        ",
      {
        "normalizedName" : "INTRINSICS.decodeURI",
        "name" : "INTRINSICS.decodeURI",
        "htmlId" : "sec-decodeuri-encodeduri",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1309,
    [
      "MemberExpression[6,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[6]]"
        ]
      ],
      "\n          1. Return ? EvaluateNew(|MemberExpression|, |Arguments|).\n        ",
      {
        "normalizedName" : "MemberExpression[6,0].Evaluation",
        "name" : "MemberExpression[6,0].Evaluation",
        "htmlId" : "sec-new-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1893,
    [
      "CallExpression[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. If this |CallExpression| is _call_, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CallExpression[0,0].HasCallInTailPosition",
        "name" : "CallExpression[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverCallExpressionAndAsyncArrowHead"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2294,
    [
      "CharacterEscape[1,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterEscape[1]]"
        ]
      ],
      "\n          1. Let _ch_ be the code point matched by |AsciiLetter|.\n          1. Let _i_ be the numeric value of _ch_.\n          1. Return the remainder of dividing _i_ by 32.\n        ",
      {
        "normalizedName" : "CharacterEscape[1,0].CharacterValue",
        "name" : "CharacterEscape[1,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CharacterEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "c"
              },
              {
                "type" : "nonterminal",
                "value" : "AsciiLetter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2739,
    [
      "INTRINSICS.FinalizationRegistry.prototype.unregister",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _finalizationRegistry_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).\n          1. If CanBeHeldWeakly(_unregisterToken_) is *false*, throw a *TypeError* exception.\n          1. Let _removed_ be *false*.\n          1. For each Record { [[WeakRefTarget]], [[HeldValue]], [[UnregisterToken]] } _cell_ of _finalizationRegistry_.[[Cells]], do\n            1. If _cell_.[[UnregisterToken]] is not ~empty~ and SameValue(_cell_.[[UnregisterToken]], _unregisterToken_) is *true*, then\n              1. Remove _cell_ from _finalizationRegistry_.[[Cells]].\n              1. Set _removed_ to *true*.\n          1. Return _removed_.\n        ",
      {
        "normalizedName" : "INTRINSICS.FinalizationRegistry.prototype.unregister",
        "name" : "INTRINSICS.FinalizationRegistry.prototype.unregister",
        "htmlId" : "sec-finalization-registry.prototype.unregister",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    549,
    [
      "ForInOfStatement[7,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[7]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[7,0].ContainsDuplicateLabels",
        "name" : "ForInOfStatement[7,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2494,
    [
      "FindViaPredicate",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "len",
          false,
          "Int[0+]"
        ],
        [
          "direction",
          false,
          "Enum[~ascending~, ~descending~]"
        ],
        [
          "predicate",
          false,
          "ESValue"
        ],
        [
          "thisArg",
          false,
          "ESValue"
        ]
      ],
      "\n            1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.\n            1. If _direction_ is ~ascending~, then\n              1. Let _indices_ be a List of the integers in the interval from 0 (inclusive) to _len_ (exclusive), in ascending order.\n            1. Else,\n              1. Let _indices_ be a List of the integers in the interval from 0 (inclusive) to _len_ (exclusive), in descending order.\n            1. For each integer _k_ of _indices_, do\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. NOTE: If _O_ is a TypedArray, the following invocation of Get will return a normal completion.\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Let _testResult_ be ? Call(_predicate_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n              1. If ToBoolean(_testResult_) is *true*, return the Record { [[Index]]: 𝔽(_k_), [[Value]]: _kValue_ }.\n            1. Return the Record { [[Index]]: *-1*<sub>𝔽</sub>, [[Value]]: *undefined* }.\n          ",
      {
        "normalizedName" : "FindViaPredicate",
        "name" : "FindViaPredicate",
        "htmlId" : "sec-findviapredicate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1444,
    [
      "BindingProperty[1,0].PropertyBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingProperty[1]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n          1. Let _P_ be ? Evaluation of |PropertyName|.\n          1. Perform ? KeyedBindingInitialization of |BindingElement| with arguments _value_, _environment_, and _P_.\n          1. Return « _P_ ».\n        ",
      {
        "normalizedName" : "BindingProperty[1,0].PropertyBindingInitialization",
        "name" : "BindingProperty[1,0].PropertyBindingInitialization",
        "htmlId" : "sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingProperty",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PropertyName"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1442,
    [
      "BindingPropertyList[1,0].PropertyBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingPropertyList[1]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n          1. Let _boundNames_ be ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.\n          1. Let _nextNames_ be ? PropertyBindingInitialization of |BindingProperty| with arguments _value_ and _environment_.\n          1. Return the list-concatenation of _boundNames_ and _nextNames_.\n        ",
      {
        "normalizedName" : "BindingPropertyList[1,0].PropertyBindingInitialization",
        "name" : "BindingPropertyList[1,0].PropertyBindingInitialization",
        "htmlId" : "sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropertyBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingPropertyList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPropertyList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "BindingProperty"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2779,
    [
      "INTRINSICS.get Promise[@@species]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return the *this* value.\n        ",
      {
        "normalizedName" : "INTRINSICS.get Promise[@@species]",
        "name" : "INTRINSICS.get Promise[@@species]",
        "htmlId" : "sec-get-promise-@@species",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    536,
    [
      "ForStatement[1,2].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[1,2].ContainsDuplicateLabels",
        "name" : "ForStatement[1,2].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2019,
    [
      "ExportSpecifier[1,0].ReferencedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportSpecifier[1]]"
        ]
      ],
      "\n          1. Return the ReferencedBindings of the first |ModuleExportName|.\n        ",
      {
        "normalizedName" : "ExportSpecifier[1,0].ReferencedBindings",
        "name" : "ExportSpecifier[1,0].ReferencedBindings",
        "htmlId" : "sec-static-semantics-referencedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ReferencedBindings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportSpecifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              },
              {
                "type" : "terminal",
                "value" : "as"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    82,
    [
      "BinaryOr",
      0,
      [
        [
          "x",
          false,
          "Int[0, 1]"
        ],
        [
          "y",
          false,
          "Int[0, 1]"
        ]
      ],
      "\n            1. If _x_ = 1 or _y_ = 1, return 1.\n            1. Else, return 0.\n          ",
      {
        "normalizedName" : "BinaryOr",
        "name" : "BinaryOr",
        "htmlId" : "sec-binaryor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1045,
    [
      "Record[GlobalEnvironmentRecord].HasRestrictedGlobalProperty",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ]
      ],
      "\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n            1. Let _existingProp_ be ? <emu-meta effects=\"user-code\">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_).\n            1. If _existingProp_ is *undefined*, return *false*.\n            1. If _existingProp_.[[Configurable]] is *true*, return *false*.\n            1. Return *true*.\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].HasRestrictedGlobalProperty",
        "name" : "Record[GlobalEnvironmentRecord].HasRestrictedGlobalProperty",
        "htmlId" : "sec-hasrestrictedglobalproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "HasRestrictedGlobalProperty"
        ]
      }
    ]
  ],
  [
    716,
    [
      "AsyncFunctionExpression[0,1].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,1].HasName",
        "name" : "AsyncFunctionExpression[0,1].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    214,
    [
      "LexicalBinding[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[LexicalBinding[1]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingPattern|.\n      ",
      {
        "normalizedName" : "LexicalBinding[1,0].BoundNames",
        "name" : "LexicalBinding[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LexicalBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1161,
    [
      "Record[TypedArray].GetOwnProperty",
      4,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. If _P_ is a String, then\n            1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n            1. If _numericIndex_ is not *undefined*, then\n              1. Let _value_ be TypedArrayGetElement(_O_, _numericIndex_).\n              1. If _value_ is *undefined*, return *undefined*.\n              1. Return the PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n          1. Return OrdinaryGetOwnProperty(_O_, _P_).\n        ",
      {
        "normalizedName" : "Record[TypedArray].GetOwnProperty",
        "name" : "Record[TypedArray].GetOwnProperty",
        "htmlId" : "sec-typedarray-getownproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "TypedArray",
          "[[GetOwnProperty]]"
        ]
      }
    ]
  ],
  [
    1614,
    [
      "FunctionExpression[0,0].InstantiateOrdinaryFunctionExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ],
        [
          "name",
          true,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |FunctionExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Perform MakeConstructor(_closure_).\n        1. Return _closure_.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,0].InstantiateOrdinaryFunctionExpression",
        "name" : "FunctionExpression[0,0].InstantiateOrdinaryFunctionExpression",
        "htmlId" : "sec-runtime-semantics-instantiateordinaryfunctionexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateOrdinaryFunctionExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2421,
    [
      "NestedClass[2,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[NestedClass[2]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return CompileToCharSet of |CharacterClassEscape| with argument _rer_.\n        ",
      {
        "normalizedName" : "NestedClass[2,0].CompileToCharSet",
        "name" : "NestedClass[2,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "NestedClass",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "\\"
              },
              {
                "type" : "nonterminal",
                "value" : "CharacterClassEscape"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    800,
    [
      "PrimaryExpression[7,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[7]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[7,0].IsIdentifierRef",
        "name" : "PrimaryExpression[7,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "GeneratorExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    287,
    [
      "ExportDeclaration[0,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ExportDeclaration[0,0].IsConstantDeclaration",
        "name" : "ExportDeclaration[0,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "ExportFromClause"
              },
              {
                "type" : "nonterminal",
                "value" : "FromClause"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    432,
    [
      "VariableDeclarationList[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[VariableDeclarationList[0]]"
        ]
      ],
      "\n        1. Return « |VariableDeclaration| ».\n      ",
      {
        "normalizedName" : "VariableDeclarationList[0,0].VarScopedDeclarations",
        "name" : "VariableDeclarationList[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "VariableDeclarationList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "VariableDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    30,
    [
      "ToBoolean",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If _argument_ is a Boolean, return _argument_.\n        1. If _argument_ is one of *undefined*, *null*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *NaN*, *0*<sub>ℤ</sub>, or the empty String, return *false*.\n        1. [id=\"step-to-boolean-web-compat-insertion-point\"] NOTE: This step is replaced in section <emu-xref href=\"#sec-IsHTMLDDA-internal-slot-to-boolean\"></emu-xref>.\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "ToBoolean",
        "name" : "ToBoolean",
        "htmlId" : "sec-toboolean",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1546,
    [
      "Statement[11,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[11]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |Statement|.\n      ",
      {
        "normalizedName" : "Statement[11,0].LabelledEvaluation",
        "name" : "Statement[11,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 11,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ThrowStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    818,
    [
      "FunctionExpression[0,0].NamedEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionExpression[0]]"
        ],
        [
          "name",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression| with argument _name_.\n      ",
      {
        "normalizedName" : "FunctionExpression[0,0].NamedEvaluation",
        "name" : "FunctionExpression[0,0].NamedEvaluation",
        "htmlId" : "sec-runtime-semantics-namedevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NamedEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2522,
    [
      "INTRINSICS.Array.prototype.toSpliced",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ is -∞, let _actualStart_ be 0.\n          1. Else if _relativeStart_ < 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _actualStart_ be min(_relativeStart_, _len_).\n          1. Let _insertCount_ be the number of elements in _items_.\n          1. If _start_ is not present, then\n            1. Let _actualSkipCount_ be 0.\n          1. Else if _skipCount_ is not present, then\n            1. Let _actualSkipCount_ be _len_ - _actualStart_.\n          1. Else,\n            1. Let _sc_ be ? ToIntegerOrInfinity(_skipCount_).\n            1. Let _actualSkipCount_ be the result of clamping _sc_ between 0 and _len_ - _actualStart_.\n          1. Let _newLen_ be _len_ + _insertCount_ - _actualSkipCount_.\n          1. If _newLen_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n          1. Let _A_ be ? ArrayCreate(_newLen_).\n          1. Let _i_ be 0.\n          1. Let _r_ be _actualStart_ + _actualSkipCount_.\n          1. Repeat, while _i_ < _actualStart_,\n            1. Let _Pi_ be ! ToString(𝔽(_i_)).\n            1. Let _iValue_ be ? Get(_O_, _Pi_).\n            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _iValue_).\n            1. Set _i_ to _i_ + 1.\n          1. For each element _E_ of _items_, do\n            1. Let _Pi_ be ! ToString(𝔽(_i_)).\n            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _E_).\n            1. Set _i_ to _i_ + 1.\n          1. Repeat, while _i_ < _newLen_,\n            1. Let _Pi_ be ! ToString(𝔽(_i_)).\n            1. Let _from_ be ! ToString(𝔽(_r_)).\n            1. Let _fromValue_ be ? Get(_O_, _from_).\n            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _fromValue_).\n            1. Set _i_ to _i_ + 1.\n            1. Set _r_ to _r_ + 1.\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.toSpliced",
        "name" : "INTRINSICS.Array.prototype.toSpliced",
        "htmlId" : "sec-array.prototype.tospliced",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    405,
    [
      "LabelledStatement[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |LabelledItem|.\n      ",
      {
        "normalizedName" : "LabelledStatement[0,0].VarDeclaredNames",
        "name" : "LabelledStatement[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelledItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1876,
    [
      "PrimaryExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[1,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierReference"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    735,
    [
      "LeftHandSideExpression[2,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[LeftHandSideExpression[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "LeftHandSideExpression[2,0].IsFunctionDefinition",
        "name" : "LeftHandSideExpression[2,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "LeftHandSideExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2003,
    [
      "ModuleItem[2,0].ExportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[2]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ModuleItem[2,0].ExportEntries",
        "name" : "ModuleItem[2,0].ExportEntries",
        "htmlId" : "sec-static-semantics-exportentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntries",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2142,
    [
      "INTRINSICS.Math.hypot",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _coerced_ be a new empty List.\n          1. For each element _arg_ of _args_, do\n            1. Let _n_ be ? ToNumber(_arg_).\n            1. Append _n_ to _coerced_.\n          1. For each element _number_ of _coerced_, do\n            1. If _number_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n          1. Let _onlyZero_ be *true*.\n          1. For each element _number_ of _coerced_, do\n            1. If _number_ is *NaN*, return *NaN*.\n            1. If _number_ is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>, set _onlyZero_ to *false*.\n          1. If _onlyZero_ is *true*, return *+0*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the square root of the sum of squares of the mathematical values of the elements of _coerced_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.hypot",
        "name" : "INTRINSICS.Math.hypot",
        "htmlId" : "sec-math.hypot",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1116,
    [
      "GeneratorBody[0,0].EvaluateBody",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorBody[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Return ? EvaluateGeneratorBody of |GeneratorBody| with arguments _functionObject_ and _argumentsList_.\n        ",
      {
        "normalizedName" : "GeneratorBody[0,0].EvaluateBody",
        "name" : "GeneratorBody[0,0].EvaluateBody",
        "htmlId" : "sec-runtime-semantics-evaluatebody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1908,
    [
      "PrimaryExpression[12,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[12]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return HasCallInTailPosition of _expr_ with argument _call_.\n      ",
      {
        "normalizedName" : "PrimaryExpression[12,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[12,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 12,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2123,
    [
      "INTRINSICS.BigInt.prototype.valueOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return ? ThisBigIntValue(*this* value).\n        ",
      {
        "normalizedName" : "INTRINSICS.BigInt.prototype.valueOf",
        "name" : "INTRINSICS.BigInt.prototype.valueOf",
        "htmlId" : "sec-bigint.prototype.valueof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2218,
    [
      "INTRINSICS.Date.prototype.setUTCHours",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _h_ be ? ToNumber(_hour_).\n          1. If _min_ is present, let _m_ be ? ToNumber(_min_).\n          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. If _min_ is not present, let _m_ be MinFromTime(_t_).\n          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).\n          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n          1. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).\n          1. Let _v_ be TimeClip(_date_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.setUTCHours",
        "name" : "INTRINSICS.Date.prototype.setUTCHours",
        "htmlId" : "sec-date.prototype.setutchours",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    151,
    [
      "IsPropertyKey",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If _argument_ is a String, return *true*.\n        1. If _argument_ is a Symbol, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "IsPropertyKey",
        "name" : "IsPropertyKey",
        "htmlId" : "sec-ispropertykey",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2258,
    [
      "INTRINSICS.String.prototype.repeat",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _n_ be ? ToIntegerOrInfinity(_count_).\n          1. If _n_ < 0 or _n_ = +∞, throw a *RangeError* exception.\n          1. If _n_ = 0, return the empty String.\n          1. Return the String value that is made from _n_ copies of _S_ appended together.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.repeat",
        "name" : "INTRINSICS.String.prototype.repeat",
        "htmlId" : "sec-string.prototype.repeat",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1133,
    [
      "FunctionDeclarationInstantiation",
      0,
      [
        [
          "func",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n        1. Let _calleeContext_ be the running execution context.\n        1. Let _code_ be _func_.[[ECMAScriptCode]].\n        1. Let _strict_ be _func_.[[Strict]].\n        1. Let _formals_ be _func_.[[FormalParameters]].\n        1. Let _parameterNames_ be the BoundNames of _formals_.\n        1. If _parameterNames_ has any duplicate entries, let _hasDuplicates_ be *true*. Otherwise, let _hasDuplicates_ be *false*.\n        1. Let _simpleParameterList_ be IsSimpleParameterList of _formals_.\n        1. Let _hasParameterExpressions_ be ContainsExpression of _formals_.\n        1. Let _varNames_ be the VarDeclaredNames of _code_.\n        1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.\n        1. Let _lexicalNames_ be the LexicallyDeclaredNames of _code_.\n        1. Let _functionNames_ be a new empty List.\n        1. Let _functionsToInitialize_ be a new empty List.\n        1. For each element _d_ of _varDeclarations_, in reverse List order, do\n          1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then\n            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.\n            1. Let _fn_ be the sole element of the BoundNames of _d_.\n            1. If _functionNames_ does not contain _fn_, then\n              1. Insert _fn_ as the first element of _functionNames_.\n              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.\n              1. Insert _d_ as the first element of _functionsToInitialize_.\n        1. Let _argumentsObjectNeeded_ be *true*.\n        1. If _func_.[[ThisMode]] is ~lexical~, then\n          1. NOTE: Arrow functions never have an arguments object.\n          1. Set _argumentsObjectNeeded_ to *false*.\n        1. Else if _parameterNames_ contains *\"arguments\"*, then\n          1. Set _argumentsObjectNeeded_ to *false*.\n        1. Else if _hasParameterExpressions_ is *false*, then\n          1. If _functionNames_ contains *\"arguments\"* or _lexicalNames_ contains *\"arguments\"*, then\n            1. Set _argumentsObjectNeeded_ to *false*.\n        1. If _strict_ is *true* or _hasParameterExpressions_ is *false*, then\n          1. NOTE: Only a single Environment Record is needed for the parameters, since calls to `eval` in strict mode code cannot create new bindings which are visible outside of the `eval`.\n          1. Let _env_ be the LexicalEnvironment of _calleeContext_.\n        1. Else,\n          1. NOTE: A separate Environment Record is needed to ensure that bindings created by direct eval calls in the formal parameter list are outside the environment where parameters are declared.\n          1. Let _calleeEnv_ be the LexicalEnvironment of _calleeContext_.\n          1. Let _env_ be NewDeclarativeEnvironment(_calleeEnv_).\n          1. Assert: The VariableEnvironment of _calleeContext_ is _calleeEnv_.\n          1. Set the LexicalEnvironment of _calleeContext_ to _env_.\n        1. For each String _paramName_ of _parameterNames_, do\n          1. Let _alreadyDeclared_ be ! _env_.HasBinding(_paramName_).\n          1. NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.\n          1. If _alreadyDeclared_ is *false*, then\n            1. Perform ! _env_.CreateMutableBinding(_paramName_, *false*).\n            1. If _hasDuplicates_ is *true*, then\n              1. Perform ! _env_.InitializeBinding(_paramName_, *undefined*).\n        1. If _argumentsObjectNeeded_ is *true*, then\n          1. If _strict_ is *true* or _simpleParameterList_ is *false*, then\n            1. Let _ao_ be CreateUnmappedArgumentsObject(_argumentsList_).\n          1. Else,\n            1. NOTE: A mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.\n            1. Let _ao_ be CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _env_).\n          1. If _strict_ is *true*, then\n            1. Perform ! _env_.CreateImmutableBinding(*\"arguments\"*, *false*).\n            1. NOTE: In strict mode code early errors prevent attempting to assign to this binding, so its mutability is not observable.\n          1. Else,\n            1. Perform ! _env_.CreateMutableBinding(*\"arguments\"*, *false*).\n          1. Perform ! _env_.InitializeBinding(*\"arguments\"*, _ao_).\n          1. Let _parameterBindings_ be the list-concatenation of _parameterNames_ and « *\"arguments\"* ».\n        1. Else,\n          1. Let _parameterBindings_ be _parameterNames_.\n        1. Let _iteratorRecord_ be CreateListIteratorRecord(_argumentsList_).\n        1. If _hasDuplicates_ is *true*, then\n          1. Perform ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and *undefined*.\n        1. Else,\n          1. Perform ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _env_.\n        1. If _hasParameterExpressions_ is *false*, then\n          1. NOTE: Only a single Environment Record is needed for the parameters and top-level vars.\n          1. Let _instantiatedVarNames_ be a copy of the List _parameterBindings_.\n          1. For each element _n_ of _varNames_, do\n            1. If _instantiatedVarNames_ does not contain _n_, then\n              1. Append _n_ to _instantiatedVarNames_.\n              1. Perform ! _env_.CreateMutableBinding(_n_, *false*).\n              1. Perform ! _env_.InitializeBinding(_n_, *undefined*).\n          1. Let _varEnv_ be _env_.\n        1. Else,\n          1. NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.\n          1. Let _varEnv_ be NewDeclarativeEnvironment(_env_).\n          1. Set the VariableEnvironment of _calleeContext_ to _varEnv_.\n          1. Let _instantiatedVarNames_ be a new empty List.\n          1. For each element _n_ of _varNames_, do\n            1. If _instantiatedVarNames_ does not contain _n_, then\n              1. Append _n_ to _instantiatedVarNames_.\n              1. Perform ! _varEnv_.CreateMutableBinding(_n_, *false*).\n              1. If _parameterBindings_ does not contain _n_, or if _functionNames_ contains _n_, then\n                1. Let _initialValue_ be *undefined*.\n              1. Else,\n                1. Let _initialValue_ be ! _env_.GetBindingValue(_n_, *false*).\n              1. Perform ! _varEnv_.InitializeBinding(_n_, _initialValue_).\n              1. NOTE: A var with the same name as a formal parameter initially has the same value as the corresponding initialized parameter.\n        1. [id=\"step-functiondeclarationinstantiation-web-compat-insertion-point\"] NOTE: Annex <emu-xref href=\"#sec-web-compat-functiondeclarationinstantiation\"></emu-xref> adds additional steps at this point.\n        1. If _strict_ is *false*, then\n          1. Let _lexEnv_ be NewDeclarativeEnvironment(_varEnv_).\n          1. NOTE: Non-strict functions use a separate Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.\n        1. Else,\n          1. Let _lexEnv_ be _varEnv_.\n        1. Set the LexicalEnvironment of _calleeContext_ to _lexEnv_.\n        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.\n        1. For each element _d_ of _lexDeclarations_, do\n          1. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.\n          1. For each element _dn_ of the BoundNames of _d_, do\n            1. If IsConstantDeclaration of _d_ is *true*, then\n              1. Perform ! _lexEnv_.CreateImmutableBinding(_dn_, *true*).\n            1. Else,\n              1. Perform ! _lexEnv_.CreateMutableBinding(_dn_, *false*).\n        1. Let _privateEnv_ be the PrivateEnvironment of _calleeContext_.\n        1. For each Parse Node _f_ of _functionsToInitialize_, do\n          1. Let _fn_ be the sole element of the BoundNames of _f_.\n          1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_.\n          1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "FunctionDeclarationInstantiation",
        "name" : "FunctionDeclarationInstantiation",
        "htmlId" : "sec-functiondeclarationinstantiation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2374,
    [
      "Atom[3,0].CompileAtom",
      2,
      [
        [
          "this",
          false,
          "Ast[Atom[3]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Let _cc_ be CompileCharacterClass of |CharacterClass| with argument _rer_.\n          1. Let _cs_ be _cc_.[[CharSet]].\n          1. If _rer_.[[UnicodeSets]] is *false*, or if every CharSetElement of _cs_ consists of a single character (including if _cs_ is empty), return CharacterSetMatcher(_rer_, _cs_, _cc_.[[Invert]], _direction_).\n          1. Assert: _cc_.[[Invert]] is *false*.\n          1. Let _lm_ be an empty List of Matchers.\n          1. For each CharSetElement _s_ in _cs_ containing more than 1 character, iterating in descending order of length, do\n            1. Let _cs2_ be a one-element CharSet containing the last code point of _s_.\n            1. Let _m2_ be CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_).\n            1. For each code point _c1_ in _s_, iterating backwards from its second-to-last code point, do\n              1. Let _cs1_ be a one-element CharSet containing _c1_.\n              1. Let _m1_ be CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_).\n              1. Set _m2_ to MatchSequence(_m1_, _m2_, _direction_).\n            1. Append _m2_ to _lm_.\n          1. Let _singles_ be the CharSet containing every CharSetElement of _cs_ that consists of a single character.\n          1. Append CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) to _lm_.\n          1. If _cs_ contains the empty sequence of characters, append EmptyMatcher() to _lm_.\n          1. Let _m2_ be the last Matcher in _lm_.\n          1. For each Matcher _m1_ of _lm_, iterating backwards from its second-to-last element, do\n            1. Set _m2_ to MatchTwoAlternatives(_m1_, _m2_).\n          1. Return _m2_.\n        ",
      {
        "normalizedName" : "Atom[3,0].CompileAtom",
        "name" : "Atom[3,0].CompileAtom",
        "htmlId" : "sec-compileatom",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAtom",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "Atom",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CharacterClass"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    300,
    [
      "CaseClause[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the LexicallyDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "CaseClause[0,0].LexicallyDeclaredNames",
        "name" : "CaseClause[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1348,
    [
      "UpdateExpression[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[UpdateExpression[2]]"
        ]
      ],
      "\n          1. Let _lhs_ be ? Evaluation of |LeftHandSideExpression|.\n          1. Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).\n          1. If _oldValue_ is a Number, then\n            1. Let _newValue_ be Number::subtract(_oldValue_, *1*<sub>𝔽</sub>).\n          1. Else,\n            1. Assert: _oldValue_ is a BigInt.\n            1. Let _newValue_ be BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>).\n          1. Perform ? PutValue(_lhs_, _newValue_).\n          1. Return _oldValue_.\n        ",
      {
        "normalizedName" : "UpdateExpression[2,0].Evaluation",
        "name" : "UpdateExpression[2,0].Evaluation",
        "htmlId" : "sec-postfix-decrement-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "UpdateExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "--"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    999,
    [
      "MethodDefinition[5,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[5]]"
        ]
      ],
      "\n        1. Return PropName of |ClassElementName|.\n      ",
      {
        "normalizedName" : "MethodDefinition[5,0].PropName",
        "name" : "MethodDefinition[5,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "set"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "PropertySetParameterList"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2287,
    [
      "ClassEscape[3,0].IsCharacterClass",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassEscape[3]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ClassEscape[3,0].IsCharacterClass",
        "name" : "ClassEscape[3,0].IsCharacterClass",
        "htmlId" : "sec-patterns-static-semantics-is-character-class",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsCharacterClass",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ClassEscape",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CharacterEscape"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    620,
    [
      "CaseBlock[1,2].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,2].ContainsUndefinedBreakTarget",
        "name" : "CaseBlock[1,2].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1642,
    [
      "MethodDefinition[5,0].MethodDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[5]]"
        ],
        [
          "object",
          false,
          "Record[Object]"
        ],
        [
          "enumerable",
          false,
          "Boolean"
        ]
      ],
      "\n        1. Let _propKey_ be ? Evaluation of |ClassElementName|.\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |MethodDefinition|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |PropertySetParameterList|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform MakeMethod(_closure_, _object_).\n        1. Perform SetFunctionName(_closure_, _propKey_, *\"set\"*).\n        1. If _propKey_ is a Private Name, then\n          1. Return PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: *undefined*, [[Set]]: _closure_ }.\n        1. Else,\n          1. Let _desc_ be the PropertyDescriptor { [[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.\n          1. Perform ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).\n          1. Return ~unused~.\n      ",
      {
        "normalizedName" : "MethodDefinition[5,0].MethodDefinitionEvaluation",
        "name" : "MethodDefinition[5,0].MethodDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-methoddefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MethodDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "set"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "PropertySetParameterList"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2102,
    [
      "INTRINSICS.Error",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.\n          1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%Error.prototype%\"*, « [[ErrorData]] »).\n          1. If _message_ is not *undefined*, then\n            1. Let _msg_ be ? ToString(_message_).\n            1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *\"message\"*, _msg_).\n          1. Perform ? InstallErrorCause(_O_, _options_).\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Error",
        "name" : "INTRINSICS.Error",
        "htmlId" : "sec-error-message",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    752,
    [
      "ShiftExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[ShiftExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ShiftExpression[1,0].IsFunctionDefinition",
        "name" : "ShiftExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ShiftExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              },
              {
                "type" : "terminal",
                "value" : "<<"
              },
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1512,
    [
      "ContinueStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ContinueStatement[0]]"
        ]
      ],
      "\n        1. Return Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.\n      ",
      {
        "normalizedName" : "ContinueStatement[0,0].Evaluation",
        "name" : "ContinueStatement[0,0].Evaluation",
        "htmlId" : "sec-continue-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ContinueStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "continue"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1774,
    [
      "Statement[13,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[13]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[13,0].HasCallInTailPosition",
        "name" : "Statement[13,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 13,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DebuggerStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2302,
    [
      "HexNonSurrogate[0,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[HexNonSurrogate[0]]"
        ]
      ],
      "\n          1. Return the MV of |Hex4Digits|.\n        ",
      {
        "normalizedName" : "HexNonSurrogate[0,0].CharacterValue",
        "name" : "HexNonSurrogate[0,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "HexNonSurrogate",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Hex4Digits"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2517,
    [
      "INTRINSICS.Array.prototype.splice",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _actualStart_ be 0.\n          1. Else if _relativeStart_ < 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _actualStart_ be min(_relativeStart_, _len_).\n          1. Let _itemCount_ be the number of elements in _items_.\n          1. If _start_ is not present, then\n            1. Let _actualDeleteCount_ be 0.\n          1. Else if _deleteCount_ is not present, then\n            1. Let _actualDeleteCount_ be _len_ - _actualStart_.\n          1. Else,\n            1. Let _dc_ be ? ToIntegerOrInfinity(_deleteCount_).\n            1. Let _actualDeleteCount_ be the result of clamping _dc_ between 0 and _len_ - _actualStart_.\n          1. If _len_ + _itemCount_ - _actualDeleteCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, _actualDeleteCount_).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _actualDeleteCount_,\n            1. Let _from_ be ! ToString(𝔽(_actualStart_ + _k_)).\n            1. If ? HasProperty(_O_, _from_) is *true*, then\n              1. Let _fromValue_ be ? Get(_O_, _from_).\n              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_k_)), _fromValue_).\n            1. Set _k_ to _k_ + 1.\n          1. [id=\"step-array-proto-splice-set-length\"] Perform ? Set(_A_, *\"length\"*, 𝔽(_actualDeleteCount_), *true*).\n          1. If _itemCount_ < _actualDeleteCount_, then\n            1. Set _k_ to _actualStart_.\n            1. Repeat, while _k_ < (_len_ - _actualDeleteCount_),\n              1. Let _from_ be ! ToString(𝔽(_k_ + _actualDeleteCount_)).\n              1. Let _to_ be ! ToString(𝔽(_k_ + _itemCount_)).\n              1. If ? HasProperty(_O_, _from_) is *true*, then\n                1. Let _fromValue_ be ? Get(_O_, _from_).\n                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).\n              1. Else,\n                1. Perform ? DeletePropertyOrThrow(_O_, _to_).\n              1. Set _k_ to _k_ + 1.\n            1. Set _k_ to _len_.\n            1. Repeat, while _k_ > (_len_ - _actualDeleteCount_ + _itemCount_),\n              1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_k_ - 1))).\n              1. Set _k_ to _k_ - 1.\n          1. Else if _itemCount_ > _actualDeleteCount_, then\n            1. Set _k_ to (_len_ - _actualDeleteCount_).\n            1. Repeat, while _k_ > _actualStart_,\n              1. Let _from_ be ! ToString(𝔽(_k_ + _actualDeleteCount_ - 1)).\n              1. Let _to_ be ! ToString(𝔽(_k_ + _itemCount_ - 1)).\n              1. If ? HasProperty(_O_, _from_) is *true*, then\n                1. Let _fromValue_ be ? Get(_O_, _from_).\n                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).\n              1. Else,\n                1. Perform ? DeletePropertyOrThrow(_O_, _to_).\n              1. Set _k_ to _k_ - 1.\n          1. Set _k_ to _actualStart_.\n          1. For each element _E_ of _items_, do\n            1. Perform ? Set(_O_, ! ToString(𝔽(_k_)), _E_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. [id=\"step-array-proto-splice-set-length-2\"] Perform ? Set(_O_, *\"length\"*, 𝔽(_len_ - _actualDeleteCount_ + _itemCount_), *true*).\n          1. Return _A_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.splice",
        "name" : "INTRINSICS.Array.prototype.splice",
        "htmlId" : "sec-array.prototype.splice",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2683,
    [
      "INTRINSICS.DataView.prototype.setBigUint64",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~biguint64~, _value_).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.setBigUint64",
        "name" : "INTRINSICS.DataView.prototype.setBigUint64",
        "htmlId" : "sec-dataview.prototype.setbiguint64",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    447,
    [
      "ForStatement[1,1].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "ForStatement[1,1].VarScopedDeclarations",
        "name" : "ForStatement[1,1].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    315,
    [
      "ModuleItemList[1,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be LexicallyDeclaredNames of |ModuleItemList|.\n        1. Let _names2_ be LexicallyDeclaredNames of |ModuleItem|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ModuleItemList[1,0].LexicallyDeclaredNames",
        "name" : "ModuleItemList[1,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1725,
    [
      "FieldDefinition[0,0].ClassFieldDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[FieldDefinition[0]]"
        ],
        [
          "homeObject",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Let _name_ be ? Evaluation of |ClassElementName|.\n        1. If |Initializer| is present, then\n          1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.\n          1. Let _env_ be the LexicalEnvironment of the running execution context.\n          1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n          1. Let _sourceText_ be the empty sequence of Unicode code points.\n          1. Let _initializer_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |Initializer|, ~non-lexical-this~, _env_, _privateEnv_).\n          1. Perform MakeMethod(_initializer_, _homeObject_).\n          1. Set _initializer_.[[ClassFieldInitializerName]] to _name_.\n        1. Else,\n          1. Let _initializer_ be ~empty~.\n        1. Return the ClassFieldDefinition Record { [[Name]]: _name_, [[Initializer]]: _initializer_ }.\n      ",
      {
        "normalizedName" : "FieldDefinition[0,0].ClassFieldDefinitionEvaluation",
        "name" : "FieldDefinition[0,0].ClassFieldDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-classfielddefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassFieldDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FieldDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1280,
    [
      "TemplateLiteral[0,0].TemplateStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateLiteral[0]]"
        ],
        [
          "raw",
          false,
          "Boolean"
        ]
      ],
      "\n          1. Return « TemplateString(|NoSubstitutionTemplate|, _raw_) ».\n        ",
      {
        "normalizedName" : "TemplateLiteral[0,0].TemplateStrings",
        "name" : "TemplateLiteral[0,0].TemplateStrings",
        "htmlId" : "sec-static-semantics-templatestrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TemplateStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TemplateLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NoSubstitutionTemplate"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1578,
    [
      "FormalParameters[4,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameters[4]]"
        ]
      ],
      "\n        1. If ContainsExpression of |FormalParameterList| is *true*, return *true*.\n        1. Return ContainsExpression of |FunctionRestParameter|.\n      ",
      {
        "normalizedName" : "FormalParameters[4,0].ContainsExpression",
        "name" : "FormalParameters[4,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "FormalParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameterList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionRestParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1957,
    [
      "ModuleItem[1,0].ImportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[1]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ModuleItem[1,0].ImportEntries",
        "name" : "ModuleItem[1,0].ImportEntries",
        "htmlId" : "sec-static-semantics-importentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntries",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2385,
    [
      "CharacterClass[0,0].CompileCharacterClass",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClass[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.\n          1. Return the Record { [[CharSet]]: _A_, [[Invert]]: *false* }.\n        ",
      {
        "normalizedName" : "CharacterClass[0,0].CompileCharacterClass",
        "name" : "CharacterClass[0,0].CompileCharacterClass",
        "htmlId" : "sec-compilecharacterclass",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileCharacterClass",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CharacterClass",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "ClassContents"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1678,
    [
      "ClassElementList[1,0].NonConstructorElements",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementList[1]]"
        ]
      ],
      "\n        1. Let _list_ be NonConstructorElements of |ClassElementList|.\n        1. If ClassElementKind of |ClassElement| is ~non-constructor-method~, then\n          1. Append |ClassElement| to the end of _list_.\n        1. Return _list_.\n      ",
      {
        "normalizedName" : "ClassElementList[1,0].NonConstructorElements",
        "name" : "ClassElementList[1,0].NonConstructorElements",
        "htmlId" : "sec-static-semantics-nonconstructorelements",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NonConstructorElements",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementList"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2155,
    [
      "INTRINSICS.Math.sqrt",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ < *-0*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the square root of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.sqrt",
        "name" : "INTRINSICS.Math.sqrt",
        "htmlId" : "sec-math.sqrt",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2534,
    [
      "INTRINSICS.TypedArray.prototype.at",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n          1. If _relativeIndex_ ≥ 0, then\n            1. Let _k_ be _relativeIndex_.\n          1. Else,\n            1. Let _k_ be _len_ + _relativeIndex_.\n          1. If _k_ < 0 or _k_ ≥ _len_, return *undefined*.\n          1. Return ! Get(_O_, ! ToString(𝔽(_k_))).\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.at",
        "name" : "INTRINSICS.TypedArray.prototype.at",
        "htmlId" : "sec-%typedarray%.prototype.at",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2255,
    [
      "StringPaddingBuiltinsImpl",
      0,
      [
        [
          "O",
          false,
          "ESValue"
        ],
        [
          "maxLength",
          false,
          "ESValue"
        ],
        [
          "fillString",
          false,
          "ESValue"
        ],
        [
          "placement",
          false,
          "Enum[~end~, ~start~]"
        ]
      ],
      "\n            1. Let _S_ be ? ToString(_O_).\n            1. Let _intMaxLength_ be ℝ(? ToLength(_maxLength_)).\n            1. Let _stringLength_ be the length of _S_.\n            1. If _intMaxLength_ ≤ _stringLength_, return _S_.\n            1. If _fillString_ is *undefined*, set _fillString_ to the String value consisting solely of the code unit 0x0020 (SPACE).\n            1. Else, set _fillString_ to ? ToString(_fillString_).\n            1. Return StringPad(_S_, _intMaxLength_, _fillString_, _placement_).\n          ",
      {
        "normalizedName" : "StringPaddingBuiltinsImpl",
        "name" : "StringPaddingBuiltinsImpl",
        "htmlId" : "sec-stringpaddingbuiltinsimpl",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    833,
    [
      "GeneratorExpression[0,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,0].Contains",
        "name" : "GeneratorExpression[0,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    410,
    [
      "Catch[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[Catch[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Block|.\n      ",
      {
        "normalizedName" : "Catch[0,0].VarDeclaredNames",
        "name" : "Catch[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Catch",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "catch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "CatchParameter"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    36,
    [
      "__HAS_DUPLICATE__",
      8,
      [
        [
          "list",
          false,
          "List"
        ]
      ],
      "",
      null
    ]
  ],
  [
    967,
    [
      "RelationalExpression[5,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[5]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "RelationalExpression[5,0].AssignmentTargetType",
        "name" : "RelationalExpression[5,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "instanceof"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2719,
    [
      "INTRINSICS.Atomics.or",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _or_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:\n          1. Return ByteListBitwiseOp(`|`, _xBytes_, _yBytes_).\n        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _or_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.or",
        "name" : "INTRINSICS.Atomics.or",
        "htmlId" : "sec-atomics.or",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    950,
    [
      "UnaryExpression[3,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[3]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "UnaryExpression[3,0].AssignmentTargetType",
        "name" : "UnaryExpression[3,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "typeof"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1097,
    [
      "OrdinaryHasProperty",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. Let _hasOwn_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. If _hasOwn_ is not *undefined*, return *true*.\n          1. Let _parent_ be ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]</emu-meta>().\n          1. If _parent_ is not *null*, then\n            1. Return ? <emu-meta effects=\"user-code\">_parent_.[[HasProperty]]</emu-meta>(_P_).\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "OrdinaryHasProperty",
        "name" : "OrdinaryHasProperty",
        "htmlId" : "sec-ordinaryhasproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    168,
    [
      "DeletePropertyOrThrow",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n        1. Let _success_ be ? <emu-meta effects=\"user-code\">_O_.[[Delete]]</emu-meta>(_P_).\n        1. If _success_ is *false*, throw a *TypeError* exception.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "DeletePropertyOrThrow",
        "name" : "DeletePropertyOrThrow",
        "htmlId" : "sec-deletepropertyorthrow",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    835,
    [
      "AsyncGeneratorDeclaration[0,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorDeclaration[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorDeclaration[0,0].Contains",
        "name" : "AsyncGeneratorDeclaration[0,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    262,
    [
      "ExportDeclaration[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[1]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ExportDeclaration[1,0].BoundNames",
        "name" : "ExportDeclaration[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "NamedExports"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2587,
    [
      "AddEntriesFromIterable",
      0,
      [
        [
          "target",
          false,
          "Record[Object]"
        ],
        [
          "iterable",
          false,
          "Unknown[\"ECMAScriptLanguageValue,ButNot*undefined*Or*null*\"]"
        ],
        [
          "adder",
          false,
          "Record[FunctionObject]"
        ]
      ],
      "\n          1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).\n          1. Repeat,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is ~done~, return _target_.\n            1. If _next_ is not an Object, then\n              1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).\n              1. Return ? IteratorClose(_iteratorRecord_, _error_).\n            1. Let _k_ be Completion(Get(_next_, *\"0\"*)).\n            1. IfAbruptCloseIterator(_k_, _iteratorRecord_).\n            1. Let _v_ be Completion(Get(_next_, *\"1\"*)).\n            1. IfAbruptCloseIterator(_v_, _iteratorRecord_).\n            1. Let _status_ be Completion(Call(_adder_, _target_, « _k_, _v_ »)).\n            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).\n        ",
      {
        "normalizedName" : "AddEntriesFromIterable",
        "name" : "AddEntriesFromIterable",
        "htmlId" : "sec-add-entries-from-iterable",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    146,
    [
      "IsArray",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. If _argument_ is not an Object, return *false*.\n        1. If _argument_ is an Array exotic object, return *true*.\n        1. If _argument_ is a Proxy exotic object, then\n          1. Perform ? ValidateNonRevokedProxy(_argument_).\n          1. Let _proxyTarget_ be _argument_.[[ProxyTarget]].\n          1. Return ? IsArray(_proxyTarget_).\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "IsArray",
        "name" : "IsArray",
        "htmlId" : "sec-isarray",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1229,
    [
      "IdentifierReference[1,0].StringValue",
      2,
      [
        [
          "this",
          false,
          "Ast[IdentifierReference[1]]"
        ]
      ],
      "\n        1. Return *\"yield\"*.\n      ",
      {
        "normalizedName" : "IdentifierReference[1,0].StringValue",
        "name" : "IdentifierReference[1,0].StringValue",
        "htmlId" : "sec-static-semantics-stringvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "IdentifierReference",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "yield"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2233,
    [
      "INTRINSICS.Date.prototype.valueOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Return _dateObject_.[[DateValue]].\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.valueOf",
        "name" : "INTRINSICS.Date.prototype.valueOf",
        "htmlId" : "sec-date.prototype.valueof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1625,
    [
      "ArrowFunction[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowFunction[0]]"
        ]
      ],
      "\n        1. Return InstantiateArrowFunctionExpression of |ArrowFunction|.\n      ",
      {
        "normalizedName" : "ArrowFunction[0,0].Evaluation",
        "name" : "ArrowFunction[0,0].Evaluation",
        "htmlId" : "sec-arrow-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrowFunction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrowParameters"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "ConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1395,
    [
      "ObjectAssignmentPattern[3,1].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectAssignmentPattern[3]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Perform ? RequireObjectCoercible(_value_).\n          1. Let _excludedNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.\n          1. Return ? RestDestructuringAssignmentEvaluation of |AssignmentRestProperty| with arguments _value_ and _excludedNames_.\n        ",
      {
        "normalizedName" : "ObjectAssignmentPattern[3,1].DestructuringAssignmentEvaluation",
        "name" : "ObjectAssignmentPattern[3,1].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 1,
            "astName" : "ObjectAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentPropertyList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentRestProperty"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    51,
    [
      "Number::unaryMinus",
      1,
      [
        [
          "x",
          false,
          "Number"
        ]
      ],
      "\n            1. If _x_ is *NaN*, return *NaN*.\n            1. Return the result of negating _x_; that is, compute a Number with the same magnitude but opposite sign.\n          ",
      {
        "normalizedName" : "Number::unaryMinus",
        "name" : "Number::unaryMinus",
        "htmlId" : "sec-numeric-types-number-unaryMinus",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1593,
    [
      "ArrowParameters[1,0].IsSimpleParameterList",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowParameters[1]]"
        ]
      ],
      "\n        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return IsSimpleParameterList of _formals_.\n      ",
      {
        "normalizedName" : "ArrowParameters[1,0].IsSimpleParameterList",
        "name" : "ArrowParameters[1,0].IsSimpleParameterList",
        "htmlId" : "sec-static-semantics-issimpleparameterlist",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsSimpleParameterList",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ArrowParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CoverParenthesizedExpressionAndArrowParameterList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1380,
    [
      "LogicalANDExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[LogicalANDExpression[1]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |LogicalANDExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _lbool_ be ToBoolean(_lval_).\n        1. If _lbool_ is *false*, return _lval_.\n        1. Let _rref_ be ? Evaluation of |BitwiseORExpression|.\n        1. Return ? GetValue(_rref_).\n      ",
      {
        "normalizedName" : "LogicalANDExpression[1,0].Evaluation",
        "name" : "LogicalANDExpression[1,0].Evaluation",
        "htmlId" : "sec-binary-logical-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LogicalANDExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LogicalANDExpression"
              },
              {
                "type" : "terminal",
                "value" : "&&"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseORExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2604,
    [
      "INTRINSICS.get Set[@@species]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Return the *this* value.\n        ",
      {
        "normalizedName" : "INTRINSICS.get Set[@@species]",
        "name" : "INTRINSICS.get Set[@@species]",
        "htmlId" : "sec-get-set-@@species",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2815,
    [
      "AsyncGeneratorResume:cont0",
      7,
      [
        [
          "result",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Assert: _generator_.[[AsyncGeneratorState]] is either ~suspended-start~ or ~suspended-yield~.\n          1. Let _genContext_ be _generator_.[[AsyncGeneratorContext]].\n          1. Let _callerContext_ be the running execution context.\n          1. Suspend _callerContext_.\n          1. Set _generator_.[[AsyncGeneratorState]] to ~executing~.\n          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _genContext_</emu-meta> using _completion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.\n          1. Assert: _result_ is never an abrupt completion.\n          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _callerContext_ is the currently running execution context.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncGeneratorResume",
        "name" : "AsyncGeneratorResume",
        "htmlId" : "sec-asyncgeneratorresume",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : true,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2736,
    [
      "WeakRefDeref",
      0,
      [
        [
          "weakRef",
          false,
          "Record[WeakRef]"
        ]
      ],
      "\n          1. Let _target_ be _weakRef_.[[WeakRefTarget]].\n          1. If _target_ is not ~empty~, then\n            1. Perform AddToKeptObjects(_target_).\n            1. Return _target_.\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "WeakRefDeref",
        "name" : "WeakRefDeref",
        "htmlId" : "sec-weakrefderef",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1986,
    [
      "ModuleItem[2,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[2]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ModuleItem[2,0].ExportedNames",
        "name" : "ModuleItem[2,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    854,
    [
      "CallExpression[5,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[5]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. If |CallExpression| Contains _symbol_ is *true*, return *true*.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CallExpression[5,0].Contains",
        "name" : "CallExpression[5,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    190,
    [
      "DefineField",
      0,
      [
        [
          "receiver",
          false,
          "Record[Object]"
        ],
        [
          "fieldRecord",
          false,
          "Record[ClassFieldDefinitionRecord]"
        ]
      ],
      "\n        1. Let _fieldName_ be _fieldRecord_.[[Name]].\n        1. Let _initializer_ be _fieldRecord_.[[Initializer]].\n        1. If _initializer_ is not ~empty~, then\n          1. Let _initValue_ be ? Call(_initializer_, _receiver_).\n        1. Else,\n          1. Let _initValue_ be *undefined*.\n        1. If _fieldName_ is a Private Name, then\n          1. Perform ? PrivateFieldAdd(_receiver_, _fieldName_, _initValue_).\n        1. Else,\n          1. Assert: IsPropertyKey(_fieldName_) is *true*.\n          1. Perform ? CreateDataPropertyOrThrow(_receiver_, _fieldName_, _initValue_).\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "DefineField",
        "name" : "DefineField",
        "htmlId" : "sec-definefield",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2008,
    [
      "ExportDeclaration[4,0].ExportEntries",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[4]]"
        ]
      ],
      "\n          1. Let _names_ be BoundNames of |HoistableDeclaration|.\n          1. Let _localName_ be the sole element of _names_.\n          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *\"default\"* }.\n        ",
      {
        "normalizedName" : "ExportDeclaration[4,0].ExportEntries",
        "name" : "ExportDeclaration[4,0].ExportEntries",
        "htmlId" : "sec-static-semantics-exportentries",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportEntries",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "HoistableDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1303,
    [
      "CallExpression[4,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[4]]"
        ]
      ],
      "\n          1. Let _baseReference_ be ? Evaluation of |CallExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If the source text matched by this |CallExpression| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_).\n        ",
      {
        "normalizedName" : "CallExpression[4,0].Evaluation",
        "name" : "CallExpression[4,0].Evaluation",
        "htmlId" : "sec-property-accessors-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CallExpression"
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    19,
    [
      "INTRINSICS.TypeError",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1527,
    [
      "CaseClause[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ]
      ],
      "\n        1. Return ~empty~.\n      ",
      {
        "normalizedName" : "CaseClause[0,0].Evaluation",
        "name" : "CaseClause[0,0].Evaluation",
        "htmlId" : "sec-switch-statement-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    183,
    [
      "GetFunctionRealm",
      0,
      [
        [
          "obj",
          false,
          "Record[FunctionObject]"
        ]
      ],
      "\n        1. If _obj_ has a [[Realm]] internal slot, then\n          1. Return _obj_.[[Realm]].\n        1. If _obj_ is a bound function exotic object, then\n          1. Let _boundTargetFunction_ be _obj_.[[BoundTargetFunction]].\n          1. Return ? GetFunctionRealm(_boundTargetFunction_).\n        1. If _obj_ is a Proxy exotic object, then\n          1. Perform ? ValidateNonRevokedProxy(_obj_).\n          1. Let _proxyTarget_ be _obj_.[[ProxyTarget]].\n          1. Return ? GetFunctionRealm(_proxyTarget_).\n        1. [id=\"step-getfunctionrealm-default-return\"] Return the current Realm Record.\n      ",
      {
        "normalizedName" : "GetFunctionRealm",
        "name" : "GetFunctionRealm",
        "htmlId" : "sec-getfunctionrealm",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1148,
    [
      "StringCreate",
      0,
      [
        [
          "value",
          false,
          "String"
        ],
        [
          "prototype",
          false,
          "Record[Object]"
        ]
      ],
      "\n          1. Let _S_ be MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] »).\n          1. Set _S_.[[Prototype]] to _prototype_.\n          1. Set _S_.[[StringData]] to _value_.\n          1. Set _S_.[[GetOwnProperty]] as specified in <emu-xref href=\"#sec-string-exotic-objects-getownproperty-p\"></emu-xref>.\n          1. Set _S_.[[DefineOwnProperty]] as specified in <emu-xref href=\"#sec-string-exotic-objects-defineownproperty-p-desc\"></emu-xref>.\n          1. Set _S_.[[OwnPropertyKeys]] as specified in <emu-xref href=\"#sec-string-exotic-objects-ownpropertykeys\"></emu-xref>.\n          1. Let _length_ be the length of _value_.\n          1. Perform ! DefinePropertyOrThrow(_S_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n          1. Return _S_.\n        ",
      {
        "normalizedName" : "StringCreate",
        "name" : "StringCreate",
        "htmlId" : "sec-stringcreate",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1673,
    [
      "ClassElement[2,0].IsStatic",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassElement[2,0].IsStatic",
        "name" : "ClassElement[2,0].IsStatic",
        "htmlId" : "sec-static-semantics-isstatic",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsStatic",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FieldDefinition"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    422,
    [
      "Statement[2,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[2]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[2,0].VarScopedDeclarations",
        "name" : "Statement[2,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EmptyStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1248,
    [
      "ElementList[0,0].ArrayAccumulation",
      2,
      [
        [
          "this",
          false,
          "Ast[ElementList[0]]"
        ],
        [
          "array",
          false,
          "Record[Array]"
        ],
        [
          "nextIndex",
          false,
          "Int"
        ]
      ],
      "\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Let _initResult_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _initValue_ be ? GetValue(_initResult_).\n          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).\n          1. Return _nextIndex_ + 1.\n        ",
      {
        "normalizedName" : "ElementList[0,0].ArrayAccumulation",
        "name" : "ElementList[0,0].ArrayAccumulation",
        "htmlId" : "sec-runtime-semantics-arrayaccumulation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArrayAccumulation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    790,
    [
      "ClassExpression[0,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassExpression[0]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "ClassExpression[0,0].IsFunctionDefinition",
        "name" : "ClassExpression[0,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "class"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2050,
    [
      "INTRINSICS.Object.freeze",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _O_ is not an Object, return _O_.\n          1. Let _status_ be ? SetIntegrityLevel(_O_, ~frozen~).\n          1. If _status_ is *false*, throw a *TypeError* exception.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.freeze",
        "name" : "INTRINSICS.Object.freeze",
        "htmlId" : "sec-object.freeze",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    867,
    [
      "ClassElement[5,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[5]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ClassElement[5,0].ComputedPropertyContains",
        "name" : "ClassElement[5,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1757,
    [
      "AwaitExpression[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AwaitExpression[0]]"
        ]
      ],
      "\n        1. Let _exprRef_ be ? Evaluation of |UnaryExpression|.\n        1. Let _value_ be ? GetValue(_exprRef_).\n        1. Return ? Await(_value_).\n      ",
      {
        "normalizedName" : "AwaitExpression[0,0].Evaluation",
        "name" : "AwaitExpression[0,0].Evaluation",
        "htmlId" : "sec-async-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AwaitExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    273,
    [
      "Declaration[2,0].DeclarationPart",
      2,
      [
        [
          "this",
          false,
          "Ast[Declaration[2]]"
        ]
      ],
      "\n        1. Return |LexicalDeclaration|.\n      ",
      {
        "normalizedName" : "Declaration[2,0].DeclarationPart",
        "name" : "Declaration[2,0].DeclarationPart",
        "htmlId" : "sec-static-semantics-declarationpart",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DeclarationPart",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "Declaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2768,
    [
      "INTRINSICS.yet:`Promise.allSettled`ResolveElementFunction",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Let _F_ be the active function object.\n            1. Let _alreadyCalled_ be _F_.[[AlreadyCalled]].\n            1. If _alreadyCalled_.[[Value]] is *true*, return *undefined*.\n            1. Set _alreadyCalled_.[[Value]] to *true*.\n            1. Let _index_ be _F_.[[Index]].\n            1. Let _values_ be _F_.[[Values]].\n            1. Let _promiseCapability_ be _F_.[[Capability]].\n            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].\n            1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"status\"*, *\"fulfilled\"*).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"value\"*, _x_).\n            1. Set _values_[_index_] to _obj_.\n            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n            1. If _remainingElementsCount_.[[Value]] = 0, then\n              1. Let _valuesArray_ be CreateArrayFromList(_values_).\n              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n            1. Return *undefined*.\n          ",
      {
        "normalizedName" : "INTRINSICS.yet:Promise.allSettledResolveElementFunction",
        "name" : "INTRINSICS.yet:`Promise.allSettled`ResolveElementFunction",
        "htmlId" : "sec-promise.allsettled-resolve-element-functions",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    865,
    [
      "ClassElementList[1,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElementList[1]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Let _inList_ be ComputedPropertyContains of |ClassElementList| with argument _symbol_.\n        1. If _inList_ is *true*, return *true*.\n        1. Return the result of ComputedPropertyContains of |ClassElement| with argument _symbol_.\n      ",
      {
        "normalizedName" : "ClassElementList[1,0].ComputedPropertyContains",
        "name" : "ClassElementList[1,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementList"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1480,
    [
      "MemberExpression[1,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[1]]"
        ]
      ],
      "\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "MemberExpression[1,0].IsDestructuring",
        "name" : "MemberExpression[1,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    373,
    [
      "ForStatement[0,5].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,5].VarDeclaredNames",
        "name" : "ForStatement[0,5].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 5,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    603,
    [
      "ForStatement[2,3].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[2,3].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[2,3].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    305,
    [
      "LabelledItem[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "LabelledItem[0,0].LexicallyDeclaredNames",
        "name" : "LabelledItem[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2186,
    [
      "IsTimeZoneOffsetString",
      0,
      [
        [
          "offsetString",
          false,
          "String"
        ]
      ],
      "\n            1. Let _parseResult_ be ParseText(StringToCodePoints(_offsetString_), |UTCOffset|).\n            1. If _parseResult_ is a List of errors, return *false*.\n            1. Return *true*.\n          ",
      {
        "normalizedName" : "IsTimeZoneOffsetString",
        "name" : "IsTimeZoneOffsetString",
        "htmlId" : "sec-istimezoneoffsetstring",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    195,
    [
      "GetIterator",
      0,
      [
        [
          "obj",
          false,
          "ESValue"
        ],
        [
          "kind",
          false,
          "Enum[~async~, ~sync~]"
        ]
      ],
      "\n        1. If _kind_ is ~async~, then\n          1. Let _method_ be ? GetMethod(_obj_, @@asyncIterator).\n          1. If _method_ is *undefined*, then\n            1. Let _syncMethod_ be ? GetMethod(_obj_, @@iterator).\n            1. If _syncMethod_ is *undefined*, throw a *TypeError* exception.\n            1. Let _syncIteratorRecord_ be ? GetIteratorFromMethod(_obj_, _syncMethod_).\n            1. Return CreateAsyncFromSyncIterator(_syncIteratorRecord_).\n        1. Else,\n          1. Let _method_ be ? GetMethod(_obj_, @@iterator).\n        1. If _method_ is *undefined*, throw a *TypeError* exception.\n        1. Return ? GetIteratorFromMethod(_obj_, _method_).\n      ",
      {
        "normalizedName" : "GetIterator",
        "name" : "GetIterator",
        "htmlId" : "sec-getiterator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2746,
    [
      "AsyncFromSyncIteratorContinuation:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n          1. NOTE: Because _promiseCapability_ is derived from the intrinsic %Promise%, the calls to _promiseCapability_.[[Reject]] entailed by the use IfAbruptRejectPromise below are guaranteed not to throw.\n          1. Let _done_ be Completion(IteratorComplete(_result_)).\n          1. IfAbruptRejectPromise(_done_, _promiseCapability_).\n          1. Let _value_ be Completion(IteratorValue(_result_)).\n          1. IfAbruptRejectPromise(_value_, _promiseCapability_).\n          1. Let _valueWrapper_ be Completion(PromiseResolve(%Promise%, _value_)).\n          1. IfAbruptRejectPromise(_valueWrapper_, _promiseCapability_).\n          1. Let _unwrap_ be a new Abstract Closure with parameters (_v_) that captures _done_ and performs the following steps when called:\n            1. Return CreateIterResultObject(_v_, _done_).\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_unwrap_, 1, *\"\"*, « »).\n          1. NOTE: _onFulfilled_ is used when processing the *\"value\"* property of an IteratorResult object in order to wait for its value if it is a promise and re-package the result in a new \"unwrapped\" IteratorResult object.\n          1. Perform PerformPromiseThen(_valueWrapper_, _onFulfilled_, *undefined*, _promiseCapability_).\n          1. Return _promiseCapability_.[[Promise]].\n        ",
      {
        "normalizedName" : "AsyncFromSyncIteratorContinuation",
        "name" : "AsyncFromSyncIteratorContinuation",
        "htmlId" : "sec-asyncfromsynciteratorcontinuation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2366,
    [
      "QuantifierPrefix[0,0].CompileQuantifierPrefix",
      2,
      [
        [
          "this",
          false,
          "Ast[QuantifierPrefix[0]]"
        ]
      ],
      "\n          1. Return the Record { [[Min]]: 0, [[Max]]: +∞ }.\n        ",
      {
        "normalizedName" : "QuantifierPrefix[0,0].CompileQuantifierPrefix",
        "name" : "QuantifierPrefix[0,0].CompileQuantifierPrefix",
        "htmlId" : "sec-compilequantifierprefix",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileQuantifierPrefix",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "QuantifierPrefix",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "*"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    828,
    [
      "FunctionDeclaration[1,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[1]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[1,0].Contains",
        "name" : "FunctionDeclaration[1,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    955,
    [
      "UnaryExpression[8,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[8]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "UnaryExpression[8,0].AssignmentTargetType",
        "name" : "UnaryExpression[8,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AwaitExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    564,
    [
      "LabelledItem[1,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledItem[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "LabelledItem[1,0].ContainsDuplicateLabels",
        "name" : "LabelledItem[1,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LabelledItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2636,
    [
      "IsNoTearConfiguration",
      0,
      [
        [
          "type",
          false,
          "Unknown[\"TypedArrayElementType\"]"
        ],
        [
          "order",
          false,
          "Enum[~init~, ~seq-cst~, ~unordered~]"
        ]
      ],
      "\n          1. If IsUnclampedIntegerElementType(_type_) is *true*, return *true*.\n          1. If IsBigIntElementType(_type_) is *true* and _order_ is neither ~init~ nor ~unordered~, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "IsNoTearConfiguration",
        "name" : "IsNoTearConfiguration",
        "htmlId" : "sec-isnotearconfiguration",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1436,
    [
      "LexicalBinding[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[LexicalBinding[1]]"
        ]
      ],
      "\n          1. Let _rhs_ be ? Evaluation of |Initializer|.\n          1. Let _value_ be ? GetValue(_rhs_).\n          1. Let _env_ be the running execution context's LexicalEnvironment.\n          1. Return ? BindingInitialization of |BindingPattern| with arguments _value_ and _env_.\n        ",
      {
        "normalizedName" : "LexicalBinding[1,0].Evaluation",
        "name" : "LexicalBinding[1,0].Evaluation",
        "htmlId" : "sec-let-and-const-declarations-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LexicalBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1859,
    [
      "UnaryExpression[5,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[5]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[5,0].HasCallInTailPosition",
        "name" : "UnaryExpression[5,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "-"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    210,
    [
      "LexicalDeclaration[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[LexicalDeclaration[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingList|.\n      ",
      {
        "normalizedName" : "LexicalDeclaration[0,0].BoundNames",
        "name" : "LexicalDeclaration[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LexicalDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LetOrConst"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2751,
    [
      "FulfillPromise",
      0,
      [
        [
          "promise",
          false,
          "Record[Promise]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Assert: The value of _promise_.[[PromiseState]] is ~pending~.\n          1. Let _reactions_ be _promise_.[[PromiseFulfillReactions]].\n          1. Set _promise_.[[PromiseResult]] to _value_.\n          1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.\n          1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.\n          1. Set _promise_.[[PromiseState]] to ~fulfilled~.\n          1. Perform TriggerPromiseReactions(_reactions_, _value_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "FulfillPromise",
        "name" : "FulfillPromise",
        "htmlId" : "sec-fulfillpromise",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2800,
    [
      "GeneratorResumeAbrupt",
      0,
      [
        [
          "generator",
          false,
          "ESValue"
        ],
        [
          "abruptCompletion",
          false,
          "Return | Throw"
        ],
        [
          "generatorBrand",
          false,
          "Enum[~empty~] | String"
        ]
      ],
      "\n          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).\n          1. If _state_ is ~suspended-start~, then\n            1. Set _generator_.[[GeneratorState]] to ~completed~.\n            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.\n            1. Set _state_ to ~completed~.\n          1. If _state_ is ~completed~, then\n            1. If _abruptCompletion_ is a return completion, then\n              1. Return CreateIterResultObject(_abruptCompletion_.[[Value]], *true*).\n            1. Return ? _abruptCompletion_.\n          1. Assert: _state_ is ~suspended-yield~.\n          1. Let _genContext_ be _generator_.[[GeneratorContext]].\n          1. Let _methodContext_ be the running execution context.\n          1. Suspend _methodContext_.\n          1. Set _generator_.[[GeneratorState]] to ~executing~.\n          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _genContext_</emu-meta> using _abruptCompletion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.\n          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.\n          1. Return ? _result_.\n        ",
      {
        "normalizedName" : "GeneratorResumeAbrupt",
        "name" : "GeneratorResumeAbrupt",
        "htmlId" : "sec-generatorresumeabrupt",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    326,
    [
      "CaseBlock[1,3].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _declarations1_ be the LexicallyScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the LexicallyScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,3].LexicallyScopedDeclarations",
        "name" : "CaseBlock[1,3].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    107,
    [
      "CreateSharedByteDataBlock",
      0,
      [
        [
          "size",
          false,
          "Int[0+]"
        ]
      ],
      "\n          1. Let _db_ be a new Shared Data Block value consisting of _size_ bytes. If it is impossible to create such a Shared Data Block, throw a *RangeError* exception.\n          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n          1. Let _zero_ be « 0 ».\n          1. For each index _i_ of _db_, do\n            1. Append WriteSharedMemory { [[Order]]: ~init~, [[NoTear]]: *true*, [[Block]]: _db_, [[ByteIndex]]: _i_, [[ElementSize]]: 1, [[Payload]]: _zero_ } to _eventsRecord_.[[EventList]].\n          1. Return _db_.\n        ",
      {
        "normalizedName" : "CreateSharedByteDataBlock",
        "name" : "CreateSharedByteDataBlock",
        "htmlId" : "sec-createsharedbytedatablock",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    239,
    [
      "FunctionDeclaration[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |BindingIdentifier|.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[0,0].BoundNames",
        "name" : "FunctionDeclaration[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    242,
    [
      "FormalParameters[4,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[FormalParameters[4]]"
        ]
      ],
      "\n        1. Let _names1_ be BoundNames of |FormalParameterList|.\n        1. Let _names2_ be BoundNames of |FunctionRestParameter|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "FormalParameters[4,0].BoundNames",
        "name" : "FormalParameters[4,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "FormalParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FormalParameterList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionRestParameter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    4,
    [
      "HostEnsureCanCompileStrings",
      0,
      [
        [
          "calleeRealm",
          false,
          "Record[RealmRecord]"
        ],
        [
          "parameterStrings",
          false,
          "List[String]"
        ],
        [
          "bodyString",
          false,
          "String"
        ],
        [
          "direct",
          false,
          "Boolean"
        ]
      ],
      "",
      null
    ]
  ],
  [
    294,
    [
      "CaseBlock[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "CaseBlock[0,0].LexicallyDeclaredNames",
        "name" : "CaseBlock[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2201,
    [
      "INTRINSICS.Date.prototype.getUTCDay",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return WeekDay(_t_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getUTCDay",
        "name" : "INTRINSICS.Date.prototype.getUTCDay",
        "htmlId" : "sec-date.prototype.getutcday",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    126,
    [
      "StrUnsignedDecimalLiteral[2,0].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StrUnsignedDecimalLiteral[2]]"
        ]
      ],
      "\n            1. Let _b_ be MV of |DecimalDigits|.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Let _n_ be the number of code points in |DecimalDigits|.\n            1. Return RoundMVResult(_b_ × 10<sup>_e_ - _n_</sup>).\n          ",
      {
        "normalizedName" : "StrUnsignedDecimalLiteral[2,0].StringNumericValue",
        "name" : "StrUnsignedDecimalLiteral[2,0].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "StrUnsignedDecimalLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    918,
    [
      "MemberExpression[2,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[2]]"
        ]
      ],
      "\n        1. Return ~simple~.\n      ",
      {
        "normalizedName" : "MemberExpression[2,0].AssignmentTargetType",
        "name" : "MemberExpression[2,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    801,
    [
      "PrimaryExpression[8,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[8]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[8,0].IsIdentifierRef",
        "name" : "PrimaryExpression[8,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1989,
    [
      "ExportFromClause[1,0].ExportedNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportFromClause[1]]"
        ]
      ],
      "\n          1. Return a List whose sole element is the StringValue of |ModuleExportName|.\n        ",
      {
        "normalizedName" : "ExportFromClause[1,0].ExportedNames",
        "name" : "ExportFromClause[1,0].ExportedNames",
        "htmlId" : "sec-static-semantics-exportednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportFromClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "as"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleExportName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    136,
    [
      "ToInt8",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n        1. Let _int_ be truncate(ℝ(_number_)).\n        1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.\n        1. If _int8bit_ ≥ 2<sup>7</sup>, return 𝔽(_int8bit_ - 2<sup>8</sup>); otherwise return 𝔽(_int8bit_).\n      ",
      {
        "normalizedName" : "ToInt8",
        "name" : "ToInt8",
        "htmlId" : "sec-toint8",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1363,
    [
      "ShiftExpression[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ShiftExpression[2]]"
        ]
      ],
      "\n          1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>`, |AdditiveExpression|).\n        ",
      {
        "normalizedName" : "ShiftExpression[2,0].Evaluation",
        "name" : "ShiftExpression[2,0].Evaluation",
        "htmlId" : "sec-signed-right-shift-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ShiftExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              },
              {
                "type" : "terminal",
                "value" : ">>"
              },
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1314,
    [
      "SuperProperty[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[SuperProperty[0]]"
        ]
      ],
      "\n          1. Let _env_ be GetThisEnvironment().\n          1. Let _actualThis_ be ? _env_.GetThisBinding().\n          1. Let _propertyNameReference_ be ? Evaluation of |Expression|.\n          1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).\n          1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).\n          1. If the source text matched by this |SuperProperty| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return ? MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_).\n        ",
      {
        "normalizedName" : "SuperProperty[0,0].Evaluation",
        "name" : "SuperProperty[0,0].Evaluation",
        "htmlId" : "sec-super-keyword-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SuperProperty",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "super"
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    341,
    [
      "Script[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Script[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Script[0,0].LexicallyScopedDeclarations",
        "name" : "Script[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Script",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1816,
    [
      "DefaultClause[0,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "DefaultClause[0,0].HasCallInTailPosition",
        "name" : "DefaultClause[0,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1495,
    [
      "ForInOfStatement[0,0].ForInOfLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~).\n          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~enumerate~, ~assignment~, _labelSet_).\n        ",
      {
        "normalizedName" : "ForInOfStatement[0,0].ForInOfLoopEvaluation",
        "name" : "ForInOfStatement[0,0].ForInOfLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forinofloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForInOfLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1657,
    [
      "AsyncGeneratorDeclaration[0,0].InstantiateAsyncGeneratorFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorDeclaration[0]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Let _name_ be StringValue of |BindingIdentifier|.\n        1. Let _sourceText_ be the source text matched by |AsyncGeneratorDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, _name_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "AsyncGeneratorDeclaration[0,0].InstantiateAsyncGeneratorFunctionObject",
        "name" : "AsyncGeneratorDeclaration[0,0].InstantiateAsyncGeneratorFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiateasyncgeneratorfunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateAsyncGeneratorFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2334,
    [
      "GroupName[0,0].CapturingGroupName",
      2,
      [
        [
          "this",
          false,
          "Ast[GroupName[0]]"
        ]
      ],
      "\n          1. Let _idTextUnescaped_ be RegExpIdentifierCodePoints of |RegExpIdentifierName|.\n          1. Return CodePointsToString(_idTextUnescaped_).\n        ",
      {
        "normalizedName" : "GroupName[0,0].CapturingGroupName",
        "name" : "GroupName[0,0].CapturingGroupName",
        "htmlId" : "sec-static-semantics-capturinggroupname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CapturingGroupName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "GroupName",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "<"
              },
              {
                "type" : "nonterminal",
                "value" : "RegExpIdentifierName"
              },
              {
                "type" : "terminal",
                "value" : ">"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    506,
    [
      "StatementListItem[0,0].TopLevelVarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[0]]"
        ]
      ],
      "\n        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return TopLevelVarScopedDeclarations of |Statement|.\n        1. Return VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "StatementListItem[0,0].TopLevelVarScopedDeclarations",
        "name" : "StatementListItem[0,0].TopLevelVarScopedDeclarations",
        "htmlId" : "sec-static-semantics-toplevelvarscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelVarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    268,
    [
      "HoistableDeclaration[0,0].DeclarationPart",
      2,
      [
        [
          "this",
          false,
          "Ast[HoistableDeclaration[0]]"
        ]
      ],
      "\n        1. Return |FunctionDeclaration|.\n      ",
      {
        "normalizedName" : "HoistableDeclaration[0,0].DeclarationPart",
        "name" : "HoistableDeclaration[0,0].DeclarationPart",
        "htmlId" : "sec-static-semantics-declarationpart",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DeclarationPart",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "HoistableDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    807,
    [
      "MemberExpression[2,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[2]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[2,0].IsIdentifierRef",
        "name" : "MemberExpression[2,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    358,
    [
      "Statement[11,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[11]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[11,0].VarDeclaredNames",
        "name" : "Statement[11,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 11,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ThrowStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    79,
    [
      "BigInt::lessThan",
      1,
      [
        [
          "x",
          false,
          "BigInt"
        ],
        [
          "y",
          false,
          "BigInt"
        ]
      ],
      "\n            1. If ℝ(_x_) < ℝ(_y_), return *true*; otherwise return *false*.\n          ",
      {
        "normalizedName" : "BigInt::lessThan",
        "name" : "BigInt::lessThan",
        "htmlId" : "sec-numeric-types-bigint-lessThan",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    437,
    [
      "WhileStatement[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[WhileStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "WhileStatement[0,0].VarScopedDeclarations",
        "name" : "WhileStatement[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "WhileStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "while"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1335,
    [
      "OptionalChain[6,0].ChainEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[6]]"
        ],
        [
          "baseValue",
          false,
          "ESValue"
        ],
        [
          "baseReference",
          false,
          "ESValue | Record[ReferenceRecord]"
        ]
      ],
      "\n          1. Let _optionalChain_ be |OptionalChain|.\n          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n          1. Let _newValue_ be ? GetValue(_newReference_).\n          1. If the source text matched by this |OptionalChain| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return ? EvaluatePropertyAccessWithExpressionKey(_newValue_, |Expression|, _strict_).\n        ",
      {
        "normalizedName" : "OptionalChain[6,0].ChainEvaluation",
        "name" : "OptionalChain[6,0].ChainEvaluation",
        "htmlId" : "sec-optional-chaining-chain-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ChainEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1693,
    [
      "ClassElement[5,0].PrivateBoundIdentifiers",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassElement[5]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ClassElement[5,0].PrivateBoundIdentifiers",
        "name" : "ClassElement[5,0].PrivateBoundIdentifiers",
        "htmlId" : "sec-static-semantics-privateboundidentifiers",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PrivateBoundIdentifiers",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ClassElement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2070,
    [
      "INTRINSICS.Object.prototype.hasOwnProperty",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. [id=\"step-hasownproperty-topropertykey\"] Let _P_ be ? ToPropertyKey(_V_).\n          1. [id=\"step-hasownproperty-toobject\"] Let _O_ be ? ToObject(*this* value).\n          1. Return ? HasOwnProperty(_O_, _P_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.prototype.hasOwnProperty",
        "name" : "INTRINSICS.Object.prototype.hasOwnProperty",
        "htmlId" : "sec-object.prototype.hasownproperty",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2572,
    [
      "TypedArraySpeciesCreate",
      0,
      [
        [
          "exemplar",
          false,
          "Record[TypedArray]"
        ],
        [
          "argumentList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Let _defaultConstructor_ be the intrinsic object associated with the constructor name _exemplar_.[[TypedArrayName]] in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref>.\n          1. Let _constructor_ be ? SpeciesConstructor(_exemplar_, _defaultConstructor_).\n          1. Let _result_ be ? TypedArrayCreateFromConstructor(_constructor_, _argumentList_).\n          1. Assert: _result_ has [[TypedArrayName]] and [[ContentType]] internal slots.\n          1. If _result_.[[ContentType]] is not _exemplar_.[[ContentType]], throw a *TypeError* exception.\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "TypedArraySpeciesCreate",
        "name" : "TypedArraySpeciesCreate",
        "htmlId" : "typedarray-species-create",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1561,
    [
      "ArrayBindingPattern[0,1].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[0]]"
        ]
      ],
      "\n        1. Return ContainsExpression of |BindingRestElement|.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[0,1].ContainsExpression",
        "name" : "ArrayBindingPattern[0,1].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2704,
    [
      "EnqueueResolveInAgentJob:clo0",
      6,
      [
      ],
      "\n          1. Let _resolveJob_ be a new Job Abstract Closure with no parameters that captures _agentSignifier_, _promiseCapability_, and _resolution_ and performs the following steps when called:\n            1. Assert: AgentSignifier() is _agentSignifier_.\n            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _resolution_ »).\n            1. Return ~unused~.\n          1. Let _realmInTargetAgent_ be ! GetFunctionRealm(_promiseCapability_.[[Resolve]]).\n          1. Assert: _agentSignifier_ is _realmInTargetAgent_.[[AgentSignifier]].\n          1. Perform HostEnqueueGenericJob(_resolveJob_, _realmInTargetAgent_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "EnqueueResolveInAgentJob",
        "name" : "EnqueueResolveInAgentJob",
        "htmlId" : "sec-enqueueresolveinagentjob",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1172,
    [
      "IsTypedArrayOutOfBounds",
      0,
      [
        [
          "taRecord",
          false,
          "Record[TypedArrayWithBufferWitnessRecord]"
        ]
      ],
      "\n          1. Let _O_ be _taRecord_.[[Object]].\n          1. Let _bufferByteLength_ be _taRecord_.[[CachedBufferByteLength]].\n          1. Assert: IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true* if and only if _bufferByteLength_ is ~detached~.\n          1. If _bufferByteLength_ is ~detached~, return *true*.\n          1. Let _byteOffsetStart_ be _O_.[[ByteOffset]].\n          1. If _O_.[[ArrayLength]] is ~auto~, then\n            1. Let _byteOffsetEnd_ be _bufferByteLength_.\n          1. Else,\n            1. Let _elementSize_ be TypedArrayElementSize(_O_).\n            1. Let _byteOffsetEnd_ be _byteOffsetStart_ + _O_.[[ArrayLength]] × _elementSize_.\n          1. If _byteOffsetStart_ > _bufferByteLength_ or _byteOffsetEnd_ > _bufferByteLength_, return *true*.\n          1. NOTE: 0-length TypedArrays are not considered out-of-bounds.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "IsTypedArrayOutOfBounds",
        "name" : "IsTypedArrayOutOfBounds",
        "htmlId" : "sec-istypedarrayoutofbounds",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    897,
    [
      "BindingElementList[1,0].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElementList[1]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.\n        1. Return ? IteratorBindingInitialization of |BindingElisionElement| with arguments _iteratorRecord_ and _environment_.\n      ",
      {
        "normalizedName" : "BindingElementList[1,0].IteratorBindingInitialization",
        "name" : "BindingElementList[1,0].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BindingElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElisionElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    474,
    [
      "DefaultClause[0,1].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return the VarScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "DefaultClause[0,1].VarScopedDeclarations",
        "name" : "DefaultClause[0,1].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1410,
    [
      "AssignmentElementList[0,0].IteratorDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentElementList[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| with argument _iteratorRecord_.\n        ",
      {
        "normalizedName" : "AssignmentElementList[0,0].IteratorDestructuringAssignmentEvaluation",
        "name" : "AssignmentElementList[0,0].IteratorDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AssignmentElementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AssignmentElisionElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    767,
    [
      "BitwiseXORExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[BitwiseXORExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "BitwiseXORExpression[1,0].IsFunctionDefinition",
        "name" : "BitwiseXORExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BitwiseXORExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BitwiseXORExpression"
              },
              {
                "type" : "terminal",
                "value" : "^"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseANDExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2417,
    [
      "ClassSetOperand[1,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassSetOperand[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _A_ be CompileToCharSet of |ClassStringDisjunction| with argument _rer_.\n          1. Return MaybeSimpleCaseFolding(_rer_, _A_).\n        ",
      {
        "normalizedName" : "ClassSetOperand[1,0].CompileToCharSet",
        "name" : "ClassSetOperand[1,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassSetOperand",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassStringDisjunction"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1056,
    [
      "NewObjectEnvironment",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "W",
          false,
          "Boolean"
        ],
        [
          "E",
          false,
          "Record[EnvironmentRecord] | Null"
        ]
      ],
      "\n          1. Let _env_ be a new Object Environment Record.\n          1. Set _env_.[[BindingObject]] to _O_.\n          1. Set _env_.[[IsWithEnvironment]] to _W_.\n          1. Set _env_.[[OuterEnv]] to _E_.\n          1. Return _env_.\n        ",
      {
        "normalizedName" : "NewObjectEnvironment",
        "name" : "NewObjectEnvironment",
        "htmlId" : "sec-newobjectenvironment",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1789,
    [
      "ForStatement[0,3].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      ",
      {
        "normalizedName" : "ForStatement[0,3].HasCallInTailPosition",
        "name" : "ForStatement[0,3].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    664,
    [
      "ForStatement[1,2].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[1,2].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[1,2].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1033,
    [
      "Record[GlobalEnvironmentRecord].CreateMutableBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "D",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, throw a *TypeError* exception.\n            1. Return ! _DclRec_.CreateMutableBinding(_N_, _D_).\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].CreateMutableBinding",
        "name" : "Record[GlobalEnvironmentRecord].CreateMutableBinding",
        "htmlId" : "sec-global-environment-records-createmutablebinding-n-d",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "CreateMutableBinding"
        ]
      }
    ]
  ],
  [
    1288,
    [
      "TemplateSpans[0,0].SubstitutionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[TemplateSpans[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "TemplateSpans[0,0].SubstitutionEvaluation",
        "name" : "TemplateSpans[0,0].SubstitutionEvaluation",
        "htmlId" : "sec-runtime-semantics-substitutionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "SubstitutionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "TemplateSpans",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "TemplateTail"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1710,
    [
      "GeneratorExpression[0,1].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[GeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "GeneratorExpression[0,1].ContainsArguments",
        "name" : "GeneratorExpression[0,1].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "GeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "GeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    400,
    [
      "CaseClauses[1,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClauses[1]]"
        ]
      ],
      "\n        1. Let _names1_ be VarDeclaredNames of |CaseClauses|.\n        1. Let _names2_ be VarDeclaredNames of |CaseClause|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "CaseClauses[1,0].VarDeclaredNames",
        "name" : "CaseClauses[1,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "CaseClauses",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClause"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1197,
    [
      "Record[ProxyExoticObject].HasProperty",
      4,
      [
        [
          "O",
          false,
          "Record[ProxyExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"has\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[HasProperty]]</emu-meta>(_P_).\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)).\n        1. If _booleanTrapResult_ is *false*, then\n          1. Let _targetDesc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. If _targetDesc_ is not *undefined*, then\n            1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.\n            1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n            1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.\n        1. Return _booleanTrapResult_.\n      ",
      {
        "normalizedName" : "Record[ProxyExoticObject].HasProperty",
        "name" : "Record[ProxyExoticObject].HasProperty",
        "htmlId" : "sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ProxyExoticObject",
          "[[HasProperty]]"
        ]
      }
    ]
  ],
  [
    2091,
    [
      "ThisBooleanValue",
      0,
      [
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n            1. If _value_ is a Boolean, return _value_.\n            1. If _value_ is an Object and _value_ has a [[BooleanData]] internal slot, then\n              1. Let _b_ be _value_.[[BooleanData]].\n              1. Assert: _b_ is a Boolean.\n              1. Return _b_.\n            1. Throw a *TypeError* exception.\n          ",
      {
        "normalizedName" : "ThisBooleanValue",
        "name" : "ThisBooleanValue",
        "htmlId" : "sec-thisbooleanvalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2404,
    [
      "CharacterClassEscape[7,0].CompileToCharSet",
      2,
      [
        [
          "this",
          false,
          "Ast[CharacterClassEscape[7]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Let _S_ be CompileToCharSet of |UnicodePropertyValueExpression| with argument _rer_.\n          1. Assert: _S_ contains only single code points.\n          1. Return CharacterComplement(_rer_, _S_).\n        ",
      {
        "normalizedName" : "CharacterClassEscape[7,0].CompileToCharSet",
        "name" : "CharacterClassEscape[7,0].CompileToCharSet",
        "htmlId" : "sec-compiletocharset",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileToCharSet",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "CharacterClassEscape",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "P{"
              },
              {
                "type" : "nonterminal",
                "value" : "UnicodePropertyValueExpression"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2714,
    [
      "INTRINSICS.Atomics.and",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. Let _and_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:\n          1. Return ByteListBitwiseOp(`&`, _xBytes_, _yBytes_).\n        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _and_).\n      ",
      {
        "normalizedName" : "INTRINSICS.Atomics.and",
        "name" : "INTRINSICS.Atomics.and",
        "htmlId" : "sec-atomics.and",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1891,
    [
      "LogicalORExpression[1,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[LogicalORExpression[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return HasCallInTailPosition of |LogicalANDExpression| with argument _call_.\n      ",
      {
        "normalizedName" : "LogicalORExpression[1,0].HasCallInTailPosition",
        "name" : "LogicalORExpression[1,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "LogicalORExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LogicalORExpression"
              },
              {
                "type" : "terminal",
                "value" : "||"
              },
              {
                "type" : "nonterminal",
                "value" : "LogicalANDExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2223,
    [
      "INTRINSICS.Date.prototype.toDateString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _tv_ be _dateObject_.[[DateValue]].\n          1. If _tv_ is *NaN*, return *\"Invalid Date\"*.\n          1. Let _t_ be LocalTime(_tv_).\n          1. Return DateString(_t_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.toDateString",
        "name" : "INTRINSICS.Date.prototype.toDateString",
        "htmlId" : "sec-date.prototype.todatestring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    960,
    [
      "ShiftExpression[1,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[ShiftExpression[1]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "ShiftExpression[1,0].AssignmentTargetType",
        "name" : "ShiftExpression[1,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ShiftExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              },
              {
                "type" : "terminal",
                "value" : "<<"
              },
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    635,
    [
      "ModuleItemList[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItemList[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |ModuleItemList| with argument _labelSet_.\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of |ModuleItem| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ModuleItemList[1,0].ContainsUndefinedBreakTarget",
        "name" : "ModuleItemList[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleItemList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ModuleItemList"
              },
              {
                "type" : "nonterminal",
                "value" : "ModuleItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2795,
    [
      "GeneratorStart",
      0,
      [
        [
          "generator",
          false,
          "Record[Generator]"
        ],
        [
          "generatorBody",
          false,
          "Clo | Ast[FunctionBody]"
        ]
      ],
      "\n          1. Assert: The value of _generator_.[[GeneratorState]] is *undefined*.\n          1. Let _genContext_ be the running execution context.\n          1. Set the Generator component of _genContext_ to _generator_.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:\n            1. Let _acGenContext_ be the running execution context.\n            1. Let _acGenerator_ be the Generator component of _acGenContext_.\n            1. If _generatorBody_ is a Parse Node, then\n              1. Let _result_ be Completion(Evaluation of _generatorBody_).\n            1. Else,\n              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.\n              1. Let _result_ be _generatorBody_().\n            1. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.\n            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. Set _acGenerator_.[[GeneratorState]] to ~completed~.\n            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _acGenerator_ can be discarded at this point.\n            1. If _result_ is a normal completion, then\n              1. Let _resultValue_ be *undefined*.\n            1. Else if _result_ is a return completion, then\n              1. Let _resultValue_ be _result_.[[Value]].\n            1. Else,\n              1. Assert: _result_ is a throw completion.\n              1. Return ? _result_.\n            1. Return CreateIterResultObject(_resultValue_, *true*).\n          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Set _generator_.[[GeneratorContext]] to _genContext_.\n          1. Set _generator_.[[GeneratorState]] to ~suspended-start~.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "GeneratorStart",
        "name" : "GeneratorStart",
        "htmlId" : "sec-generatorstart",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1473,
    [
      "ForStatement[2,0].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n          1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.\n          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.\n          1. For each element _dn_ of _boundNames_, do\n            1. If _isConst_ is *true*, then\n              1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).\n            1. Else,\n              1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).\n          1. Set the running execution context's LexicalEnvironment to _loopEnv_.\n          1. Let _forDcl_ be Completion(Evaluation of |LexicalDeclaration|).\n          1. If _forDcl_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n            1. Return ? _forDcl_.\n          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be a new empty List.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).\n          1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n          1. Return ? _bodyResult_.\n        ",
      {
        "normalizedName" : "ForStatement[2,0].ForLoopEvaluation",
        "name" : "ForStatement[2,0].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LexicalDeclaration"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2619,
    [
      "INTRINSICS.WeakMap.prototype.has",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).\n          1. If CanBeHeldWeakly(_key_) is *false*, return *false*.\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.WeakMap.prototype.has",
        "name" : "INTRINSICS.WeakMap.prototype.has",
        "htmlId" : "sec-weakmap.prototype.has",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    532,
    [
      "ForStatement[0,6].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,6].ContainsDuplicateLabels",
        "name" : "ForStatement[0,6].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 6,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1065,
    [
      "SetDefaultGlobalBindings",
      0,
      [
        [
          "realmRec",
          false,
          "Record[RealmRecord]"
        ]
      ],
      "\n        1. Let _global_ be _realmRec_.[[GlobalObject]].\n        1. For each property of the Global Object specified in clause <emu-xref href=\"#sec-global-object\"></emu-xref>, do\n          1. Let _name_ be the String value of the property name.\n          1. Let _desc_ be the fully populated data Property Descriptor for the property, containing the specified attributes for the property. For properties listed in <emu-xref href=\"#sec-function-properties-of-the-global-object\"></emu-xref>, <emu-xref href=\"#sec-constructor-properties-of-the-global-object\"></emu-xref>, or <emu-xref href=\"#sec-other-properties-of-the-global-object\"></emu-xref> the value of the [[Value]] attribute is the corresponding intrinsic object from _realmRec_.\n          1. Perform ? DefinePropertyOrThrow(_global_, _name_, _desc_).\n        1. Return _global_.\n      ",
      {
        "normalizedName" : "SetDefaultGlobalBindings",
        "name" : "SetDefaultGlobalBindings",
        "htmlId" : "sec-setdefaultglobalbindings",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2040,
    [
      "Encode",
      0,
      [
        [
          "string",
          false,
          "String"
        ],
        [
          "extraUnescaped",
          false,
          "String"
        ]
      ],
      "\n          1. Let _len_ be the length of _string_.\n          1. Let _R_ be the empty String.\n          1. Let _alwaysUnescaped_ be the string-concatenation of the ASCII word characters and *\"-.!~\\*'()\"*.\n          1. Let _unescapedSet_ be the string-concatenation of _alwaysUnescaped_ and _extraUnescaped_.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _C_ be the code unit at index _k_ within _string_.\n            1. If _unescapedSet_ contains _C_, then\n              1. Set _k_ to _k_ + 1.\n              1. Set _R_ to the string-concatenation of _R_ and _C_.\n            1. Else,\n              1. Let _cp_ be CodePointAt(_string_, _k_).\n              1. If _cp_.[[IsUnpairedSurrogate]] is *true*, throw a *URIError* exception.\n              1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].\n              1. Let _Octets_ be the List of octets resulting by applying the UTF-8 transformation to _cp_.[[CodePoint]].\n              1. For each element _octet_ of _Octets_, do\n                1. Let _hex_ be the String representation of _octet_, formatted as an uppercase hexadecimal number.\n                1. Set _R_ to the string-concatenation of _R_, *\"%\"*, and StringPad(_hex_, 2, *\"0\"*, ~start~).\n          1. Return _R_.\n        ",
      {
        "normalizedName" : "Encode",
        "name" : "Encode",
        "htmlId" : "sec-encode",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    696,
    [
      "TryStatement[1,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[TryStatement[1]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « ».\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of |Finally| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "TryStatement[1,0].ContainsUndefinedContinueTarget",
        "name" : "TryStatement[1,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "TryStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "try"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              },
              {
                "type" : "nonterminal",
                "value" : "Finally"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    720,
    [
      "PrimaryExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[1,0].IsFunctionDefinition",
        "name" : "PrimaryExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "IdentifierReference"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2340,
    [
      "RegExpIdentifierPart[1,0].RegExpIdentifierCodePoint",
      2,
      [
        [
          "this",
          false,
          "Ast[RegExpIdentifierPart[1]]"
        ]
      ],
      "\n          1. Return the code point whose numeric value is the CharacterValue of |RegExpUnicodeEscapeSequence|.\n        ",
      {
        "normalizedName" : "RegExpIdentifierPart[1,0].RegExpIdentifierCodePoint",
        "name" : "RegExpIdentifierPart[1,0].RegExpIdentifierCodePoint",
        "htmlId" : "sec-regexpidentifiercodepoint",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "RegExpIdentifierCodePoint",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "RegExpIdentifierPart",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "\\"
              },
              {
                "type" : "nonterminal",
                "value" : "RegExpUnicodeEscapeSequence"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2668,
    [
      "INTRINSICS.DataView",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Perform ? RequireInternalSlot(_buffer_, [[ArrayBufferData]]).\n          1. Let _offset_ be ? ToIndex(_byteOffset_).\n          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.\n          1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_, ~seq-cst~).\n          1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.\n          1. Let _bufferIsFixedLength_ be IsFixedLengthArrayBuffer(_buffer_).\n          1. If _byteLength_ is *undefined*, then\n            1. If _bufferIsFixedLength_ is *true*, then\n              1. Let _viewByteLength_ be _bufferByteLength_ - _offset_.\n            1. Else,\n              1. Let _viewByteLength_ be ~auto~.\n          1. Else,\n            1. Let _viewByteLength_ be ? ToIndex(_byteLength_).\n            1. If _offset_ + _viewByteLength_ > _bufferByteLength_, throw a *RangeError* exception.\n          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%DataView.prototype%\"*, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).\n          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.\n          1. Set _bufferByteLength_ to ArrayBufferByteLength(_buffer_, ~seq-cst~).\n          1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.\n          1. If _byteLength_ is not *undefined*, then\n            1. If _offset_ + _viewByteLength_ > _bufferByteLength_, throw a *RangeError* exception.\n          1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.\n          1. Set _O_.[[ByteLength]] to _viewByteLength_.\n          1. Set _O_.[[ByteOffset]] to _offset_.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView",
        "name" : "INTRINSICS.DataView",
        "htmlId" : "sec-dataview-buffer-byteoffset-bytelength",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1165,
    [
      "Record[TypedArray].Set",
      4,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If _P_ is a String, then\n            1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n            1. If _numericIndex_ is not *undefined*, then\n              1. If SameValue(_O_, _Receiver_) is *true*, then\n                1. Perform ? TypedArraySetElement(_O_, _numericIndex_, _V_).\n                1. Return *true*.\n              1. If IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *true*.\n          1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_).\n        ",
      {
        "normalizedName" : "Record[TypedArray].Set",
        "name" : "Record[TypedArray].Set",
        "htmlId" : "sec-typedarray-set",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "TypedArray",
          "[[Set]]"
        ]
      }
    ]
  ],
  [
    2021,
    [
      "ModuleExportName[1,0].ReferencedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleExportName[1]]"
        ]
      ],
      "\n          1. Return a List whose sole element is the |StringLiteral|.\n        ",
      {
        "normalizedName" : "ModuleExportName[1,0].ReferencedBindings",
        "name" : "ModuleExportName[1,0].ReferencedBindings",
        "htmlId" : "sec-static-semantics-referencedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ReferencedBindings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ModuleExportName",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StringLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1346,
    [
      "ImportMeta[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportMeta[0]]"
        ]
      ],
      "\n          1. Let _module_ be GetActiveScriptOrModule().\n          1. Assert: _module_ is a Source Text Module Record.\n          1. Let _importMeta_ be _module_.[[ImportMeta]].\n          1. If _importMeta_ is ~empty~, then\n            1. Set _importMeta_ to OrdinaryObjectCreate(*null*).\n            1. Let _importMetaValues_ be HostGetImportMetaProperties(_module_).\n            1. For each Record { [[Key]], [[Value]] } _p_ of _importMetaValues_, do\n              1. Perform ! CreateDataPropertyOrThrow(_importMeta_, _p_.[[Key]], _p_.[[Value]]).\n            1. Perform HostFinalizeImportMeta(_importMeta_, _module_).\n            1. Set _module_.[[ImportMeta]] to _importMeta_.\n            1. Return _importMeta_.\n          1. Else,\n            1. Assert: _importMeta_ is an Object.\n            1. Return _importMeta_.\n        ",
      {
        "normalizedName" : "ImportMeta[0,0].Evaluation",
        "name" : "ImportMeta[0,0].Evaluation",
        "htmlId" : "sec-meta-properties-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ImportMeta",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "import"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "terminal",
                "value" : "meta"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2063,
    [
      "INTRINSICS.Object.isFrozen",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If _O_ is not an Object, return *true*.\n          1. Return ? TestIntegrityLevel(_O_, ~frozen~).\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.isFrozen",
        "name" : "INTRINSICS.Object.isFrozen",
        "htmlId" : "sec-object.isfrozen",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1610,
    [
      "FunctionBody[0,0].FunctionBodyContainsUseStrict",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionBody[0]]"
        ]
      ],
      "\n        1. If the Directive Prologue of |FunctionBody| contains a Use Strict Directive, return *true*; otherwise, return *false*.\n      ",
      {
        "normalizedName" : "FunctionBody[0,0].FunctionBodyContainsUseStrict",
        "name" : "FunctionBody[0,0].FunctionBodyContainsUseStrict",
        "htmlId" : "sec-static-semantics-functionbodycontainsusestrict",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "FunctionBodyContainsUseStrict",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionStatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    94,
    [
      "IsPrivateReference",
      0,
      [
        [
          "V",
          false,
          "Record[ReferenceRecord]"
        ]
      ],
      "\n          1. If _V_.[[ReferencedName]] is a Private Name, return *true*; otherwise return *false*.\n        ",
      {
        "normalizedName" : "IsPrivateReference",
        "name" : "IsPrivateReference",
        "htmlId" : "sec-isprivatereference",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2651,
    [
      "INTRINSICS.ArrayBuffer.prototype.slice",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. Let _len_ be _O_.[[ArrayBufferByteLength]].\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _first_ be 0.\n          1. Else if _relativeStart_ < 0, let _first_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _first_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _final_ be 0.\n          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _final_ be min(_relativeEnd_, _len_).\n          1. Let _newLen_ be max(_final_ - _first_, 0).\n          1. Let _ctor_ be ? SpeciesConstructor(_O_, %ArrayBuffer%).\n          1. Let _new_ be ? Construct(_ctor_, « 𝔽(_newLen_) »).\n          1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_new_) is *true*, throw a *TypeError* exception.\n          1. If IsDetachedBuffer(_new_) is *true*, throw a *TypeError* exception.\n          1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.\n          1. If _new_.[[ArrayBufferByteLength]] < _newLen_, throw a *TypeError* exception.\n          1. NOTE: Side-effects of the above steps may have detached or resized _O_.\n          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].\n          1. Let _toBuf_ be _new_.[[ArrayBufferData]].\n          1. Let _currentLen_ be _O_.[[ArrayBufferByteLength]].\n          1. If _first_ < _currentLen_, then\n            1. Let _count_ be min(_newLen_, _currentLen_ - _first_).\n            1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _count_).\n          1. Return _new_.\n        ",
      {
        "normalizedName" : "INTRINSICS.ArrayBuffer.prototype.slice",
        "name" : "INTRINSICS.ArrayBuffer.prototype.slice",
        "htmlId" : "sec-arraybuffer.prototype.slice",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2783,
    [
      "INTRINSICS.Promise.prototype.finally:clo1:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _promise_ be the *this* value.\n          1. If _promise_ is not an Object, throw a *TypeError* exception.\n          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).\n          1. Assert: IsConstructor(_C_) is *true*.\n          1. If IsCallable(_onFinally_) is *false*, then\n            1. Let _thenFinally_ be _onFinally_.\n            1. Let _catchFinally_ be _onFinally_.\n          1. Else,\n            1. Let _thenFinallyClosure_ be a new Abstract Closure with parameters (_value_) that captures _onFinally_ and _C_ and performs the following steps when called:\n              1. Let _result_ be ? Call(_onFinally_, *undefined*).\n              1. Let _p_ be ? PromiseResolve(_C_, _result_).\n              1. Let _returnValue_ be a new Abstract Closure with no parameters that captures _value_ and performs the following steps when called:\n                1. Return _value_.\n              1. Let _valueThunk_ be CreateBuiltinFunction(_returnValue_, 0, *\"\"*, « »).\n              1. Return ? Invoke(_p_, *\"then\"*, « _valueThunk_ »).\n            1. Let _thenFinally_ be CreateBuiltinFunction(_thenFinallyClosure_, 1, *\"\"*, « »).\n            1. Let _catchFinallyClosure_ be a new Abstract Closure with parameters (_reason_) that captures _onFinally_ and _C_ and performs the following steps when called:\n              1. Let _result_ be ? Call(_onFinally_, *undefined*).\n              1. Let _p_ be ? PromiseResolve(_C_, _result_).\n              1. Let _throwReason_ be a new Abstract Closure with no parameters that captures _reason_ and performs the following steps when called:\n                1. Return ThrowCompletion(_reason_).\n              1. Let _thrower_ be CreateBuiltinFunction(_throwReason_, 0, *\"\"*, « »).\n              1. Return ? Invoke(_p_, *\"then\"*, « _thrower_ »).\n            1. Let _catchFinally_ be CreateBuiltinFunction(_catchFinallyClosure_, 1, *\"\"*, « »).\n          1. Return ? Invoke(_promise_, *\"then\"*, « _thenFinally_, _catchFinally_ »).\n        ",
      {
        "normalizedName" : "INTRINSICS.Promise.prototype.finally",
        "name" : "INTRINSICS.Promise.prototype.finally",
        "htmlId" : "sec-promise.prototype.finally",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    796,
    [
      "PrimaryExpression[3,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[3]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[3,0].IsIdentifierRef",
        "name" : "PrimaryExpression[3,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrayLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    283,
    [
      "AsyncFunctionDeclaration[0,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionDeclaration[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncFunctionDeclaration[0,0].IsConstantDeclaration",
        "name" : "AsyncFunctionDeclaration[0,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    886,
    [
      "ObjectBindingPattern[3,0].BindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectBindingPattern[3]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Perform ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "ObjectBindingPattern[3,0].BindingInitialization",
        "name" : "ObjectBindingPattern[3,0].BindingInitialization",
        "htmlId" : "sec-runtime-semantics-bindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ObjectBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingPropertyList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1742,
    [
      "ClassTail[0,3].ClassDefinitionEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassTail[0]]"
        ],
        [
          "classBinding",
          false,
          "String | Undefined"
        ],
        [
          "className",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.\n        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n        1. If |ClassBody| is present, then\n          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do\n            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then\n              1. Assert: This is only possible for getter/setter pairs.\n            1. Else,\n              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.\n              1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n        1. If |ClassHeritage| is not present, then\n          1. Let _protoParent_ be %Object.prototype%.\n          1. Let _constructorParent_ be %Function.prototype%.\n        1. Else,\n          1. Set the running execution context's LexicalEnvironment to _classEnv_.\n          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).\n          1. Set the running execution context's LexicalEnvironment to _env_.\n          1. Let _superclass_ be ? GetValue(? _superclassRef_).\n          1. If _superclass_ is *null*, then\n            1. Let _protoParent_ be *null*.\n            1. Let _constructorParent_ be %Function.prototype%.\n          1. Else if IsConstructor(_superclass_) is *false*, then\n            1. Throw a *TypeError* exception.\n          1. Else,\n            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.\n            1. Let _constructorParent_ be _superclass_.\n        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n        1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n        1. Set the running execution context's LexicalEnvironment to _classEnv_.\n        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.\n        1. If _constructor_ is ~empty~, then\n          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n            1. If NewTarget is *undefined*, throw a *TypeError* exception.\n            1. Let _F_ be the active function object.\n            1. If _F_.[[ConstructorKind]] is ~derived~, then\n              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n            1. Else,\n              1. NOTE: This branch behaves similarly to `constructor() {}`.\n              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n            1. Perform ? InitializeInstanceElements(_result_, _F_).\n            1. Return _result_.\n          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n        1. Else,\n          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n          1. Let _F_ be _constructorInfo_.[[Closure]].\n          1. Perform MakeClassConstructor(_F_).\n          1. Perform SetFunctionName(_F_, _className_).\n        1. Perform MakeConstructor(_F_, *false*, _proto_).\n        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n        1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n        1. If |ClassBody| is not present, let _elements_ be a new empty List.\n        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n        1. Let _instancePrivateMethods_ be a new empty List.\n        1. Let _staticPrivateMethods_ be a new empty List.\n        1. Let _instanceFields_ be a new empty List.\n        1. Let _staticElements_ be a new empty List.\n        1. For each |ClassElement| _e_ of _elements_, do\n          1. If IsStatic of _e_ is *false*, then\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n          1. Else,\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n          1. If _element_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _env_.\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _element_.\n          1. Set _element_ to ! _element_.\n          1. If _element_ is a PrivateElement, then\n            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n            1. Else, let _container_ be _staticPrivateMethods_.\n            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.\n              1. If _element_.[[Get]] is *undefined*, then\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n              1. Else,\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n              1. Replace _pe_ in _container_ with _combined_.\n            1. Else,\n              1. Append _element_ to _container_.\n          1. Else if _element_ is a ClassFieldDefinition Record, then\n            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n            1. Else, append _element_ to _staticElements_.\n          1. Else if _element_ is a ClassStaticBlockDefinition Record, then\n            1. Append _element_ to _staticElements_.\n        1. Set the running execution context's LexicalEnvironment to _env_.\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n        1. Set _F_.[[Fields]] to _instanceFields_.\n        1. For each PrivateElement _method_ of _staticPrivateMethods_, do\n          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n        1. For each element _elementRecord_ of _staticElements_, do\n          1. If _elementRecord_ is a ClassFieldDefinition Record, then\n            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n          1. Else,\n            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.\n            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n          1. If _result_ is an abrupt completion, then\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _result_.\n        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "ClassTail[0,3].ClassDefinitionEvaluation",
        "name" : "ClassTail[0,3].ClassDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-classdefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ClassDefinitionEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ClassTail",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassHeritage"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2549,
    [
      "INTRINSICS.TypedArray.prototype.indexOf",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.\n          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.\n          1. If _n_ = +∞, return *-1*<sub>𝔽</sub>.\n          1. Else if _n_ = -∞, set _n_ to 0.\n          1. If _n_ ≥ 0, then\n            1. Let _k_ be _n_.\n          1. Else,\n            1. Let _k_ be _len_ + _n_.\n            1. If _k_ < 0, set _k_ to 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _kPresent_ be ! HasProperty(_O_, ! ToString(𝔽(_k_))).\n            1. If _kPresent_ is *true*, then\n              1. Let _elementK_ be ! Get(_O_, ! ToString(𝔽(_k_))).\n              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).\n            1. Set _k_ to _k_ + 1.\n          1. Return *-1*<sub>𝔽</sub>.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.indexOf",
        "name" : "INTRINSICS.TypedArray.prototype.indexOf",
        "htmlId" : "sec-%typedarray%.prototype.indexof",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    928,
    [
      "PrimaryExpression[7,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[7]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "PrimaryExpression[7,0].AssignmentTargetType",
        "name" : "PrimaryExpression[7,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "GeneratorExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    415,
    [
      "ConciseBody[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ConciseBody[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ConciseBody[0,0].VarDeclaredNames",
        "name" : "ConciseBody[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    871,
    [
      "FunctionDeclaration[0,0].InstantiateFunctionObject",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[0]]"
        ],
        [
          "env",
          false,
          "Record[EnvironmentRecord]"
        ],
        [
          "privateEnv",
          false,
          "Record[PrivateEnvironmentRecord] | Null"
        ]
      ],
      "\n        1. Return InstantiateOrdinaryFunctionObject of |FunctionDeclaration| with arguments _env_ and _privateEnv_.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[0,0].InstantiateFunctionObject",
        "name" : "FunctionDeclaration[0,0].InstantiateFunctionObject",
        "htmlId" : "sec-runtime-semantics-instantiatefunctionobject",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "InstantiateFunctionObject",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1120,
    [
      "Initializer[0,0].EvaluateBody",
      2,
      [
        [
          "this",
          false,
          "Ast[Initializer[0]]"
        ],
        [
          "functionObject",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "argumentsList",
          false,
          "List[ESValue]"
        ]
      ],
      "\n          1. Assert: _argumentsList_ is empty.\n          1. Assert: _functionObject_.[[ClassFieldInitializerName]] is not ~empty~.\n          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then\n            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _functionObject_.[[ClassFieldInitializerName]].\n          1. Else,\n            1. Let _rhs_ be ? Evaluation of |AssignmentExpression|.\n            1. Let _value_ be ? GetValue(_rhs_).\n          1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n        ",
      {
        "normalizedName" : "Initializer[0,0].EvaluateBody",
        "name" : "Initializer[0,0].EvaluateBody",
        "htmlId" : "sec-runtime-semantics-evaluatebody",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "EvaluateBody",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Initializer",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1093,
    [
      "OrdinaryDefineOwnProperty",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Desc",
          false,
          "Record[PropertyDescriptor]"
        ]
      ],
      "\n          1. Let _current_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. Let _extensible_ be ? IsExtensible(_O_).\n          1. Return ValidateAndApplyPropertyDescriptor(_O_, _P_, _extensible_, _Desc_, _current_).\n        ",
      {
        "normalizedName" : "OrdinaryDefineOwnProperty",
        "name" : "OrdinaryDefineOwnProperty",
        "htmlId" : "sec-ordinarydefineownproperty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1930,
    [
      "Record[CyclicModuleRecord].LoadRequestedModules",
      3,
      [
        [
          "module",
          false,
          "Record[CyclicModuleRecord]"
        ],
        [
          "hostDefined",
          true,
          "Unknown[\"Anything\"]"
        ]
      ],
      "\n            1. If _hostDefined_ is not present, let _hostDefined_ be ~empty~.\n            1. Let _pc_ be ! NewPromiseCapability(%Promise%).\n            1. Let _state_ be the GraphLoadingState Record { [[IsLoading]]: *true*, [[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]: _pc_, [[HostDefined]]: _hostDefined_ }.\n            1. Perform InnerModuleLoading(_state_, _module_).\n            1. Return _pc_.[[Promise]].\n          ",
      {
        "normalizedName" : "Record[CyclicModuleRecord].LoadRequestedModules",
        "name" : "Record[CyclicModuleRecord].LoadRequestedModules",
        "htmlId" : "sec-LoadRequestedModules",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "CyclicModuleRecord",
          "LoadRequestedModules"
        ]
      }
    ]
  ],
  [
    395,
    [
      "CaseBlock[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "CaseBlock[0,0].VarDeclaredNames",
        "name" : "CaseBlock[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    839,
    [
      "AsyncFunctionDeclaration[0,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionDeclaration[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncFunctionDeclaration[0,0].Contains",
        "name" : "AsyncFunctionDeclaration[0,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    624,
    [
      "CaseClause[0,1].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CaseClause[0,1].ContainsUndefinedBreakTarget",
        "name" : "CaseClause[0,1].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2353,
    [
      "MatchTwoAlternatives",
      0,
      [
        [
          "m1",
          false,
          "Record[Matcher]"
        ],
        [
          "m2",
          false,
          "Record[Matcher]"
        ]
      ],
      "\n            1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:\n              1. Assert: _x_ is a MatchState.\n              1. Assert: _c_ is a MatcherContinuation.\n              1. Let _r_ be _m1_(_x_, _c_).\n              1. If _r_ is not ~failure~, return _r_.\n              1. Return _m2_(_x_, _c_).\n          ",
      {
        "normalizedName" : "MatchTwoAlternatives",
        "name" : "MatchTwoAlternatives",
        "htmlId" : "sec-matchtwoalternatives",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    728,
    [
      "MemberExpression[3,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[3]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[3,0].IsFunctionDefinition",
        "name" : "MemberExpression[3,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "TemplateLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    740,
    [
      "UnaryExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "UnaryExpression[1,0].IsFunctionDefinition",
        "name" : "UnaryExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "delete"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1236,
    [
      "PrivateIdentifier[0,0].StringValue",
      2,
      [
        [
          "this",
          false,
          "Ast[PrivateIdentifier[0]]"
        ]
      ],
      "\n        1. Return the string-concatenation of 0x0023 (NUMBER SIGN) and the StringValue of |IdentifierName|.\n      ",
      {
        "normalizedName" : "PrivateIdentifier[0,0].StringValue",
        "name" : "PrivateIdentifier[0,0].StringValue",
        "htmlId" : "sec-static-semantics-stringvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "PrivateIdentifier",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "#"
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2502,
    [
      "INTRINSICS.Array.prototype.keys",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Return CreateArrayIterator(_O_, ~key~).\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.keys",
        "name" : "INTRINSICS.Array.prototype.keys",
        "htmlId" : "sec-array.prototype.keys",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2241,
    [
      "INTRINSICS.String.prototype.charCodeAt",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).\n          1. Let _size_ be the length of _S_.\n          1. If _position_ < 0 or _position_ ≥ _size_, return *NaN*.\n          1. Return the Number value for the numeric value of the code unit at index _position_ within the String _S_.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.charCodeAt",
        "name" : "INTRINSICS.String.prototype.charCodeAt",
        "htmlId" : "sec-string.prototype.charcodeat",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    987,
    [
      "AssignmentExpression[7,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[7]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "AssignmentExpression[7,0].AssignmentTargetType",
        "name" : "AssignmentExpression[7,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "||="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2127,
    [
      "INTRINSICS.Math.acosh",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ < *1*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the inverse hyperbolic cosine of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.acosh",
        "name" : "INTRINSICS.Math.acosh",
        "htmlId" : "sec-math.acosh",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2159,
    [
      "Day",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. Return 𝔽(floor(ℝ(_t_ / msPerDay))).\n        ",
      {
        "normalizedName" : "Day",
        "name" : "Day",
        "htmlId" : "sec-day",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2810,
    [
      "AsyncGeneratorStart:cont1",
      7,
      [
      ],
      "\n          1. Assert: _generator_.[[AsyncGeneratorState]] is *undefined*.\n          1. Let _genContext_ be the running execution context.\n          1. Set the Generator component of _genContext_ to _generator_.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:\n            1. Let _acGenContext_ be the running execution context.\n            1. Let _acGenerator_ be the Generator component of _acGenContext_.\n            1. If _generatorBody_ is a Parse Node, then\n              1. Let _result_ be Completion(Evaluation of _generatorBody_).\n            1. Else,\n              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.\n              1. Let _result_ be Completion(_generatorBody_()).\n            1. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.\n            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. Set _acGenerator_.[[AsyncGeneratorState]] to ~completed~.\n            1. If _result_ is a normal completion, set _result_ to NormalCompletion(*undefined*).\n            1. If _result_ is a return completion, set _result_ to NormalCompletion(_result_.[[Value]]).\n            1. Perform AsyncGeneratorCompleteStep(_acGenerator_, _result_, *true*).\n            1. Perform AsyncGeneratorDrainQueue(_acGenerator_).\n            1. Return *undefined*.\n          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Set _generator_.[[AsyncGeneratorContext]] to _genContext_.\n          1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-start~.\n          1. Set _generator_.[[AsyncGeneratorQueue]] to a new empty List.\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AsyncGeneratorStart",
        "name" : "AsyncGeneratorStart",
        "htmlId" : "sec-asyncgeneratorstart",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : true,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    464,
    [
      "SwitchStatement[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[SwitchStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |CaseBlock|.\n      ",
      {
        "normalizedName" : "SwitchStatement[0,0].VarScopedDeclarations",
        "name" : "SwitchStatement[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "SwitchStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "switch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseBlock"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1352,
    [
      "UnaryExpression[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[2]]"
        ]
      ],
      "\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Perform ? GetValue(_expr_).\n          1. Return *undefined*.\n        ",
      {
        "normalizedName" : "UnaryExpression[2,0].Evaluation",
        "name" : "UnaryExpression[2,0].Evaluation",
        "htmlId" : "sec-void-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "void"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2731,
    [
      "UnicodeEscape",
      0,
      [
        [
          "C",
          false,
          "Unknown[\"CodeUnit\"]"
        ]
      ],
      "\n          1. Let _n_ be the numeric value of _C_.\n          1. Assert: _n_ ≤ 0xFFFF.\n          1. Let _hex_ be the String representation of _n_, formatted as a lowercase hexadecimal number.\n          1. Return the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS), *\"u\"*, and StringPad(_hex_, 4, *\"0\"*, ~start~).\n        ",
      {
        "normalizedName" : "UnicodeEscape",
        "name" : "UnicodeEscape",
        "htmlId" : "sec-unicodeescape",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1829,
    [
      "AssignmentExpression[8,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[8]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[8,0].HasCallInTailPosition",
        "name" : "AssignmentExpression[8,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "??="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1977,
    [
      "ExportDeclaration[5,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[5]]"
        ]
      ],
      "\n          1. Return the BoundNames of this |ExportDeclaration|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[5,0].ExportedBindings",
        "name" : "ExportDeclaration[5,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    332,
    [
      "LabelledStatement[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledStatement[0]]"
        ]
      ],
      "\n        1. Return the LexicallyScopedDeclarations of |LabelledItem|.\n      ",
      {
        "normalizedName" : "LabelledStatement[0,0].LexicallyScopedDeclarations",
        "name" : "LabelledStatement[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelledItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1129,
    [
      "MakeMethod",
      0,
      [
        [
          "F",
          false,
          "Record[ECMAScriptFunctionObject]"
        ],
        [
          "homeObject",
          false,
          "Record[Object]"
        ]
      ],
      "\n        1. Set _F_.[[HomeObject]] to _homeObject_.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "MakeMethod",
        "name" : "MakeMethod",
        "htmlId" : "sec-makemethod",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1827,
    [
      "AssignmentExpression[6,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[6]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[6,0].HasCallInTailPosition",
        "name" : "AssignmentExpression[6,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "&&="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1261,
    [
      "ArrayLiteral[2,1].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayLiteral[2]]"
        ]
      ],
      "\n          1. Let _array_ be ! ArrayCreate(0).\n          1. Let _nextIndex_ be ? ArrayAccumulation of |ElementList| with arguments _array_ and 0.\n          1. If |Elision| is present, then\n            1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Return _array_.\n        ",
      {
        "normalizedName" : "ArrayLiteral[2,1].Evaluation",
        "name" : "ArrayLiteral[2,1].Evaluation",
        "htmlId" : "sec-array-initializer-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ArrayLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "ElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2430,
    [
      "HasEitherUnicodeFlag",
      0,
      [
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n            1. If _rer_.[[Unicode]] is *true* or _rer_.[[UnicodeSets]] is *true*, then\n              1. Return *true*.\n            1. Return *false*.\n          ",
      {
        "normalizedName" : "HasEitherUnicodeFlag",
        "name" : "HasEitherUnicodeFlag",
        "htmlId" : "sec-runtime-semantics-haseitherunicodeflag-abstract-operation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1268,
    [
      "ObjectLiteral[2,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ObjectLiteral[2]]"
        ]
      ],
      "\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with argument _obj_.\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "ObjectLiteral[2,0].Evaluation",
        "name" : "ObjectLiteral[2,0].Evaluation",
        "htmlId" : "sec-object-initializer-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ObjectLiteral",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "PropertyDefinitionList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    575,
    [
      "Statement[2,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[2]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[2,0].ContainsUndefinedBreakTarget",
        "name" : "Statement[2,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EmptyStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1152,
    [
      "Record[ArgumentsExoticObject].Get",
      4,
      [
        [
          "args",
          false,
          "Record[ArgumentsExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _map_ be _args_.[[ParameterMap]].\n          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n          1. If _isMapped_ is *false*, then\n            1. Return ? OrdinaryGet(_args_, _P_, _Receiver_).\n          1. Else,\n            1. Assert: _map_ contains a formal parameter mapping for _P_.\n            1. Return ! Get(_map_, _P_).\n        ",
      {
        "normalizedName" : "Record[ArgumentsExoticObject].Get",
        "name" : "Record[ArgumentsExoticObject].Get",
        "htmlId" : "sec-arguments-exotic-objects-get-p-receiver",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ArgumentsExoticObject",
          "[[Get]]"
        ]
      }
    ]
  ],
  [
    427,
    [
      "Statement[11,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[11]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[11,0].VarScopedDeclarations",
        "name" : "Statement[11,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 11,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ThrowStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2803,
    [
      "GeneratorYield",
      0,
      [
        [
          "iterNextObj",
          false,
          "Unknown[\"ObjectThatConformsToThe<i>IteratorResult</i>Interface\"]"
        ]
      ],
      "\n          1. Let _genContext_ be the running execution context.\n          1. Assert: _genContext_ is the execution context of a generator.\n          1. Let _generator_ be the value of the Generator component of _genContext_.\n          1. Assert: GetGeneratorKind() is ~sync~.\n          1. Set _generator_.[[GeneratorState]] to ~suspended-yield~.\n          1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n          1. Let _callerContext_ be the running execution context.\n          1. Resume _callerContext_ passing NormalCompletion(_iterNextObj_). If _genContext_ is ever resumed again, let _resumptionValue_ be the Completion Record with which it is resumed.\n          1. Assert: If control reaches here, then _genContext_ is the running execution context again.\n          1. Return _resumptionValue_.\n        ",
      {
        "normalizedName" : "GeneratorYield",
        "name" : "GeneratorYield",
        "htmlId" : "sec-generatoryield",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1532,
    [
      "LabelledStatement[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[LabelledStatement[0]]"
        ]
      ],
      "\n        1. Return ? LabelledEvaluation of this |LabelledStatement| with argument « ».\n      ",
      {
        "normalizedName" : "LabelledStatement[0,0].Evaluation",
        "name" : "LabelledStatement[0,0].Evaluation",
        "htmlId" : "sec-labelled-statements-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "LabelledStatement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LabelIdentifier"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "LabelledItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    860,
    [
      "MethodDefinition[0,0].ComputedPropertyContains",
      2,
      [
        [
          "this",
          false,
          "Ast[MethodDefinition[0]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      ",
      {
        "normalizedName" : "MethodDefinition[0,0].ComputedPropertyContains",
        "name" : "MethodDefinition[0,0].ComputedPropertyContains",
        "htmlId" : "sec-static-semantics-computedpropertycontains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ComputedPropertyContains",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "MethodDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2847,
    [
      "INTRINSICS.Reflect.preventExtensions",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[PreventExtensions]]()</emu-meta>.\n      ",
      {
        "normalizedName" : "INTRINSICS.Reflect.preventExtensions",
        "name" : "INTRINSICS.Reflect.preventExtensions",
        "htmlId" : "sec-reflect.preventextensions",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2600,
    [
      "CreateMapIterator:clo0",
      6,
      [
      ],
      "\n          1. Perform ? RequireInternalSlot(_map_, [[MapData]]).\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _map_ and _kind_ and performs the following steps when called:\n            1. Let _entries_ be _map_.[[MapData]].\n            1. Let _index_ be 0.\n            1. Let _numEntries_ be the number of elements in _entries_.\n            1. Repeat, while _index_ < _numEntries_,\n              1. Let _e_ be _entries_[_index_].\n              1. Set _index_ to _index_ + 1.\n              1. If _e_.[[Key]] is not ~empty~, then\n                1. If _kind_ is ~key~, then\n                  1. Let _result_ be _e_.[[Key]].\n                1. Else if _kind_ is ~value~, then\n                  1. Let _result_ be _e_.[[Value]].\n                1. Else,\n                  1. Assert: _kind_ is ~key+value~.\n                  1. Let _result_ be CreateArrayFromList(« _e_.[[Key]], _e_.[[Value]] »).\n                1. Perform ? GeneratorYield(CreateIterResultObject(_result_, *false*)).\n                1. NOTE: The number of elements in _entries_ may have increased while execution of this abstract operation was paused by Yield.\n                1. Set _numEntries_ to the number of elements in _entries_.\n            1. Return NormalCompletion(*undefined*).\n          1. Return CreateIteratorFromClosure(_closure_, *\"%MapIteratorPrototype%\"*, %MapIteratorPrototype%).\n        ",
      {
        "normalizedName" : "CreateMapIterator",
        "name" : "CreateMapIterator",
        "htmlId" : "sec-createmapiterator",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1384,
    [
      "AssignmentExpression[4,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[4]]"
        ]
      ],
      "\n        1. If |LeftHandSideExpression| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n          1. Let _lref_ be ? Evaluation of |LeftHandSideExpression|.\n          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) and IsIdentifierRef of |LeftHandSideExpression| are both *true*, then\n            1. Let _rval_ be ? NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].\n          1. Else,\n            1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n            1. Let _rval_ be ? GetValue(_rref_).\n          1. [id=\"step-assignmentexpression-evaluation-simple-putvalue\"] Perform ? PutValue(_lref_, _rval_).\n          1. Return _rval_.\n        1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |LeftHandSideExpression|.\n        1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Perform ? DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _rval_.\n        1. Return _rval_.\n      ",
      {
        "normalizedName" : "AssignmentExpression[4,0].Evaluation",
        "name" : "AssignmentExpression[4,0].Evaluation",
        "htmlId" : "sec-assignment-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "="
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2485,
    [
      "INTRINSICS.Array.prototype.copyWithin",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).\n          1. If _relativeTarget_ = -∞, let _to_ be 0.\n          1. Else if _relativeTarget_ < 0, let _to_ be max(_len_ + _relativeTarget_, 0).\n          1. Else, let _to_ be min(_relativeTarget_, _len_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _from_ be 0.\n          1. Else if _relativeStart_ < 0, let _from_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _from_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _final_ be 0.\n          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _final_ be min(_relativeEnd_, _len_).\n          1. Let _count_ be min(_final_ - _from_, _len_ - _to_).\n          1. If _from_ < _to_ and _to_ < _from_ + _count_, then\n            1. Let _direction_ be -1.\n            1. Set _from_ to _from_ + _count_ - 1.\n            1. Set _to_ to _to_ + _count_ - 1.\n          1. Else,\n            1. Let _direction_ be 1.\n          1. Repeat, while _count_ > 0,\n            1. Let _fromKey_ be ! ToString(𝔽(_from_)).\n            1. Let _toKey_ be ! ToString(𝔽(_to_)).\n            1. Let _fromPresent_ be ? HasProperty(_O_, _fromKey_).\n            1. If _fromPresent_ is *true*, then\n              1. Let _fromVal_ be ? Get(_O_, _fromKey_).\n              1. Perform ? Set(_O_, _toKey_, _fromVal_, *true*).\n            1. Else,\n              1. Assert: _fromPresent_ is *false*.\n              1. Perform ? DeletePropertyOrThrow(_O_, _toKey_).\n            1. Set _from_ to _from_ + _direction_.\n            1. Set _to_ to _to_ + _direction_.\n            1. Set _count_ to _count_ - 1.\n          1. Return _O_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.copyWithin",
        "name" : "INTRINSICS.Array.prototype.copyWithin",
        "htmlId" : "sec-array.prototype.copywithin",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1537,
    [
      "Statement[0,0].LabelledEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ? Evaluation of |Statement|.\n      ",
      {
        "normalizedName" : "Statement[0,0].LabelledEvaluation",
        "name" : "Statement[0,0].LabelledEvaluation",
        "htmlId" : "sec-runtime-semantics-labelledevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LabelledEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BlockStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    596,
    [
      "ForStatement[1,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[1,0].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[1,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1378,
    [
      "BitwiseXORExpression[1,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[BitwiseXORExpression[1]]"
        ]
      ],
      "\n        1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseXORExpression|, `^`, |BitwiseANDExpression|).\n      ",
      {
        "normalizedName" : "BitwiseXORExpression[1,0].Evaluation",
        "name" : "BitwiseXORExpression[1,0].Evaluation",
        "htmlId" : "sec-binary-bitwise-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "BitwiseXORExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BitwiseXORExpression"
              },
              {
                "type" : "terminal",
                "value" : "^"
              },
              {
                "type" : "nonterminal",
                "value" : "BitwiseANDExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1582,
    [
      "AsyncArrowBindingIdentifier[0,0].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncArrowBindingIdentifier[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncArrowBindingIdentifier[0,0].ContainsExpression",
        "name" : "AsyncArrowBindingIdentifier[0,0].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncArrowBindingIdentifier",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2265,
    [
      "INTRINSICS.String.prototype.startsWith",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _isRegExp_ be ? IsRegExp(_searchString_).\n          1. If _isRegExp_ is *true*, throw a *TypeError* exception.\n          1. Let _searchStr_ be ? ToString(_searchString_).\n          1. Let _len_ be the length of _S_.\n          1. If _position_ is *undefined*, let _pos_ be 0; else let _pos_ be ? ToIntegerOrInfinity(_position_).\n          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.\n          1. Let _searchLength_ be the length of _searchStr_.\n          1. If _searchLength_ = 0, return *true*.\n          1. Let _end_ be _start_ + _searchLength_.\n          1. If _end_ > _len_, return *false*.\n          1. Let _substring_ be the substring of _S_ from _start_ to _end_.\n          1. If _substring_ is _searchStr_, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.startsWith",
        "name" : "INTRINSICS.String.prototype.startsWith",
        "htmlId" : "sec-string.prototype.startswith",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1019,
    [
      "Record[ObjectEnvironmentRecord].CreateMutableBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[ObjectEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "D",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n            1. Perform ? DefinePropertyOrThrow(_bindingObject_, _N_, PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }).\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[ObjectEnvironmentRecord].CreateMutableBinding",
        "name" : "Record[ObjectEnvironmentRecord].CreateMutableBinding",
        "htmlId" : "sec-object-environment-records-createmutablebinding-n-d",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ObjectEnvironmentRecord",
          "CreateMutableBinding"
        ]
      }
    ]
  ],
  [
    528,
    [
      "ForStatement[0,2].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,2].ContainsDuplicateLabels",
        "name" : "ForStatement[0,2].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2467,
    [
      "RegExpExec",
      0,
      [
        [
          "R",
          false,
          "Record[Object]"
        ],
        [
          "S",
          false,
          "String"
        ]
      ],
      "\n          1. Let _exec_ be ? Get(_R_, *\"exec\"*).\n          1. If IsCallable(_exec_) is *true*, then\n            1. Let _result_ be ? Call(_exec_, _R_, « _S_ »).\n            1. If _result_ is not an Object and _result_ is not *null*, throw a *TypeError* exception.\n            1. Return _result_.\n          1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).\n          1. Return ? RegExpBuiltinExec(_R_, _S_).\n        ",
      {
        "normalizedName" : "RegExpExec",
        "name" : "RegExpExec",
        "htmlId" : "sec-regexpexec",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1976,
    [
      "ExportDeclaration[4,0].ExportedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[4]]"
        ]
      ],
      "\n          1. Return the BoundNames of this |ExportDeclaration|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[4,0].ExportedBindings",
        "name" : "ExportDeclaration[4,0].ExportedBindings",
        "htmlId" : "sec-static-semantics-exportedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExportedBindings",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "nonterminal",
                "value" : "HoistableDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    644,
    [
      "Statement[13,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[13]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[13,0].ContainsUndefinedContinueTarget",
        "name" : "Statement[13,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 13,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DebuggerStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1550,
    [
      "Catch[0,0].CatchClauseEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Catch[0]]"
        ],
        [
          "thrownValue",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _catchEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n        1. For each element _argName_ of the BoundNames of |CatchParameter|, do\n          1. Perform ! _catchEnv_.CreateMutableBinding(_argName_, *false*).\n        1. Set the running execution context's LexicalEnvironment to _catchEnv_.\n        1. Let _status_ be Completion(BindingInitialization of |CatchParameter| with arguments _thrownValue_ and _catchEnv_).\n        1. If _status_ is an abrupt completion, then\n          1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n          1. Return ? _status_.\n        1. Let _B_ be Completion(Evaluation of |Block|).\n        1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n        1. Return ? _B_.\n      ",
      {
        "normalizedName" : "Catch[0,0].CatchClauseEvaluation",
        "name" : "Catch[0,0].CatchClauseEvaluation",
        "htmlId" : "sec-runtime-semantics-catchclauseevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CatchClauseEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Catch",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "catch"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "CatchParameter"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Block"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1357,
    [
      "UnaryExpression[7,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[UnaryExpression[7]]"
        ]
      ],
      "\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Let _oldValue_ be ToBoolean(? GetValue(_expr_)).\n          1. If _oldValue_ is *true*, return *false*.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "UnaryExpression[7,0].Evaluation",
        "name" : "UnaryExpression[7,0].Evaluation",
        "htmlId" : "sec-logical-not-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 7,
            "j" : 0,
            "astName" : "UnaryExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "!"
              },
              {
                "type" : "nonterminal",
                "value" : "UnaryExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    459,
    [
      "ForInOfStatement[8,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[8]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForInOfStatement[8,0].VarScopedDeclarations",
        "name" : "ForInOfStatement[8,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 8,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2583,
    [
      "InitializeTypedArrayFromList",
      0,
      [
        [
          "O",
          false,
          "Record[TypedArray]"
        ],
        [
          "values",
          false,
          "List[ESValue]"
        ]
      ],
      "\n            1. Let _len_ be the number of elements in _values_.\n            1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).\n            1. Let _k_ be 0.\n            1. Repeat, while _k_ < _len_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Let _kValue_ be the first element of _values_.\n              1. Remove the first element from _values_.\n              1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).\n              1. Set _k_ to _k_ + 1.\n            1. Assert: _values_ is now an empty List.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "InitializeTypedArrayFromList",
        "name" : "InitializeTypedArrayFromList",
        "htmlId" : "sec-initializetypedarrayfromlist",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    908,
    [
      "ArrowParameters[0,0].IteratorBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowParameters[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Let _v_ be *undefined*.\n        1. Assert: _iteratorRecord_.[[Done]] is *false*.\n        1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n        1. If _next_ is not ~done~, then\n          1. Set _v_ to _next_.\n        1. Return ? BindingInitialization of |BindingIdentifier| with arguments _v_ and _environment_.\n      ",
      {
        "normalizedName" : "ArrowParameters[0,0].IteratorBindingInitialization",
        "name" : "ArrowParameters[0,0].IteratorBindingInitialization",
        "htmlId" : "sec-runtime-semantics-iteratorbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrowParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    992,
    [
      "PropertyDefinition[2,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyDefinition[2]]"
        ]
      ],
      "\n        1. Return PropName of |PropertyName|.\n      ",
      {
        "normalizedName" : "PropertyDefinition[2,0].PropName",
        "name" : "PropertyDefinition[2,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "PropertyDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PropertyName"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1500,
    [
      "ForInOfStatement[5,0].ForInOfLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[5]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~iterate~).\n          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_).\n        ",
      {
        "normalizedName" : "ForInOfStatement[5,0].ForInOfLoopEvaluation",
        "name" : "ForInOfStatement[5,0].ForInOfLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forinofloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForInOfLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "ForDeclaration"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1923,
    [
      "ExportDeclaration[0,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[0]]"
        ]
      ],
      "\n          1. Return the ModuleRequests of |FromClause|.\n        ",
      {
        "normalizedName" : "ExportDeclaration[0,0].ModuleRequests",
        "name" : "ExportDeclaration[0,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "ExportFromClause"
              },
              {
                "type" : "nonterminal",
                "value" : "FromClause"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    723,
    [
      "PrimaryExpression[4,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[4]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[4,0].IsFunctionDefinition",
        "name" : "PrimaryExpression[4,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ObjectLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    822,
    [
      "ArrowFunction[0,0].NamedEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowFunction[0]]"
        ],
        [
          "name",
          false,
          "Record[PrivateName | Symbol] | String"
        ]
      ],
      "\n        1. Return InstantiateArrowFunctionExpression of |ArrowFunction| with argument _name_.\n      ",
      {
        "normalizedName" : "ArrowFunction[0,0].NamedEvaluation",
        "name" : "ArrowFunction[0,0].NamedEvaluation",
        "htmlId" : "sec-runtime-semantics-namedevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "NamedEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrowFunction",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrowParameters"
              },
              {
                "type" : "terminal",
                "value" : "=>"
              },
              {
                "type" : "nonterminal",
                "value" : "ConciseBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2507,
    [
      "INTRINSICS.Array.prototype.reduce",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Let _accumulator_ be *undefined*.\n          1. If _initialValue_ is present, then\n            1. Set _accumulator_ to _initialValue_.\n          1. Else,\n            1. Let _kPresent_ be *false*.\n            1. Repeat, while _kPresent_ is *false* and _k_ < _len_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).\n              1. If _kPresent_ is *true*, then\n                1. Set _accumulator_ to ? Get(_O_, _Pk_).\n              1. Set _k_ to _k_ + 1.\n            1. If _kPresent_ is *false*, throw a *TypeError* exception.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).\n            1. Set _k_ to _k_ + 1.\n          1. Return _accumulator_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Array.prototype.reduce",
        "name" : "INTRINSICS.Array.prototype.reduce",
        "htmlId" : "sec-array.prototype.reduce",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    131,
    [
      "ToIntegerOrInfinity",
      0,
      [
        [
          "argument",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return 0.\n        1. If _number_ is *+∞*<sub>𝔽</sub>, return +∞.\n        1. If _number_ is *-∞*<sub>𝔽</sub>, return -∞.\n        1. Return truncate(ℝ(_number_)).\n      ",
      {
        "normalizedName" : "ToIntegerOrInfinity",
        "name" : "ToIntegerOrInfinity",
        "htmlId" : "sec-tointegerorinfinity",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    47,
    [
      "RunJobs:clo0",
      6,
      [
      ],
      "\n    1. Perform ? InitializeHostDefinedRealm().\n    1. Let _scriptEvaluationJob_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n      1. Let _sourceText_ be the source code of a script.\n      1. Let _script_ be ParseScript(_sourceText_, the current Realm Record, ~empty~).\n      1. Perform ? ScriptEvaluation(_script_).\n      1. Return *undefined*.\n    1. Perform HostEnqueuePromiseJob(_scriptEvaluationJob_, the current Realm Record).\n    1. Let _errors_ be *undefined*.\n    1. Repeat,\n      1. Suspend the running execution context and remove it from the execution context stack.\n      1. Assert: The execution context stack is empty.\n      1. Let _nextQueue_ be a non-empty Job Queue chosen in an implementation-defined manner.\n      1. If all Job Queues are empty, the result is implementation-defined.\n      1. Let _nextPending_ be the PendingJob record at the front of _nextQueue_. Remove that record from _nextQueue_.\n      1. Let _newContext_ be a new execution context.\n      1. Set _newContext_'s Function to *null*.\n      1. Set _newContext_'s Realm to _nextPending_.[[Realm]].\n      1. Set _newContext_'s ScriptOrModule to _nextPending_.[[ScriptOrModule]].\n      1. Push _newContext_ onto the execution context stack; _newContext_ is now the running execution context.\n      1. Let _job_ be _nextPending_.[[Job]].\n      1. Let _result_ be _job_().\n      1. If _result_ is an abrupt completion,\n        1. If _errors_ is *undefined*, set _errors_ to « _result_.[[Value]] ».\n        1. Otherwise, append _result_.[[Value]] to _errors_.\n  ",
      {
        "normalizedName" : "RunJobs",
        "name" : "RunJobs",
        "htmlId" : "sec-runjobs",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    15,
    [
      "INTRINSICS.String.prototype.toLocaleLowerCase",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Object] | Undefined"
        ]
      ],
      "",
      null
    ]
  ],
  [
    1925,
    [
      "ExportDeclaration[2,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportDeclaration[2]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "ExportDeclaration[2,0].ModuleRequests",
        "name" : "ExportDeclaration[2,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "ExportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "export"
              },
              {
                "type" : "nonterminal",
                "value" : "VariableStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    163,
    [
      "Set",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "V",
          false,
          "ESValue"
        ],
        [
          "Throw",
          false,
          "Boolean"
        ]
      ],
      "\n        1. Let _success_ be ? <emu-meta effects=\"user-code\">_O_.[[Set]]</emu-meta>(_P_, _V_, _O_).\n        1. If _success_ is *false* and _Throw_ is *true*, throw a *TypeError* exception.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "Set",
        "name" : "Set",
        "htmlId" : "sec-set-o-p-v-throw",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    200,
    [
      "IteratorStepValue",
      0,
      [
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n        1. Let _result_ be Completion(IteratorNext(_iteratorRecord_)).\n        1. If _result_ is a throw completion, then\n          1. Set _iteratorRecord_.[[Done]] to *true*.\n          1. Return ? _result_.\n        1. Set _result_ to ! _result_.\n        1. Let _done_ be Completion(IteratorComplete(_result_)).\n        1. If _done_ is a throw completion, then\n          1. Set _iteratorRecord_.[[Done]] to *true*.\n          1. Return ? _done_.\n        1. Set _done_ to ! _done_.\n        1. If _done_ is *true*, then\n          1. Set _iteratorRecord_.[[Done]] to *true*.\n          1. Return ~done~.\n        1. Let _value_ be Completion(Get(_result_, *\"value\"*)).\n        1. If _value_ is a throw completion, then\n          1. Set _iteratorRecord_.[[Done]] to *true*.\n        1. Return ? _value_.\n      ",
      {
        "normalizedName" : "IteratorStepValue",
        "name" : "IteratorStepValue",
        "htmlId" : "sec-iteratorstepvalue",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2539,
    [
      "INTRINSICS.TypedArray.prototype.entries",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _O_ be the *this* value.\n          1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Return CreateArrayIterator(_O_, ~key+value~).\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.entries",
        "name" : "INTRINSICS.TypedArray.prototype.entries",
        "htmlId" : "sec-%typedarray%.prototype.entries",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    850,
    [
      "PropertyDefinition[3,0].Contains",
      2,
      [
        [
          "this",
          false,
          "Ast[PropertyDefinition[3]]"
        ],
        [
          "symbol",
          false,
          "GrammarSymbol"
        ]
      ],
      "\n        1. If _symbol_ is |MethodDefinition|, return *true*.\n        1. Return the result of ComputedPropertyContains of |MethodDefinition| with argument _symbol_.\n      ",
      {
        "normalizedName" : "PropertyDefinition[3,0].Contains",
        "name" : "PropertyDefinition[3,0].Contains",
        "htmlId" : "sec-static-semantics-contains",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Contains",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "PropertyDefinition",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MethodDefinition"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1713,
    [
      "AsyncGeneratorExpression[0,0].ContainsArguments",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncGeneratorExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncGeneratorExpression[0,0].ContainsArguments",
        "name" : "AsyncGeneratorExpression[0,0].ContainsArguments",
        "htmlId" : "sec-static-semantics-containsarguments",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsArguments",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncGeneratorExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "*"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncGeneratorBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    68,
    [
      "Number::bitwiseXOR",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. Return NumberBitwiseOp(`^`, _x_, _y_).\n          ",
      {
        "normalizedName" : "Number::bitwiseXOR",
        "name" : "Number::bitwiseXOR",
        "htmlId" : "sec-numeric-types-number-bitwiseXOR",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1597,
    [
      "BindingElement[1,1].HasInitializer",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElement[1]]"
        ]
      ],
      "\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "BindingElement[1,1].HasInitializer",
        "name" : "BindingElement[1,1].HasInitializer",
        "htmlId" : "sec-static-semantics-hasinitializer",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasInitializer",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 1,
            "astName" : "BindingElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingPattern"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2687,
    [
      "INTRINSICS.DataView.prototype.setInt16",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~int16~, _value_).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.setInt16",
        "name" : "INTRINSICS.DataView.prototype.setInt16",
        "htmlId" : "sec-dataview.prototype.setint16",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1004,
    [
      "AsyncMethod[0,0].PropName",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncMethod[0]]"
        ]
      ],
      "\n        1. Return PropName of |ClassElementName|.\n      ",
      {
        "normalizedName" : "AsyncMethod[0,0].PropName",
        "name" : "AsyncMethod[0,0].PropName",
        "htmlId" : "sec-static-semantics-propname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "PropName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncMethod",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassElementName"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "UniqueFormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    982,
    [
      "AssignmentExpression[2,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[2]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "AssignmentExpression[2,0].AssignmentTargetType",
        "name" : "AssignmentExpression[2,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ArrowFunction"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    62,
    [
      "Number::lessThan",
      1,
      [
        [
          "x",
          false,
          "Number"
        ],
        [
          "y",
          false,
          "Number"
        ]
      ],
      "\n            1. If _x_ is *NaN*, return *undefined*.\n            1. If _y_ is *NaN*, return *undefined*.\n            1. If _x_ is _y_, return *false*.\n            1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *false*.\n            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *false*.\n            1. If _x_ is *+∞*<sub>𝔽</sub>, return *false*.\n            1. If _y_ is *+∞*<sub>𝔽</sub>, return *true*.\n            1. If _y_ is *-∞*<sub>𝔽</sub>, return *false*.\n            1. If _x_ is *-∞*<sub>𝔽</sub>, return *true*.\n            1. Assert: _x_ and _y_ are finite.\n            1. If ℝ(_x_) < ℝ(_y_), return *true*. Otherwise, return *false*.\n          ",
      {
        "normalizedName" : "Number::lessThan",
        "name" : "Number::lessThan",
        "htmlId" : "sec-numeric-types-number-lessThan",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1880,
    [
      "PrimaryExpression[5,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[5]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[5,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[5,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "FunctionExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1431,
    [
      "BlockDeclarationInstantiation",
      0,
      [
        [
          "code",
          false,
          "Ast"
        ],
        [
          "env",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ]
      ],
      "\n        1. Let _declarations_ be the LexicallyScopedDeclarations of _code_.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. For each element _d_ of _declarations_, do\n          1. For each element _dn_ of the BoundNames of _d_, do\n            1. If IsConstantDeclaration of _d_ is *true*, then\n              1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).\n            1. Else,\n              1. [id=\"step-blockdeclarationinstantiation-createmutablebinding\"] Perform ! _env_.CreateMutableBinding(_dn_, *false*). NOTE: This step is replaced in section <emu-xref href=\"#sec-web-compat-blockdeclarationinstantiation\"></emu-xref>.\n          1. If _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then\n            1. Let _fn_ be the sole element of the BoundNames of _d_.\n            1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.\n            1. [id=\"step-blockdeclarationinstantiation-initializebinding\"] Perform ! _env_.InitializeBinding(_fn_, _fo_). NOTE: This step is replaced in section <emu-xref href=\"#sec-web-compat-blockdeclarationinstantiation\"></emu-xref>.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "BlockDeclarationInstantiation",
        "name" : "BlockDeclarationInstantiation",
        "htmlId" : "sec-blockdeclarationinstantiation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    178,
    [
      "CreateListFromArrayLike",
      0,
      [
        [
          "obj",
          false,
          "ESValue"
        ],
        [
          "elementTypes",
          true,
          "Unknown[\"ListOfNamesOfECMAScriptLanguageType\"]"
        ]
      ],
      "\n        1. If _elementTypes_ is not present, set _elementTypes_ to « Undefined, Null, Boolean, String, Symbol, Number, BigInt, Object ».\n        1. If _obj_ is not an Object, throw a *TypeError* exception.\n        1. Let _len_ be ? LengthOfArrayLike(_obj_).\n        1. Let _list_ be a new empty List.\n        1. Let _index_ be 0.\n        1. Repeat, while _index_ < _len_,\n          1. Let _indexName_ be ! ToString(𝔽(_index_)).\n          1. Let _next_ be ? Get(_obj_, _indexName_).\n          1. If _elementTypes_ does not contain Type(_next_), throw a *TypeError* exception.\n          1. Append _next_ to _list_.\n          1. Set _index_ to _index_ + 1.\n        1. Return _list_.\n      ",
      {
        "normalizedName" : "CreateListFromArrayLike",
        "name" : "CreateListFromArrayLike",
        "htmlId" : "sec-createlistfromarraylike",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1299,
    [
      "ParenthesizedExpression[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ParenthesizedExpression[0]]"
        ]
      ],
      "\n          1. Return ? Evaluation of |Expression|. This may be of type Reference.\n        ",
      {
        "normalizedName" : "ParenthesizedExpression[0,0].Evaluation",
        "name" : "ParenthesizedExpression[0,0].Evaluation",
        "htmlId" : "sec-grouping-operator-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ParenthesizedExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    277,
    [
      "FunctionDeclaration[0,0].IsConstantDeclaration",
      2,
      [
        [
          "this",
          false,
          "Ast[FunctionDeclaration[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "FunctionDeclaration[0,0].IsConstantDeclaration",
        "name" : "FunctionDeclaration[0,0].IsConstantDeclaration",
        "htmlId" : "sec-static-semantics-isconstantdeclaration",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsConstantDeclaration",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "FunctionDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "FunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1902,
    [
      "OptionalChain[6,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[6]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "OptionalChain[6,0].HasCallInTailPosition",
        "name" : "OptionalChain[6,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "OptionalChain"
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    691,
    [
      "DefaultClause[0,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[DefaultClause[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "DefaultClause[0,0].ContainsUndefinedContinueTarget",
        "name" : "DefaultClause[0,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "DefaultClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "default"
              },
              {
                "type" : "terminal",
                "value" : ":"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2484,
    [
      "IsConcatSpreadable",
      0,
      [
        [
          "O",
          false,
          "ESValue"
        ]
      ],
      "\n            1. If _O_ is not an Object, return *false*.\n            1. Let _spreadable_ be ? Get(_O_, @@isConcatSpreadable).\n            1. If _spreadable_ is not *undefined*, return ToBoolean(_spreadable_).\n            1. Return ? IsArray(_O_).\n          ",
      {
        "normalizedName" : "IsConcatSpreadable",
        "name" : "IsConcatSpreadable",
        "htmlId" : "sec-isconcatspreadable",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1885,
    [
      "PrimaryExpression[10,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[10]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[10,0].HasCallInTailPosition",
        "name" : "PrimaryExpression[10,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 10,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RegularExpressionLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2699,
    [
      "AddWaiter",
      0,
      [
        [
          "WL",
          false,
          "Record[WaiterListRecord]"
        ],
        [
          "waiterRecord",
          false,
          "Record[WaiterRecord]"
        ]
      ],
      "\n          1. Assert: The surrounding agent is in the critical section for _WL_.\n          1. Assert: There is no Waiter Record in _WL_.[[Waiters]] whose [[PromiseCapability]] field is _waiterRecord_.[[PromiseCapability]] and whose [[AgentSignifier]] field is _waiterRecord_.[[AgentSignifier]].\n          1. Append _waiterRecord_ to _WL_.[[Waiters]].\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "AddWaiter",
        "name" : "AddWaiter",
        "htmlId" : "sec-addwaiter",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    442,
    [
      "ForStatement[0,4].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,4].VarScopedDeclarations",
        "name" : "ForStatement[0,4].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 4,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1505,
    [
      "ForIn/OfBodyEvaluation",
      0,
      [
        [
          "lhs",
          false,
          "Ast"
        ],
        [
          "stmt",
          false,
          "Ast[Statement]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "iterationKind",
          false,
          "Enum[~enumerate~, ~iterate~]"
        ],
        [
          "lhsKind",
          false,
          "Enum[~assignment~, ~lexical-binding~, ~var-binding~]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ],
        [
          "iteratorKind",
          true,
          "Enum[~async~, ~sync~]"
        ]
      ],
      "\n          1. If _iteratorKind_ is not present, set _iteratorKind_ to ~sync~.\n          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n          1. Let _V_ be *undefined*.\n          1. Let _destructuring_ be IsDestructuring of _lhs_.\n          1. If _destructuring_ is *true* and _lhsKind_ is ~assignment~, then\n            1. Assert: _lhs_ is a |LeftHandSideExpression|.\n            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by _lhs_.\n          1. Repeat,\n            1. Let _nextResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).\n            1. If _iteratorKind_ is ~async~, set _nextResult_ to ? Await(_nextResult_).\n            1. If _nextResult_ is not an Object, throw a *TypeError* exception.\n            1. Let _done_ be ? IteratorComplete(_nextResult_).\n            1. If _done_ is *true*, return _V_.\n            1. Let _nextValue_ be ? IteratorValue(_nextResult_).\n            1. If _lhsKind_ is either ~assignment~ or ~var-binding~, then\n              1. If _destructuring_ is *true*, then\n                1. If _lhsKind_ is ~assignment~, then\n                  1. Let _status_ be Completion(DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _nextValue_).\n                1. Else,\n                  1. Assert: _lhsKind_ is ~var-binding~.\n                  1. Assert: _lhs_ is a |ForBinding|.\n                  1. Let _status_ be Completion(BindingInitialization of _lhs_ with arguments _nextValue_ and *undefined*).\n              1. Else,\n                1. Let _lhsRef_ be Completion(Evaluation of _lhs_). (It may be evaluated repeatedly.)\n                1. If _lhsRef_ is an abrupt completion, then\n                  1. Let _status_ be _lhsRef_.\n                1. Else,\n                  1. Let _status_ be Completion(PutValue(_lhsRef_.[[Value]], _nextValue_)).\n            1. Else,\n              1. Assert: _lhsKind_ is ~lexical-binding~.\n              1. Assert: _lhs_ is a |ForDeclaration|.\n              1. Let _iterationEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n              1. Perform ForDeclarationBindingInstantiation of _lhs_ with argument _iterationEnv_.\n              1. Set the running execution context's LexicalEnvironment to _iterationEnv_.\n              1. If _destructuring_ is *true*, then\n                1. Let _status_ be Completion(ForDeclarationBindingInitialization of _lhs_ with arguments _nextValue_ and _iterationEnv_).\n              1. Else,\n                1. Assert: _lhs_ binds a single name.\n                1. Let _lhsName_ be the sole element of BoundNames of _lhs_.\n                1. Let _lhsRef_ be ! ResolveBinding(_lhsName_).\n                1. Let _status_ be Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_)).\n            1. If _status_ is an abrupt completion, then\n              1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n              1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).\n              1. If _iterationKind_ is ~enumerate~, then\n                1. Return ? _status_.\n              1. Else,\n                1. Assert: _iterationKind_ is ~iterate~.\n                1. Return ? IteratorClose(_iteratorRecord_, _status_).\n            1. Let _result_ be Completion(Evaluation of _stmt_).\n            1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n            1. If LoopContinues(_result_, _labelSet_) is *false*, then\n              1. If _iterationKind_ is ~enumerate~, then\n                1. Return ? UpdateEmpty(_result_, _V_).\n              1. Else,\n                1. Assert: _iterationKind_ is ~iterate~.\n                1. Set _status_ to Completion(UpdateEmpty(_result_, _V_)).\n                1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).\n                1. Return ? IteratorClose(_iteratorRecord_, _status_).\n            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].\n        ",
      {
        "normalizedName" : "ForInOfBodyEvaluation",
        "name" : "ForIn/OfBodyEvaluation",
        "htmlId" : "sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1399,
    [
      "ArrayAssignmentPattern[0,3].DestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayAssignmentPattern[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. If |Elision| is present, then\n            1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n            1. If _status_ is an abrupt completion, then\n              1. Assert: _iteratorRecord_.[[Done]] is *true*.\n              1. Return ? _status_.\n          1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "ArrayAssignmentPattern[0,3].DestructuringAssignmentEvaluation",
        "name" : "ArrayAssignmentPattern[0,3].DestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-destructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "DestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 3,
            "astName" : "ArrayAssignmentPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2270,
    [
      "INTRINSICS.String.prototype.trim",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _S_ be the *this* value.\n          1. Return ? TrimString(_S_, ~start+end~).\n        ",
      {
        "normalizedName" : "INTRINSICS.String.prototype.trim",
        "name" : "INTRINSICS.String.prototype.trim",
        "htmlId" : "sec-string.prototype.trim",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1621,
    [
      "ConciseBody[0,0].ConciseBodyContainsUseStrict",
      2,
      [
        [
          "this",
          false,
          "Ast[ConciseBody[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "ConciseBody[0,0].ConciseBodyContainsUseStrict",
        "name" : "ConciseBody[0,0].ConciseBodyContainsUseStrict",
        "htmlId" : "sec-static-semantics-concisebodycontainsusestrict",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ConciseBodyContainsUseStrict",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    501,
    [
      "StatementListItem[0,0].TopLevelVarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementListItem[0]]"
        ]
      ],
      "\n        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return TopLevelVarDeclaredNames of |Statement|.\n        1. Return VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "StatementListItem[0,0].TopLevelVarDeclaredNames",
        "name" : "StatementListItem[0,0].TopLevelVarDeclaredNames",
        "htmlId" : "sec-static-semantics-toplevelvardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelVarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "StatementListItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2372,
    [
      "Atom[0,0].CompileAtom",
      2,
      [
        [
          "this",
          false,
          "Ast[Atom[0]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ],
        [
          "direction",
          false,
          "Enum[~backward~, ~forward~]"
        ]
      ],
      "\n          1. Let _ch_ be the character matched by |PatternCharacter|.\n          1. Let _A_ be a one-element CharSet containing the character _ch_.\n          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).\n        ",
      {
        "normalizedName" : "Atom[0,0].CompileAtom",
        "name" : "Atom[0,0].CompileAtom",
        "htmlId" : "sec-compileatom",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileAtom",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Atom",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "PatternCharacter"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    369,
    [
      "ForStatement[0,1].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ]
      ],
      "\n        1. Return the VarDeclaredNames of |Statement|.\n      ",
      {
        "normalizedName" : "ForStatement[0,1].VarDeclaredNames",
        "name" : "ForStatement[0,1].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    607,
    [
      "ForInOfStatement[3,0].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[3]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[3,0].ContainsUndefinedBreakTarget",
        "name" : "ForInOfStatement[3,0].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2138,
    [
      "INTRINSICS.Math.exp",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n          1. If _n_ is *-∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of the exponential function of ℝ(_n_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Math.exp",
        "name" : "INTRINSICS.Math.exp",
        "htmlId" : "sec-math.exp",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    803,
    [
      "PrimaryExpression[10,0].IsIdentifierRef",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[10]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "PrimaryExpression[10,0].IsIdentifierRef",
        "name" : "PrimaryExpression[10,0].IsIdentifierRef",
        "htmlId" : "sec-static-semantics-isidentifierref",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsIdentifierRef",
          "type" : "base",
          "prod" : {
            "i" : 10,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RegularExpressionLiteral"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1320,
    [
      "ArgumentList[0,0].ArgumentListEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ArgumentList[0]]"
        ]
      ],
      "\n          1. Let _ref_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _arg_ be ? GetValue(_ref_).\n          1. Return « _arg_ ».\n        ",
      {
        "normalizedName" : "ArgumentList[0,0].ArgumentListEvaluation",
        "name" : "ArgumentList[0,0].ArgumentListEvaluation",
        "htmlId" : "sec-runtime-semantics-argumentlistevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ArgumentListEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArgumentList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1962,
    [
      "ImportClause[4,0].ImportEntriesForModule",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportClause[4]]"
        ],
        [
          "module",
          false,
          "String"
        ]
      ],
      "\n          1. Let _entries1_ be ImportEntriesForModule of |ImportedDefaultBinding| with argument _module_.\n          1. Let _entries2_ be ImportEntriesForModule of |NamedImports| with argument _module_.\n          1. Return the list-concatenation of _entries1_ and _entries2_.\n        ",
      {
        "normalizedName" : "ImportClause[4,0].ImportEntriesForModule",
        "name" : "ImportClause[4,0].ImportEntriesForModule",
        "htmlId" : "sec-static-semantics-importentriesformodule",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ImportEntriesForModule",
          "type" : "base",
          "prod" : {
            "i" : 4,
            "j" : 0,
            "astName" : "ImportClause",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportedDefaultBinding"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "NamedImports"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2563,
    [
      "INTRINSICS.TypedArray.prototype.sort:clo0",
      6,
      [
        [
          "x",
          false,
          "Unknown"
        ],
        [
          "y",
          false,
          "Unknown"
        ]
      ],
      "\n          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n          1. Let _obj_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_obj_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href=\"#sec-array.prototype.sort\"></emu-xref>.\n          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n            1. Return ? CompareTypedArrayElements(_x_, _y_, _comparefn_).\n          1. Let _sortedList_ be ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~read-through-holes~).\n          1. Let _j_ be 0.\n          1. Repeat, while _j_ < _len_,\n            1. Perform ! Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).\n            1. Set _j_ to _j_ + 1.\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "INTRINSICS.TypedArray.prototype.sort",
        "name" : "INTRINSICS.TypedArray.prototype.sort",
        "htmlId" : "sec-%typedarray%.prototype.sort",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2436,
    [
      "UnicodeMatchPropertyValue",
      0,
      [
        [
          "p",
          false,
          "Unknown[\"ECMAScriptSourceText\"]"
        ],
        [
          "v",
          false,
          "Unknown[\"ECMAScriptSourceText\"]"
        ]
      ],
      "\n            1. Assert: _p_ is a canonical, unaliased Unicode property name listed in the “Canonical property name” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref>.\n            1. Assert: _v_ is a property value or property value alias for the Unicode property _p_ listed in <a href=\"https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt\"><code>PropertyValueAliases.txt</code></a>.\n            1. Let _value_ be the canonical property value of _v_ as given in the “Canonical property value” column of the corresponding row.\n            1. Return the List of Unicode code points _value_.\n          ",
      {
        "normalizedName" : "UnicodeMatchPropertyValue",
        "name" : "UnicodeMatchPropertyValue",
        "htmlId" : "sec-runtime-semantics-unicodematchpropertyvalue-p-v",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1416,
    [
      "AssignmentElement[0,0].IteratorDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentElement[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.\n          1. Let _value_ be *undefined*.\n          1. If _iteratorRecord_.[[Done]] is *false*, then\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is not ~done~, then\n              1. Set _value_ to _next_.\n          1. If |Initializer| is present and _value_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true* and IsIdentifierRef of |DestructuringAssignmentTarget| is *true*, then\n              1. Let _v_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Let _v_ be ? GetValue(_defaultValue_).\n          1. Else,\n            1. Let _v_ be _value_.\n          1. If |DestructuringAssignmentTarget| is either an |ObjectLiteral| or an |ArrayLiteral|, then\n            1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n            1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _v_.\n          1. Return ? PutValue(_lref_, _v_).\n        ",
      {
        "normalizedName" : "AssignmentElement[0,0].IteratorDestructuringAssignmentEvaluation",
        "name" : "AssignmentElement[0,0].IteratorDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AssignmentElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DestructuringAssignmentTarget"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    639,
    [
      "Statement[2,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[2]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[2,0].ContainsUndefinedContinueTarget",
        "name" : "Statement[2,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EmptyStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2453,
    [
      "INTRINSICS.get RegExp.prototype.ignoreCase",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0069 (LATIN SMALL LETTER I).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        ",
      {
        "normalizedName" : "INTRINSICS.get RegExp.prototype.ignoreCase",
        "name" : "INTRINSICS.get RegExp.prototype.ignoreCase",
        "htmlId" : "sec-get-regexp.prototype.ignorecase",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    364,
    [
      "IfStatement[0,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[IfStatement[0]]"
        ]
      ],
      "\n        1. Let _names1_ be VarDeclaredNames of the first |Statement|.\n        1. Let _names2_ be VarDeclaredNames of the second |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "IfStatement[0,0].VarDeclaredNames",
        "name" : "IfStatement[0,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "IfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "if"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              },
              {
                "type" : "terminal",
                "value" : "else"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    90,
    [
      "UpdateEmpty",
      0,
      [
        [
          "completionRecord",
          false,
          "Completion"
        ],
        [
          "value",
          false,
          "Unknown[\"AnyValueExceptACompletionRecord\"]"
        ]
      ],
      "\n          1. Assert: If _completionRecord_ is either a return completion or a throw completion, then _completionRecord_.[[Value]] is not ~empty~.\n          1. If _completionRecord_.[[Value]] is not ~empty~, return ? _completionRecord_.\n          1. Return Completion Record { [[Type]]: _completionRecord_.[[Type]], [[Value]]: _value_, [[Target]]: _completionRecord_.[[Target]] }.\n        ",
      {
        "normalizedName" : "UpdateEmpty",
        "name" : "UpdateEmpty",
        "htmlId" : "sec-updateempty",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    111,
    [
      "ToNumeric",
      0,
      [
        [
          "value",
          false,
          "ESValue"
        ]
      ],
      "\n        1. Let _primValue_ be ? ToPrimitive(_value_, ~number~).\n        1. If _primValue_ is a BigInt, return _primValue_.\n        1. Return ? <emu-meta suppress-effects=\"user-code\">ToNumber(_primValue_)</emu-meta>.\n      ",
      {
        "normalizedName" : "ToNumeric",
        "name" : "ToNumeric",
        "htmlId" : "sec-tonumeric",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1331,
    [
      "OptionalChain[1,0].ChainEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[OptionalChain[1]]"
        ],
        [
          "baseValue",
          false,
          "ESValue"
        ],
        [
          "baseReference",
          false,
          "ESValue | Record[ReferenceRecord]"
        ]
      ],
      "\n          1. If the source text matched by this |OptionalChain| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_).\n        ",
      {
        "normalizedName" : "OptionalChain[1,0].ChainEvaluation",
        "name" : "OptionalChain[1,0].ChainEvaluation",
        "htmlId" : "sec-optional-chaining-chain-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ChainEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "OptionalChain",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "?."
              },
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    254,
    [
      "ImportDeclaration[0,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ImportDeclaration[0]]"
        ]
      ],
      "\n        1. Return the BoundNames of |ImportClause|.\n      ",
      {
        "normalizedName" : "ImportDeclaration[0,0].BoundNames",
        "name" : "ImportDeclaration[0,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ImportDeclaration",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "import"
              },
              {
                "type" : "nonterminal",
                "value" : "ImportClause"
              },
              {
                "type" : "nonterminal",
                "value" : "FromClause"
              },
              {
                "type" : "terminal",
                "value" : ";"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    227,
    [
      "ArrayBindingPattern[2,1].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[2]]"
        ]
      ],
      "\n        1. Let _names1_ be BoundNames of |BindingElementList|.\n        1. Let _names2_ be BoundNames of |BindingRestElement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[2,1].BoundNames",
        "name" : "ArrayBindingPattern[2,1].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1606,
    [
      "ArrowParameters[0,0].ExpectedArgumentCount",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrowParameters[0]]"
        ]
      ],
      "\n        1. Return 1.\n      ",
      {
        "normalizedName" : "ArrowParameters[0,0].ExpectedArgumentCount",
        "name" : "ArrowParameters[0,0].ExpectedArgumentCount",
        "htmlId" : "sec-static-semantics-expectedargumentcount",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ExpectedArgumentCount",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ArrowParameters",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2754,
    [
      "IsPromise",
      0,
      [
        [
          "x",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If _x_ is not an Object, return *false*.\n          1. If _x_ does not have a [[PromiseState]] internal slot, return *false*.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "IsPromise",
        "name" : "IsPromise",
        "htmlId" : "sec-ispromise",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    322,
    [
      "CaseBlock[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "CaseBlock[0,0].LexicallyScopedDeclarations",
        "name" : "CaseBlock[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    486,
    [
      "AsyncConciseBody[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncConciseBody[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "AsyncConciseBody[0,0].VarScopedDeclarations",
        "name" : "AsyncConciseBody[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncConciseBody",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionBody"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2672,
    [
      "INTRINSICS.DataView.prototype.getBigInt64",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~bigint64~).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.getBigInt64",
        "name" : "INTRINSICS.DataView.prototype.getBigInt64",
        "htmlId" : "sec-dataview.prototype.getbigint64",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2640,
    [
      "NumericToRawBytes",
      0,
      [
        [
          "type",
          false,
          "Unknown[\"TypedArrayElementType\"]"
        ],
        [
          "value",
          false,
          "Number | BigInt"
        ],
        [
          "isLittleEndian",
          false,
          "Boolean"
        ]
      ],
      "\n          1. If _type_ is ~float32~, then\n            1. Let _rawBytes_ be a List whose elements are the 4 bytes that are the result of converting _value_ to IEEE 754-2019 binary32 format using roundTiesToEven mode. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.\n          1. Else if _type_ is ~float64~, then\n            1. Let _rawBytes_ be a List whose elements are the 8 bytes that are the IEEE 754-2019 binary64 format encoding of _value_. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.\n          1. Else,\n            1. Let _n_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n            1. Let _convOp_ be the abstract operation named in the Conversion Operation column in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n            1. Let _intValue_ be ℝ(_convOp_(_value_)).\n            1. If _intValue_ ≥ 0, then\n              1. Let _rawBytes_ be a List whose elements are the _n_-byte binary encoding of _intValue_. The bytes are ordered in little endian order.\n            1. Else,\n              1. Let _rawBytes_ be a List whose elements are the _n_-byte binary two's complement encoding of _intValue_. The bytes are ordered in little endian order.\n          1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.\n          1. Return _rawBytes_.\n        ",
      {
        "normalizedName" : "NumericToRawBytes",
        "name" : "NumericToRawBytes",
        "htmlId" : "sec-numerictorawbytes",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    337,
    [
      "ClassStaticBlockStatementList[0,0].LexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockStatementList[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ClassStaticBlockStatementList[0,0].LexicallyScopedDeclarations",
        "name" : "ClassStaticBlockStatementList[0,0].LexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-lexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStaticBlockStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    122,
    [
      "StrUnsignedDecimalLiteral[1,0].StringNumericValue",
      2,
      [
        [
          "this",
          false,
          "Ast[StrUnsignedDecimalLiteral[1]]"
        ]
      ],
      "\n            1. Let _a_ be MV of the first |DecimalDigits|.\n            1. If the second |DecimalDigits| is present, then\n              1. Let _b_ be MV of the second |DecimalDigits|.\n              1. Let _n_ be the number of code points in the second |DecimalDigits|.\n            1. Else,\n              1. Let _b_ be 0.\n              1. Let _n_ be 0.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Return RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>).\n          ",
      {
        "normalizedName" : "StrUnsignedDecimalLiteral[1,0].StringNumericValue",
        "name" : "StrUnsignedDecimalLiteral[1,0].StringNumericValue",
        "htmlId" : "sec-runtime-semantics-stringnumericvalue",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "StringNumericValue",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StrUnsignedDecimalLiteral",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DecimalDigits"
              },
              {
                "type" : "terminal",
                "value" : "."
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2321,
    [
      "ClassUnion[0,1].MayContainStrings",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassUnion[0]]"
        ]
      ],
      "\n          1. If the |ClassUnion| is present, return MayContainStrings of the |ClassUnion|.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "ClassUnion[0,1].MayContainStrings",
        "name" : "ClassUnion[0,1].MayContainStrings",
        "htmlId" : "sec-static-semantics-maycontainstrings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "MayContainStrings",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "ClassUnion",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ClassSetRange"
              },
              {
                "type" : "nonterminal",
                "value" : "ClassUnion"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1653,
    [
      "YieldExpression[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[YieldExpression[0]]"
        ]
      ],
      "\n        1. Return ? Yield(*undefined*).\n      ",
      {
        "normalizedName" : "YieldExpression[0,0].Evaluation",
        "name" : "YieldExpression[0,0].Evaluation",
        "htmlId" : "sec-generator-function-definitions-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "YieldExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "yield"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    469,
    [
      "CaseBlock[1,3].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ]
      ],
      "\n        1. If the first |CaseClauses| is present, let _declarations1_ be the VarScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be VarScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the VarScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,3].VarScopedDeclarations",
        "name" : "CaseBlock[1,3].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1944,
    [
      "Record[SourceTextModuleRecord].GetExportedNames",
      3,
      [
        [
          "module",
          false,
          "Record[SourceTextModuleRecord]"
        ],
        [
          "exportStarSet",
          true,
          "List[Record[SourceTextModuleRecord]]"
        ]
      ],
      "\n            1. Assert: _module_.[[Status]] is not ~new~.\n            1. If _exportStarSet_ is not present, set _exportStarSet_ to a new empty List.\n            1. If _exportStarSet_ contains _module_, then\n              1. Assert: We've reached the starting point of an `export *` circularity.\n              1. Return a new empty List.\n            1. Append _module_ to _exportStarSet_.\n            1. Let _exportedNames_ be a new empty List.\n            1. For each ExportEntry Record _e_ of _module_.[[LocalExportEntries]], do\n              1. Assert: _module_ provides the direct binding for this export.\n              1. Assert: _e_.[[ExportName]] is not *null*.\n              1. Append _e_.[[ExportName]] to _exportedNames_.\n            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do\n              1. Assert: _module_ imports a specific binding for this export.\n              1. Assert: _e_.[[ExportName]] is not *null*.\n              1. Append _e_.[[ExportName]] to _exportedNames_.\n            1. For each ExportEntry Record _e_ of _module_.[[StarExportEntries]], do\n              1. Assert: _e_.[[ModuleRequest]] is not *null*.\n              1. Let _requestedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]).\n              1. Let _starNames_ be _requestedModule_.GetExportedNames(_exportStarSet_).\n              1. For each element _n_ of _starNames_, do\n                1. If SameValue(_n_, *\"default\"*) is *false*, then\n                  1. If _exportedNames_ does not contain _n_, then\n                    1. Append _n_ to _exportedNames_.\n            1. Return _exportedNames_.\n          ",
      {
        "normalizedName" : "Record[SourceTextModuleRecord].GetExportedNames",
        "name" : "Record[SourceTextModuleRecord].GetExportedNames",
        "htmlId" : "sec-getexportednames",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "SourceTextModuleRecord",
          "GetExportedNames"
        ]
      }
    ]
  ],
  [
    1367,
    [
      "RelationalExpression[3,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[3]]"
        ]
      ],
      "\n        1. Let _lref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _r_ be ? IsLessThan(_rval_, _lval_, *false*).\n        1. If _r_ is either *true* or *undefined*, return *false*. Otherwise, return *true*.\n      ",
      {
        "normalizedName" : "RelationalExpression[3,0].Evaluation",
        "name" : "RelationalExpression[3,0].Evaluation",
        "htmlId" : "sec-relational-operators-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "<="
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    940,
    [
      "MemberExpression[6,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[6]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "MemberExpression[6,0].AssignmentTargetType",
        "name" : "MemberExpression[6,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "new"
              },
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "Arguments"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    354,
    [
      "Statement[3,0].VarDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[3]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "Statement[3,0].VarDeclaredNames",
        "name" : "Statement[3,0].VarDeclaredNames",
        "htmlId" : "sec-static-semantics-vardeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExpressionStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    83,
    [
      "BinaryXor",
      0,
      [
        [
          "x",
          false,
          "Int[0, 1]"
        ],
        [
          "y",
          false,
          "Int[0, 1]"
        ]
      ],
      "\n            1. If _x_ = 1 and _y_ = 0, return 1.\n            1. Else if _x_ = 0 and _y_ = 1, return 1.\n            1. Else, return 0.\n          ",
      {
        "normalizedName" : "BinaryXor",
        "name" : "BinaryXor",
        "htmlId" : "sec-binaryxor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    935,
    [
      "CallExpression[2,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[CallExpression[2]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "CallExpression[2,0].AssignmentTargetType",
        "name" : "CallExpression[2,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "CallExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportCall"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1945,
    [
      "Record[SourceTextModuleRecord].ResolveExport",
      3,
      [
        [
          "module",
          false,
          "Record[SourceTextModuleRecord]"
        ],
        [
          "exportName",
          false,
          "String"
        ],
        [
          "resolveSet",
          true,
          "Unknown[\"ListOfRecordsWithFields[[Module]](aModuleRecord)And[[ExportName]](aString)\"]"
        ]
      ],
      "\n            1. Assert: _module_.[[Status]] is not ~new~.\n            1. If _resolveSet_ is not present, set _resolveSet_ to a new empty List.\n            1. For each Record { [[Module]], [[ExportName]] } _r_ of _resolveSet_, do\n              1. If _module_ and _r_.[[Module]] are the same Module Record and SameValue(_exportName_, _r_.[[ExportName]]) is *true*, then\n                1. Assert: This is a circular import request.\n                1. Return *null*.\n            1. Append the Record { [[Module]]: _module_, [[ExportName]]: _exportName_ } to _resolveSet_.\n            1. For each ExportEntry Record _e_ of _module_.[[LocalExportEntries]], do\n              1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then\n                1. Assert: _module_ provides the direct binding for this export.\n                1. Return ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]] }.\n            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do\n              1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then\n                1. Assert: _e_.[[ModuleRequest]] is not *null*.\n                1. Let _importedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]).\n                1. If _e_.[[ImportName]] is ~all~, then\n                  1. Assert: _module_ does not provide the direct binding for this export.\n                  1. Return ResolvedBinding Record { [[Module]]: _importedModule_, [[BindingName]]: ~namespace~ }.\n                1. Else,\n                  1. Assert: _module_ imports a specific binding for this export.\n                  1. Return _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_).\n            1. If SameValue(_exportName_, *\"default\"*) is *true*, then\n              1. Assert: A `default` export was not explicitly defined by this module.\n              1. Return *null*.\n              1. NOTE: A `default` export cannot be provided by an `export * from \"mod\"` declaration.\n            1. Let _starResolution_ be *null*.\n            1. For each ExportEntry Record _e_ of _module_.[[StarExportEntries]], do\n              1. Assert: _e_.[[ModuleRequest]] is not *null*.\n              1. Let _importedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]).\n              1. Let _resolution_ be _importedModule_.ResolveExport(_exportName_, _resolveSet_).\n              1. If _resolution_ is ~ambiguous~, return ~ambiguous~.\n              1. If _resolution_ is not *null*, then\n                1. Assert: _resolution_ is a ResolvedBinding Record.\n                1. If _starResolution_ is *null*, then\n                  1. Set _starResolution_ to _resolution_.\n                1. Else,\n                  1. Assert: There is more than one `*` import that includes the requested name.\n                  1. If _resolution_.[[Module]] and _starResolution_.[[Module]] are not the same Module Record, return ~ambiguous~.\n                  1. If _resolution_.[[BindingName]] is not _starResolution_.[[BindingName]] and either _resolution_.[[BindingName]] or _starResolution_.[[BindingName]] is ~namespace~, return ~ambiguous~.\n                  1. If _resolution_.[[BindingName]] is a String, _starResolution_.[[BindingName]] is a String, and SameValue(_resolution_.[[BindingName]], _starResolution_.[[BindingName]]) is *false*, return ~ambiguous~.\n            1. Return _starResolution_.\n          ",
      {
        "normalizedName" : "Record[SourceTextModuleRecord].ResolveExport",
        "name" : "Record[SourceTextModuleRecord].ResolveExport",
        "htmlId" : "sec-resolveexport",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "SourceTextModuleRecord",
          "ResolveExport"
        ]
      }
    ]
  ],
  [
    1009,
    [
      "Record[DeclarativeEnvironmentRecord].CreateMutableBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "D",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Assert: _envRec_ does not already have a binding for _N_.\n            1. Create a mutable binding in _envRec_ for _N_ and record that it is uninitialized. If _D_ is *true*, record that the newly created binding may be deleted by a subsequent DeleteBinding call.\n            1. Return ~unused~.\n          ",
      {
        "normalizedName" : "Record[DeclarativeEnvironmentRecord].CreateMutableBinding",
        "name" : "Record[DeclarativeEnvironmentRecord].CreateMutableBinding",
        "htmlId" : "sec-declarative-environment-records-createmutablebinding-n-d",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "DeclarativeEnvironmentRecord",
          "CreateMutableBinding"
        ]
      }
    ]
  ],
  [
    923,
    [
      "PrimaryExpression[2,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[PrimaryExpression[2]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "PrimaryExpression[2,0].AssignmentTargetType",
        "name" : "PrimaryExpression[2,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "PrimaryExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Literal"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2206,
    [
      "INTRINSICS.Date.prototype.getUTCMonth",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return MonthFromTime(_t_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getUTCMonth",
        "name" : "INTRINSICS.Date.prototype.getUTCMonth",
        "htmlId" : "sec-date.prototype.getutcmonth",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1737,
    [
      "ClassTail[0,1].ClassDefinitionEvaluation:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.\n        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n        1. If |ClassBody| is present, then\n          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do\n            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then\n              1. Assert: This is only possible for getter/setter pairs.\n            1. Else,\n              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.\n              1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n        1. If |ClassHeritage| is not present, then\n          1. Let _protoParent_ be %Object.prototype%.\n          1. Let _constructorParent_ be %Function.prototype%.\n        1. Else,\n          1. Set the running execution context's LexicalEnvironment to _classEnv_.\n          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).\n          1. Set the running execution context's LexicalEnvironment to _env_.\n          1. Let _superclass_ be ? GetValue(? _superclassRef_).\n          1. If _superclass_ is *null*, then\n            1. Let _protoParent_ be *null*.\n            1. Let _constructorParent_ be %Function.prototype%.\n          1. Else if IsConstructor(_superclass_) is *false*, then\n            1. Throw a *TypeError* exception.\n          1. Else,\n            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.\n            1. Let _constructorParent_ be _superclass_.\n        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n        1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n        1. Set the running execution context's LexicalEnvironment to _classEnv_.\n        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.\n        1. If _constructor_ is ~empty~, then\n          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n            1. If NewTarget is *undefined*, throw a *TypeError* exception.\n            1. Let _F_ be the active function object.\n            1. If _F_.[[ConstructorKind]] is ~derived~, then\n              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n            1. Else,\n              1. NOTE: This branch behaves similarly to `constructor() {}`.\n              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n            1. Perform ? InitializeInstanceElements(_result_, _F_).\n            1. Return _result_.\n          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n        1. Else,\n          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n          1. Let _F_ be _constructorInfo_.[[Closure]].\n          1. Perform MakeClassConstructor(_F_).\n          1. Perform SetFunctionName(_F_, _className_).\n        1. Perform MakeConstructor(_F_, *false*, _proto_).\n        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n        1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n        1. If |ClassBody| is not present, let _elements_ be a new empty List.\n        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n        1. Let _instancePrivateMethods_ be a new empty List.\n        1. Let _staticPrivateMethods_ be a new empty List.\n        1. Let _instanceFields_ be a new empty List.\n        1. Let _staticElements_ be a new empty List.\n        1. For each |ClassElement| _e_ of _elements_, do\n          1. If IsStatic of _e_ is *false*, then\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n          1. Else,\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n          1. If _element_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _env_.\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _element_.\n          1. Set _element_ to ! _element_.\n          1. If _element_ is a PrivateElement, then\n            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n            1. Else, let _container_ be _staticPrivateMethods_.\n            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.\n              1. If _element_.[[Get]] is *undefined*, then\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n              1. Else,\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n              1. Replace _pe_ in _container_ with _combined_.\n            1. Else,\n              1. Append _element_ to _container_.\n          1. Else if _element_ is a ClassFieldDefinition Record, then\n            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n            1. Else, append _element_ to _staticElements_.\n          1. Else if _element_ is a ClassStaticBlockDefinition Record, then\n            1. Append _element_ to _staticElements_.\n        1. Set the running execution context's LexicalEnvironment to _env_.\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n        1. Set _F_.[[Fields]] to _instanceFields_.\n        1. For each PrivateElement _method_ of _staticPrivateMethods_, do\n          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n        1. For each element _elementRecord_ of _staticElements_, do\n          1. If _elementRecord_ is a ClassFieldDefinition Record, then\n            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n          1. Else,\n            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.\n            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n          1. If _result_ is an abrupt completion, then\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _result_.\n        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n        1. Return _F_.\n      ",
      {
        "normalizedName" : "ClassTail[0,1].ClassDefinitionEvaluation",
        "name" : "ClassTail[0,1].ClassDefinitionEvaluation",
        "htmlId" : "sec-runtime-semantics-classdefinitionevaluation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1681,
    [
      "<DEFAULT>.AllPrivateIdentifiersValid",
      2,
      [
        [
          "this",
          false,
          "Ast"
        ],
        [
          "names",
          false,
          "List[String]"
        ]
      ],
      "\n        1. For each child node _child_ of this Parse Node, do\n          1. If _child_ is an instance of a nonterminal, then\n            1. If AllPrivateIdentifiersValid of _child_ with argument _names_ is *false*, return *false*.\n        1. Return *true*.\n      ",
      {
        "normalizedName" : "<DEFAULT>.AllPrivateIdentifiersValid",
        "name" : "<DEFAULT>.AllPrivateIdentifiersValid",
        "htmlId" : "sec-static-semantics-allprivateidentifiersvalid",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AllPrivateIdentifiersValid",
          "type" : "default",
          "prod" : null
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1184,
    [
      "Record[ModuleNamespaceExoticObject].Get",
      4,
      [
        [
          "O",
          false,
          "Record[ModuleNamespaceExoticObject]"
        ],
        [
          "P",
          false,
          "Record[Symbol] | String"
        ],
        [
          "Receiver",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If _P_ is a Symbol, then\n            1. Return ! OrdinaryGet(_O_, _P_, _Receiver_).\n          1. Let _exports_ be _O_.[[Exports]].\n          1. If _exports_ does not contain _P_, return *undefined*.\n          1. Let _m_ be _O_.[[Module]].\n          1. Let _binding_ be _m_.ResolveExport(_P_).\n          1. Assert: _binding_ is a ResolvedBinding Record.\n          1. Let _targetModule_ be _binding_.[[Module]].\n          1. Assert: _targetModule_ is not *undefined*.\n          1. If _binding_.[[BindingName]] is ~namespace~, then\n            1. Return GetModuleNamespace(_targetModule_).\n          1. Let _targetEnv_ be _targetModule_.[[Environment]].\n          1. If _targetEnv_ is ~empty~, throw a *ReferenceError* exception.\n          1. Return ? _targetEnv_.GetBindingValue(_binding_.[[BindingName]], *true*).\n        ",
      {
        "normalizedName" : "Record[ModuleNamespaceExoticObject].Get",
        "name" : "Record[ModuleNamespaceExoticObject].Get",
        "htmlId" : "sec-module-namespace-exotic-objects-get-p-receiver",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "ModuleNamespaceExoticObject",
          "[[Get]]"
        ]
      }
    ]
  ],
  [
    2074,
    [
      "INTRINSICS.Object.prototype.toString",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. If the *this* value is *undefined*, return *\"[object Undefined]\"*.\n          1. If the *this* value is *null*, return *\"[object Null]\"*.\n          1. Let _O_ be ! ToObject(*this* value).\n          1. Let _isArray_ be ? IsArray(_O_).\n          1. If _isArray_ is *true*, let _builtinTag_ be *\"Array\"*.\n          1. Else if _O_ has a [[ParameterMap]] internal slot, let _builtinTag_ be *\"Arguments\"*.\n          1. Else if _O_ has a [[Call]] internal method, let _builtinTag_ be *\"Function\"*.\n          1. Else if _O_ has an [[ErrorData]] internal slot, let _builtinTag_ be *\"Error\"*.\n          1. Else if _O_ has a [[BooleanData]] internal slot, let _builtinTag_ be *\"Boolean\"*.\n          1. Else if _O_ has a [[NumberData]] internal slot, let _builtinTag_ be *\"Number\"*.\n          1. Else if _O_ has a [[StringData]] internal slot, let _builtinTag_ be *\"String\"*.\n          1. Else if _O_ has a [[DateValue]] internal slot, let _builtinTag_ be *\"Date\"*.\n          1. Else if _O_ has a [[RegExpMatcher]] internal slot, let _builtinTag_ be *\"RegExp\"*.\n          1. Else, let _builtinTag_ be *\"Object\"*.\n          1. Let _tag_ be ? Get(_O_, @@toStringTag).\n          1. If _tag_ is not a String, set _tag_ to _builtinTag_.\n          1. Return the string-concatenation of *\"[object \"*, _tag_, and *\"]\"*.\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.prototype.toString",
        "name" : "INTRINSICS.Object.prototype.toString",
        "htmlId" : "sec-object.prototype.tostring",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    309,
    [
      "ClassStaticBlockStatementList[0,0].LexicallyDeclaredNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassStaticBlockStatementList[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ClassStaticBlockStatementList[0,0].LexicallyDeclaredNames",
        "name" : "ClassStaticBlockStatementList[0,0].LexicallyDeclaredNames",
        "htmlId" : "sec-static-semantics-lexicallydeclarednames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "LexicallyDeclaredNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ClassStaticBlockStatementList",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2690,
    [
      "INTRINSICS.DataView.prototype.setUint16",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~uint16~, _value_).\n        ",
      {
        "normalizedName" : "INTRINSICS.DataView.prototype.setUint16",
        "name" : "INTRINSICS.DataView.prototype.setUint16",
        "htmlId" : "sec-dataview.prototype.setuint16",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1463,
    [
      "ForStatement[0,2].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        ",
      {
        "normalizedName" : "ForStatement[0,2].ForLoopEvaluation",
        "name" : "ForStatement[0,2].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 2,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    659,
    [
      "ForStatement[0,5].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForStatement[0,5].ContainsUndefinedContinueTarget",
        "name" : "ForStatement[0,5].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 5,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1565,
    [
      "ArrayBindingPattern[2,1].ContainsExpression",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[2]]"
        ]
      ],
      "\n        1. Let _has_ be ContainsExpression of |BindingElementList|.\n        1. If _has_ is *true*, return *true*.\n        1. Return ContainsExpression of |BindingRestElement|.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[2,1].ContainsExpression",
        "name" : "ArrayBindingPattern[2,1].ContainsExpression",
        "htmlId" : "sec-static-semantics-containsexpression",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsExpression",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 1,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElementList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "BindingRestElement"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    543,
    [
      "ForInOfStatement[1,0].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[1]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForInOfStatement[1,0].ContainsDuplicateLabels",
        "name" : "ForInOfStatement[1,0].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "terminal",
                "value" : "var"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2018,
    [
      "ExportsList[1,0].ReferencedBindings",
      2,
      [
        [
          "this",
          false,
          "Ast[ExportsList[1]]"
        ]
      ],
      "\n          1. Let _names1_ be the ReferencedBindings of |ExportsList|.\n          1. Let _names2_ be the ReferencedBindings of |ExportSpecifier|.\n          1. Return the list-concatenation of _names1_ and _names2_.\n        ",
      {
        "normalizedName" : "ExportsList[1,0].ReferencedBindings",
        "name" : "ExportsList[1,0].ReferencedBindings",
        "htmlId" : "sec-static-semantics-referencedbindings",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ReferencedBindings",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ExportsList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ExportsList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "ExportSpecifier"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2832,
    [
      "Await:clo0",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _asyncContext_ be the running execution context.\n          1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).\n          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_v_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using NormalCompletion(_v_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using ThrowCompletion(_reason_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n          1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n          1. Let _callerContext_ be the running execution context.\n          1. Resume _callerContext_ passing ~empty~. If _asyncContext_ is ever resumed again, let _completion_ be the Completion Record with which it is resumed.\n          1. Assert: If control reaches here, then _asyncContext_ is the running execution context again.\n          1. Return _completion_.\n        ",
      {
        "normalizedName" : "Await",
        "name" : "Await",
        "htmlId" : "await",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1848,
    [
      "AdditiveExpression[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[AdditiveExpression[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AdditiveExpression[2,0].HasCallInTailPosition",
        "name" : "AdditiveExpression[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "AdditiveExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "AdditiveExpression"
              },
              {
                "type" : "terminal",
                "value" : "-"
              },
              {
                "type" : "nonterminal",
                "value" : "MultiplicativeExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2059,
    [
      "INTRINSICS.Object.groupBy",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _groups_ be ? GroupBy(_items_, _callbackfn_, ~property~).\n          1. Let _obj_ be OrdinaryObjectCreate(*null*).\n          1. For each Record { [[Key]], [[Elements]] } _g_ of _groups_, do\n            1. Let _elements_ be CreateArrayFromList(_g_.[[Elements]]).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, _g_.[[Key]], _elements_).\n          1. Return _obj_.\n        ",
      {
        "normalizedName" : "INTRINSICS.Object.groupBy",
        "name" : "INTRINSICS.Object.groupBy",
        "htmlId" : "sec-object.groupby",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    215,
    [
      "VariableDeclarationList[1,0].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[VariableDeclarationList[1]]"
        ]
      ],
      "\n        1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n        1. Let _names2_ be BoundNames of |VariableDeclaration|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      ",
      {
        "normalizedName" : "VariableDeclarationList[1,0].BoundNames",
        "name" : "VariableDeclarationList[1,0].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "VariableDeclarationList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "VariableDeclarationList"
              },
              {
                "type" : "terminal",
                "value" : ","
              },
              {
                "type" : "nonterminal",
                "value" : "VariableDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1490,
    [
      "ForDeclaration[0,0].IsDestructuring",
      2,
      [
        [
          "this",
          false,
          "Ast[ForDeclaration[0]]"
        ]
      ],
      "\n          1. Return IsDestructuring of |ForBinding|.\n        ",
      {
        "normalizedName" : "ForDeclaration[0,0].IsDestructuring",
        "name" : "ForDeclaration[0,0].IsDestructuring",
        "htmlId" : "sec-static-semantics-isdestructuring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsDestructuring",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForDeclaration",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LetOrConst"
              },
              {
                "type" : "nonterminal",
                "value" : "ForBinding"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1037,
    [
      "Record[GlobalEnvironmentRecord].GetBindingValue",
      3,
      [
        [
          "envRec",
          false,
          "Record[GlobalEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ],
        [
          "S",
          false,
          "Boolean"
        ]
      ],
      "\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, then\n              1. Return ? _DclRec_.GetBindingValue(_N_, _S_).\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Return ? <emu-meta effects=\"user-code\">_ObjRec_.GetBindingValue</emu-meta>(_N_, _S_).\n          ",
      {
        "normalizedName" : "Record[GlobalEnvironmentRecord].GetBindingValue",
        "name" : "Record[GlobalEnvironmentRecord].GetBindingValue",
        "htmlId" : "sec-global-environment-records-getbindingvalue-n-s",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "GlobalEnvironmentRecord",
          "GetBindingValue"
        ]
      }
    ]
  ],
  [
    2297,
    [
      "RegExpUnicodeEscapeSequence[0,0].CharacterValue",
      2,
      [
        [
          "this",
          false,
          "Ast[RegExpUnicodeEscapeSequence[0]]"
        ]
      ],
      "\n          1. Let _lead_ be the CharacterValue of |HexLeadSurrogate|.\n          1. Let _trail_ be the CharacterValue of |HexTrailSurrogate|.\n          1. Let _cp_ be UTF16SurrogatePairToCodePoint(_lead_, _trail_).\n          1. Return the numeric value of _cp_.\n        ",
      {
        "normalizedName" : "RegExpUnicodeEscapeSequence[0,0].CharacterValue",
        "name" : "RegExpUnicodeEscapeSequence[0,0].CharacterValue",
        "htmlId" : "sec-patterns-static-semantics-character-value",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CharacterValue",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "RegExpUnicodeEscapeSequence",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "u"
              },
              {
                "type" : "nonterminal",
                "value" : "HexLeadSurrogate"
              },
              {
                "type" : "terminal",
                "value" : "\\u"
              },
              {
                "type" : "nonterminal",
                "value" : "HexTrailSurrogate"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    775,
    [
      "AssignmentExpression[5,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentExpression[5]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AssignmentExpression[5,0].IsFunctionDefinition",
        "name" : "AssignmentExpression[5,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 5,
            "j" : 0,
            "astName" : "AssignmentExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentOperator"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    560,
    [
      "CaseClause[0,1].ContainsDuplicateLabels",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseClause[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. If the |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "CaseClause[0,1].ContainsDuplicateLabels",
        "name" : "CaseClause[0,1].ContainsDuplicateLabels",
        "htmlId" : "sec-static-semantics-containsduplicatelabels",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsDuplicateLabels",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "CaseClause",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "case"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ":"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2438,
    [
      "ClassString[1,0].CompileClassSetString",
      2,
      [
        [
          "this",
          false,
          "Ast[ClassString[1]]"
        ],
        [
          "rer",
          false,
          "Record[RegExpRecord]"
        ]
      ],
      "\n          1. Return CompileClassSetString of |NonEmptyClassString| with argument _rer_.\n        ",
      {
        "normalizedName" : "ClassString[1,0].CompileClassSetString",
        "name" : "ClassString[1,0].CompileClassSetString",
        "htmlId" : "sec-compileclasssetstring",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "CompileClassSetString",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "ClassString",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "NonEmptyClassString"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2238,
    [
      "INTRINSICS.String.raw",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _substitutionCount_ be the number of elements in _substitutions_.\n          1. Let _cooked_ be ? ToObject(_template_).\n          1. Let _literals_ be ? ToObject(? Get(_cooked_, *\"raw\"*)).\n          1. Let _literalCount_ be ? LengthOfArrayLike(_literals_).\n          1. If _literalCount_ ≤ 0, return the empty String.\n          1. Let _R_ be the empty String.\n          1. Let _nextIndex_ be 0.\n          1. Repeat,\n            1. Let _nextLiteralVal_ be ? Get(_literals_, ! ToString(𝔽(_nextIndex_))).\n            1. Let _nextLiteral_ be ? ToString(_nextLiteralVal_).\n            1. Set _R_ to the string-concatenation of _R_ and _nextLiteral_.\n            1. If _nextIndex_ + 1 = _literalCount_, return _R_.\n            1. If _nextIndex_ < _substitutionCount_, then\n              1. Let _nextSubVal_ be _substitutions_[_nextIndex_].\n              1. Let _nextSub_ be ? ToString(_nextSubVal_).\n              1. Set _R_ to the string-concatenation of _R_ and _nextSub_.\n            1. Set _nextIndex_ to _nextIndex_ + 1.\n        ",
      {
        "normalizedName" : "INTRINSICS.String.raw",
        "name" : "INTRINSICS.String.raw",
        "htmlId" : "sec-string.raw",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2615,
    [
      "INTRINSICS.SetIteratorPrototype.next",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n            1. Return ? <emu-meta suppress-effects=\"user-code\">GeneratorResume(*this* value, ~empty~, *\"%SetIteratorPrototype%\"*)</emu-meta>.\n          ",
      {
        "normalizedName" : "INTRINSICS.SetIteratorPrototype.next",
        "name" : "INTRINSICS.SetIteratorPrototype.next",
        "htmlId" : "sec-%setiteratorprototype%.next",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1769,
    [
      "Statement[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[Statement[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "Statement[2,0].HasCallInTailPosition",
        "name" : "Statement[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "Statement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EmptyStatement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1917,
    [
      "Module[0,0].ModuleRequests",
      2,
      [
        [
          "this",
          false,
          "Ast[Module[0]]"
        ]
      ],
      "\n          1. Return a new empty List.\n        ",
      {
        "normalizedName" : "Module[0,0].ModuleRequests",
        "name" : "Module[0,0].ModuleRequests",
        "htmlId" : "sec-static-semantics-modulerequests",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ModuleRequests",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Module",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    755,
    [
      "RelationalExpression[1,0].IsFunctionDefinition",
      2,
      [
        [
          "this",
          false,
          "Ast[RelationalExpression[1]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "RelationalExpression[1,0].IsFunctionDefinition",
        "name" : "RelationalExpression[1,0].IsFunctionDefinition",
        "htmlId" : "sec-static-semantics-isfunctiondefinition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IsFunctionDefinition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "RelationalExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              },
              {
                "type" : "terminal",
                "value" : "<"
              },
              {
                "type" : "nonterminal",
                "value" : "ShiftExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    676,
    [
      "ForInOfStatement[6,0].ContainsUndefinedContinueTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[6]]"
        ],
        [
          "iterationSet",
          false,
          "List[String]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      ",
      {
        "normalizedName" : "ForInOfStatement[6,0].ContainsUndefinedContinueTarget",
        "name" : "ForInOfStatement[6,0].ContainsUndefinedContinueTarget",
        "htmlId" : "sec-static-semantics-containsundefinedcontinuetarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedContinueTarget",
          "type" : "base",
          "prod" : {
            "i" : 6,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "await"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "of"
              },
              {
                "type" : "nonterminal",
                "value" : "AssignmentExpression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2351,
    [
      "RepeatMatcher",
      0,
      [
        [
          "m",
          false,
          "Record[Matcher]"
        ],
        [
          "min",
          false,
          "Int[0+]"
        ],
        [
          "max",
          false,
          "Int[0+] | +INF"
        ],
        [
          "greedy",
          false,
          "Boolean"
        ],
        [
          "x",
          false,
          "Record[MatchState]"
        ],
        [
          "c",
          false,
          "Record[MatcherContinuation]"
        ],
        [
          "parenIndex",
          false,
          "Int[0+]"
        ],
        [
          "parenCount",
          false,
          "Int[0+]"
        ]
      ],
      "\n            1. If _max_ = 0, return _c_(_x_).\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _m_, _min_, _max_, _greedy_, _x_, _c_, _parenIndex_, and _parenCount_ and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. [id=\"step-repeatmatcher-done\"] If _min_ = 0 and _y_.[[EndIndex]] = _x_.[[EndIndex]], return ~failure~.\n              1. If _min_ = 0, let _min2_ be 0; otherwise let _min2_ be _min_ - 1.\n              1. If _max_ = +∞, let _max2_ be +∞; otherwise let _max2_ be _max_ - 1.\n              1. Return RepeatMatcher(_m_, _min2_, _max2_, _greedy_, _y_, _c_, _parenIndex_, _parenCount_).\n            1. Let _cap_ be a copy of _x_.[[Captures]].\n            1. [id=\"step-repeatmatcher-clear-captures\"] For each integer _k_ in the inclusive interval from _parenIndex_ + 1 to _parenIndex_ + _parenCount_, set _cap_[_k_] to *undefined*.\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _e_ be _x_.[[EndIndex]].\n            1. Let _xr_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _e_, [[Captures]]: _cap_ }.\n            1. If _min_ ≠ 0, return _m_(_xr_, _d_).\n            1. If _greedy_ is *false*, then\n              1. Let _z_ be _c_(_x_).\n              1. If _z_ is not ~failure~, return _z_.\n              1. Return _m_(_xr_, _d_).\n            1. Let _z_ be _m_(_xr_, _d_).\n            1. If _z_ is not ~failure~, return _z_.\n            1. Return _c_(_x_).\n          ",
      {
        "normalizedName" : "RepeatMatcher",
        "name" : "RepeatMatcher",
        "htmlId" : "sec-runtime-semantics-repeatmatcher-abstract-operation",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    491,
    [
      "ModuleItem[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ModuleItem[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ModuleItem[0,0].VarScopedDeclarations",
        "name" : "ModuleItem[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ModuleItem",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ImportDeclaration"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1088,
    [
      "Record[OrdinaryObject].PreventExtensions",
      4,
      [
        [
          "O",
          false,
          "Record[OrdinaryObject]"
        ]
      ],
      "\n        1. Return OrdinaryPreventExtensions(_O_).\n      ",
      {
        "normalizedName" : "Record[OrdinaryObject].PreventExtensions",
        "name" : "Record[OrdinaryObject].PreventExtensions",
        "htmlId" : "sec-ordinary-object-internal-methods-and-internal-slots-preventextensions",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "OrdinaryObject",
          "[[PreventExtensions]]"
        ]
      }
    ]
  ],
  [
    2170,
    [
      "HourFromTime",
      0,
      [
        [
          "t",
          false,
          "Unknown[\"FiniteTimeValue\"]"
        ]
      ],
      "\n          1. Return 𝔽(floor(ℝ(_t_ / msPerHour)) modulo HoursPerDay).\n        ",
      {
        "normalizedName" : "HourFromTime",
        "name" : "HourFromTime",
        "htmlId" : "sec-hourfromtime",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2834,
    [
      "Await:clo1",
      6,
      [
        [
          "this",
          false,
          "Unknown"
        ],
        [
          "ArgumentsList",
          false,
          "Unknown"
        ],
        [
          "NewTarget",
          false,
          "Unknown"
        ]
      ],
      "\n          1. Let _asyncContext_ be the running execution context.\n          1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).\n          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_v_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using NormalCompletion(_v_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using ThrowCompletion(_reason_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n          1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n          1. Let _callerContext_ be the running execution context.\n          1. Resume _callerContext_ passing ~empty~. If _asyncContext_ is ever resumed again, let _completion_ be the Completion Record with which it is resumed.\n          1. Assert: If control reaches here, then _asyncContext_ is the running execution context again.\n          1. Return _completion_.\n        ",
      {
        "normalizedName" : "Await",
        "name" : "Await",
        "htmlId" : "await",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : true,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2191,
    [
      "INTRINSICS.Date.prototype.getDay",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return WeekDay(LocalTime(_t_)).\n        ",
      {
        "normalizedName" : "INTRINSICS.Date.prototype.getDay",
        "name" : "INTRINSICS.Date.prototype.getDay",
        "htmlId" : "sec-date.prototype.getday",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1204,
    [
      "ValidateNonRevokedProxy",
      0,
      [
        [
          "proxy",
          false,
          "Record[ProxyExoticObject]"
        ]
      ],
      "\n        1. If _proxy_.[[ProxyTarget]] is *null*, throw a *TypeError* exception.\n        1. Assert: _proxy_.[[ProxyHandler]] is not *null*.\n        1. Return ~unused~.\n      ",
      {
        "normalizedName" : "ValidateNonRevokedProxy",
        "name" : "ValidateNonRevokedProxy",
        "htmlId" : "sec-validatenonrevokedproxy",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1449,
    [
      "SingleNameBinding[0,1].KeyedBindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[SingleNameBinding[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ],
        [
          "propertyName",
          false,
          "Record[Symbol] | String"
        ]
      ],
      "\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).\n          1. Let _v_ be ? GetV(_value_, _propertyName_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n              1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Set _v_ to ? GetValue(_defaultValue_).\n          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).\n          1. Return ? InitializeReferencedBinding(_lhs_, _v_).\n        ",
      {
        "normalizedName" : "SingleNameBinding[0,1].KeyedBindingInitialization",
        "name" : "SingleNameBinding[0,1].KeyedBindingInitialization",
        "htmlId" : "sec-runtime-semantics-keyedbindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "KeyedBindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "SingleNameBinding",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "BindingIdentifier"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1812,
    [
      "CaseBlock[1,3].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[CaseBlock[1]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Let _has_ be *false*.\n        1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.\n        1. Return _has_.\n      ",
      {
        "normalizedName" : "CaseBlock[1,3].HasCallInTailPosition",
        "name" : "CaseBlock[1,3].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 3,
            "astName" : "CaseBlock",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "nonterminal",
                "value" : "DefaultClause"
              },
              {
                "type" : "nonterminal",
                "value" : "CaseClauses"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2106,
    [
      "InstallErrorCause",
      0,
      [
        [
          "O",
          false,
          "Record[Object]"
        ],
        [
          "options",
          false,
          "ESValue"
        ]
      ],
      "\n          1. If _options_ is an Object and ? HasProperty(_options_, *\"cause\"*) is *true*, then\n            1. Let _cause_ be ? Get(_options_, *\"cause\"*).\n            1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *\"cause\"*, _cause_).\n          1. Return ~unused~.\n        ",
      {
        "normalizedName" : "InstallErrorCause",
        "name" : "InstallErrorCause",
        "htmlId" : "sec-installerrorcause",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    222,
    [
      "ArrayBindingPattern[0,2].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[ArrayBindingPattern[0]]"
        ]
      ],
      "\n        1. Return a new empty List.\n      ",
      {
        "normalizedName" : "ArrayBindingPattern[0,2].BoundNames",
        "name" : "ArrayBindingPattern[0,2].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 2,
            "astName" : "ArrayBindingPattern",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "["
              },
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "terminal",
                "value" : "]"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2087,
    [
      "INTRINSICS.Function.prototype[@@hasInstance]",
      5,
      [
        [
          "this",
          false,
          "ESValue"
        ],
        [
          "ArgumentsList",
          false,
          "List[ESValue]"
        ],
        [
          "NewTarget",
          false,
          "Record[Constructor] | Undefined"
        ]
      ],
      "\n          1. Let _F_ be the *this* value.\n          1. Return ? OrdinaryHasInstance(_F_, _V_).\n        ",
      {
        "normalizedName" : "INTRINSICS.Function.prototype[@@hasInstance]",
        "name" : "INTRINSICS.Function.prototype[@@hasInstance]",
        "htmlId" : "sec-function.prototype-@@hasinstance",
        "isBuiltIn" : true,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    592,
    [
      "ForStatement[0,4].ContainsUndefinedBreakTarget",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      ",
      {
        "normalizedName" : "ForStatement[0,4].ContainsUndefinedBreakTarget",
        "name" : "ForStatement[0,4].ContainsUndefinedBreakTarget",
        "htmlId" : "sec-static-semantics-containsundefinedbreaktarget",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ContainsUndefinedBreakTarget",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 4,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1468,
    [
      "ForStatement[0,7].ForLoopEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[ForStatement[0]]"
        ],
        [
          "labelSet",
          false,
          "List[String]"
        ]
      ],
      "\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        ",
      {
        "normalizedName" : "ForStatement[0,7].ForLoopEvaluation",
        "name" : "ForStatement[0,7].ForLoopEvaluation",
        "htmlId" : "sec-runtime-semantics-forloopevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "ForLoopEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 7,
            "astName" : "ForStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ";"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2470,
    [
      "GetStringIndex",
      0,
      [
        [
          "S",
          false,
          "String"
        ],
        [
          "codePointIndex",
          false,
          "Int[0+]"
        ]
      ],
      "\n          1. If _S_ is the empty String, return 0.\n          1. Let _len_ be the length of _S_.\n          1. Let _codeUnitCount_ be 0.\n          1. Let _codePointCount_ be 0.\n          1. Repeat, while _codeUnitCount_ < _len_,\n            1. If _codePointCount_ = _codePointIndex_, return _codeUnitCount_.\n            1. Let _cp_ be CodePointAt(_S_, _codeUnitCount_).\n            1. Set _codeUnitCount_ to _codeUnitCount_ + _cp_.[[CodeUnitCount]].\n            1. Set _codePointCount_ to _codePointCount_ + 1.\n          1. Return _len_.\n        ",
      {
        "normalizedName" : "GetStringIndex",
        "name" : "GetStringIndex",
        "htmlId" : "sec-getstringindex",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    496,
    [
      "StatementList[1,0].TopLevelLexicallyScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[StatementList[1]]"
        ]
      ],
      "\n        1. Let _declarations1_ be TopLevelLexicallyScopedDeclarations of |StatementList|.\n        1. Let _declarations2_ be TopLevelLexicallyScopedDeclarations of |StatementListItem|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      ",
      {
        "normalizedName" : "StatementList[1,0].TopLevelLexicallyScopedDeclarations",
        "name" : "StatementList[1,0].TopLevelLexicallyScopedDeclarations",
        "htmlId" : "sec-static-semantics-toplevellexicallyscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "TopLevelLexicallyScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 1,
            "j" : 0,
            "astName" : "StatementList",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "StatementList"
              },
              {
                "type" : "nonterminal",
                "value" : "StatementListItem"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    454,
    [
      "ForInOfStatement[0,0].VarScopedDeclarations",
      2,
      [
        [
          "this",
          false,
          "Ast[ForInOfStatement[0]]"
        ]
      ],
      "\n        1. Return the VarScopedDeclarations of |Statement|.\n      ",
      {
        "normalizedName" : "ForInOfStatement[0,0].VarScopedDeclarations",
        "name" : "ForInOfStatement[0,0].VarScopedDeclarations",
        "htmlId" : "sec-static-semantics-varscopeddeclarations",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "VarScopedDeclarations",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "ForInOfStatement",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "for"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "LeftHandSideExpression"
              },
              {
                "type" : "terminal",
                "value" : "in"
              },
              {
                "type" : "nonterminal",
                "value" : "Expression"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "nonterminal",
                "value" : "Statement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1069,
    [
      "ResolveThisBinding",
      0,
      [
      ],
      "\n        1. Let _envRec_ be GetThisEnvironment().\n        1. Return ? _envRec_.GetThisBinding().\n      ",
      {
        "normalizedName" : "ResolveThisBinding",
        "name" : "ResolveThisBinding",
        "htmlId" : "sec-resolvethisbinding",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    708,
    [
      "AsyncFunctionExpression[0,0].HasName",
      2,
      [
        [
          "this",
          false,
          "Ast[AsyncFunctionExpression[0]]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "AsyncFunctionExpression[0,0].HasName",
        "name" : "AsyncFunctionExpression[0,0].HasName",
        "htmlId" : "sec-static-semantics-hasname",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasName",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "AsyncFunctionExpression",
            "prodInfo" : [
              {
                "type" : "terminal",
                "value" : "async"
              },
              {
                "type" : "terminal",
                "value" : "function"
              },
              {
                "type" : "terminal",
                "value" : "("
              },
              {
                "type" : "nonterminal",
                "value" : "FormalParameters"
              },
              {
                "type" : "terminal",
                "value" : ")"
              },
              {
                "type" : "terminal",
                "value" : "{"
              },
              {
                "type" : "nonterminal",
                "value" : "AsyncFunctionBody"
              },
              {
                "type" : "terminal",
                "value" : "}"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    232,
    [
      "BindingElisionElement[0,1].BoundNames",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingElisionElement[0]]"
        ]
      ],
      "\n        1. Return BoundNames of |BindingElement|.\n      ",
      {
        "normalizedName" : "BindingElisionElement[0,1].BoundNames",
        "name" : "BindingElisionElement[0,1].BoundNames",
        "htmlId" : "sec-static-semantics-boundnames",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BoundNames",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "BindingElisionElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "Elision"
              },
              {
                "type" : "nonterminal",
                "value" : "BindingElement"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1912,
    [
      "Script[0,0].Evaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[Script[0]]"
        ]
      ],
      "\n        1. Return *undefined*.\n      ",
      {
        "normalizedName" : "Script[0,0].Evaluation",
        "name" : "Script[0,0].Evaluation",
        "htmlId" : "sec-script-semantics-runtime-semantics-evaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "Evaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "Script",
            "prodInfo" : [
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    882,
    [
      "BindingPattern[0,0].BindingInitialization",
      2,
      [
        [
          "this",
          false,
          "Ast[BindingPattern[0]]"
        ],
        [
          "value",
          false,
          "ESValue"
        ],
        [
          "environment",
          false,
          "Record[EnvironmentRecord] | Undefined"
        ]
      ],
      "\n        1. Perform ? RequireObjectCoercible(_value_).\n        1. Return ? BindingInitialization of |ObjectBindingPattern| with arguments _value_ and _environment_.\n      ",
      {
        "normalizedName" : "BindingPattern[0,0].BindingInitialization",
        "name" : "BindingPattern[0,0].BindingInitialization",
        "htmlId" : "sec-runtime-semantics-bindinginitialization",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "BindingInitialization",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 0,
            "astName" : "BindingPattern",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "ObjectBindingPattern"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2177,
    [
      "AvailableNamedTimeZoneIdentifiers",
      0,
      [
      ],
      "\n          1. If the implementation does not include local political rules for any time zones, then\n            1. Return « the Time Zone Identifier Record { [[Identifier]]: *\"UTC\"*, [[PrimaryIdentifier]]: *\"UTC\"* } ».\n          1. Let _identifiers_ be the List of unique available named time zone identifiers.\n          1. [declared=\"comparefn\"] Sort _identifiers_ into the same order as if an Array of the same values had been sorted using %Array.prototype.sort% with *undefined* as _comparefn_.\n          1. Let _result_ be a new empty List.\n          1. For each element _identifier_ of _identifiers_, do\n            1. Let _primary_ be _identifier_.\n            1. If _identifier_ is a non-primary time zone identifier in this implementation and _identifier_ is not *\"UTC\"*, then\n              1. Set _primary_ to the primary time zone identifier associated with _identifier_.\n              1. NOTE: An implementation may need to resolve _identifier_ iteratively to obtain the primary time zone identifier.\n            1. Let _record_ be the Time Zone Identifier Record { [[Identifier]]: _identifier_, [[PrimaryIdentifier]]: _primary_ }.\n            1. Append _record_ to _result_.\n          1. Assert: _result_ contains a Time Zone Identifier Record _r_ such that _r_.[[Identifier]] is *\"UTC\"* and _r_.[[PrimaryIdentifier]] is *\"UTC\"*.\n          1. Return _result_.\n        ",
      {
        "normalizedName" : "AvailableNamedTimeZoneIdentifiers",
        "name" : "AvailableNamedTimeZoneIdentifiers",
        "htmlId" : "sec-availablenamedtimezoneidentifiers",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    100,
    [
      "IsAccessorDescriptor",
      0,
      [
        [
          "Desc",
          false,
          "Record[PropertyDescriptor] | Undefined"
        ]
      ],
      "\n          1. If _Desc_ is *undefined*, return *false*.\n          1. If _Desc_ has a [[Get]] field, return *true*.\n          1. If _Desc_ has a [[Set]] field, return *true*.\n          1. Return *false*.\n        ",
      {
        "normalizedName" : "IsAccessorDescriptor",
        "name" : "IsAccessorDescriptor",
        "htmlId" : "sec-isaccessordescriptor",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2655,
    [
      "IsSharedArrayBuffer",
      0,
      [
        [
          "obj",
          false,
          "Record[ArrayBuffer | SharedArrayBuffer]"
        ]
      ],
      "\n          1. Let _bufferData_ be _obj_.[[ArrayBufferData]].\n          1. If _bufferData_ is *null*, return *false*.\n          1. If _bufferData_ is a Data Block, return *false*.\n          1. Assert: _bufferData_ is a Shared Data Block.\n          1. Return *true*.\n        ",
      {
        "normalizedName" : "IsSharedArrayBuffer",
        "name" : "IsSharedArrayBuffer",
        "htmlId" : "sec-issharedarraybuffer",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1014,
    [
      "Record[DeclarativeEnvironmentRecord].DeleteBinding",
      3,
      [
        [
          "envRec",
          false,
          "Record[DeclarativeEnvironmentRecord]"
        ],
        [
          "N",
          false,
          "String"
        ]
      ],
      "\n            1. Assert: _envRec_ has a binding for _N_.\n            1. If the binding for _N_ in _envRec_ cannot be deleted, return *false*.\n            1. Remove the binding for _N_ from _envRec_.\n            1. Return *true*.\n          ",
      {
        "normalizedName" : "Record[DeclarativeEnvironmentRecord].DeleteBinding",
        "name" : "Record[DeclarativeEnvironmentRecord].DeleteBinding",
        "htmlId" : "sec-declarative-environment-records-deletebinding-n",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : true,
        "methodInfo" : [
          "DeclarativeEnvironmentRecord",
          "DeleteBinding"
        ]
      }
    ]
  ],
  [
    1417,
    [
      "AssignmentElement[0,1].IteratorDestructuringAssignmentEvaluation",
      2,
      [
        [
          "this",
          false,
          "Ast[AssignmentElement[0]]"
        ],
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ]
      ],
      "\n          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.\n          1. Let _value_ be *undefined*.\n          1. If _iteratorRecord_.[[Done]] is *false*, then\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is not ~done~, then\n              1. Set _value_ to _next_.\n          1. If |Initializer| is present and _value_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true* and IsIdentifierRef of |DestructuringAssignmentTarget| is *true*, then\n              1. Let _v_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Let _v_ be ? GetValue(_defaultValue_).\n          1. Else,\n            1. Let _v_ be _value_.\n          1. If |DestructuringAssignmentTarget| is either an |ObjectLiteral| or an |ArrayLiteral|, then\n            1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n            1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _v_.\n          1. Return ? PutValue(_lref_, _v_).\n        ",
      {
        "normalizedName" : "AssignmentElement[0,1].IteratorDestructuringAssignmentEvaluation",
        "name" : "AssignmentElement[0,1].IteratorDestructuringAssignmentEvaluation",
        "htmlId" : "sec-runtime-semantics-iteratordestructuringassignmentevaluation",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "IteratorDestructuringAssignmentEvaluation",
          "type" : "base",
          "prod" : {
            "i" : 0,
            "j" : 1,
            "astName" : "AssignmentElement",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "DestructuringAssignmentTarget"
              },
              {
                "type" : "nonterminal",
                "value" : "Initializer"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    1870,
    [
      "MemberExpression[2,0].HasCallInTailPosition",
      2,
      [
        [
          "this",
          false,
          "Ast[MemberExpression[2]]"
        ],
        [
          "call",
          false,
          "Ast[CallExpression | MemberExpression | OptionalChain]"
        ]
      ],
      "\n        1. Return *false*.\n      ",
      {
        "normalizedName" : "MemberExpression[2,0].HasCallInTailPosition",
        "name" : "MemberExpression[2,0].HasCallInTailPosition",
        "htmlId" : "sec-static-semantics-hascallintailposition",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "HasCallInTailPosition",
          "type" : "base",
          "prod" : {
            "i" : 2,
            "j" : 0,
            "astName" : "MemberExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "MemberExpression"
              },
              {
                "type" : "terminal",
                "value" : "."
              },
              {
                "type" : "nonterminal",
                "value" : "IdentifierName"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    972,
    [
      "EqualityExpression[3,0].AssignmentTargetType",
      2,
      [
        [
          "this",
          false,
          "Ast[EqualityExpression[3]]"
        ]
      ],
      "\n        1. Return ~invalid~.\n      ",
      {
        "normalizedName" : "EqualityExpression[3,0].AssignmentTargetType",
        "name" : "EqualityExpression[3,0].AssignmentTargetType",
        "htmlId" : "sec-static-semantics-assignmenttargettype",
        "isBuiltIn" : false,
        "isSdo" : true,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : {
          "method" : "AssignmentTargetType",
          "type" : "base",
          "prod" : {
            "i" : 3,
            "j" : 0,
            "astName" : "EqualityExpression",
            "prodInfo" : [
              {
                "type" : "nonterminal",
                "value" : "EqualityExpression"
              },
              {
                "type" : "terminal",
                "value" : "==="
              },
              {
                "type" : "nonterminal",
                "value" : "RelationalExpression"
              }
            ]
          }
        },
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ],
  [
    2771,
    [
      "PerformPromiseAny",
      0,
      [
        [
          "iteratorRecord",
          false,
          "Record[IteratorRecord]"
        ],
        [
          "constructor",
          false,
          "Record[Constructor]"
        ],
        [
          "resultCapability",
          false,
          "Record[PromiseCapabilityRecord]"
        ],
        [
          "promiseResolve",
          false,
          "Record[FunctionObject]"
        ]
      ],
      "\n            1. Let _errors_ be a new empty List.\n            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.\n            1. Let _index_ be 0.\n            1. Repeat,\n              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n              1. If _next_ is ~done~, then\n                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n                1. If _remainingElementsCount_.[[Value]] = 0, then\n                  1. Let _error_ be a newly created *AggregateError* object.\n                  1. Perform ! DefinePropertyOrThrow(_error_, *\"errors\"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }).\n                  1. Return ThrowCompletion(_error_).\n                1. Return _resultCapability_.[[Promise]].\n              1. Append *undefined* to _errors_.\n              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).\n              1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href=\"#sec-promise.any-reject-element-functions\" title></emu-xref>.\n              1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.any-reject-element-functions\" title></emu-xref>.\n              1. Let _onRejected_ be CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Errors]], [[Capability]], [[RemainingElements]] »).\n              1. Set _onRejected_.[[AlreadyCalled]] to *false*.\n              1. Set _onRejected_.[[Index]] to _index_.\n              1. Set _onRejected_.[[Errors]] to _errors_.\n              1. Set _onRejected_.[[Capability]] to _resultCapability_.\n              1. Set _onRejected_.[[RemainingElements]] to _remainingElementsCount_.\n              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.\n              1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _resultCapability_.[[Resolve]], _onRejected_ »).\n              1. Set _index_ to _index_ + 1.\n          ",
      {
        "normalizedName" : "PerformPromiseAny",
        "name" : "PerformPromiseAny",
        "htmlId" : "sec-performpromiseany",
        "isBuiltIn" : false,
        "isSdo" : false,
        "isClo" : false,
        "isCont" : false,
        "sdoInfo" : null,
        "isMethod" : false,
        "methodInfo" : null
      }
    ]
  ]
]